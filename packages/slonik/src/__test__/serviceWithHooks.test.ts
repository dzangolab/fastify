/* istanbul ignore file */
import { newDb } from "pg-mem";
import { describe, expect, it } from "vitest";

import createConfig from "./helpers/createConfig";
import createDatabase from "./helpers/createDatabase";
import TestService from "./helpers/testService";

import type { PaginatedList } from "../types";
import type { QueryResultRow } from "slonik";

// Test service with hooks implementation
class TestServiceWithHooks<
  T extends QueryResultRow,
  C extends QueryResultRow,
  U extends QueryResultRow,
> extends TestService<T, C, U> {
  // Pre-hooks
  async preAll() {
    // No processing needed for read operations
  }

  async preCount() {
    // No processing needed for read operations
  }

  async preCreate(data: C): Promise<C> {
    return { ...data, name: `pre-${data.name}` } as C;
  }

  async preDelete() {
    // No processing needed for delete operation
  }

  async preFind() {
    // No processing needed for read operations
  }

  async preFindById() {
    // No processing needed for read operations
  }

  async preFindOne() {
    // No processing needed for read operations
  }

  async preList() {
    // No processing needed for read operations
  }

  async preUpdate(data: U): Promise<U> {
    return { ...data, name: `pre-${data.name}` } as U;
  }

  // Post-hooks
  async postAll(result: Partial<readonly T[]>): Promise<Partial<readonly T[]>> {
    return result.map((item) => ({
      ...(item as Record<string, unknown>),
      processed: "all",
    })) as unknown as Partial<readonly T[]>;
  }

  async postCount(result: number): Promise<number> {
    return result + 1000;
  }

  async postCreate(result: T): Promise<T> {
    return { ...result, processed: "created" } as T;
  }

  async postDelete(result: T): Promise<T> {
    return { ...result, processed: "deleted" } as T;
  }

  async postFind(result: readonly T[]): Promise<readonly T[]> {
    return result.map((item) => ({ ...item, processed: "found" }) as T);
  }

  async postFindById(result: T): Promise<T> {
    return { ...result, processed: "foundById" } as T;
  }

  async postFindOne(result: T): Promise<T> {
    return { ...result, processed: "foundOne" } as T;
  }

  async postList(result: PaginatedList<T>): Promise<PaginatedList<T>> {
    return {
      ...result,
      data: result.data.map(
        (item: T) => ({ ...item, processed: "listed" }) as T,
      ),
      processed: "list",
    };
  }

  async postUpdate(result: T): Promise<T> {
    return { ...result, processed: "updated" } as T;
  }
}

// Service with invalid hooks (returning wrong types)
class TestServiceWithInvalidHooks<
  T extends QueryResultRow,
  C extends QueryResultRow,
  U extends QueryResultRow,
> extends TestService<T, C, U> {
  async preCreate(): Promise<C> {
    return "invalid-type" as unknown as C;
  }

  async postCreate(): Promise<T> {
    return "invalid-type" as unknown as T;
  }
}

describe("Service Hooks", async () => {
  const db = newDb();

  db.public.none(`
    create table test(id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, name TEXT, latitude INT, country_code TEXT);
    insert into test (name, latitude, country_code) values ('Original1', 20, 'NP'), ('Original2', 30, 'US');
  `);

  const config = createConfig();
  const database = await createDatabase({ db });

  describe("Pre-hooks", () => {
    it("calls preCreate hook and modifies data before create", async () => {
      const service = new TestServiceWithHooks(config, database);
      const data = { name: "Test", latitude: 20, countryCode: "FR" };

      const result = await service.create(data);

      expect(result?.name).toBe("pre-Test");
      expect(result?.latitude).toBe(20);
      expect(result?.countryCode).toBe("FR");
    });

    it("calls preUpdate hook and modifies data before update", async () => {
      const service = new TestServiceWithHooks(config, database);
      const data = { name: "UpdatedTest" };

      const result = await service.update(1, data);

      expect(result?.name).toBe("pre-UpdatedTest");
    });

    it("handles missing pre-hooks gracefully", async () => {
      const service = new TestService(config, database);
      const data = { name: "Test", latitude: 20, countryCode: "FR" };

      const result = await service.create(data);

      expect(result?.name).toBe("Test");
    });

    it("returns original data when pre-hook returns wrong type", async () => {
      const service = new TestServiceWithInvalidHooks(config, database);
      const data = { name: "Test", latitude: 20, countryCode: "FR" };

      const result = await service.create(data);

      expect(result?.name).toBe("Test");
      expect(result?.latitude).toBe(20);
    });

    it("verifies pre-hooks are called and modify data", async () => {
      const service = new TestServiceWithHooks(config, database);
      const data = { name: "TrackingTest", latitude: 25, countryCode: "DE" };

      const result = await service.create(data);

      // The preCreate hook should have modified the name
      expect(result?.name).toBe("pre-TrackingTest");
      expect(result?.latitude).toBe(25);
      expect(result?.countryCode).toBe("DE");
    });
  });

  describe("Post-hooks", () => {
    it("calls postAll hook and modifies result", async () => {
      const service = new TestServiceWithHooks(config, database);
      const fields = ["id", "name"];

      const result = await service.all(fields);

      expect(result[0]).toHaveProperty("processed", "all");
      expect(result[1]).toHaveProperty("processed", "all");
    });

    it("calls postCount hook and modifies result", async () => {
      const service = new TestServiceWithHooks(config, database);

      const result = await service.count();

      // The hook adds 1000 to the original count
      expect(result).toBeGreaterThan(1000);
      expect(result % 1000).toBeGreaterThanOrEqual(2); // Original count should be at least 2
    });

    it("calls postCreate hook and modifies result", async () => {
      const service = new TestServiceWithHooks(config, database);
      const data = { name: "PostTest", latitude: 15, countryCode: "IT" };

      const result = await service.create(data);

      expect(result).toHaveProperty("processed", "created");
      expect(result?.name).toBe("pre-PostTest"); // Also affected by preCreate
    });

    it("calls postFind hook and modifies result", async () => {
      const service = new TestServiceWithHooks(config, database);

      const result = await service.find();

      expect(result[0]).toHaveProperty("processed", "found");
      expect(result[1]).toHaveProperty("processed", "found");
    });

    it("calls postFindById hook and modifies result", async () => {
      const service = new TestServiceWithHooks(config, database);

      const result = await service.findById(1);

      expect(result).toHaveProperty("processed", "foundById");
    });

    it("calls postFindOne hook and modifies result", async () => {
      const service = new TestServiceWithHooks(config, database);

      const result = await service.findOne({
        key: "id",
        operator: "eq",
        value: "1",
      });

      expect(result).toHaveProperty("processed", "foundOne");
    });

    it("calls postList hook and modifies result", async () => {
      const service = new TestServiceWithHooks(config, database);

      const result = await service.list(10, 0);

      expect(result).toHaveProperty("processed", "list");
      expect(result.data[0]).toHaveProperty("processed", "listed");
      expect(result.data[1]).toHaveProperty("processed", "listed");
    });

    it("calls postUpdate hook and modifies result", async () => {
      const service = new TestServiceWithHooks(config, database);
      const data = { name: "PostUpdateTest" };

      const result = await service.update(1, data);

      expect(result).toHaveProperty("processed", "updated");
    });

    it("calls postDelete hook and modifies result", async () => {
      const service = new TestServiceWithHooks(config, database);

      // First create a record to delete
      const createData = { name: "ToDelete", latitude: 50, countryCode: "CA" };
      const created = await service.create(createData);

      const result = await service.delete(created!.id as number);

      expect(result).toHaveProperty("processed", "deleted");
    });

    it("handles missing post-hooks gracefully", async () => {
      const service = new TestService(config, database);

      const result = await service.count();

      expect(typeof result).toBe("number");
      expect(result).toBeGreaterThanOrEqual(0);
    });

    it("returns original result when post-hook returns wrong type", async () => {
      const service = new TestServiceWithInvalidHooks(config, database);
      const data = { name: "Test", latitude: 20, countryCode: "FR" };

      const result = await service.create(data);

      expect(typeof result).toBe("object");
      expect(result?.name).toBe("Test");
    });

    it("verifies post-hooks are called and modify results", async () => {
      const service = new TestServiceWithHooks(config, database);
      const data = {
        name: "PostTrackingTest",
        latitude: 25,
        countryCode: "DE",
      };

      const result = await service.create(data);

      // Both pre and post hooks should have been applied
      expect(result?.name).toBe("pre-PostTrackingTest"); // Pre-hook adds "pre-"
      expect(result).toHaveProperty("processed", "created"); // Post-hook adds "processed"
    });
  });

  describe("Hook execution order", () => {
    it("executes pre-hook before and post-hook after processing", async () => {
      const service = new TestServiceWithHooks(config, database);
      const data = { name: "OrderTest", latitude: 35, countryCode: "ES" };

      const result = await service.create(data);

      // Verify both pre and post hooks were executed by checking their effects
      expect(result?.name).toBe("pre-OrderTest"); // Pre-hook prefixed "pre-"
      expect(result).toHaveProperty("processed", "created"); // Post-hook added "processed"
      expect(result?.latitude).toBe(35);
      expect(result?.countryCode).toBe("ES");
    });

    it("executes both pre and post hooks for update operation", async () => {
      const service = new TestServiceWithHooks(config, database);

      // First create a record to update
      const createData = {
        name: "ToBeUpdated",
        latitude: 10,
        countryCode: "US",
      };
      const created = await service.create(createData);

      expect(created).toBeDefined();
      expect(created?.id).toBeDefined();

      // Now update it
      const updateData = { name: "UpdateOrderTest" };
      const result = await service.update(created!.id as number, updateData);

      // Verify both pre and post hooks were executed by checking their effects
      expect(result?.name).toBe("pre-UpdateOrderTest"); // Pre-hook prefixed "pre-"
      expect(result).toHaveProperty("processed", "updated"); // Post-hook added "processed"
    });
  });

  describe("Hook method name generation", () => {
    it("generates correct hook names for different actions", async () => {
      const service = new TestServiceWithHooks(config, database);

      // Test that methods exist (they would throw if hook name generation is wrong)
      expect(typeof service.preCreate).toBe("function");
      expect(typeof service.postCreate).toBe("function");
      expect(typeof service.preUpdate).toBe("function");
      expect(typeof service.postUpdate).toBe("function");
      expect(typeof service.preAll).toBe("function");
      expect(typeof service.postAll).toBe("function");
      expect(typeof service.preCount).toBe("function");
      expect(typeof service.postCount).toBe("function");
      expect(typeof service.preFind).toBe("function");
      expect(typeof service.postFind).toBe("function");
      expect(typeof service.preFindById).toBe("function");
      expect(typeof service.postFindById).toBe("function");
      expect(typeof service.preFindOne).toBe("function");
      expect(typeof service.postFindOne).toBe("function");
      expect(typeof service.preList).toBe("function");
      expect(typeof service.postList).toBe("function");
      expect(typeof service.preDelete).toBe("function");
      expect(typeof service.postDelete).toBe("function");
    });
  });

  describe("Hook parameter handling", () => {
    it("calls pre-hooks with no data for read operations", async () => {
      const service = new TestServiceWithHooks(config, database);

      // These operations should call pre-hooks with no data
      await service.all(["id", "name"]);
      await service.count();
      await service.find();
      await service.findById(1);
      await service.findOne();
      await service.list();

      // If hooks were called incorrectly, these would throw errors
      expect(true).toBe(true); // Test passes if no errors thrown
    });

    it("calls pre-hooks with data for write operations", async () => {
      const service = new TestServiceWithHooks(config, database);

      const createData = { name: "WithData", latitude: 40, countryCode: "JP" };
      const created = await service.create(createData);

      const updateData = { name: "UpdatedWithData" };
      await service.update(created!.id as number, updateData);

      // These operations should work correctly with data passed to pre-hooks
      expect(created?.name).toBe("pre-WithData");
    });
  });

  describe("Error handling", () => {
    it("handles pre-hook errors gracefully", async () => {
      class ErrorService<
        T extends QueryResultRow,
        C extends QueryResultRow,
        U extends QueryResultRow,
      > extends TestService<T, C, U> {
        async preCreate(): Promise<C | undefined> {
          throw new Error("Pre-hook error");
        }
      }

      const service = new ErrorService(config, database);
      const data = { name: "ErrorTest", latitude: 20, countryCode: "FR" };

      // Should throw the error from the pre-hook
      await expect(service.create(data)).rejects.toThrow("Pre-hook error");
    });

    it("handles post-hook errors gracefully", async () => {
      class ErrorService<
        T extends QueryResultRow,
        C extends QueryResultRow,
        U extends QueryResultRow,
      > extends TestService<T, C, U> {
        async postCreate(): Promise<T> {
          throw new Error("Post-hook error");
        }
      }

      const service = new ErrorService(config, database);
      const data = { name: "ErrorTest", latitude: 20, countryCode: "FR" };

      // Should throw the error from the post-hook
      await expect(service.create(data)).rejects.toThrow("Post-hook error");
    });
  });
});
