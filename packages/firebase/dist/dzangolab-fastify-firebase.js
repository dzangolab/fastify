import I from "fastify-plugin";
import { apps as U, initializeApp as N, credential as R, messaging as k } from "firebase-admin";
import { sql as f } from "slonik";
import { DefaultSqlFactory as O, BaseService as _ } from "@dzangolab/fastify-slonik";
import c from "mercurius";
import { gql as m, mergeTypeDefs as F, baseSchema as C } from "@dzangolab/fastify-graphql";
const A = (e, r) => {
  if (!(U.length > 0)) {
    if (e.firebase?.enabled !== !1 && !e.firebase.credentials) {
      r.log.error("Firebase credentials are missing");
      return;
    }
    try {
      N({
        credential: R.cert({
          projectId: e.firebase.credentials?.projectId,
          privateKey: e.firebase.credentials?.privateKey.replace(
            /\\n/g,
            `
`
          ),
          clientEmail: e.firebase.credentials?.clientEmail
        })
      });
    } catch (t) {
      r.log.error("Failed to initialize firebase"), r.log.error(t);
    }
  }
}, y = async (e) => {
  await k().sendEachForMulticast(e);
}, P = "/send-notification", M = "/user-device", B = "/user-device", T = "user_devices", L = (e) => {
  const r = e.firebase.table?.userDevices?.name || T;
  return f.unsafe`
    CREATE TABLE IF NOT EXISTS ${f.identifier([r])} (
        id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        user_id VARCHAR(255) NOT NULL,
        device_token VARCHAR(255) NOT NULL,
        created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
    );

    CREATE INDEX IF NOT EXISTS idx_user_id_device_token ON ${f.identifier([
    r
  ])} (user_id, device_token);
  `;
}, W = async (e, r) => {
  await e.connect(async (t) => {
    await t.query(L(r));
  });
}, $ = async (e, r, t) => {
  const { config: n, slonik: i, log: o } = e;
  n.firebase.enabled === !1 ? o.info("fastify-firebase plugin is not enabled") : (o.info("Registering fastify-firebase plugin"), await W(i, n), A(n, e)), t();
}, oe = I($);
class H extends O {
  getFindByUserIdSql = (r) => f.type(this.validationSchema)`
      SELECT * 
      FROM ${this.getTableFragment()}
      WHERE user_id = ${r};
    `;
  getDeleteExistingTokenSql = (r) => f.type(this.validationSchema)`
      DELETE
      FROM ${this.getTableFragment()}
      WHERE device_token = ${r}
      RETURNING *;
    `;
}
class g extends _ {
  get table() {
    return T;
  }
  get factory() {
    if (!this.table)
      throw new Error("Service table is not defined");
    return this._factory || (this._factory = new H(this)), this._factory;
  }
  create = async (r) => {
    const { deviceToken: t } = r;
    await this.removeByDeviceToken(t);
    const n = this.factory.getCreateSql(r);
    return await this.database.connect((o) => o.maybeOne(n));
  };
  getByUserId = async (r) => {
    const t = this.factory.getFindByUserIdSql(r);
    return await this.database.connect((i) => i.any(t));
  };
  removeByDeviceToken = async (r) => {
    const t = this.factory.getDeleteExistingTokenSql(r);
    return await this.database.connect((i) => i.maybeOne(t));
  };
}
const x = async (e, r) => {
  if (!e.session?.getUserId())
    throw e.log.error("user id is not defined"), new Error("Oops, Please login to continue");
  const {
    body: n,
    title: i,
    data: o,
    userId: l
  } = e.body;
  if (!l)
    throw e.log.error("receiver id is not defined"), new Error("Oops, Please provide a receiver id");
  const d = await new g(
    e.config,
    e.slonik,
    e.dbSchema
  ).getByUserId(l);
  if (!d || d.length === 0)
    throw e.log.error("no device found for the receiver"), new Error("Unable to find device for the receiver");
  const a = d.map((v) => v.deviceToken), s = {
    android: {
      priority: "high",
      notification: {
        sound: "default"
      }
    },
    apns: {
      payload: {
        aps: {
          sound: "default"
        }
      }
    },
    tokens: a,
    notification: {
      title: i,
      body: n
    },
    data: {
      ...o,
      title: i,
      body: n
    }
  };
  await y(s), r.send({ message: "Notification sent successfully" });
}, V = {
  sendNotification: x
}, h = (e) => async () => {
  if (e.config.firebase.enabled === !1)
    throw new Error("Firebase is not enabled");
}, se = async (e, r, t) => {
  const n = e.config.firebase.handlers?.userDevice, i = e.config.firebase.notification;
  i?.test?.enabled && e.post(
    i.test.path || P,
    {
      preHandler: [e.verifySession(), h(e)]
    },
    n?.addUserDevice || V.sendNotification
  ), t();
}, Q = {
  sendNotification: async (e, r, t) => {
    const { app: n, config: i, dbSchema: o, database: l, user: u } = t;
    if (u?.id || new c.ErrorWithProps("Could not get user id", {}, 403), i.firebase.enabled === !1)
      return new c.ErrorWithProps("Firebase is not enabled", {}, 404);
    try {
      const { userId: a, title: s, body: v, data: E } = r.data;
      if (!a)
        return new c.ErrorWithProps("Receiver id is required", {}, 400);
      const p = await new g(
        i,
        l,
        o
      ).getByUserId(a);
      if (!p || p.length === 0)
        return new c.ErrorWithProps(
          "Receiver device not found",
          {},
          404
        );
      const S = {
        tokens: p.map(
          (D) => D.deviceToken
        ),
        notification: {
          title: s,
          body: v
        },
        data: E
      };
      return await y(S), { message: "Notification sent successfully" };
    } catch (a) {
      n.log.error(a);
      const s = new c.ErrorWithProps(
        "Oops, Something went wrong"
      );
      return s.statusCode = 500, s;
    }
  }
}, Y = {}, ae = { Mutation: Q, Query: Y }, z = {
  addUserDevice: async (e, r, t) => {
    const { app: n, config: i, dbSchema: o, database: l, user: u } = t, d = u?.id;
    if (i.firebase.enabled === !1)
      return new c.ErrorWithProps("Firebase is not enabled", {}, 404);
    if (!d)
      return new c.ErrorWithProps("Could not get user id", {}, 403);
    try {
      const { deviceToken: a } = r.data;
      return await new g(i, l, o).create({ userId: d, deviceToken: a });
    } catch (a) {
      n.log.error(a);
      const s = new c.ErrorWithProps(
        "Oops, Something went wrong"
      );
      return s.statusCode = 500, s;
    }
  },
  removeUserDevice: async (e, r, t) => {
    const { app: n, config: i, dbSchema: o, database: l, user: u } = t, d = u?.id;
    if (i.firebase.enabled === !1)
      return new c.ErrorWithProps("Firebase is not enabled", {}, 404);
    if (!d)
      return new c.ErrorWithProps("Could not get user id", {}, 403);
    try {
      const { deviceToken: a } = r.data, s = new g(i, l, o), v = await s.getByUserId(d);
      return !v || v.length === 0 ? new c.ErrorWithProps(
        "No devices found for user",
        {},
        403
      ) : v.find(
        (w) => w.deviceToken === a
      ) ? await s.removeByDeviceToken(a) : new c.ErrorWithProps(
        "Device requested to delete not owned by user",
        {},
        403
      );
    } catch (a) {
      n.log.error(a);
      const s = new c.ErrorWithProps(
        "Oops, Something went wrong"
      );
      return s.statusCode = 500, s;
    }
  }
}, K = {}, ce = { Mutation: z, Query: K }, X = async (e, r) => {
  const t = e.session?.getUserId();
  if (!t)
    throw e.log.error("could not get user id from session"), new Error("Oops, Something went wrong");
  const { deviceToken: n } = e.body;
  if (!n)
    throw e.log.error("device token is not defined"), new Error("Oops, Something went wrong");
  const i = new g(e.config, e.slonik, e.dbSchema);
  r.send(await i.create({ userId: t, deviceToken: n }));
}, j = async (e, r) => {
  const t = e.session?.getUserId();
  if (!t)
    throw e.log.error("could not get user id from session"), new Error("Oops, Something went wrong");
  const { deviceToken: n } = e.body;
  if (!n)
    throw e.log.error("device token is not defined"), new Error("Oops, Something went wrong");
  const i = new g(e.config, e.slonik, e.dbSchema), o = await i.getByUserId(t);
  if (!o || o.length === 0)
    throw e.log.error("No devices found for user"), new Error("Oops, Something went wrong");
  if (!o.find(
    (u) => u.deviceToken === n
  ))
    throw e.log.error("device requested to delete not owned by user"), new Error("Oops, Something went wrong");
  r.send(await i.removeByDeviceToken(n));
}, b = {
  addUserDevice: X,
  removeUserDevice: j
}, de = async (e, r, t) => {
  const n = e.config.firebase.handlers?.userDevice;
  e.post(
    M,
    {
      preHandler: [e.verifySession(), h(e)]
    },
    n?.addUserDevice || b.addUserDevice
  ), e.delete(
    B,
    {
      preHandler: [e.verifySession(), h(e)]
    },
    n?.removeUserDevice || b.removeUserDevice
  ), t();
}, G = m`
  type SendNotificationResponse {
    message: String!
  }

  input SendNotificationInput {
    userId: String!
    title: String!
    body: String!
  }

  type Mutation {
    sendNotification(data: SendNotificationInput): SendNotificationResponse
      @auth
  }
`, J = m`
  type UserDevice {
    id: Int!
    userId: String!
    deviceToken: String!
    createdAt: Float!
    updatedAt: Float!
  }

  type UserDevices {
    data: [UserDevice]!
  }

  input UserDeviceCreateInput {
    deviceToken: String!
  }

  input UserDeviceUpdateInput {
    deviceToken: String!
  }

  input UserDeviceRemoveInput {
    deviceToken: String!
  }

  type Mutation {
    addUserDevice(data: UserDeviceCreateInput): UserDevice @auth
    removeUserDevice(data: UserDeviceRemoveInput): UserDevice @auth
  }
`, le = F([
  C,
  G,
  J
]);
export {
  g as UserDeviceService,
  oe as default,
  le as firebaseSchema,
  A as initializeFirebase,
  ae as notificationResolver,
  se as notificationRoutes,
  y as sendPushNotification,
  ce as userDeviceResolver,
  de as userDeviceRoutes
};
