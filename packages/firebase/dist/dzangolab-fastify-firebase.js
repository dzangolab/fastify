import "@dzangolab/fastify-mercurius";
import S from "fastify-plugin";
import { apps as I, initializeApp as U, credential as R, messaging as N } from "firebase-admin";
import { sql as g } from "slonik";
import { DefaultSqlFactory as k, BaseService as O } from "@dzangolab/fastify-slonik";
import c from "mercurius";
const _ = (e, r) => {
  if (!(I.length > 0)) {
    if (e.firebase?.enabled !== !1 && !e.firebase.credentials) {
      r.log.error("Firebase credentials are missing");
      return;
    }
    try {
      U({
        credential: R.cert({
          projectId: e.firebase.credentials?.projectId,
          privateKey: e.firebase.credentials?.privateKey.replace(
            /\\n/g,
            `
`
          ),
          clientEmail: e.firebase.credentials?.clientEmail
        })
      });
    } catch (o) {
      r.log.error("Failed to initialize firebase"), r.log.error(o);
    }
  }
}, T = async (e) => {
  await N().sendEachForMulticast(e);
}, F = "/send-notification", P = "/user-device", C = "/user-device", y = "user_devices", A = (e) => {
  const r = e.firebase.table?.userDevices?.name || y;
  return g.unsafe`
    CREATE TABLE IF NOT EXISTS ${g.identifier([r])} (
        id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        user_id VARCHAR(255) NOT NULL,
        device_token VARCHAR(255) NOT NULL,
        created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
    );

    CREATE INDEX IF NOT EXISTS idx_user_id_device_token ON ${g.identifier([
    r
  ])} (user_id, device_token);
  `;
}, M = async (e, r) => {
  await e.connect(async (o) => {
    await o.query(A(r));
  });
}, B = async (e, r, o) => {
  const { config: n, slonik: t, log: i } = e;
  n.firebase.enabled === !1 ? i.info("fastify-firebase plugin is not enabled") : (i.info("Registering fastify-firebase plugin"), await M(t, n), _(n, e)), o();
}, ee = S(B);
class L extends k {
  getFindByUserIdSql = (r) => g.type(this.validationSchema)`
      SELECT * 
      FROM ${this.getTableFragment()}
      WHERE user_id = ${r};
    `;
  getDeleteExistingTokenSql = (r) => g.type(this.validationSchema)`
      DELETE
      FROM ${this.getTableFragment()}
      WHERE device_token = ${r}
      RETURNING *;
    `;
}
class v extends O {
  get table() {
    return y;
  }
  get factory() {
    if (!this.table)
      throw new Error("Service table is not defined");
    return this._factory || (this._factory = new L(this)), this._factory;
  }
  create = async (r) => {
    const { deviceToken: o } = r;
    await this.removeByDeviceToken(o);
    const n = this.factory.getCreateSql(r);
    return await this.database.connect((i) => i.maybeOne(n));
  };
  getByUserId = async (r) => {
    const o = this.factory.getFindByUserIdSql(r);
    return await this.database.connect((t) => t.any(o));
  };
  removeByDeviceToken = async (r) => {
    const o = this.factory.getDeleteExistingTokenSql(r);
    return await this.database.connect((t) => t.maybeOne(o));
  };
}
const W = async (e, r) => {
  if (!e.session?.getUserId())
    throw e.log.error("user id is not defined"), new Error("Oops, Please login to continue");
  const {
    body: n,
    title: t,
    data: i,
    userId: l
  } = e.body;
  if (!l)
    throw e.log.error("receiver id is not defined"), new Error("Oops, Please provide a receiver id");
  const d = await new v(
    e.config,
    e.slonik,
    e.dbSchema
  ).getByUserId(l);
  if (!d || d.length === 0)
    throw e.log.error("no device found for the receiver"), new Error("Unable to find device for the receiver");
  const a = d.map((f) => f.deviceToken), s = {
    android: {
      priority: "high",
      notification: {
        sound: "default"
      }
    },
    apns: {
      payload: {
        aps: {
          sound: "default"
        }
      }
    },
    tokens: a,
    notification: {
      title: t,
      body: n
    },
    data: {
      ...i,
      title: t,
      body: n
    }
  };
  await T(s), r.send({ message: "Notification sent successfully" });
}, $ = {
  sendNotification: W
}, h = (e) => async () => {
  if (e.config.firebase.enabled === !1)
    throw new Error("Firebase is not enabled");
}, re = async (e, r, o) => {
  const n = e.config.firebase.handlers?.userDevice, t = e.config.firebase.notification;
  t?.test?.enabled && e.post(
    t.test.path || F,
    {
      preHandler: [e.verifySession(), h(e)]
    },
    n?.addUserDevice || $.sendNotification
  ), o();
}, H = {
  sendNotification: async (e, r, o) => {
    const { app: n, config: t, dbSchema: i, database: l, user: u } = o;
    if (u?.id || new c.ErrorWithProps("Could not get user id", {}, 403), t.firebase.enabled === !1)
      return new c.ErrorWithProps("Firebase is not enabled", {}, 404);
    try {
      const { userId: a, title: s, body: f, data: w } = r.data;
      if (!a)
        return new c.ErrorWithProps("Receiver id is required", {}, 400);
      const E = await new v(
        t,
        l,
        i
      ).getByUserId(a);
      if (!E || E.length === 0)
        return new c.ErrorWithProps(
          "Receiver device not found",
          {},
          404
        );
      const m = {
        tokens: E.map(
          (D) => D.deviceToken
        ),
        notification: {
          title: s,
          body: f
        },
        data: w
      };
      return await T(m), { message: "Notification sent successfully" };
    } catch (a) {
      n.log.error(a);
      const s = new c.ErrorWithProps(
        "Oops, Something went wrong"
      );
      return s.statusCode = 500, s;
    }
  }
}, x = {}, oe = { Mutation: H, Query: x }, V = {
  addUserDevice: async (e, r, o) => {
    const { app: n, config: t, dbSchema: i, database: l, user: u } = o, d = u?.id;
    if (t.firebase.enabled === !1)
      return new c.ErrorWithProps("Firebase is not enabled", {}, 404);
    if (!d)
      return new c.ErrorWithProps("Could not get user id", {}, 403);
    try {
      const { deviceToken: a } = r.data;
      return await new v(t, l, i).create({ userId: d, deviceToken: a });
    } catch (a) {
      n.log.error(a);
      const s = new c.ErrorWithProps(
        "Oops, Something went wrong"
      );
      return s.statusCode = 500, s;
    }
  },
  removeUserDevice: async (e, r, o) => {
    const { app: n, config: t, dbSchema: i, database: l, user: u } = o, d = u?.id;
    if (t.firebase.enabled === !1)
      return new c.ErrorWithProps("Firebase is not enabled", {}, 404);
    if (!d)
      return new c.ErrorWithProps("Could not get user id", {}, 403);
    try {
      const { deviceToken: a } = r.data, s = new v(t, l, i), f = await s.getByUserId(d);
      return !f || f.length === 0 ? new c.ErrorWithProps(
        "No devices found for user",
        {},
        403
      ) : f.find(
        (p) => p.deviceToken === a
      ) ? await s.removeByDeviceToken(a) : new c.ErrorWithProps(
        "Device requested to delete not owned by user",
        {},
        403
      );
    } catch (a) {
      n.log.error(a);
      const s = new c.ErrorWithProps(
        "Oops, Something went wrong"
      );
      return s.statusCode = 500, s;
    }
  }
}, Q = {}, ne = { Mutation: V, Query: Q }, Y = async (e, r) => {
  const o = e.session?.getUserId();
  if (!o)
    throw e.log.error("could not get user id from session"), new Error("Oops, Something went wrong");
  const { deviceToken: n } = e.body;
  if (!n)
    throw e.log.error("device token is not defined"), new Error("Oops, Something went wrong");
  const t = new v(e.config, e.slonik, e.dbSchema);
  r.send(await t.create({ userId: o, deviceToken: n }));
}, z = async (e, r) => {
  const o = e.session?.getUserId();
  if (!o)
    throw e.log.error("could not get user id from session"), new Error("Oops, Something went wrong");
  const { deviceToken: n } = e.body;
  if (!n)
    throw e.log.error("device token is not defined"), new Error("Oops, Something went wrong");
  const t = new v(e.config, e.slonik, e.dbSchema), i = await t.getByUserId(o);
  if (!i || i.length === 0)
    throw e.log.error("No devices found for user"), new Error("Oops, Something went wrong");
  if (!i.find(
    (u) => u.deviceToken === n
  ))
    throw e.log.error("device requested to delete not owned by user"), new Error("Oops, Something went wrong");
  r.send(await t.removeByDeviceToken(n));
}, b = {
  addUserDevice: Y,
  removeUserDevice: z
}, te = async (e, r, o) => {
  const n = e.config.firebase.handlers?.userDevice;
  e.post(
    P,
    {
      preHandler: [e.verifySession(), h(e)]
    },
    n?.addUserDevice || b.addUserDevice
  ), e.delete(
    C,
    {
      preHandler: [e.verifySession(), h(e)]
    },
    n?.removeUserDevice || b.removeUserDevice
  ), o();
};
export {
  v as UserDeviceService,
  ee as default,
  _ as initializeFirebase,
  oe as notificationResolver,
  re as notificationRoutes,
  T as sendPushNotification,
  ne as userDeviceResolver,
  te as userDeviceRoutes
};
