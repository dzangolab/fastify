import { BaseService as iS } from "@dzangolab/fastify-slonik";
import oa from "fastify-plugin";
import Ln, { parse as sS } from "graphql";
import { sql as Jh } from "slonik";
const T0 = "organizations";
class mr extends iS {
  static TABLE = T0;
}
const oS = async (e, t) => {
  const n = new mr(e.config, e.slonik), r = e.body, i = await n.create(r);
  t.send(i);
}, aS = async (e, t) => {
  const n = new mr(e.config, e.slonik), { id: r } = e.params, i = await n.delete(r);
  t.send(i);
}, lS = async (e, t) => {
  const n = new mr(e.config, e.slonik), { limit: r, offset: i, filters: s, sort: o } = e.query, a = await n.list(
    r,
    i,
    s ? JSON.parse(s) : void 0,
    o ? JSON.parse(o) : void 0
  );
  t.send(a);
}, uS = async (e, t) => {
  const n = new mr(e.config, e.slonik), { id: r } = e.params, i = await n.findById(r);
  t.send(i);
}, cS = async (e, t) => {
  const n = new mr(e.config, e.slonik), { id: r } = e.params, i = e.body, s = await n.update(r, i);
  t.send(s);
}, io = {
  createOrganization: oS,
  deleteOrganization: aS,
  listOrganization: lS,
  organization: uS,
  updateOrganization: cS
}, $B = async (e, t, n) => {
  const r = e.config.organization?.handlers?.organization;
  e.get(
    "/organizations",
    {
      preHandler: e.verifySession()
    },
    r?.list || io.listOrganization
  ), e.get(
    "/organizations/:id(^\\d+)",
    {
      preHandler: e.verifySession()
    },
    r?.organization || io.organization
  ), e.delete(
    "/organizations/:id(^\\d+)",
    {
      preHandler: e.verifySession()
    },
    r?.delete || io.deleteOrganization
  ), e.post(
    "/organizations",
    {
      preHandler: e.verifySession()
    },
    r?.create || io.createOrganization
  ), e.put(
    "/organizations/:id(^\\d+)",
    {
      preHandler: e.verifySession()
    },
    r?.update || io.updateOrganization
  ), n();
}, fS = {
  createOrganization: async (e, t, n) => {
    const r = new mr(n.config, n.database);
    try {
      if (!n.user)
        throw new Error("UserId not found in session.");
      return await r.create(
        t.data
      );
    } catch (i) {
      console.log(i);
    }
  },
  deleteOrganization: async (e, t, n) => {
    const r = new mr(n.config, n.database);
    try {
      return await r.delete(t.id);
    } catch (i) {
      console.log(i);
    }
  },
  updateOrganization: async (e, t, n) => {
    const r = new mr(n.config, n.database);
    try {
      return await r.update(
        t.id,
        t.data
      );
    } catch (i) {
      console.log(i);
    }
  }
}, dS = {
  organization: async (e, t, n) => await new mr(n.config, n.database).findById(t.id),
  organizations: async (e, t, n) => await new mr(n.config, n.database).list(
    t.limit,
    t.offset,
    t.filters ? JSON.parse(JSON.stringify(t.filters)) : void 0,
    t.sort ? JSON.parse(JSON.stringify(t.sort)) : void 0
  )
}, NB = { Mutation: fS, Query: dS };
var We = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function pS(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function Hi(e) {
  if (e.__esModule)
    return e;
  var t = e.default;
  if (typeof t == "function") {
    var n = function r() {
      return this instanceof r ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    n.prototype = t.prototype;
  } else
    n = {};
  return Object.defineProperty(n, "__esModule", { value: !0 }), Object.keys(e).forEach(function(r) {
    var i = Object.getOwnPropertyDescriptor(e, r);
    Object.defineProperty(n, r, i.get ? i : {
      enumerable: !0,
      get: function() {
        return e[r];
      }
    });
  }), n;
}
var lu = { exports: {} }, uu = {};
/**
 * tiny-lru
 *
 * @copyright 2024 Jason Mulligan <jason.mulligan@avoidwork.com>
 * @license BSD-3-Clause
 * @version 11.2.11
 */
let $0 = class {
  constructor(t = 0, n = 0, r = !1) {
    this.first = null, this.items = /* @__PURE__ */ Object.create(null), this.last = null, this.max = t, this.resetTtl = r, this.size = 0, this.ttl = n;
  }
  clear() {
    return this.first = null, this.items = /* @__PURE__ */ Object.create(null), this.last = null, this.size = 0, this;
  }
  delete(t) {
    if (this.has(t)) {
      const n = this.items[t];
      delete this.items[t], this.size--, n.prev !== null && (n.prev.next = n.next), n.next !== null && (n.next.prev = n.prev), this.first === n && (this.first = n.next), this.last === n && (this.last = n.prev);
    }
    return this;
  }
  entries(t = this.keys()) {
    return t.map((n) => [n, this.get(n)]);
  }
  evict(t = !1) {
    if (t || this.size > 0) {
      const n = this.first;
      delete this.items[n.key], --this.size === 0 ? (this.first = null, this.last = null) : (this.first = n.next, this.first.prev = null);
    }
    return this;
  }
  expiresAt(t) {
    let n;
    return this.has(t) && (n = this.items[t].expiry), n;
  }
  get(t) {
    let n;
    if (this.has(t)) {
      const r = this.items[t];
      this.ttl > 0 && r.expiry <= Date.now() ? this.delete(t) : (n = r.value, this.set(t, n, !0));
    }
    return n;
  }
  has(t) {
    return t in this.items;
  }
  keys() {
    const t = [];
    let n = this.first;
    for (; n !== null; )
      t.push(n.key), n = n.next;
    return t;
  }
  set(t, n, r = !1, i = this.resetTtl) {
    let s;
    if (r || this.has(t)) {
      if (s = this.items[t], s.value = n, r === !1 && i && (s.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl), this.last !== s) {
        const o = this.last, a = s.next, l = s.prev;
        this.first === s && (this.first = s.next), s.next = null, s.prev = this.last, o.next = s, l !== null && (l.next = a), a !== null && (a.prev = l);
      }
    } else
      this.max > 0 && this.size === this.max && this.evict(!0), s = this.items[t] = {
        expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
        key: t,
        prev: this.last,
        next: null,
        value: n
      }, ++this.size === 1 ? this.first = s : this.last.next = s;
    return this.last = s, this;
  }
  values(t = this.keys()) {
    return t.map((n) => this.get(n));
  }
};
function hS(e = 1e3, t = 0, n = !1) {
  if (isNaN(e) || e < 0)
    throw new TypeError("Invalid max value");
  if (isNaN(t) || t < 0)
    throw new TypeError("Invalid ttl value");
  if (typeof n != "boolean")
    throw new TypeError("Invalid resetTtl value");
  return new $0(e, t, n);
}
uu.LRU = $0;
uu.lru = hS;
const mS = {}, yS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: mS
}, Symbol.toStringTag, { value: "Module" })), at = /* @__PURE__ */ Hi(yS);
var cu = { exports: {} }, N0 = {}, li = {}, gS = O0;
function O0(e, t, n) {
  e instanceof RegExp && (e = Kh(e, n)), t instanceof RegExp && (t = Kh(t, n));
  var r = I0(e, t, n);
  return r && {
    start: r[0],
    end: r[1],
    pre: n.slice(0, r[0]),
    body: n.slice(r[0] + e.length, r[1]),
    post: n.slice(r[1] + t.length)
  };
}
function Kh(e, t) {
  var n = t.match(e);
  return n ? n[0] : null;
}
O0.range = I0;
function I0(e, t, n) {
  var r, i, s, o, a, l = n.indexOf(e), c = n.indexOf(t, l + 1), u = l;
  if (l >= 0 && c > 0) {
    if (e === t)
      return [l, c];
    for (r = [], s = n.length; u >= 0 && !a; )
      u == l ? (r.push(u), l = n.indexOf(e, u + 1)) : r.length == 1 ? a = [r.pop(), c] : (i = r.pop(), i < s && (s = i, o = c), c = n.indexOf(t, u + 1)), u = l < c && l >= 0 ? l : c;
    r.length && (a = [s, o]);
  }
  return a;
}
var R0 = gS, bS = wS, A0 = "\0SLASH" + Math.random() + "\0", x0 = "\0OPEN" + Math.random() + "\0", Rd = "\0CLOSE" + Math.random() + "\0", D0 = "\0COMMA" + Math.random() + "\0", P0 = "\0PERIOD" + Math.random() + "\0";
function jc(e) {
  return parseInt(e, 10) == e ? parseInt(e, 10) : e.charCodeAt(0);
}
function vS(e) {
  return e.split("\\\\").join(A0).split("\\{").join(x0).split("\\}").join(Rd).split("\\,").join(D0).split("\\.").join(P0);
}
function _S(e) {
  return e.split(A0).join("\\").split(x0).join("{").split(Rd).join("}").split(D0).join(",").split(P0).join(".");
}
function k0(e) {
  if (!e)
    return [""];
  var t = [], n = R0("{", "}", e);
  if (!n)
    return e.split(",");
  var r = n.pre, i = n.body, s = n.post, o = r.split(",");
  o[o.length - 1] += "{" + i + "}";
  var a = k0(s);
  return s.length && (o[o.length - 1] += a.shift(), o.push.apply(o, a)), t.push.apply(t, o), t;
}
function wS(e) {
  return e ? (e.substr(0, 2) === "{}" && (e = "\\{\\}" + e.substr(2)), vo(vS(e), !0).map(_S)) : [];
}
function ES(e) {
  return "{" + e + "}";
}
function SS(e) {
  return /^-?0\d/.test(e);
}
function TS(e, t) {
  return e <= t;
}
function $S(e, t) {
  return e >= t;
}
function vo(e, t) {
  var n = [], r = R0("{", "}", e);
  if (!r)
    return [e];
  var i = r.pre, s = r.post.length ? vo(r.post, !1) : [""];
  if (/\$$/.test(r.pre))
    for (var o = 0; o < s.length; o++) {
      var a = i + "{" + r.body + "}" + s[o];
      n.push(a);
    }
  else {
    var l = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(r.body), c = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(r.body), u = l || c, f = r.body.indexOf(",") >= 0;
    if (!u && !f)
      return r.post.match(/,.*\}/) ? (e = r.pre + "{" + r.body + Rd + r.post, vo(e)) : [e];
    var d;
    if (u)
      d = r.body.split(/\.\./);
    else if (d = k0(r.body), d.length === 1 && (d = vo(d[0], !1).map(ES), d.length === 1))
      return s.map(function(ee) {
        return r.pre + d[0] + ee;
      });
    var p;
    if (u) {
      var h = jc(d[0]), m = jc(d[1]), v = Math.max(d[0].length, d[1].length), b = d.length == 3 ? Math.abs(jc(d[2])) : 1, E = TS, y = m < h;
      y && (b *= -1, E = $S);
      var D = d.some(SS);
      p = [];
      for (var F = h; E(F, m); F += b) {
        var W;
        if (c)
          W = String.fromCharCode(F), W === "\\" && (W = "");
        else if (W = String(F), D) {
          var J = v - W.length;
          if (J > 0) {
            var Z = new Array(J + 1).join("0");
            F < 0 ? W = "-" + Z + W.slice(1) : W = Z + W;
          }
        }
        p.push(W);
      }
    } else {
      p = [];
      for (var j = 0; j < d.length; j++)
        p.push.apply(p, vo(d[j], !1));
    }
    for (var j = 0; j < p.length; j++)
      for (var o = 0; o < s.length; o++) {
        var a = i + p[j] + s[o];
        (!t || u || a) && n.push(a);
      }
  }
  return n;
}
var fu = {};
Object.defineProperty(fu, "__esModule", { value: !0 });
fu.assertValidPattern = void 0;
const NS = 1024 * 64, OS = (e) => {
  if (typeof e != "string")
    throw new TypeError("invalid pattern");
  if (e.length > NS)
    throw new TypeError("pattern is too long");
};
fu.assertValidPattern = OS;
var Vo = {}, du = {};
Object.defineProperty(du, "__esModule", { value: !0 });
du.parseClass = void 0;
const IS = {
  "[:alnum:]": ["\\p{L}\\p{Nl}\\p{Nd}", !0],
  "[:alpha:]": ["\\p{L}\\p{Nl}", !0],
  "[:ascii:]": ["\\x00-\\x7f", !1],
  "[:blank:]": ["\\p{Zs}\\t", !0],
  "[:cntrl:]": ["\\p{Cc}", !0],
  "[:digit:]": ["\\p{Nd}", !0],
  "[:graph:]": ["\\p{Z}\\p{C}", !0, !0],
  "[:lower:]": ["\\p{Ll}", !0],
  "[:print:]": ["\\p{C}", !0],
  "[:punct:]": ["\\p{P}", !0],
  "[:space:]": ["\\p{Z}\\t\\r\\n\\v\\f", !0],
  "[:upper:]": ["\\p{Lu}", !0],
  "[:word:]": ["\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}", !0],
  "[:xdigit:]": ["A-Fa-f0-9", !1]
}, so = (e) => e.replace(/[[\]\\-]/g, "\\$&"), RS = (e) => e.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), Yh = (e) => e.join(""), AS = (e, t) => {
  const n = t;
  if (e.charAt(n) !== "[")
    throw new Error("not in a brace expression");
  const r = [], i = [];
  let s = n + 1, o = !1, a = !1, l = !1, c = !1, u = n, f = "";
  e:
    for (; s < e.length; ) {
      const m = e.charAt(s);
      if ((m === "!" || m === "^") && s === n + 1) {
        c = !0, s++;
        continue;
      }
      if (m === "]" && o && !l) {
        u = s + 1;
        break;
      }
      if (o = !0, m === "\\" && !l) {
        l = !0, s++;
        continue;
      }
      if (m === "[" && !l) {
        for (const [v, [b, E, y]] of Object.entries(IS))
          if (e.startsWith(v, s)) {
            if (f)
              return ["$.", !1, e.length - n, !0];
            s += v.length, y ? i.push(b) : r.push(b), a = a || E;
            continue e;
          }
      }
      if (l = !1, f) {
        m > f ? r.push(so(f) + "-" + so(m)) : m === f && r.push(so(m)), f = "", s++;
        continue;
      }
      if (e.startsWith("-]", s + 1)) {
        r.push(so(m + "-")), s += 2;
        continue;
      }
      if (e.startsWith("-", s + 1)) {
        f = m, s += 2;
        continue;
      }
      r.push(so(m)), s++;
    }
  if (u < s)
    return ["", !1, 0, !1];
  if (!r.length && !i.length)
    return ["$.", !1, e.length - n, !0];
  if (i.length === 0 && r.length === 1 && /^\\?.$/.test(r[0]) && !c) {
    const m = r[0].length === 2 ? r[0].slice(-1) : r[0];
    return [RS(m), !1, u - n, !1];
  }
  const d = "[" + (c ? "^" : "") + Yh(r) + "]", p = "[" + (c ? "" : "^") + Yh(i) + "]";
  return [r.length && i.length ? "(" + d + "|" + p + ")" : r.length ? d : p, a, u - n, !0];
};
du.parseClass = AS;
var _s = {};
Object.defineProperty(_s, "__esModule", { value: !0 });
_s.unescape = void 0;
const xS = (e, { windowsPathsNoEscape: t = !1 } = {}) => t ? e.replace(/\[([^\/\\])\]/g, "$1") : e.replace(/((?!\\).|^)\[([^\/\\])\]/g, "$1$2").replace(/\\([^\/])/g, "$1");
_s.unescape = xS;
Object.defineProperty(Vo, "__esModule", { value: !0 });
Vo.AST = void 0;
const DS = du, xa = _s, PS = /* @__PURE__ */ new Set(["!", "?", "+", "*", "@"]), Xh = (e) => PS.has(e), kS = "(?!(?:^|/)\\.\\.?(?:$|/))", Da = "(?!\\.)", LS = /* @__PURE__ */ new Set(["[", "."]), jS = /* @__PURE__ */ new Set(["..", "."]), CS = new Set("().*{}+?[]^$\\!"), MS = (e) => e.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), Ad = "[^/]", Zh = Ad + "*?", em = Ad + "+?";
class an {
  type;
  #e;
  #t;
  #s = !1;
  #n = [];
  #o;
  #g;
  #u;
  #c = !1;
  #a;
  #l;
  // set to true if it's an extglob with no children
  // (which really means one child of '')
  #r = !1;
  constructor(t, n, r = {}) {
    this.type = t, t && (this.#t = !0), this.#o = n, this.#e = this.#o ? this.#o.#e : this, this.#a = this.#e === this ? r : this.#e.#a, this.#u = this.#e === this ? [] : this.#e.#u, t === "!" && !this.#e.#c && this.#u.push(this), this.#g = this.#o ? this.#o.#n.length : 0;
  }
  get hasMagic() {
    if (this.#t !== void 0)
      return this.#t;
    for (const t of this.#n)
      if (typeof t != "string" && (t.type || t.hasMagic))
        return this.#t = !0;
    return this.#t;
  }
  // reconstructs the pattern
  toString() {
    return this.#l !== void 0 ? this.#l : this.type ? this.#l = this.type + "(" + this.#n.map((t) => String(t)).join("|") + ")" : this.#l = this.#n.map((t) => String(t)).join("");
  }
  #p() {
    if (this !== this.#e)
      throw new Error("should only call on root");
    if (this.#c)
      return this;
    this.toString(), this.#c = !0;
    let t;
    for (; t = this.#u.pop(); ) {
      if (t.type !== "!")
        continue;
      let n = t, r = n.#o;
      for (; r; ) {
        for (let i = n.#g + 1; !r.type && i < r.#n.length; i++)
          for (const s of t.#n) {
            if (typeof s == "string")
              throw new Error("string part in extglob AST??");
            s.copyIn(r.#n[i]);
          }
        n = r, r = n.#o;
      }
    }
    return this;
  }
  push(...t) {
    for (const n of t)
      if (n !== "") {
        if (typeof n != "string" && !(n instanceof an && n.#o === this))
          throw new Error("invalid part: " + n);
        this.#n.push(n);
      }
  }
  toJSON() {
    const t = this.type === null ? this.#n.slice().map((n) => typeof n == "string" ? n : n.toJSON()) : [this.type, ...this.#n.map((n) => n.toJSON())];
    return this.isStart() && !this.type && t.unshift([]), this.isEnd() && (this === this.#e || this.#e.#c && this.#o?.type === "!") && t.push({}), t;
  }
  isStart() {
    if (this.#e === this)
      return !0;
    if (!this.#o?.isStart())
      return !1;
    if (this.#g === 0)
      return !0;
    const t = this.#o;
    for (let n = 0; n < this.#g; n++) {
      const r = t.#n[n];
      if (!(r instanceof an && r.type === "!"))
        return !1;
    }
    return !0;
  }
  isEnd() {
    if (this.#e === this || this.#o?.type === "!")
      return !0;
    if (!this.#o?.isEnd())
      return !1;
    if (!this.type)
      return this.#o?.isEnd();
    const t = this.#o ? this.#o.#n.length : 0;
    return this.#g === t - 1;
  }
  copyIn(t) {
    typeof t == "string" ? this.push(t) : this.push(t.clone(this));
  }
  clone(t) {
    const n = new an(this.type, t);
    for (const r of this.#n)
      n.copyIn(r);
    return n;
  }
  static #h(t, n, r, i) {
    let s = !1, o = !1, a = -1, l = !1;
    if (n.type === null) {
      let p = r, h = "";
      for (; p < t.length; ) {
        const m = t.charAt(p++);
        if (s || m === "\\") {
          s = !s, h += m;
          continue;
        }
        if (o) {
          p === a + 1 ? (m === "^" || m === "!") && (l = !0) : m === "]" && !(p === a + 2 && l) && (o = !1), h += m;
          continue;
        } else if (m === "[") {
          o = !0, a = p, l = !1, h += m;
          continue;
        }
        if (!i.noext && Xh(m) && t.charAt(p) === "(") {
          n.push(h), h = "";
          const v = new an(m, n);
          p = an.#h(t, v, p, i), n.push(v);
          continue;
        }
        h += m;
      }
      return n.push(h), p;
    }
    let c = r + 1, u = new an(null, n);
    const f = [];
    let d = "";
    for (; c < t.length; ) {
      const p = t.charAt(c++);
      if (s || p === "\\") {
        s = !s, d += p;
        continue;
      }
      if (o) {
        c === a + 1 ? (p === "^" || p === "!") && (l = !0) : p === "]" && !(c === a + 2 && l) && (o = !1), d += p;
        continue;
      } else if (p === "[") {
        o = !0, a = c, l = !1, d += p;
        continue;
      }
      if (Xh(p) && t.charAt(c) === "(") {
        u.push(d), d = "";
        const h = new an(p, u);
        u.push(h), c = an.#h(t, h, c, i);
        continue;
      }
      if (p === "|") {
        u.push(d), d = "", f.push(u), u = new an(null, n);
        continue;
      }
      if (p === ")")
        return d === "" && n.#n.length === 0 && (n.#r = !0), u.push(d), d = "", n.push(...f, u), c;
      d += p;
    }
    return n.type = null, n.#t = void 0, n.#n = [t.substring(r - 1)], c;
  }
  static fromGlob(t, n = {}) {
    const r = new an(null, void 0, n);
    return an.#h(t, r, 0, n), r;
  }
  // returns the regular expression if there's magic, or the unescaped
  // string if not.
  toMMPattern() {
    if (this !== this.#e)
      return this.#e.toMMPattern();
    const t = this.toString(), [n, r, i, s] = this.toRegExpSource();
    if (!(i || this.#t || this.#a.nocase && !this.#a.nocaseMagicOnly && t.toUpperCase() !== t.toLowerCase()))
      return r;
    const a = (this.#a.nocase ? "i" : "") + (s ? "u" : "");
    return Object.assign(new RegExp(`^${n}$`, a), {
      _src: n,
      _glob: t
    });
  }
  get options() {
    return this.#a;
  }
  // returns the string match, the regexp source, whether there's magic
  // in the regexp (so a regular expression is required) and whether or
  // not the uflag is needed for the regular expression (for posix classes)
  // TODO: instead of injecting the start/end at this point, just return
  // the BODY of the regexp, along with the start/end portions suitable
  // for binding the start/end in either a joined full-path makeRe context
  // (where we bind to (^|/), or a standalone matchPart context (where
  // we bind to ^, and not /).  Otherwise slashes get duped!
  //
  // In part-matching mode, the start is:
  // - if not isStart: nothing
  // - if traversal possible, but not allowed: ^(?!\.\.?$)
  // - if dots allowed or not possible: ^
  // - if dots possible and not allowed: ^(?!\.)
  // end is:
  // - if not isEnd(): nothing
  // - else: $
  //
  // In full-path matching mode, we put the slash at the START of the
  // pattern, so start is:
  // - if first pattern: same as part-matching mode
  // - if not isStart(): nothing
  // - if traversal possible, but not allowed: /(?!\.\.?(?:$|/))
  // - if dots allowed or not possible: /
  // - if dots possible and not allowed: /(?!\.)
  // end is:
  // - if last pattern, same as part-matching mode
  // - else nothing
  //
  // Always put the (?:$|/) on negated tails, though, because that has to be
  // there to bind the end of the negated pattern portion, and it's easier to
  // just stick it in now rather than try to inject it later in the middle of
  // the pattern.
  //
  // We can just always return the same end, and leave it up to the caller
  // to know whether it's going to be used joined or in parts.
  // And, if the start is adjusted slightly, can do the same there:
  // - if not isStart: nothing
  // - if traversal possible, but not allowed: (?:/|^)(?!\.\.?$)
  // - if dots allowed or not possible: (?:/|^)
  // - if dots possible and not allowed: (?:/|^)(?!\.)
  //
  // But it's better to have a simpler binding without a conditional, for
  // performance, so probably better to return both start options.
  //
  // Then the caller just ignores the end if it's not the first pattern,
  // and the start always gets applied.
  //
  // But that's always going to be $ if it's the ending pattern, or nothing,
  // so the caller can just attach $ at the end of the pattern when building.
  //
  // So the todo is:
  // - better detect what kind of start is needed
  // - return both flavors of starting pattern
  // - attach $ at the end of the pattern when creating the actual RegExp
  //
  // Ah, but wait, no, that all only applies to the root when the first pattern
  // is not an extglob. If the first pattern IS an extglob, then we need all
  // that dot prevention biz to live in the extglob portions, because eg
  // +(*|.x*) can match .xy but not .yx.
  //
  // So, return the two flavors if it's #root and the first child is not an
  // AST, otherwise leave it to the child AST to handle it, and there,
  // use the (?:^|/) style of start binding.
  //
  // Even simplified further:
  // - Since the start for a join is eg /(?!\.) and the start for a part
  // is ^(?!\.), we can just prepend (?!\.) to the pattern (either root
  // or start or whatever) and prepend ^ or / at the Regexp construction.
  toRegExpSource(t) {
    const n = t ?? !!this.#a.dot;
    if (this.#e === this && this.#p(), !this.type) {
      const l = this.isStart() && this.isEnd(), c = this.#n.map((p) => {
        const [h, m, v, b] = typeof p == "string" ? an.#d(p, this.#t, l) : p.toRegExpSource(t);
        return this.#t = this.#t || v, this.#s = this.#s || b, h;
      }).join("");
      let u = "";
      if (this.isStart() && typeof this.#n[0] == "string" && !(this.#n.length === 1 && jS.has(this.#n[0]))) {
        const h = LS, m = (
          // dots are allowed, and the pattern starts with [ or .
          n && h.has(c.charAt(0)) || // the pattern starts with \., and then [ or .
          c.startsWith("\\.") && h.has(c.charAt(2)) || // the pattern starts with \.\., and then [ or .
          c.startsWith("\\.\\.") && h.has(c.charAt(4))
        ), v = !n && !t && h.has(c.charAt(0));
        u = m ? kS : v ? Da : "";
      }
      let f = "";
      return this.isEnd() && this.#e.#c && this.#o?.type === "!" && (f = "(?:$|\\/)"), [
        u + c + f,
        (0, xa.unescape)(c),
        this.#t = !!this.#t,
        this.#s
      ];
    }
    const r = this.type === "*" || this.type === "+", i = this.type === "!" ? "(?:(?!(?:" : "(?:";
    let s = this.#m(n);
    if (this.isStart() && this.isEnd() && !s && this.type !== "!") {
      const l = this.toString();
      return this.#n = [l], this.type = null, this.#t = void 0, [l, (0, xa.unescape)(this.toString()), !1, !1];
    }
    let o = !r || t || n || !Da ? "" : this.#m(!0);
    o === s && (o = ""), o && (s = `(?:${s})(?:${o})*?`);
    let a = "";
    if (this.type === "!" && this.#r)
      a = (this.isStart() && !n ? Da : "") + em;
    else {
      const l = this.type === "!" ? (
        // !() must match something,but !(x) can match ''
        "))" + (this.isStart() && !n && !t ? Da : "") + Zh + ")"
      ) : this.type === "@" ? ")" : this.type === "?" ? ")?" : this.type === "+" && o ? ")" : this.type === "*" && o ? ")?" : `)${this.type}`;
      a = i + s + l;
    }
    return [
      a,
      (0, xa.unescape)(s),
      this.#t = !!this.#t,
      this.#s
    ];
  }
  #m(t) {
    return this.#n.map((n) => {
      if (typeof n == "string")
        throw new Error("string type in extglob ast??");
      const [r, i, s, o] = n.toRegExpSource(t);
      return this.#s = this.#s || o, r;
    }).filter((n) => !(this.isStart() && this.isEnd()) || !!n).join("|");
  }
  static #d(t, n, r = !1) {
    let i = !1, s = "", o = !1;
    for (let a = 0; a < t.length; a++) {
      const l = t.charAt(a);
      if (i) {
        i = !1, s += (CS.has(l) ? "\\" : "") + l;
        continue;
      }
      if (l === "\\") {
        a === t.length - 1 ? s += "\\\\" : i = !0;
        continue;
      }
      if (l === "[") {
        const [c, u, f, d] = (0, DS.parseClass)(t, a);
        if (f) {
          s += c, o = o || u, a += f - 1, n = n || d;
          continue;
        }
      }
      if (l === "*") {
        r && t === "*" ? s += em : s += Zh, n = !0;
        continue;
      }
      if (l === "?") {
        s += Ad, n = !0;
        continue;
      }
      s += MS(l);
    }
    return [s, (0, xa.unescape)(t), !!n, o];
  }
}
Vo.AST = an;
var Bo = {};
Object.defineProperty(Bo, "__esModule", { value: !0 });
Bo.escape = void 0;
const FS = (e, { windowsPathsNoEscape: t = !1 } = {}) => t ? e.replace(/[?*()[\]]/g, "[$&]") : e.replace(/[?*()[\]\\]/g, "\\$&");
Bo.escape = FS;
(function(e) {
  var t = We && We.__importDefault || function(oe) {
    return oe && oe.__esModule ? oe : { default: oe };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.unescape = e.escape = e.AST = e.Minimatch = e.match = e.makeRe = e.braceExpand = e.defaults = e.filter = e.GLOBSTAR = e.sep = e.minimatch = void 0;
  const n = t(bS), r = fu, i = Vo, s = Bo, o = _s, a = (oe, S, $ = {}) => ((0, r.assertValidPattern)(S), !$.nocomment && S.charAt(0) === "#" ? !1 : new k(S, $).match(oe));
  e.minimatch = a;
  const l = /^\*+([^+@!?\*\[\(]*)$/, c = (oe) => (S) => !S.startsWith(".") && S.endsWith(oe), u = (oe) => (S) => S.endsWith(oe), f = (oe) => (oe = oe.toLowerCase(), (S) => !S.startsWith(".") && S.toLowerCase().endsWith(oe)), d = (oe) => (oe = oe.toLowerCase(), (S) => S.toLowerCase().endsWith(oe)), p = /^\*+\.\*+$/, h = (oe) => !oe.startsWith(".") && oe.includes("."), m = (oe) => oe !== "." && oe !== ".." && oe.includes("."), v = /^\.\*+$/, b = (oe) => oe !== "." && oe !== ".." && oe.startsWith("."), E = /^\*+$/, y = (oe) => oe.length !== 0 && !oe.startsWith("."), D = (oe) => oe.length !== 0 && oe !== "." && oe !== "..", F = /^\?+([^+@!?\*\[\(]*)?$/, W = ([oe, S = ""]) => {
    const $ = ee([oe]);
    return S ? (S = S.toLowerCase(), (O) => $(O) && O.toLowerCase().endsWith(S)) : $;
  }, J = ([oe, S = ""]) => {
    const $ = le([oe]);
    return S ? (S = S.toLowerCase(), (O) => $(O) && O.toLowerCase().endsWith(S)) : $;
  }, Z = ([oe, S = ""]) => {
    const $ = le([oe]);
    return S ? (O) => $(O) && O.endsWith(S) : $;
  }, j = ([oe, S = ""]) => {
    const $ = ee([oe]);
    return S ? (O) => $(O) && O.endsWith(S) : $;
  }, ee = ([oe]) => {
    const S = oe.length;
    return ($) => $.length === S && !$.startsWith(".");
  }, le = ([oe]) => {
    const S = oe.length;
    return ($) => $.length === S && $ !== "." && $ !== "..";
  }, ce = typeof process == "object" && process ? typeof process.env == "object" && process.env && process.env.__MINIMATCH_TESTING_PLATFORM__ || process.platform : "posix", U = {
    win32: { sep: "\\" },
    posix: { sep: "/" }
  };
  e.sep = ce === "win32" ? U.win32.sep : U.posix.sep, e.minimatch.sep = e.sep, e.GLOBSTAR = Symbol("globstar **"), e.minimatch.GLOBSTAR = e.GLOBSTAR;
  const ne = "[^/]" + "*?", K = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?", se = "(?:(?!(?:\\/|^)\\.).)*?", re = (oe, S = {}) => ($) => (0, e.minimatch)($, oe, S);
  e.filter = re, e.minimatch.filter = e.filter;
  const ue = (oe, S = {}) => Object.assign({}, oe, S), te = (oe) => {
    if (!oe || typeof oe != "object" || !Object.keys(oe).length)
      return e.minimatch;
    const S = e.minimatch;
    return Object.assign((O, I, L = {}) => S(O, I, ue(oe, L)), {
      Minimatch: class extends S.Minimatch {
        constructor(I, L = {}) {
          super(I, ue(oe, L));
        }
        static defaults(I) {
          return S.defaults(ue(oe, I)).Minimatch;
        }
      },
      AST: class extends S.AST {
        /* c8 ignore start */
        constructor(I, L, H = {}) {
          super(I, L, ue(oe, H));
        }
        /* c8 ignore stop */
        static fromGlob(I, L = {}) {
          return S.AST.fromGlob(I, ue(oe, L));
        }
      },
      unescape: (O, I = {}) => S.unescape(O, ue(oe, I)),
      escape: (O, I = {}) => S.escape(O, ue(oe, I)),
      filter: (O, I = {}) => S.filter(O, ue(oe, I)),
      defaults: (O) => S.defaults(ue(oe, O)),
      makeRe: (O, I = {}) => S.makeRe(O, ue(oe, I)),
      braceExpand: (O, I = {}) => S.braceExpand(O, ue(oe, I)),
      match: (O, I, L = {}) => S.match(O, I, ue(oe, L)),
      sep: S.sep,
      GLOBSTAR: e.GLOBSTAR
    });
  };
  e.defaults = te, e.minimatch.defaults = e.defaults;
  const B = (oe, S = {}) => ((0, r.assertValidPattern)(oe), S.nobrace || !/\{(?:(?!\{).)*\}/.test(oe) ? [oe] : (0, n.default)(oe));
  e.braceExpand = B, e.minimatch.braceExpand = e.braceExpand;
  const M = (oe, S = {}) => new k(oe, S).makeRe();
  e.makeRe = M, e.minimatch.makeRe = e.makeRe;
  const N = (oe, S, $ = {}) => {
    const O = new k(S, $);
    return oe = oe.filter((I) => O.match(I)), O.options.nonull && !oe.length && oe.push(S), oe;
  };
  e.match = N, e.minimatch.match = e.match;
  const T = /[?*]|[+@!]\(.*?\)|\[|\]/, P = (oe) => oe.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
  class k {
    options;
    set;
    pattern;
    windowsPathsNoEscape;
    nonegate;
    negate;
    comment;
    empty;
    preserveMultipleSlashes;
    partial;
    globSet;
    globParts;
    nocase;
    isWindows;
    platform;
    windowsNoMagicRoot;
    regexp;
    constructor(S, $ = {}) {
      (0, r.assertValidPattern)(S), $ = $ || {}, this.options = $, this.pattern = S, this.platform = $.platform || ce, this.isWindows = this.platform === "win32", this.windowsPathsNoEscape = !!$.windowsPathsNoEscape || $.allowWindowsEscape === !1, this.windowsPathsNoEscape && (this.pattern = this.pattern.replace(/\\/g, "/")), this.preserveMultipleSlashes = !!$.preserveMultipleSlashes, this.regexp = null, this.negate = !1, this.nonegate = !!$.nonegate, this.comment = !1, this.empty = !1, this.partial = !!$.partial, this.nocase = !!this.options.nocase, this.windowsNoMagicRoot = $.windowsNoMagicRoot !== void 0 ? $.windowsNoMagicRoot : !!(this.isWindows && this.nocase), this.globSet = [], this.globParts = [], this.set = [], this.make();
    }
    hasMagic() {
      if (this.options.magicalBraces && this.set.length > 1)
        return !0;
      for (const S of this.set)
        for (const $ of S)
          if (typeof $ != "string")
            return !0;
      return !1;
    }
    debug(...S) {
    }
    make() {
      const S = this.pattern, $ = this.options;
      if (!$.nocomment && S.charAt(0) === "#") {
        this.comment = !0;
        return;
      }
      if (!S) {
        this.empty = !0;
        return;
      }
      this.parseNegate(), this.globSet = [...new Set(this.braceExpand())], $.debug && (this.debug = (...L) => console.error(...L)), this.debug(this.pattern, this.globSet);
      const O = this.globSet.map((L) => this.slashSplit(L));
      this.globParts = this.preprocess(O), this.debug(this.pattern, this.globParts);
      let I = this.globParts.map((L, H, ae) => {
        if (this.isWindows && this.windowsNoMagicRoot) {
          const Ee = L[0] === "" && L[1] === "" && (L[2] === "?" || !T.test(L[2])) && !T.test(L[3]), Oe = /^[a-z]:/i.test(L[0]);
          if (Ee)
            return [...L.slice(0, 4), ...L.slice(4).map((Te) => this.parse(Te))];
          if (Oe)
            return [L[0], ...L.slice(1).map((Te) => this.parse(Te))];
        }
        return L.map((Ee) => this.parse(Ee));
      });
      if (this.debug(this.pattern, I), this.set = I.filter((L) => L.indexOf(!1) === -1), this.isWindows)
        for (let L = 0; L < this.set.length; L++) {
          const H = this.set[L];
          H[0] === "" && H[1] === "" && this.globParts[L][2] === "?" && typeof H[3] == "string" && /^[a-z]:$/i.test(H[3]) && (H[2] = "?");
        }
      this.debug(this.pattern, this.set);
    }
    // various transforms to equivalent pattern sets that are
    // faster to process in a filesystem walk.  The goal is to
    // eliminate what we can, and push all ** patterns as far
    // to the right as possible, even if it increases the number
    // of patterns that we have to process.
    preprocess(S) {
      if (this.options.noglobstar)
        for (let O = 0; O < S.length; O++)
          for (let I = 0; I < S[O].length; I++)
            S[O][I] === "**" && (S[O][I] = "*");
      const { optimizationLevel: $ = 1 } = this.options;
      return $ >= 2 ? (S = this.firstPhasePreProcess(S), S = this.secondPhasePreProcess(S)) : $ >= 1 ? S = this.levelOneOptimize(S) : S = this.adjascentGlobstarOptimize(S), S;
    }
    // just get rid of adjascent ** portions
    adjascentGlobstarOptimize(S) {
      return S.map(($) => {
        let O = -1;
        for (; (O = $.indexOf("**", O + 1)) !== -1; ) {
          let I = O;
          for (; $[I + 1] === "**"; )
            I++;
          I !== O && $.splice(O, I - O);
        }
        return $;
      });
    }
    // get rid of adjascent ** and resolve .. portions
    levelOneOptimize(S) {
      return S.map(($) => ($ = $.reduce((O, I) => {
        const L = O[O.length - 1];
        return I === "**" && L === "**" ? O : I === ".." && L && L !== ".." && L !== "." && L !== "**" ? (O.pop(), O) : (O.push(I), O);
      }, []), $.length === 0 ? [""] : $));
    }
    levelTwoFileOptimize(S) {
      Array.isArray(S) || (S = this.slashSplit(S));
      let $ = !1;
      do {
        if ($ = !1, !this.preserveMultipleSlashes) {
          for (let I = 1; I < S.length - 1; I++) {
            const L = S[I];
            I === 1 && L === "" && S[0] === "" || (L === "." || L === "") && ($ = !0, S.splice(I, 1), I--);
          }
          S[0] === "." && S.length === 2 && (S[1] === "." || S[1] === "") && ($ = !0, S.pop());
        }
        let O = 0;
        for (; (O = S.indexOf("..", O + 1)) !== -1; ) {
          const I = S[O - 1];
          I && I !== "." && I !== ".." && I !== "**" && ($ = !0, S.splice(O - 1, 2), O -= 2);
        }
      } while ($);
      return S.length === 0 ? [""] : S;
    }
    // First phase: single-pattern processing
    // <pre> is 1 or more portions
    // <rest> is 1 or more portions
    // <p> is any portion other than ., .., '', or **
    // <e> is . or ''
    //
    // **/.. is *brutal* for filesystem walking performance, because
    // it effectively resets the recursive walk each time it occurs,
    // and ** cannot be reduced out by a .. pattern part like a regexp
    // or most strings (other than .., ., and '') can be.
    //
    // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
    // <pre>/<e>/<rest> -> <pre>/<rest>
    // <pre>/<p>/../<rest> -> <pre>/<rest>
    // **/**/<rest> -> **/<rest>
    //
    // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow
    // this WOULD be allowed if ** did follow symlinks, or * didn't
    firstPhasePreProcess(S) {
      let $ = !1;
      do {
        $ = !1;
        for (let O of S) {
          let I = -1;
          for (; (I = O.indexOf("**", I + 1)) !== -1; ) {
            let H = I;
            for (; O[H + 1] === "**"; )
              H++;
            H > I && O.splice(I + 1, H - I);
            let ae = O[I + 1];
            const Ee = O[I + 2], Oe = O[I + 3];
            if (ae !== ".." || !Ee || Ee === "." || Ee === ".." || !Oe || Oe === "." || Oe === "..")
              continue;
            $ = !0, O.splice(I, 1);
            const Te = O.slice(0);
            Te[I] = "**", S.push(Te), I--;
          }
          if (!this.preserveMultipleSlashes) {
            for (let H = 1; H < O.length - 1; H++) {
              const ae = O[H];
              H === 1 && ae === "" && O[0] === "" || (ae === "." || ae === "") && ($ = !0, O.splice(H, 1), H--);
            }
            O[0] === "." && O.length === 2 && (O[1] === "." || O[1] === "") && ($ = !0, O.pop());
          }
          let L = 0;
          for (; (L = O.indexOf("..", L + 1)) !== -1; ) {
            const H = O[L - 1];
            if (H && H !== "." && H !== ".." && H !== "**") {
              $ = !0;
              const Ee = L === 1 && O[L + 1] === "**" ? ["."] : [];
              O.splice(L - 1, 2, ...Ee), O.length === 0 && O.push(""), L -= 2;
            }
          }
        }
      } while ($);
      return S;
    }
    // second phase: multi-pattern dedupes
    // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>
    // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>
    // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>
    //
    // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>
    // ^-- not valid because ** doens't follow symlinks
    secondPhasePreProcess(S) {
      for (let $ = 0; $ < S.length - 1; $++)
        for (let O = $ + 1; O < S.length; O++) {
          const I = this.partsMatch(S[$], S[O], !this.preserveMultipleSlashes);
          if (I) {
            S[$] = [], S[O] = I;
            break;
          }
        }
      return S.filter(($) => $.length);
    }
    partsMatch(S, $, O = !1) {
      let I = 0, L = 0, H = [], ae = "";
      for (; I < S.length && L < $.length; )
        if (S[I] === $[L])
          H.push(ae === "b" ? $[L] : S[I]), I++, L++;
        else if (O && S[I] === "**" && $[L] === S[I + 1])
          H.push(S[I]), I++;
        else if (O && $[L] === "**" && S[I] === $[L + 1])
          H.push($[L]), L++;
        else if (S[I] === "*" && $[L] && (this.options.dot || !$[L].startsWith(".")) && $[L] !== "**") {
          if (ae === "b")
            return !1;
          ae = "a", H.push(S[I]), I++, L++;
        } else if ($[L] === "*" && S[I] && (this.options.dot || !S[I].startsWith(".")) && S[I] !== "**") {
          if (ae === "a")
            return !1;
          ae = "b", H.push($[L]), I++, L++;
        } else
          return !1;
      return S.length === $.length && H;
    }
    parseNegate() {
      if (this.nonegate)
        return;
      const S = this.pattern;
      let $ = !1, O = 0;
      for (let I = 0; I < S.length && S.charAt(I) === "!"; I++)
        $ = !$, O++;
      O && (this.pattern = S.slice(O)), this.negate = $;
    }
    // set partial to true to test if, for example,
    // "/a/b" matches the start of "/*/b/*/d"
    // Partial means, if you run out of file before you run
    // out of pattern, then that's fine, as long as all
    // the parts match.
    matchOne(S, $, O = !1) {
      const I = this.options;
      if (this.isWindows) {
        const Je = typeof S[0] == "string" && /^[a-z]:$/i.test(S[0]), bt = !Je && S[0] === "" && S[1] === "" && S[2] === "?" && /^[a-z]:$/i.test(S[3]), x = typeof $[0] == "string" && /^[a-z]:$/i.test($[0]), g = !x && $[0] === "" && $[1] === "" && $[2] === "?" && typeof $[3] == "string" && /^[a-z]:$/i.test($[3]), _ = bt ? 3 : Je ? 0 : void 0, V = g ? 3 : x ? 0 : void 0;
        if (typeof _ == "number" && typeof V == "number") {
          const [X, pe] = [S[_], $[V]];
          X.toLowerCase() === pe.toLowerCase() && ($[V] = X, V > _ ? $ = $.slice(V) : _ > V && (S = S.slice(_)));
        }
      }
      const { optimizationLevel: L = 1 } = this.options;
      L >= 2 && (S = this.levelTwoFileOptimize(S)), this.debug("matchOne", this, { file: S, pattern: $ }), this.debug("matchOne", S.length, $.length);
      for (var H = 0, ae = 0, Ee = S.length, Oe = $.length; H < Ee && ae < Oe; H++, ae++) {
        this.debug("matchOne loop");
        var Te = $[ae], Me = S[H];
        if (this.debug($, Te, Me), Te === !1)
          return !1;
        if (Te === e.GLOBSTAR) {
          this.debug("GLOBSTAR", [$, Te, Me]);
          var we = H, Le = ae + 1;
          if (Le === Oe) {
            for (this.debug("** at the end"); H < Ee; H++)
              if (S[H] === "." || S[H] === ".." || !I.dot && S[H].charAt(0) === ".")
                return !1;
            return !0;
          }
          for (; we < Ee; ) {
            var ut = S[we];
            if (this.debug(`
globstar while`, S, we, $, Le, ut), this.matchOne(S.slice(we), $.slice(Le), O))
              return this.debug("globstar found match!", we, Ee, ut), !0;
            if (ut === "." || ut === ".." || !I.dot && ut.charAt(0) === ".") {
              this.debug("dot detected!", S, we, $, Le);
              break;
            }
            this.debug("globstar swallow a segment, and continue"), we++;
          }
          return !!(O && (this.debug(`
>>> no match, partial?`, S, we, $, Le), we === Ee));
        }
        let Je;
        if (typeof Te == "string" ? (Je = Me === Te, this.debug("string match", Te, Me, Je)) : (Je = Te.test(Me), this.debug("pattern match", Te, Me, Je)), !Je)
          return !1;
      }
      if (H === Ee && ae === Oe)
        return !0;
      if (H === Ee)
        return O;
      if (ae === Oe)
        return H === Ee - 1 && S[H] === "";
      throw new Error("wtf?");
    }
    braceExpand() {
      return (0, e.braceExpand)(this.pattern, this.options);
    }
    parse(S) {
      (0, r.assertValidPattern)(S);
      const $ = this.options;
      if (S === "**")
        return e.GLOBSTAR;
      if (S === "")
        return "";
      let O, I = null;
      (O = S.match(E)) ? I = $.dot ? D : y : (O = S.match(l)) ? I = ($.nocase ? $.dot ? d : f : $.dot ? u : c)(O[1]) : (O = S.match(F)) ? I = ($.nocase ? $.dot ? J : W : $.dot ? Z : j)(O) : (O = S.match(p)) ? I = $.dot ? m : h : (O = S.match(v)) && (I = b);
      const L = i.AST.fromGlob(S, this.options).toMMPattern();
      return I && typeof L == "object" && Reflect.defineProperty(L, "test", { value: I }), L;
    }
    makeRe() {
      if (this.regexp || this.regexp === !1)
        return this.regexp;
      const S = this.set;
      if (!S.length)
        return this.regexp = !1, this.regexp;
      const $ = this.options, O = $.noglobstar ? ne : $.dot ? K : se, I = new Set($.nocase ? ["i"] : []);
      let L = S.map((Ee) => {
        const Oe = Ee.map((Te) => {
          if (Te instanceof RegExp)
            for (const Me of Te.flags.split(""))
              I.add(Me);
          return typeof Te == "string" ? P(Te) : Te === e.GLOBSTAR ? e.GLOBSTAR : Te._src;
        });
        return Oe.forEach((Te, Me) => {
          const we = Oe[Me + 1], Le = Oe[Me - 1];
          Te !== e.GLOBSTAR || Le === e.GLOBSTAR || (Le === void 0 ? we !== void 0 && we !== e.GLOBSTAR ? Oe[Me + 1] = "(?:\\/|" + O + "\\/)?" + we : Oe[Me] = O : we === void 0 ? Oe[Me - 1] = Le + "(?:\\/|" + O + ")?" : we !== e.GLOBSTAR && (Oe[Me - 1] = Le + "(?:\\/|\\/" + O + "\\/)" + we, Oe[Me + 1] = e.GLOBSTAR));
        }), Oe.filter((Te) => Te !== e.GLOBSTAR).join("/");
      }).join("|");
      const [H, ae] = S.length > 1 ? ["(?:", ")"] : ["", ""];
      L = "^" + H + L + ae + "$", this.negate && (L = "^(?!" + L + ").+$");
      try {
        this.regexp = new RegExp(L, [...I].join(""));
      } catch {
        this.regexp = !1;
      }
      return this.regexp;
    }
    slashSplit(S) {
      return this.preserveMultipleSlashes ? S.split("/") : this.isWindows && /^\/\/[^\/]+/.test(S) ? ["", ...S.split(/\/+/)] : S.split(/\/+/);
    }
    match(S, $ = this.partial) {
      if (this.debug("match", S, this.pattern), this.comment)
        return !1;
      if (this.empty)
        return S === "";
      if (S === "/" && $)
        return !0;
      const O = this.options;
      this.isWindows && (S = S.split("\\").join("/"));
      const I = this.slashSplit(S);
      this.debug(this.pattern, "split", I);
      const L = this.set;
      this.debug(this.pattern, "set", L);
      let H = I[I.length - 1];
      if (!H)
        for (let ae = I.length - 2; !H && ae >= 0; ae--)
          H = I[ae];
      for (let ae = 0; ae < L.length; ae++) {
        const Ee = L[ae];
        let Oe = I;
        if (O.matchBase && Ee.length === 1 && (Oe = [H]), this.matchOne(Oe, Ee, $))
          return O.flipNegate ? !0 : !this.negate;
      }
      return O.flipNegate ? !1 : this.negate;
    }
    static defaults(S) {
      return e.minimatch.defaults(S).Minimatch;
    }
  }
  e.Minimatch = k;
  var q = Vo;
  Object.defineProperty(e, "AST", { enumerable: !0, get: function() {
    return q.AST;
  } });
  var Y = Bo;
  Object.defineProperty(e, "escape", { enumerable: !0, get: function() {
    return Y.escape;
  } });
  var ve = _s;
  Object.defineProperty(e, "unescape", { enumerable: !0, get: function() {
    return ve.unescape;
  } }), e.minimatch.AST = i.AST, e.minimatch.Minimatch = k, e.minimatch.escape = s.escape, e.minimatch.unescape = o.unescape;
})(li);
var Go = {}, $t = {}, pu = {};
Object.defineProperty(pu, "__esModule", { value: !0 });
pu.LRUCache = void 0;
const ss = typeof performance == "object" && performance && typeof performance.now == "function" ? performance : Date, L0 = /* @__PURE__ */ new Set(), jf = typeof process == "object" && process ? process : {}, j0 = (e, t, n, r) => {
  typeof jf.emitWarning == "function" ? jf.emitWarning(e, t, n, r) : console.error(`[${n}] ${t}: ${e}`);
};
let Al = globalThis.AbortController, tm = globalThis.AbortSignal;
if (typeof Al > "u") {
  tm = class {
    onabort;
    _onabort = [];
    reason;
    aborted = !1;
    addEventListener(r, i) {
      this._onabort.push(i);
    }
  }, Al = class {
    constructor() {
      t();
    }
    signal = new tm();
    abort(r) {
      if (!this.signal.aborted) {
        this.signal.reason = r, this.signal.aborted = !0;
        for (const i of this.signal._onabort)
          i(r);
        this.signal.onabort?.(r);
      }
    }
  };
  let e = jf.env?.LRU_CACHE_IGNORE_AC_WARNING !== "1";
  const t = () => {
    e && (e = !1, j0("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", t));
  };
}
const US = (e) => !L0.has(e), Xr = (e) => e && e === Math.floor(e) && e > 0 && isFinite(e), C0 = (e) => Xr(e) ? e <= Math.pow(2, 8) ? Uint8Array : e <= Math.pow(2, 16) ? Uint16Array : e <= Math.pow(2, 32) ? Uint32Array : e <= Number.MAX_SAFE_INTEGER ? ul : null : null;
class ul extends Array {
  constructor(t) {
    super(t), this.fill(0);
  }
}
class fs {
  heap;
  length;
  // private constructor
  static #e = !1;
  static create(t) {
    const n = C0(t);
    if (!n)
      return [];
    fs.#e = !0;
    const r = new fs(t, n);
    return fs.#e = !1, r;
  }
  constructor(t, n) {
    if (!fs.#e)
      throw new TypeError("instantiate Stack using Stack.create(n)");
    this.heap = new n(t), this.length = 0;
  }
  push(t) {
    this.heap[this.length++] = t;
  }
  pop() {
    return this.heap[--this.length];
  }
}
class xd {
  // options that cannot be changed without disaster
  #e;
  #t;
  #s;
  #n;
  #o;
  #g;
  /**
   * {@link LRUCache.OptionsBase.ttl}
   */
  ttl;
  /**
   * {@link LRUCache.OptionsBase.ttlResolution}
   */
  ttlResolution;
  /**
   * {@link LRUCache.OptionsBase.ttlAutopurge}
   */
  ttlAutopurge;
  /**
   * {@link LRUCache.OptionsBase.updateAgeOnGet}
   */
  updateAgeOnGet;
  /**
   * {@link LRUCache.OptionsBase.updateAgeOnHas}
   */
  updateAgeOnHas;
  /**
   * {@link LRUCache.OptionsBase.allowStale}
   */
  allowStale;
  /**
   * {@link LRUCache.OptionsBase.noDisposeOnSet}
   */
  noDisposeOnSet;
  /**
   * {@link LRUCache.OptionsBase.noUpdateTTL}
   */
  noUpdateTTL;
  /**
   * {@link LRUCache.OptionsBase.maxEntrySize}
   */
  maxEntrySize;
  /**
   * {@link LRUCache.OptionsBase.sizeCalculation}
   */
  sizeCalculation;
  /**
   * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
   */
  noDeleteOnFetchRejection;
  /**
   * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
   */
  noDeleteOnStaleGet;
  /**
   * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
   */
  allowStaleOnFetchAbort;
  /**
   * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
   */
  allowStaleOnFetchRejection;
  /**
   * {@link LRUCache.OptionsBase.ignoreFetchAbort}
   */
  ignoreFetchAbort;
  // computed properties
  #u;
  #c;
  #a;
  #l;
  #r;
  #p;
  #h;
  #m;
  #d;
  #S;
  #b;
  #T;
  #$;
  #_;
  #w;
  #E;
  #y;
  /**
   * Do not call this method unless you need to inspect the
   * inner workings of the cache.  If anything returned by this
   * object is modified in any way, strange breakage may occur.
   *
   * These fields are private for a reason!
   *
   * @internal
   */
  static unsafeExposeInternals(t) {
    return {
      // properties
      starts: t.#$,
      ttls: t.#_,
      sizes: t.#T,
      keyMap: t.#a,
      keyList: t.#l,
      valList: t.#r,
      next: t.#p,
      prev: t.#h,
      get head() {
        return t.#m;
      },
      get tail() {
        return t.#d;
      },
      free: t.#S,
      // methods
      isBackgroundFetch: (n) => t.#f(n),
      backgroundFetch: (n, r, i, s) => t.#M(n, r, i, s),
      moveToTail: (n) => t.#U(n),
      indexes: (n) => t.#O(n),
      rindexes: (n) => t.#I(n),
      isStale: (n) => t.#v(n)
    };
  }
  // Protected read-only members
  /**
   * {@link LRUCache.OptionsBase.max} (read-only)
   */
  get max() {
    return this.#e;
  }
  /**
   * {@link LRUCache.OptionsBase.maxSize} (read-only)
   */
  get maxSize() {
    return this.#t;
  }
  /**
   * The total computed size of items in the cache (read-only)
   */
  get calculatedSize() {
    return this.#c;
  }
  /**
   * The number of items stored in the cache (read-only)
   */
  get size() {
    return this.#u;
  }
  /**
   * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
   */
  get fetchMethod() {
    return this.#o;
  }
  get memoMethod() {
    return this.#g;
  }
  /**
   * {@link LRUCache.OptionsBase.dispose} (read-only)
   */
  get dispose() {
    return this.#s;
  }
  /**
   * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
   */
  get disposeAfter() {
    return this.#n;
  }
  constructor(t) {
    const { max: n = 0, ttl: r, ttlResolution: i = 1, ttlAutopurge: s, updateAgeOnGet: o, updateAgeOnHas: a, allowStale: l, dispose: c, disposeAfter: u, noDisposeOnSet: f, noUpdateTTL: d, maxSize: p = 0, maxEntrySize: h = 0, sizeCalculation: m, fetchMethod: v, memoMethod: b, noDeleteOnFetchRejection: E, noDeleteOnStaleGet: y, allowStaleOnFetchRejection: D, allowStaleOnFetchAbort: F, ignoreFetchAbort: W } = t;
    if (n !== 0 && !Xr(n))
      throw new TypeError("max option must be a nonnegative integer");
    const J = n ? C0(n) : Array;
    if (!J)
      throw new Error("invalid max value: " + n);
    if (this.#e = n, this.#t = p, this.maxEntrySize = h || this.#t, this.sizeCalculation = m, this.sizeCalculation) {
      if (!this.#t && !this.maxEntrySize)
        throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
      if (typeof this.sizeCalculation != "function")
        throw new TypeError("sizeCalculation set to non-function");
    }
    if (b !== void 0 && typeof b != "function")
      throw new TypeError("memoMethod must be a function if defined");
    if (this.#g = b, v !== void 0 && typeof v != "function")
      throw new TypeError("fetchMethod must be a function if specified");
    if (this.#o = v, this.#E = !!v, this.#a = /* @__PURE__ */ new Map(), this.#l = new Array(n).fill(void 0), this.#r = new Array(n).fill(void 0), this.#p = new J(n), this.#h = new J(n), this.#m = 0, this.#d = 0, this.#S = fs.create(n), this.#u = 0, this.#c = 0, typeof c == "function" && (this.#s = c), typeof u == "function" ? (this.#n = u, this.#b = []) : (this.#n = void 0, this.#b = void 0), this.#w = !!this.#s, this.#y = !!this.#n, this.noDisposeOnSet = !!f, this.noUpdateTTL = !!d, this.noDeleteOnFetchRejection = !!E, this.allowStaleOnFetchRejection = !!D, this.allowStaleOnFetchAbort = !!F, this.ignoreFetchAbort = !!W, this.maxEntrySize !== 0) {
      if (this.#t !== 0 && !Xr(this.#t))
        throw new TypeError("maxSize must be a positive integer if specified");
      if (!Xr(this.maxEntrySize))
        throw new TypeError("maxEntrySize must be a positive integer if specified");
      this.#A();
    }
    if (this.allowStale = !!l, this.noDeleteOnStaleGet = !!y, this.updateAgeOnGet = !!o, this.updateAgeOnHas = !!a, this.ttlResolution = Xr(i) || i === 0 ? i : 1, this.ttlAutopurge = !!s, this.ttl = r || 0, this.ttl) {
      if (!Xr(this.ttl))
        throw new TypeError("ttl must be a positive integer if specified");
      this.#R();
    }
    if (this.#e === 0 && this.ttl === 0 && this.#t === 0)
      throw new TypeError("At least one of max, maxSize, or ttl is required");
    if (!this.ttlAutopurge && !this.#e && !this.#t) {
      const Z = "LRU_CACHE_UNBOUNDED";
      US(Z) && (L0.add(Z), j0("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.", "UnboundedCacheWarning", Z, xd));
    }
  }
  /**
   * Return the number of ms left in the item's TTL. If item is not in cache,
   * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.
   */
  getRemainingTTL(t) {
    return this.#a.has(t) ? 1 / 0 : 0;
  }
  #R() {
    const t = new ul(this.#e), n = new ul(this.#e);
    this.#_ = t, this.#$ = n, this.#D = (s, o, a = ss.now()) => {
      if (n[s] = o !== 0 ? a : 0, t[s] = o, o !== 0 && this.ttlAutopurge) {
        const l = setTimeout(() => {
          this.#v(s) && this.#x(this.#l[s], "expire");
        }, o + 1);
        l.unref && l.unref();
      }
    }, this.#N = (s) => {
      n[s] = t[s] !== 0 ? ss.now() : 0;
    }, this.#i = (s, o) => {
      if (t[o]) {
        const a = t[o], l = n[o];
        if (!a || !l)
          return;
        s.ttl = a, s.start = l, s.now = r || i();
        const c = s.now - l;
        s.remainingTTL = a - c;
      }
    };
    let r = 0;
    const i = () => {
      const s = ss.now();
      if (this.ttlResolution > 0) {
        r = s;
        const o = setTimeout(() => r = 0, this.ttlResolution);
        o.unref && o.unref();
      }
      return s;
    };
    this.getRemainingTTL = (s) => {
      const o = this.#a.get(s);
      if (o === void 0)
        return 0;
      const a = t[o], l = n[o];
      if (!a || !l)
        return 1 / 0;
      const c = (r || i()) - l;
      return a - c;
    }, this.#v = (s) => {
      const o = n[s], a = t[s];
      return !!a && !!o && (r || i()) - o > a;
    };
  }
  // conditionally set private methods related to TTL
  #N = () => {
  };
  #i = () => {
  };
  #D = () => {
  };
  /* c8 ignore stop */
  #v = () => !1;
  #A() {
    const t = new ul(this.#e);
    this.#c = 0, this.#T = t, this.#P = (n) => {
      this.#c -= t[n], t[n] = 0;
    }, this.#L = (n, r, i, s) => {
      if (this.#f(r))
        return 0;
      if (!Xr(i))
        if (s) {
          if (typeof s != "function")
            throw new TypeError("sizeCalculation must be a function");
          if (i = s(r, n), !Xr(i))
            throw new TypeError("sizeCalculation return invalid (expect positive integer)");
        } else
          throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
      return i;
    }, this.#k = (n, r, i) => {
      if (t[n] = r, this.#t) {
        const s = this.#t - t[n];
        for (; this.#c > s; )
          this.#C(!0);
      }
      this.#c += t[n], i && (i.entrySize = r, i.totalCalculatedSize = this.#c);
    };
  }
  #P = (t) => {
  };
  #k = (t, n, r) => {
  };
  #L = (t, n, r, i) => {
    if (r || i)
      throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
    return 0;
  };
  *#O({ allowStale: t = this.allowStale } = {}) {
    if (this.#u)
      for (let n = this.#d; !(!this.#j(n) || ((t || !this.#v(n)) && (yield n), n === this.#m)); )
        n = this.#h[n];
  }
  *#I({ allowStale: t = this.allowStale } = {}) {
    if (this.#u)
      for (let n = this.#m; !(!this.#j(n) || ((t || !this.#v(n)) && (yield n), n === this.#d)); )
        n = this.#p[n];
  }
  #j(t) {
    return t !== void 0 && this.#a.get(this.#l[t]) === t;
  }
  /**
   * Return a generator yielding `[key, value]` pairs,
   * in order from most recently used to least recently used.
   */
  *entries() {
    for (const t of this.#O())
      this.#r[t] !== void 0 && this.#l[t] !== void 0 && !this.#f(this.#r[t]) && (yield [this.#l[t], this.#r[t]]);
  }
  /**
   * Inverse order version of {@link LRUCache.entries}
   *
   * Return a generator yielding `[key, value]` pairs,
   * in order from least recently used to most recently used.
   */
  *rentries() {
    for (const t of this.#I())
      this.#r[t] !== void 0 && this.#l[t] !== void 0 && !this.#f(this.#r[t]) && (yield [this.#l[t], this.#r[t]]);
  }
  /**
   * Return a generator yielding the keys in the cache,
   * in order from most recently used to least recently used.
   */
  *keys() {
    for (const t of this.#O()) {
      const n = this.#l[t];
      n !== void 0 && !this.#f(this.#r[t]) && (yield n);
    }
  }
  /**
   * Inverse order version of {@link LRUCache.keys}
   *
   * Return a generator yielding the keys in the cache,
   * in order from least recently used to most recently used.
   */
  *rkeys() {
    for (const t of this.#I()) {
      const n = this.#l[t];
      n !== void 0 && !this.#f(this.#r[t]) && (yield n);
    }
  }
  /**
   * Return a generator yielding the values in the cache,
   * in order from most recently used to least recently used.
   */
  *values() {
    for (const t of this.#O())
      this.#r[t] !== void 0 && !this.#f(this.#r[t]) && (yield this.#r[t]);
  }
  /**
   * Inverse order version of {@link LRUCache.values}
   *
   * Return a generator yielding the values in the cache,
   * in order from least recently used to most recently used.
   */
  *rvalues() {
    for (const t of this.#I())
      this.#r[t] !== void 0 && !this.#f(this.#r[t]) && (yield this.#r[t]);
  }
  /**
   * Iterating over the cache itself yields the same results as
   * {@link LRUCache.entries}
   */
  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * A String value that is used in the creation of the default string
   * description of an object. Called by the built-in method
   * `Object.prototype.toString`.
   */
  [Symbol.toStringTag] = "LRUCache";
  /**
   * Find a value for which the supplied fn method returns a truthy value,
   * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.
   */
  find(t, n = {}) {
    for (const r of this.#O()) {
      const i = this.#r[r], s = this.#f(i) ? i.__staleWhileFetching : i;
      if (s !== void 0 && t(s, this.#l[r], this))
        return this.get(this.#l[r], n);
    }
  }
  /**
   * Call the supplied function on each item in the cache, in order from most
   * recently used to least recently used.
   *
   * `fn` is called as `fn(value, key, cache)`.
   *
   * If `thisp` is provided, function will be called in the `this`-context of
   * the provided object, or the cache if no `thisp` object is provided.
   *
   * Does not update age or recenty of use, or iterate over stale values.
   */
  forEach(t, n = this) {
    for (const r of this.#O()) {
      const i = this.#r[r], s = this.#f(i) ? i.__staleWhileFetching : i;
      s !== void 0 && t.call(n, s, this.#l[r], this);
    }
  }
  /**
   * The same as {@link LRUCache.forEach} but items are iterated over in
   * reverse order.  (ie, less recently used items are iterated over first.)
   */
  rforEach(t, n = this) {
    for (const r of this.#I()) {
      const i = this.#r[r], s = this.#f(i) ? i.__staleWhileFetching : i;
      s !== void 0 && t.call(n, s, this.#l[r], this);
    }
  }
  /**
   * Delete any stale entries. Returns true if anything was removed,
   * false otherwise.
   */
  purgeStale() {
    let t = !1;
    for (const n of this.#I({ allowStale: !0 }))
      this.#v(n) && (this.#x(this.#l[n], "expire"), t = !0);
    return t;
  }
  /**
   * Get the extended info about a given entry, to get its value, size, and
   * TTL info simultaneously. Returns `undefined` if the key is not present.
   *
   * Unlike {@link LRUCache#dump}, which is designed to be portable and survive
   * serialization, the `start` value is always the current timestamp, and the
   * `ttl` is a calculated remaining time to live (negative if expired).
   *
   * Always returns stale values, if their info is found in the cache, so be
   * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})
   * if relevant.
   */
  info(t) {
    const n = this.#a.get(t);
    if (n === void 0)
      return;
    const r = this.#r[n], i = this.#f(r) ? r.__staleWhileFetching : r;
    if (i === void 0)
      return;
    const s = { value: i };
    if (this.#_ && this.#$) {
      const o = this.#_[n], a = this.#$[n];
      if (o && a) {
        const l = o - (ss.now() - a);
        s.ttl = l, s.start = Date.now();
      }
    }
    return this.#T && (s.size = this.#T[n]), s;
  }
  /**
   * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
   * passed to {@link LRLUCache#load}.
   *
   * The `start` fields are calculated relative to a portable `Date.now()`
   * timestamp, even if `performance.now()` is available.
   *
   * Stale entries are always included in the `dump`, even if
   * {@link LRUCache.OptionsBase.allowStale} is false.
   *
   * Note: this returns an actual array, not a generator, so it can be more
   * easily passed around.
   */
  dump() {
    const t = [];
    for (const n of this.#O({ allowStale: !0 })) {
      const r = this.#l[n], i = this.#r[n], s = this.#f(i) ? i.__staleWhileFetching : i;
      if (s === void 0 || r === void 0)
        continue;
      const o = { value: s };
      if (this.#_ && this.#$) {
        o.ttl = this.#_[n];
        const a = ss.now() - this.#$[n];
        o.start = Math.floor(Date.now() - a);
      }
      this.#T && (o.size = this.#T[n]), t.unshift([r, o]);
    }
    return t;
  }
  /**
   * Reset the cache and load in the items in entries in the order listed.
   *
   * The shape of the resulting cache may be different if the same options are
   * not used in both caches.
   *
   * The `start` fields are assumed to be calculated relative to a portable
   * `Date.now()` timestamp, even if `performance.now()` is available.
   */
  load(t) {
    this.clear();
    for (const [n, r] of t) {
      if (r.start) {
        const i = Date.now() - r.start;
        r.start = ss.now() - i;
      }
      this.set(n, r.value, r);
    }
  }
  /**
   * Add a value to the cache.
   *
   * Note: if `undefined` is specified as a value, this is an alias for
   * {@link LRUCache#delete}
   *
   * Fields on the {@link LRUCache.SetOptions} options param will override
   * their corresponding values in the constructor options for the scope
   * of this single `set()` operation.
   *
   * If `start` is provided, then that will set the effective start
   * time for the TTL calculation. Note that this must be a previous
   * value of `performance.now()` if supported, or a previous value of
   * `Date.now()` if not.
   *
   * Options object may also include `size`, which will prevent
   * calling the `sizeCalculation` function and just use the specified
   * number if it is a positive integer, and `noDisposeOnSet` which
   * will prevent calling a `dispose` function in the case of
   * overwrites.
   *
   * If the `size` (or return value of `sizeCalculation`) for a given
   * entry is greater than `maxEntrySize`, then the item will not be
   * added to the cache.
   *
   * Will update the recency of the entry.
   *
   * If the value is `undefined`, then this is an alias for
   * `cache.delete(key)`. `undefined` is never stored in the cache.
   */
  set(t, n, r = {}) {
    if (n === void 0)
      return this.delete(t), this;
    const { ttl: i = this.ttl, start: s, noDisposeOnSet: o = this.noDisposeOnSet, sizeCalculation: a = this.sizeCalculation, status: l } = r;
    let { noUpdateTTL: c = this.noUpdateTTL } = r;
    const u = this.#L(t, n, r.size || 0, a);
    if (this.maxEntrySize && u > this.maxEntrySize)
      return l && (l.set = "miss", l.maxEntrySizeExceeded = !0), this.#x(t, "set"), this;
    let f = this.#u === 0 ? void 0 : this.#a.get(t);
    if (f === void 0)
      f = this.#u === 0 ? this.#d : this.#S.length !== 0 ? this.#S.pop() : this.#u === this.#e ? this.#C(!1) : this.#u, this.#l[f] = t, this.#r[f] = n, this.#a.set(t, f), this.#p[this.#d] = f, this.#h[f] = this.#d, this.#d = f, this.#u++, this.#k(f, u, l), l && (l.set = "add"), c = !1;
    else {
      this.#U(f);
      const d = this.#r[f];
      if (n !== d) {
        if (this.#E && this.#f(d)) {
          d.__abortController.abort(new Error("replaced"));
          const { __staleWhileFetching: p } = d;
          p !== void 0 && !o && (this.#w && this.#s?.(p, t, "set"), this.#y && this.#b?.push([p, t, "set"]));
        } else
          o || (this.#w && this.#s?.(d, t, "set"), this.#y && this.#b?.push([d, t, "set"]));
        if (this.#P(f), this.#k(f, u, l), this.#r[f] = n, l) {
          l.set = "replace";
          const p = d && this.#f(d) ? d.__staleWhileFetching : d;
          p !== void 0 && (l.oldValue = p);
        }
      } else
        l && (l.set = "update");
    }
    if (i !== 0 && !this.#_ && this.#R(), this.#_ && (c || this.#D(f, i, s), l && this.#i(l, f)), !o && this.#y && this.#b) {
      const d = this.#b;
      let p;
      for (; p = d?.shift(); )
        this.#n?.(...p);
    }
    return this;
  }
  /**
   * Evict the least recently used item, returning its value or
   * `undefined` if cache is empty.
   */
  pop() {
    try {
      for (; this.#u; ) {
        const t = this.#r[this.#m];
        if (this.#C(!0), this.#f(t)) {
          if (t.__staleWhileFetching)
            return t.__staleWhileFetching;
        } else if (t !== void 0)
          return t;
      }
    } finally {
      if (this.#y && this.#b) {
        const t = this.#b;
        let n;
        for (; n = t?.shift(); )
          this.#n?.(...n);
      }
    }
  }
  #C(t) {
    const n = this.#m, r = this.#l[n], i = this.#r[n];
    return this.#E && this.#f(i) ? i.__abortController.abort(new Error("evicted")) : (this.#w || this.#y) && (this.#w && this.#s?.(i, r, "evict"), this.#y && this.#b?.push([i, r, "evict"])), this.#P(n), t && (this.#l[n] = void 0, this.#r[n] = void 0, this.#S.push(n)), this.#u === 1 ? (this.#m = this.#d = 0, this.#S.length = 0) : this.#m = this.#p[n], this.#a.delete(r), this.#u--, n;
  }
  /**
   * Check if a key is in the cache, without updating the recency of use.
   * Will return false if the item is stale, even though it is technically
   * in the cache.
   *
   * Check if a key is in the cache, without updating the recency of
   * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set
   * to `true` in either the options or the constructor.
   *
   * Will return `false` if the item is stale, even though it is technically in
   * the cache. The difference can be determined (if it matters) by using a
   * `status` argument, and inspecting the `has` field.
   *
   * Will not update item age unless
   * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
   */
  has(t, n = {}) {
    const { updateAgeOnHas: r = this.updateAgeOnHas, status: i } = n, s = this.#a.get(t);
    if (s !== void 0) {
      const o = this.#r[s];
      if (this.#f(o) && o.__staleWhileFetching === void 0)
        return !1;
      if (this.#v(s))
        i && (i.has = "stale", this.#i(i, s));
      else
        return r && this.#N(s), i && (i.has = "hit", this.#i(i, s)), !0;
    } else
      i && (i.has = "miss");
    return !1;
  }
  /**
   * Like {@link LRUCache#get} but doesn't update recency or delete stale
   * items.
   *
   * Returns `undefined` if the item is stale, unless
   * {@link LRUCache.OptionsBase.allowStale} is set.
   */
  peek(t, n = {}) {
    const { allowStale: r = this.allowStale } = n, i = this.#a.get(t);
    if (i === void 0 || !r && this.#v(i))
      return;
    const s = this.#r[i];
    return this.#f(s) ? s.__staleWhileFetching : s;
  }
  #M(t, n, r, i) {
    const s = n === void 0 ? void 0 : this.#r[n];
    if (this.#f(s))
      return s;
    const o = new Al(), { signal: a } = r;
    a?.addEventListener("abort", () => o.abort(a.reason), {
      signal: o.signal
    });
    const l = {
      signal: o.signal,
      options: r,
      context: i
    }, c = (m, v = !1) => {
      const { aborted: b } = o.signal, E = r.ignoreFetchAbort && m !== void 0;
      if (r.status && (b && !v ? (r.status.fetchAborted = !0, r.status.fetchError = o.signal.reason, E && (r.status.fetchAbortIgnored = !0)) : r.status.fetchResolved = !0), b && !E && !v)
        return f(o.signal.reason);
      const y = p;
      return this.#r[n] === p && (m === void 0 ? y.__staleWhileFetching ? this.#r[n] = y.__staleWhileFetching : this.#x(t, "fetch") : (r.status && (r.status.fetchUpdated = !0), this.set(t, m, l.options))), m;
    }, u = (m) => (r.status && (r.status.fetchRejected = !0, r.status.fetchError = m), f(m)), f = (m) => {
      const { aborted: v } = o.signal, b = v && r.allowStaleOnFetchAbort, E = b || r.allowStaleOnFetchRejection, y = E || r.noDeleteOnFetchRejection, D = p;
      if (this.#r[n] === p && (!y || D.__staleWhileFetching === void 0 ? this.#x(t, "fetch") : b || (this.#r[n] = D.__staleWhileFetching)), E)
        return r.status && D.__staleWhileFetching !== void 0 && (r.status.returnedStale = !0), D.__staleWhileFetching;
      if (D.__returned === D)
        throw m;
    }, d = (m, v) => {
      const b = this.#o?.(t, s, l);
      b && b instanceof Promise && b.then((E) => m(E === void 0 ? void 0 : E), v), o.signal.addEventListener("abort", () => {
        (!r.ignoreFetchAbort || r.allowStaleOnFetchAbort) && (m(void 0), r.allowStaleOnFetchAbort && (m = (E) => c(E, !0)));
      });
    };
    r.status && (r.status.fetchDispatched = !0);
    const p = new Promise(d).then(c, u), h = Object.assign(p, {
      __abortController: o,
      __staleWhileFetching: s,
      __returned: void 0
    });
    return n === void 0 ? (this.set(t, h, { ...l.options, status: void 0 }), n = this.#a.get(t)) : this.#r[n] = h, h;
  }
  #f(t) {
    if (!this.#E)
      return !1;
    const n = t;
    return !!n && n instanceof Promise && n.hasOwnProperty("__staleWhileFetching") && n.__abortController instanceof Al;
  }
  async fetch(t, n = {}) {
    const {
      // get options
      allowStale: r = this.allowStale,
      updateAgeOnGet: i = this.updateAgeOnGet,
      noDeleteOnStaleGet: s = this.noDeleteOnStaleGet,
      // set options
      ttl: o = this.ttl,
      noDisposeOnSet: a = this.noDisposeOnSet,
      size: l = 0,
      sizeCalculation: c = this.sizeCalculation,
      noUpdateTTL: u = this.noUpdateTTL,
      // fetch exclusive options
      noDeleteOnFetchRejection: f = this.noDeleteOnFetchRejection,
      allowStaleOnFetchRejection: d = this.allowStaleOnFetchRejection,
      ignoreFetchAbort: p = this.ignoreFetchAbort,
      allowStaleOnFetchAbort: h = this.allowStaleOnFetchAbort,
      context: m,
      forceRefresh: v = !1,
      status: b,
      signal: E
    } = n;
    if (!this.#E)
      return b && (b.fetch = "get"), this.get(t, {
        allowStale: r,
        updateAgeOnGet: i,
        noDeleteOnStaleGet: s,
        status: b
      });
    const y = {
      allowStale: r,
      updateAgeOnGet: i,
      noDeleteOnStaleGet: s,
      ttl: o,
      noDisposeOnSet: a,
      size: l,
      sizeCalculation: c,
      noUpdateTTL: u,
      noDeleteOnFetchRejection: f,
      allowStaleOnFetchRejection: d,
      allowStaleOnFetchAbort: h,
      ignoreFetchAbort: p,
      status: b,
      signal: E
    };
    let D = this.#a.get(t);
    if (D === void 0) {
      b && (b.fetch = "miss");
      const F = this.#M(t, D, y, m);
      return F.__returned = F;
    } else {
      const F = this.#r[D];
      if (this.#f(F)) {
        const ee = r && F.__staleWhileFetching !== void 0;
        return b && (b.fetch = "inflight", ee && (b.returnedStale = !0)), ee ? F.__staleWhileFetching : F.__returned = F;
      }
      const W = this.#v(D);
      if (!v && !W)
        return b && (b.fetch = "hit"), this.#U(D), i && this.#N(D), b && this.#i(b, D), F;
      const J = this.#M(t, D, y, m), j = J.__staleWhileFetching !== void 0 && r;
      return b && (b.fetch = W ? "stale" : "refresh", j && W && (b.returnedStale = !0)), j ? J.__staleWhileFetching : J.__returned = J;
    }
  }
  async forceFetch(t, n = {}) {
    const r = await this.fetch(t, n);
    if (r === void 0)
      throw new Error("fetch() returned undefined");
    return r;
  }
  memo(t, n = {}) {
    const r = this.#g;
    if (!r)
      throw new Error("no memoMethod provided to constructor");
    const { context: i, forceRefresh: s, ...o } = n, a = this.get(t, o);
    if (!s && a !== void 0)
      return a;
    const l = r(t, a, {
      options: o,
      context: i
    });
    return this.set(t, l, o), l;
  }
  /**
   * Return a value from the cache. Will update the recency of the cache
   * entry found.
   *
   * If the key is not found, get() will return `undefined`.
   */
  get(t, n = {}) {
    const { allowStale: r = this.allowStale, updateAgeOnGet: i = this.updateAgeOnGet, noDeleteOnStaleGet: s = this.noDeleteOnStaleGet, status: o } = n, a = this.#a.get(t);
    if (a !== void 0) {
      const l = this.#r[a], c = this.#f(l);
      return o && this.#i(o, a), this.#v(a) ? (o && (o.get = "stale"), c ? (o && r && l.__staleWhileFetching !== void 0 && (o.returnedStale = !0), r ? l.__staleWhileFetching : void 0) : (s || this.#x(t, "expire"), o && r && (o.returnedStale = !0), r ? l : void 0)) : (o && (o.get = "hit"), c ? l.__staleWhileFetching : (this.#U(a), i && this.#N(a), l));
    } else
      o && (o.get = "miss");
  }
  #F(t, n) {
    this.#h[n] = t, this.#p[t] = n;
  }
  #U(t) {
    t !== this.#d && (t === this.#m ? this.#m = this.#p[t] : this.#F(this.#h[t], this.#p[t]), this.#F(this.#d, t), this.#d = t);
  }
  /**
   * Deletes a key out of the cache.
   *
   * Returns true if the key was deleted, false otherwise.
   */
  delete(t) {
    return this.#x(t, "delete");
  }
  #x(t, n) {
    let r = !1;
    if (this.#u !== 0) {
      const i = this.#a.get(t);
      if (i !== void 0)
        if (r = !0, this.#u === 1)
          this.#V(n);
        else {
          this.#P(i);
          const s = this.#r[i];
          if (this.#f(s) ? s.__abortController.abort(new Error("deleted")) : (this.#w || this.#y) && (this.#w && this.#s?.(s, t, n), this.#y && this.#b?.push([s, t, n])), this.#a.delete(t), this.#l[i] = void 0, this.#r[i] = void 0, i === this.#d)
            this.#d = this.#h[i];
          else if (i === this.#m)
            this.#m = this.#p[i];
          else {
            const o = this.#h[i];
            this.#p[o] = this.#p[i];
            const a = this.#p[i];
            this.#h[a] = this.#h[i];
          }
          this.#u--, this.#S.push(i);
        }
    }
    if (this.#y && this.#b?.length) {
      const i = this.#b;
      let s;
      for (; s = i?.shift(); )
        this.#n?.(...s);
    }
    return r;
  }
  /**
   * Clear the cache entirely, throwing away all values.
   */
  clear() {
    return this.#V("delete");
  }
  #V(t) {
    for (const n of this.#I({ allowStale: !0 })) {
      const r = this.#r[n];
      if (this.#f(r))
        r.__abortController.abort(new Error("deleted"));
      else {
        const i = this.#l[n];
        this.#w && this.#s?.(r, i, t), this.#y && this.#b?.push([r, i, t]);
      }
    }
    if (this.#a.clear(), this.#r.fill(void 0), this.#l.fill(void 0), this.#_ && this.#$ && (this.#_.fill(0), this.#$.fill(0)), this.#T && this.#T.fill(0), this.#m = 0, this.#d = 0, this.#S.length = 0, this.#c = 0, this.#u = 0, this.#y && this.#b) {
      const n = this.#b;
      let r;
      for (; r = n?.shift(); )
        this.#n?.(...r);
    }
  }
}
pu.LRUCache = xd;
var Dd = {};
(function(e) {
  var t = We && We.__importDefault || function(I) {
    return I && I.__esModule ? I : { default: I };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Minipass = e.isWritable = e.isReadable = e.isStream = void 0;
  const n = typeof process == "object" && process ? process : {
    stdout: null,
    stderr: null
  }, r = at, i = t(at), s = at, o = (I) => !!I && typeof I == "object" && (I instanceof O || I instanceof i.default || (0, e.isReadable)(I) || (0, e.isWritable)(I));
  e.isStream = o;
  const a = (I) => !!I && typeof I == "object" && I instanceof r.EventEmitter && typeof I.pipe == "function" && // node core Writable streams have a pipe() method, but it throws
  I.pipe !== i.default.Writable.prototype.pipe;
  e.isReadable = a;
  const l = (I) => !!I && typeof I == "object" && I instanceof r.EventEmitter && typeof I.write == "function" && typeof I.end == "function";
  e.isWritable = l;
  const c = Symbol("EOF"), u = Symbol("maybeEmitEnd"), f = Symbol("emittedEnd"), d = Symbol("emittingEnd"), p = Symbol("emittedError"), h = Symbol("closed"), m = Symbol("read"), v = Symbol("flush"), b = Symbol("flushChunk"), E = Symbol("encoding"), y = Symbol("decoder"), D = Symbol("flowing"), F = Symbol("paused"), W = Symbol("resume"), J = Symbol("buffer"), Z = Symbol("pipes"), j = Symbol("bufferLength"), ee = Symbol("bufferPush"), le = Symbol("bufferShift"), ce = Symbol("objectMode"), U = Symbol("destroyed"), z = Symbol("error"), ne = Symbol("emitData"), K = Symbol("emitEnd"), se = Symbol("emitEnd2"), re = Symbol("async"), ue = Symbol("abort"), te = Symbol("aborted"), B = Symbol("signal"), M = Symbol("dataListeners"), N = Symbol("discarded"), T = (I) => Promise.resolve().then(I), P = (I) => I(), k = (I) => I === "end" || I === "finish" || I === "prefinish", q = (I) => I instanceof ArrayBuffer || !!I && typeof I == "object" && I.constructor && I.constructor.name === "ArrayBuffer" && I.byteLength >= 0, Y = (I) => !Buffer.isBuffer(I) && ArrayBuffer.isView(I);
  class ve {
    src;
    dest;
    opts;
    ondrain;
    constructor(L, H, ae) {
      this.src = L, this.dest = H, this.opts = ae, this.ondrain = () => L[W](), this.dest.on("drain", this.ondrain);
    }
    unpipe() {
      this.dest.removeListener("drain", this.ondrain);
    }
    // only here for the prototype
    /* c8 ignore start */
    proxyErrors(L) {
    }
    /* c8 ignore stop */
    end() {
      this.unpipe(), this.opts.end && this.dest.end();
    }
  }
  class oe extends ve {
    unpipe() {
      this.src.removeListener("error", this.proxyErrors), super.unpipe();
    }
    constructor(L, H, ae) {
      super(L, H, ae), this.proxyErrors = (Ee) => H.emit("error", Ee), L.on("error", this.proxyErrors);
    }
  }
  const S = (I) => !!I.objectMode, $ = (I) => !I.objectMode && !!I.encoding && I.encoding !== "buffer";
  class O extends r.EventEmitter {
    [D] = !1;
    [F] = !1;
    [Z] = [];
    [J] = [];
    [ce];
    [E];
    [re];
    [y];
    [c] = !1;
    [f] = !1;
    [d] = !1;
    [h] = !1;
    [p] = null;
    [j] = 0;
    [U] = !1;
    [B];
    [te] = !1;
    [M] = 0;
    [N] = !1;
    /**
     * true if the stream can be written
     */
    writable = !0;
    /**
     * true if the stream can be read
     */
    readable = !0;
    /**
     * If `RType` is Buffer, then options do not need to be provided.
     * Otherwise, an options object must be provided to specify either
     * {@link Minipass.SharedOptions.objectMode} or
     * {@link Minipass.SharedOptions.encoding}, as appropriate.
     */
    constructor(...L) {
      const H = L[0] || {};
      if (super(), H.objectMode && typeof H.encoding == "string")
        throw new TypeError("Encoding and objectMode may not be used together");
      S(H) ? (this[ce] = !0, this[E] = null) : $(H) ? (this[E] = H.encoding, this[ce] = !1) : (this[ce] = !1, this[E] = null), this[re] = !!H.async, this[y] = this[E] ? new s.StringDecoder(this[E]) : null, H && H.debugExposeBuffer === !0 && Object.defineProperty(this, "buffer", { get: () => this[J] }), H && H.debugExposePipes === !0 && Object.defineProperty(this, "pipes", { get: () => this[Z] });
      const { signal: ae } = H;
      ae && (this[B] = ae, ae.aborted ? this[ue]() : ae.addEventListener("abort", () => this[ue]()));
    }
    /**
     * The amount of data stored in the buffer waiting to be read.
     *
     * For Buffer strings, this will be the total byte length.
     * For string encoding streams, this will be the string character length,
     * according to JavaScript's `string.length` logic.
     * For objectMode streams, this is a count of the items waiting to be
     * emitted.
     */
    get bufferLength() {
      return this[j];
    }
    /**
     * The `BufferEncoding` currently in use, or `null`
     */
    get encoding() {
      return this[E];
    }
    /**
     * @deprecated - This is a read only property
     */
    set encoding(L) {
      throw new Error("Encoding must be set at instantiation time");
    }
    /**
     * @deprecated - Encoding may only be set at instantiation time
     */
    setEncoding(L) {
      throw new Error("Encoding must be set at instantiation time");
    }
    /**
     * True if this is an objectMode stream
     */
    get objectMode() {
      return this[ce];
    }
    /**
     * @deprecated - This is a read-only property
     */
    set objectMode(L) {
      throw new Error("objectMode must be set at instantiation time");
    }
    /**
     * true if this is an async stream
     */
    get async() {
      return this[re];
    }
    /**
     * Set to true to make this stream async.
     *
     * Once set, it cannot be unset, as this would potentially cause incorrect
     * behavior.  Ie, a sync stream can be made async, but an async stream
     * cannot be safely made sync.
     */
    set async(L) {
      this[re] = this[re] || !!L;
    }
    // drop everything and get out of the flow completely
    [ue]() {
      this[te] = !0, this.emit("abort", this[B]?.reason), this.destroy(this[B]?.reason);
    }
    /**
     * True if the stream has been aborted.
     */
    get aborted() {
      return this[te];
    }
    /**
     * No-op setter. Stream aborted status is set via the AbortSignal provided
     * in the constructor options.
     */
    set aborted(L) {
    }
    write(L, H, ae) {
      if (this[te])
        return !1;
      if (this[c])
        throw new Error("write after end");
      if (this[U])
        return this.emit("error", Object.assign(new Error("Cannot call write after a stream was destroyed"), { code: "ERR_STREAM_DESTROYED" })), !0;
      typeof H == "function" && (ae = H, H = "utf8"), H || (H = "utf8");
      const Ee = this[re] ? T : P;
      if (!this[ce] && !Buffer.isBuffer(L)) {
        if (Y(L))
          L = Buffer.from(L.buffer, L.byteOffset, L.byteLength);
        else if (q(L))
          L = Buffer.from(L);
        else if (typeof L != "string")
          throw new Error("Non-contiguous data written to non-objectMode stream");
      }
      return this[ce] ? (this[D] && this[j] !== 0 && this[v](!0), this[D] ? this.emit("data", L) : this[ee](L), this[j] !== 0 && this.emit("readable"), ae && Ee(ae), this[D]) : L.length ? (typeof L == "string" && // unless it is a string already ready for us to use
      !(H === this[E] && !this[y]?.lastNeed) && (L = Buffer.from(L, H)), Buffer.isBuffer(L) && this[E] && (L = this[y].write(L)), this[D] && this[j] !== 0 && this[v](!0), this[D] ? this.emit("data", L) : this[ee](L), this[j] !== 0 && this.emit("readable"), ae && Ee(ae), this[D]) : (this[j] !== 0 && this.emit("readable"), ae && Ee(ae), this[D]);
    }
    /**
     * Low-level explicit read method.
     *
     * In objectMode, the argument is ignored, and one item is returned if
     * available.
     *
     * `n` is the number of bytes (or in the case of encoding streams,
     * characters) to consume. If `n` is not provided, then the entire buffer
     * is returned, or `null` is returned if no data is available.
     *
     * If `n` is greater that the amount of data in the internal buffer,
     * then `null` is returned.
     */
    read(L) {
      if (this[U])
        return null;
      if (this[N] = !1, this[j] === 0 || L === 0 || L && L > this[j])
        return this[u](), null;
      this[ce] && (L = null), this[J].length > 1 && !this[ce] && (this[J] = [
        this[E] ? this[J].join("") : Buffer.concat(this[J], this[j])
      ]);
      const H = this[m](L || null, this[J][0]);
      return this[u](), H;
    }
    [m](L, H) {
      if (this[ce])
        this[le]();
      else {
        const ae = H;
        L === ae.length || L === null ? this[le]() : typeof ae == "string" ? (this[J][0] = ae.slice(L), H = ae.slice(0, L), this[j] -= L) : (this[J][0] = ae.subarray(L), H = ae.subarray(0, L), this[j] -= L);
      }
      return this.emit("data", H), !this[J].length && !this[c] && this.emit("drain"), H;
    }
    end(L, H, ae) {
      return typeof L == "function" && (ae = L, L = void 0), typeof H == "function" && (ae = H, H = "utf8"), L !== void 0 && this.write(L, H), ae && this.once("end", ae), this[c] = !0, this.writable = !1, (this[D] || !this[F]) && this[u](), this;
    }
    // don't let the internal resume be overwritten
    [W]() {
      this[U] || (!this[M] && !this[Z].length && (this[N] = !0), this[F] = !1, this[D] = !0, this.emit("resume"), this[J].length ? this[v]() : this[c] ? this[u]() : this.emit("drain"));
    }
    /**
     * Resume the stream if it is currently in a paused state
     *
     * If called when there are no pipe destinations or `data` event listeners,
     * this will place the stream in a "discarded" state, where all data will
     * be thrown away. The discarded state is removed if a pipe destination or
     * data handler is added, if pause() is called, or if any synchronous or
     * asynchronous iteration is started.
     */
    resume() {
      return this[W]();
    }
    /**
     * Pause the stream
     */
    pause() {
      this[D] = !1, this[F] = !0, this[N] = !1;
    }
    /**
     * true if the stream has been forcibly destroyed
     */
    get destroyed() {
      return this[U];
    }
    /**
     * true if the stream is currently in a flowing state, meaning that
     * any writes will be immediately emitted.
     */
    get flowing() {
      return this[D];
    }
    /**
     * true if the stream is currently in a paused state
     */
    get paused() {
      return this[F];
    }
    [ee](L) {
      this[ce] ? this[j] += 1 : this[j] += L.length, this[J].push(L);
    }
    [le]() {
      return this[ce] ? this[j] -= 1 : this[j] -= this[J][0].length, this[J].shift();
    }
    [v](L = !1) {
      do
        ;
      while (this[b](this[le]()) && this[J].length);
      !L && !this[J].length && !this[c] && this.emit("drain");
    }
    [b](L) {
      return this.emit("data", L), this[D];
    }
    /**
     * Pipe all data emitted by this stream into the destination provided.
     *
     * Triggers the flow of data.
     */
    pipe(L, H) {
      if (this[U])
        return L;
      this[N] = !1;
      const ae = this[f];
      return H = H || {}, L === n.stdout || L === n.stderr ? H.end = !1 : H.end = H.end !== !1, H.proxyErrors = !!H.proxyErrors, ae ? H.end && L.end() : (this[Z].push(H.proxyErrors ? new oe(this, L, H) : new ve(this, L, H)), this[re] ? T(() => this[W]()) : this[W]()), L;
    }
    /**
     * Fully unhook a piped destination stream.
     *
     * If the destination stream was the only consumer of this stream (ie,
     * there are no other piped destinations or `'data'` event listeners)
     * then the flow of data will stop until there is another consumer or
     * {@link Minipass#resume} is explicitly called.
     */
    unpipe(L) {
      const H = this[Z].find((ae) => ae.dest === L);
      H && (this[Z].length === 1 ? (this[D] && this[M] === 0 && (this[D] = !1), this[Z] = []) : this[Z].splice(this[Z].indexOf(H), 1), H.unpipe());
    }
    /**
     * Alias for {@link Minipass#on}
     */
    addListener(L, H) {
      return this.on(L, H);
    }
    /**
     * Mostly identical to `EventEmitter.on`, with the following
     * behavior differences to prevent data loss and unnecessary hangs:
     *
     * - Adding a 'data' event handler will trigger the flow of data
     *
     * - Adding a 'readable' event handler when there is data waiting to be read
     *   will cause 'readable' to be emitted immediately.
     *
     * - Adding an 'endish' event handler ('end', 'finish', etc.) which has
     *   already passed will cause the event to be emitted immediately and all
     *   handlers removed.
     *
     * - Adding an 'error' event handler after an error has been emitted will
     *   cause the event to be re-emitted immediately with the error previously
     *   raised.
     */
    on(L, H) {
      const ae = super.on(L, H);
      if (L === "data")
        this[N] = !1, this[M]++, !this[Z].length && !this[D] && this[W]();
      else if (L === "readable" && this[j] !== 0)
        super.emit("readable");
      else if (k(L) && this[f])
        super.emit(L), this.removeAllListeners(L);
      else if (L === "error" && this[p]) {
        const Ee = H;
        this[re] ? T(() => Ee.call(this, this[p])) : Ee.call(this, this[p]);
      }
      return ae;
    }
    /**
     * Alias for {@link Minipass#off}
     */
    removeListener(L, H) {
      return this.off(L, H);
    }
    /**
     * Mostly identical to `EventEmitter.off`
     *
     * If a 'data' event handler is removed, and it was the last consumer
     * (ie, there are no pipe destinations or other 'data' event listeners),
     * then the flow of data will stop until there is another consumer or
     * {@link Minipass#resume} is explicitly called.
     */
    off(L, H) {
      const ae = super.off(L, H);
      return L === "data" && (this[M] = this.listeners("data").length, this[M] === 0 && !this[N] && !this[Z].length && (this[D] = !1)), ae;
    }
    /**
     * Mostly identical to `EventEmitter.removeAllListeners`
     *
     * If all 'data' event handlers are removed, and they were the last consumer
     * (ie, there are no pipe destinations), then the flow of data will stop
     * until there is another consumer or {@link Minipass#resume} is explicitly
     * called.
     */
    removeAllListeners(L) {
      const H = super.removeAllListeners(L);
      return (L === "data" || L === void 0) && (this[M] = 0, !this[N] && !this[Z].length && (this[D] = !1)), H;
    }
    /**
     * true if the 'end' event has been emitted
     */
    get emittedEnd() {
      return this[f];
    }
    [u]() {
      !this[d] && !this[f] && !this[U] && this[J].length === 0 && this[c] && (this[d] = !0, this.emit("end"), this.emit("prefinish"), this.emit("finish"), this[h] && this.emit("close"), this[d] = !1);
    }
    /**
     * Mostly identical to `EventEmitter.emit`, with the following
     * behavior differences to prevent data loss and unnecessary hangs:
     *
     * If the stream has been destroyed, and the event is something other
     * than 'close' or 'error', then `false` is returned and no handlers
     * are called.
     *
     * If the event is 'end', and has already been emitted, then the event
     * is ignored. If the stream is in a paused or non-flowing state, then
     * the event will be deferred until data flow resumes. If the stream is
     * async, then handlers will be called on the next tick rather than
     * immediately.
     *
     * If the event is 'close', and 'end' has not yet been emitted, then
     * the event will be deferred until after 'end' is emitted.
     *
     * If the event is 'error', and an AbortSignal was provided for the stream,
     * and there are no listeners, then the event is ignored, matching the
     * behavior of node core streams in the presense of an AbortSignal.
     *
     * If the event is 'finish' or 'prefinish', then all listeners will be
     * removed after emitting the event, to prevent double-firing.
     */
    emit(L, ...H) {
      const ae = H[0];
      if (L !== "error" && L !== "close" && L !== U && this[U])
        return !1;
      if (L === "data")
        return !this[ce] && !ae ? !1 : this[re] ? (T(() => this[ne](ae)), !0) : this[ne](ae);
      if (L === "end")
        return this[K]();
      if (L === "close") {
        if (this[h] = !0, !this[f] && !this[U])
          return !1;
        const Oe = super.emit("close");
        return this.removeAllListeners("close"), Oe;
      } else if (L === "error") {
        this[p] = ae, super.emit(z, ae);
        const Oe = !this[B] || this.listeners("error").length ? super.emit("error", ae) : !1;
        return this[u](), Oe;
      } else if (L === "resume") {
        const Oe = super.emit("resume");
        return this[u](), Oe;
      } else if (L === "finish" || L === "prefinish") {
        const Oe = super.emit(L);
        return this.removeAllListeners(L), Oe;
      }
      const Ee = super.emit(L, ...H);
      return this[u](), Ee;
    }
    [ne](L) {
      for (const ae of this[Z])
        ae.dest.write(L) === !1 && this.pause();
      const H = this[N] ? !1 : super.emit("data", L);
      return this[u](), H;
    }
    [K]() {
      return this[f] ? !1 : (this[f] = !0, this.readable = !1, this[re] ? (T(() => this[se]()), !0) : this[se]());
    }
    [se]() {
      if (this[y]) {
        const H = this[y].end();
        if (H) {
          for (const ae of this[Z])
            ae.dest.write(H);
          this[N] || super.emit("data", H);
        }
      }
      for (const H of this[Z])
        H.end();
      const L = super.emit("end");
      return this.removeAllListeners("end"), L;
    }
    /**
     * Return a Promise that resolves to an array of all emitted data once
     * the stream ends.
     */
    async collect() {
      const L = Object.assign([], {
        dataLength: 0
      });
      this[ce] || (L.dataLength = 0);
      const H = this.promise();
      return this.on("data", (ae) => {
        L.push(ae), this[ce] || (L.dataLength += ae.length);
      }), await H, L;
    }
    /**
     * Return a Promise that resolves to the concatenation of all emitted data
     * once the stream ends.
     *
     * Not allowed on objectMode streams.
     */
    async concat() {
      if (this[ce])
        throw new Error("cannot concat in objectMode");
      const L = await this.collect();
      return this[E] ? L.join("") : Buffer.concat(L, L.dataLength);
    }
    /**
     * Return a void Promise that resolves once the stream ends.
     */
    async promise() {
      return new Promise((L, H) => {
        this.on(U, () => H(new Error("stream destroyed"))), this.on("error", (ae) => H(ae)), this.on("end", () => L());
      });
    }
    /**
     * Asynchronous `for await of` iteration.
     *
     * This will continue emitting all chunks until the stream terminates.
     */
    [Symbol.asyncIterator]() {
      this[N] = !1;
      let L = !1;
      const H = async () => (this.pause(), L = !0, { value: void 0, done: !0 });
      return {
        next: () => {
          if (L)
            return H();
          const Ee = this.read();
          if (Ee !== null)
            return Promise.resolve({ done: !1, value: Ee });
          if (this[c])
            return H();
          let Oe, Te;
          const Me = (Je) => {
            this.off("data", we), this.off("end", Le), this.off(U, ut), H(), Te(Je);
          }, we = (Je) => {
            this.off("error", Me), this.off("end", Le), this.off(U, ut), this.pause(), Oe({ value: Je, done: !!this[c] });
          }, Le = () => {
            this.off("error", Me), this.off("data", we), this.off(U, ut), H(), Oe({ done: !0, value: void 0 });
          }, ut = () => Me(new Error("stream destroyed"));
          return new Promise((Je, bt) => {
            Te = bt, Oe = Je, this.once(U, ut), this.once("error", Me), this.once("end", Le), this.once("data", we);
          });
        },
        throw: H,
        return: H,
        [Symbol.asyncIterator]() {
          return this;
        }
      };
    }
    /**
     * Synchronous `for of` iteration.
     *
     * The iteration will terminate when the internal buffer runs out, even
     * if the stream has not yet terminated.
     */
    [Symbol.iterator]() {
      this[N] = !1;
      let L = !1;
      const H = () => (this.pause(), this.off(z, H), this.off(U, H), this.off("end", H), L = !0, { done: !0, value: void 0 }), ae = () => {
        if (L)
          return H();
        const Ee = this.read();
        return Ee === null ? H() : { done: !1, value: Ee };
      };
      return this.once("end", H), this.once(z, H), this.once(U, H), {
        next: ae,
        throw: H,
        return: H,
        [Symbol.iterator]() {
          return this;
        }
      };
    }
    /**
     * Destroy a stream, preventing it from being used for any further purpose.
     *
     * If the stream has a `close()` method, then it will be called on
     * destruction.
     *
     * After destruction, any attempt to write data, read data, or emit most
     * events will be ignored.
     *
     * If an error argument is provided, then it will be emitted in an
     * 'error' event.
     */
    destroy(L) {
      if (this[U])
        return L ? this.emit("error", L) : this.emit(U), this;
      this[U] = !0, this[N] = !0, this[J].length = 0, this[j] = 0;
      const H = this;
      return typeof H.close == "function" && !this[h] && H.close(), L ? this.emit("error", L) : this.emit(U), this;
    }
    /**
     * Alias for {@link isStream}
     *
     * Former export location, maintained for backwards compatibility.
     *
     * @deprecated
     */
    static get isStream() {
      return e.isStream;
    }
  }
  e.Minipass = O;
})(Dd);
var VS = We && We.__createBinding || (Object.create ? function(e, t, n, r) {
  r === void 0 && (r = n);
  var i = Object.getOwnPropertyDescriptor(t, n);
  (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
    return t[n];
  } }), Object.defineProperty(e, r, i);
} : function(e, t, n, r) {
  r === void 0 && (r = n), e[r] = t[n];
}), BS = We && We.__setModuleDefault || (Object.create ? function(e, t) {
  Object.defineProperty(e, "default", { enumerable: !0, value: t });
} : function(e, t) {
  e.default = t;
}), GS = We && We.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var t = {};
  if (e != null)
    for (var n in e)
      n !== "default" && Object.prototype.hasOwnProperty.call(e, n) && VS(t, e, n);
  return BS(t, e), t;
};
Object.defineProperty($t, "__esModule", { value: !0 });
$t.PathScurry = $t.Path = $t.PathScurryDarwin = $t.PathScurryPosix = $t.PathScurryWin32 = $t.PathScurryBase = $t.PathPosix = $t.PathWin32 = $t.PathBase = $t.ChildrenCache = $t.ResolveCache = void 0;
const M0 = pu, xl = at, zS = at, _o = at, qS = GS(at), HS = _o.realpathSync.native, Pa = at, nm = Dd, wo = {
  lstatSync: _o.lstatSync,
  readdir: _o.readdir,
  readdirSync: _o.readdirSync,
  readlinkSync: _o.readlinkSync,
  realpathSync: HS,
  promises: {
    lstat: Pa.lstat,
    readdir: Pa.readdir,
    readlink: Pa.readlink,
    realpath: Pa.realpath
  }
}, F0 = (e) => !e || e === wo || e === qS ? wo : {
  ...wo,
  ...e,
  promises: {
    ...wo.promises,
    ...e.promises || {}
  }
}, U0 = /^\\\\\?\\([a-z]:)\\?$/i, WS = (e) => e.replace(/\//g, "\\").replace(U0, "$1\\"), QS = /[\\\/]/, On = 0, V0 = 1, B0 = 2, sr = 4, G0 = 6, z0 = 8, Ri = 10, q0 = 12, Sn = 15, oo = ~Sn, Cc = 16, rm = 32, Eo = 64, qn = 128, ka = 256, cl = 512, im = Eo | qn | cl, JS = 1023, Mc = (e) => e.isFile() ? z0 : e.isDirectory() ? sr : e.isSymbolicLink() ? Ri : e.isCharacterDevice() ? B0 : e.isBlockDevice() ? G0 : e.isSocket() ? q0 : e.isFIFO() ? V0 : On, sm = /* @__PURE__ */ new Map(), So = (e) => {
  const t = sm.get(e);
  if (t)
    return t;
  const n = e.normalize("NFKD");
  return sm.set(e, n), n;
}, om = /* @__PURE__ */ new Map(), La = (e) => {
  const t = om.get(e);
  if (t)
    return t;
  const n = So(e.toLowerCase());
  return om.set(e, n), n;
};
class Cf extends M0.LRUCache {
  constructor() {
    super({ max: 256 });
  }
}
$t.ResolveCache = Cf;
class H0 extends M0.LRUCache {
  constructor(t = 16 * 1024) {
    super({
      maxSize: t,
      // parent + children
      sizeCalculation: (n) => n.length + 1
    });
  }
}
$t.ChildrenCache = H0;
const W0 = Symbol("PathScurry setAsCwd");
class nn {
  /**
   * the basename of this path
   *
   * **Important**: *always* test the path name against any test string
   * usingthe {@link isNamed} method, and not by directly comparing this
   * string. Otherwise, unicode path strings that the system sees as identical
   * will not be properly treated as the same path, leading to incorrect
   * behavior and possible security issues.
   */
  name;
  /**
   * the Path entry corresponding to the path root.
   *
   * @internal
   */
  root;
  /**
   * All roots found within the current PathScurry family
   *
   * @internal
   */
  roots;
  /**
   * a reference to the parent path, or undefined in the case of root entries
   *
   * @internal
   */
  parent;
  /**
   * boolean indicating whether paths are compared case-insensitively
   * @internal
   */
  nocase;
  /**
   * boolean indicating that this path is the current working directory
   * of the PathScurry collection that contains it.
   */
  isCWD = !1;
  // potential default fs override
  #e;
  // Stats fields
  #t;
  get dev() {
    return this.#t;
  }
  #s;
  get mode() {
    return this.#s;
  }
  #n;
  get nlink() {
    return this.#n;
  }
  #o;
  get uid() {
    return this.#o;
  }
  #g;
  get gid() {
    return this.#g;
  }
  #u;
  get rdev() {
    return this.#u;
  }
  #c;
  get blksize() {
    return this.#c;
  }
  #a;
  get ino() {
    return this.#a;
  }
  #l;
  get size() {
    return this.#l;
  }
  #r;
  get blocks() {
    return this.#r;
  }
  #p;
  get atimeMs() {
    return this.#p;
  }
  #h;
  get mtimeMs() {
    return this.#h;
  }
  #m;
  get ctimeMs() {
    return this.#m;
  }
  #d;
  get birthtimeMs() {
    return this.#d;
  }
  #S;
  get atime() {
    return this.#S;
  }
  #b;
  get mtime() {
    return this.#b;
  }
  #T;
  get ctime() {
    return this.#T;
  }
  #$;
  get birthtime() {
    return this.#$;
  }
  #_;
  #w;
  #E;
  #y;
  #R;
  #N;
  #i;
  #D;
  #v;
  #A;
  /**
   * This property is for compatibility with the Dirent class as of
   * Node v20, where Dirent['parentPath'] refers to the path of the
   * directory that was passed to readdir. For root entries, it's the path
   * to the entry itself.
   */
  get parentPath() {
    return (this.parent || this).fullpath();
  }
  /**
   * Deprecated alias for Dirent['parentPath'] Somewhat counterintuitively,
   * this property refers to the *parent* path, not the path object itself.
   */
  get path() {
    return this.parentPath;
  }
  /**
   * Do not create new Path objects directly.  They should always be accessed
   * via the PathScurry class or other methods on the Path class.
   *
   * @internal
   */
  constructor(t, n = On, r, i, s, o, a) {
    this.name = t, this.#_ = s ? La(t) : So(t), this.#i = n & JS, this.nocase = s, this.roots = i, this.root = r || this, this.#D = o, this.#E = a.fullpath, this.#R = a.relative, this.#N = a.relativePosix, this.parent = a.parent, this.parent ? this.#e = this.parent.#e : this.#e = F0(a.fs);
  }
  /**
   * Returns the depth of the Path object from its root.
   *
   * For example, a path at `/foo/bar` would have a depth of 2.
   */
  depth() {
    return this.#w !== void 0 ? this.#w : this.parent ? this.#w = this.parent.depth() + 1 : this.#w = 0;
  }
  /**
   * @internal
   */
  childrenCache() {
    return this.#D;
  }
  /**
   * Get the Path object referenced by the string path, resolved from this Path
   */
  resolve(t) {
    if (!t)
      return this;
    const n = this.getRootString(t), i = t.substring(n.length).split(this.splitSep);
    return n ? this.getRoot(n).#P(i) : this.#P(i);
  }
  #P(t) {
    let n = this;
    for (const r of t)
      n = n.child(r);
    return n;
  }
  /**
   * Returns the cached children Path objects, if still available.  If they
   * have fallen out of the cache, then returns an empty array, and resets the
   * READDIR_CALLED bit, so that future calls to readdir() will require an fs
   * lookup.
   *
   * @internal
   */
  children() {
    const t = this.#D.get(this);
    if (t)
      return t;
    const n = Object.assign([], { provisional: 0 });
    return this.#D.set(this, n), this.#i &= ~Cc, n;
  }
  /**
   * Resolves a path portion and returns or creates the child Path.
   *
   * Returns `this` if pathPart is `''` or `'.'`, or `parent` if pathPart is
   * `'..'`.
   *
   * This should not be called directly.  If `pathPart` contains any path
   * separators, it will lead to unsafe undefined behavior.
   *
   * Use `Path.resolve()` instead.
   *
   * @internal
   */
  child(t, n) {
    if (t === "" || t === ".")
      return this;
    if (t === "..")
      return this.parent || this;
    const r = this.children(), i = this.nocase ? La(t) : So(t);
    for (const l of r)
      if (l.#_ === i)
        return l;
    const s = this.parent ? this.sep : "", o = this.#E ? this.#E + s + t : void 0, a = this.newChild(t, On, {
      ...n,
      parent: this,
      fullpath: o
    });
    return this.canReaddir() || (a.#i |= qn), r.push(a), a;
  }
  /**
   * The relative path from the cwd. If it does not share an ancestor with
   * the cwd, then this ends up being equivalent to the fullpath()
   */
  relative() {
    if (this.isCWD)
      return "";
    if (this.#R !== void 0)
      return this.#R;
    const t = this.name, n = this.parent;
    if (!n)
      return this.#R = this.name;
    const r = n.relative();
    return r + (!r || !n.parent ? "" : this.sep) + t;
  }
  /**
   * The relative path from the cwd, using / as the path separator.
   * If it does not share an ancestor with
   * the cwd, then this ends up being equivalent to the fullpathPosix()
   * On posix systems, this is identical to relative().
   */
  relativePosix() {
    if (this.sep === "/")
      return this.relative();
    if (this.isCWD)
      return "";
    if (this.#N !== void 0)
      return this.#N;
    const t = this.name, n = this.parent;
    if (!n)
      return this.#N = this.fullpathPosix();
    const r = n.relativePosix();
    return r + (!r || !n.parent ? "" : "/") + t;
  }
  /**
   * The fully resolved path string for this Path entry
   */
  fullpath() {
    if (this.#E !== void 0)
      return this.#E;
    const t = this.name, n = this.parent;
    if (!n)
      return this.#E = this.name;
    const i = n.fullpath() + (n.parent ? this.sep : "") + t;
    return this.#E = i;
  }
  /**
   * On platforms other than windows, this is identical to fullpath.
   *
   * On windows, this is overridden to return the forward-slash form of the
   * full UNC path.
   */
  fullpathPosix() {
    if (this.#y !== void 0)
      return this.#y;
    if (this.sep === "/")
      return this.#y = this.fullpath();
    if (!this.parent) {
      const i = this.fullpath().replace(/\\/g, "/");
      return /^[a-z]:\//i.test(i) ? this.#y = `//?/${i}` : this.#y = i;
    }
    const t = this.parent, n = t.fullpathPosix(), r = n + (!n || !t.parent ? "" : "/") + this.name;
    return this.#y = r;
  }
  /**
   * Is the Path of an unknown type?
   *
   * Note that we might know *something* about it if there has been a previous
   * filesystem operation, for example that it does not exist, or is not a
   * link, or whether it has child entries.
   */
  isUnknown() {
    return (this.#i & Sn) === On;
  }
  isType(t) {
    return this[`is${t}`]();
  }
  getType() {
    return this.isUnknown() ? "Unknown" : this.isDirectory() ? "Directory" : this.isFile() ? "File" : this.isSymbolicLink() ? "SymbolicLink" : this.isFIFO() ? "FIFO" : this.isCharacterDevice() ? "CharacterDevice" : this.isBlockDevice() ? "BlockDevice" : (
      /* c8 ignore start */
      this.isSocket() ? "Socket" : "Unknown"
    );
  }
  /**
   * Is the Path a regular file?
   */
  isFile() {
    return (this.#i & Sn) === z0;
  }
  /**
   * Is the Path a directory?
   */
  isDirectory() {
    return (this.#i & Sn) === sr;
  }
  /**
   * Is the path a character device?
   */
  isCharacterDevice() {
    return (this.#i & Sn) === B0;
  }
  /**
   * Is the path a block device?
   */
  isBlockDevice() {
    return (this.#i & Sn) === G0;
  }
  /**
   * Is the path a FIFO pipe?
   */
  isFIFO() {
    return (this.#i & Sn) === V0;
  }
  /**
   * Is the path a socket?
   */
  isSocket() {
    return (this.#i & Sn) === q0;
  }
  /**
   * Is the path a symbolic link?
   */
  isSymbolicLink() {
    return (this.#i & Ri) === Ri;
  }
  /**
   * Return the entry if it has been subject of a successful lstat, or
   * undefined otherwise.
   *
   * Does not read the filesystem, so an undefined result *could* simply
   * mean that we haven't called lstat on it.
   */
  lstatCached() {
    return this.#i & rm ? this : void 0;
  }
  /**
   * Return the cached link target if the entry has been the subject of a
   * successful readlink, or undefined otherwise.
   *
   * Does not read the filesystem, so an undefined result *could* just mean we
   * don't have any cached data. Only use it if you are very sure that a
   * readlink() has been called at some point.
   */
  readlinkCached() {
    return this.#v;
  }
  /**
   * Returns the cached realpath target if the entry has been the subject
   * of a successful realpath, or undefined otherwise.
   *
   * Does not read the filesystem, so an undefined result *could* just mean we
   * don't have any cached data. Only use it if you are very sure that a
   * realpath() has been called at some point.
   */
  realpathCached() {
    return this.#A;
  }
  /**
   * Returns the cached child Path entries array if the entry has been the
   * subject of a successful readdir(), or [] otherwise.
   *
   * Does not read the filesystem, so an empty array *could* just mean we
   * don't have any cached data. Only use it if you are very sure that a
   * readdir() has been called recently enough to still be valid.
   */
  readdirCached() {
    const t = this.children();
    return t.slice(0, t.provisional);
  }
  /**
   * Return true if it's worth trying to readlink.  Ie, we don't (yet) have
   * any indication that readlink will definitely fail.
   *
   * Returns false if the path is known to not be a symlink, if a previous
   * readlink failed, or if the entry does not exist.
   */
  canReadlink() {
    if (this.#v)
      return !0;
    if (!this.parent)
      return !1;
    const t = this.#i & Sn;
    return !(t !== On && t !== Ri || this.#i & ka || this.#i & qn);
  }
  /**
   * Return true if readdir has previously been successfully called on this
   * path, indicating that cachedReaddir() is likely valid.
   */
  calledReaddir() {
    return !!(this.#i & Cc);
  }
  /**
   * Returns true if the path is known to not exist. That is, a previous lstat
   * or readdir failed to verify its existence when that would have been
   * expected, or a parent entry was marked either enoent or enotdir.
   */
  isENOENT() {
    return !!(this.#i & qn);
  }
  /**
   * Return true if the path is a match for the given path name.  This handles
   * case sensitivity and unicode normalization.
   *
   * Note: even on case-sensitive systems, it is **not** safe to test the
   * equality of the `.name` property to determine whether a given pathname
   * matches, due to unicode normalization mismatches.
   *
   * Always use this method instead of testing the `path.name` property
   * directly.
   */
  isNamed(t) {
    return this.nocase ? this.#_ === La(t) : this.#_ === So(t);
  }
  /**
   * Return the Path object corresponding to the target of a symbolic link.
   *
   * If the Path is not a symbolic link, or if the readlink call fails for any
   * reason, `undefined` is returned.
   *
   * Result is cached, and thus may be outdated if the filesystem is mutated.
   */
  async readlink() {
    const t = this.#v;
    if (t)
      return t;
    if (this.canReadlink() && this.parent)
      try {
        const n = await this.#e.promises.readlink(this.fullpath()), r = (await this.parent.realpath())?.resolve(n);
        if (r)
          return this.#v = r;
      } catch (n) {
        this.#f(n.code);
        return;
      }
  }
  /**
   * Synchronous {@link PathBase.readlink}
   */
  readlinkSync() {
    const t = this.#v;
    if (t)
      return t;
    if (this.canReadlink() && this.parent)
      try {
        const n = this.#e.readlinkSync(this.fullpath()), r = this.parent.realpathSync()?.resolve(n);
        if (r)
          return this.#v = r;
      } catch (n) {
        this.#f(n.code);
        return;
      }
  }
  #k(t) {
    this.#i |= Cc;
    for (let n = t.provisional; n < t.length; n++) {
      const r = t[n];
      r && r.#L();
    }
  }
  #L() {
    this.#i & qn || (this.#i = (this.#i | qn) & oo, this.#O());
  }
  #O() {
    const t = this.children();
    t.provisional = 0;
    for (const n of t)
      n.#L();
  }
  #I() {
    this.#i |= cl, this.#j();
  }
  // save the information when we know the entry is not a dir
  #j() {
    if (this.#i & Eo)
      return;
    let t = this.#i;
    (t & Sn) === sr && (t &= oo), this.#i = t | Eo, this.#O();
  }
  #C(t = "") {
    t === "ENOTDIR" || t === "EPERM" ? this.#j() : t === "ENOENT" ? this.#L() : this.children().provisional = 0;
  }
  #M(t = "") {
    t === "ENOTDIR" ? this.parent.#j() : t === "ENOENT" && this.#L();
  }
  #f(t = "") {
    let n = this.#i;
    n |= ka, t === "ENOENT" && (n |= qn), (t === "EINVAL" || t === "UNKNOWN") && (n &= oo), this.#i = n, t === "ENOTDIR" && this.parent && this.parent.#j();
  }
  #F(t, n) {
    return this.#x(t, n) || this.#U(t, n);
  }
  #U(t, n) {
    const r = Mc(t), i = this.newChild(t.name, r, { parent: this }), s = i.#i & Sn;
    return s !== sr && s !== Ri && s !== On && (i.#i |= Eo), n.unshift(i), n.provisional++, i;
  }
  #x(t, n) {
    for (let r = n.provisional; r < n.length; r++) {
      const i = n[r];
      if ((this.nocase ? La(t.name) : So(t.name)) === i.#_)
        return this.#V(t, i, r, n);
    }
  }
  #V(t, n, r, i) {
    const s = n.name;
    return n.#i = n.#i & oo | Mc(t), s !== t.name && (n.name = t.name), r !== i.provisional && (r === i.length - 1 ? i.pop() : i.splice(r, 1), i.unshift(n)), i.provisional++, n;
  }
  /**
   * Call lstat() on this Path, and update all known information that can be
   * determined.
   *
   * Note that unlike `fs.lstat()`, the returned value does not contain some
   * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
   * information is required, you will need to call `fs.lstat` yourself.
   *
   * If the Path refers to a nonexistent file, or if the lstat call fails for
   * any reason, `undefined` is returned.  Otherwise the updated Path object is
   * returned.
   *
   * Results are cached, and thus may be out of date if the filesystem is
   * mutated.
   */
  async lstat() {
    if (!(this.#i & qn))
      try {
        return this.#q(await this.#e.promises.lstat(this.fullpath())), this;
      } catch (t) {
        this.#M(t.code);
      }
  }
  /**
   * synchronous {@link PathBase.lstat}
   */
  lstatSync() {
    if (!(this.#i & qn))
      try {
        return this.#q(this.#e.lstatSync(this.fullpath())), this;
      } catch (t) {
        this.#M(t.code);
      }
  }
  #q(t) {
    const { atime: n, atimeMs: r, birthtime: i, birthtimeMs: s, blksize: o, blocks: a, ctime: l, ctimeMs: c, dev: u, gid: f, ino: d, mode: p, mtime: h, mtimeMs: m, nlink: v, rdev: b, size: E, uid: y } = t;
    this.#S = n, this.#p = r, this.#$ = i, this.#d = s, this.#c = o, this.#r = a, this.#T = l, this.#m = c, this.#t = u, this.#g = f, this.#a = d, this.#s = p, this.#b = h, this.#h = m, this.#n = v, this.#u = b, this.#l = E, this.#o = y;
    const D = Mc(t);
    this.#i = this.#i & oo | D | rm, D !== On && D !== sr && D !== Ri && (this.#i |= Eo);
  }
  #G = [];
  #z = !1;
  #H(t) {
    this.#z = !1;
    const n = this.#G.slice();
    this.#G.length = 0, n.forEach((r) => r(null, t));
  }
  /**
   * Standard node-style callback interface to get list of directory entries.
   *
   * If the Path cannot or does not contain any children, then an empty array
   * is returned.
   *
   * Results are cached, and thus may be out of date if the filesystem is
   * mutated.
   *
   * @param cb The callback called with (er, entries).  Note that the `er`
   * param is somewhat extraneous, as all readdir() errors are handled and
   * simply result in an empty set of entries being returned.
   * @param allowZalgo Boolean indicating that immediately known results should
   * *not* be deferred with `queueMicrotask`. Defaults to `false`. Release
   * zalgo at your peril, the dark pony lord is devious and unforgiving.
   */
  readdirCB(t, n = !1) {
    if (!this.canReaddir()) {
      n ? t(null, []) : queueMicrotask(() => t(null, []));
      return;
    }
    const r = this.children();
    if (this.calledReaddir()) {
      const s = r.slice(0, r.provisional);
      n ? t(null, s) : queueMicrotask(() => t(null, s));
      return;
    }
    if (this.#G.push(t), this.#z)
      return;
    this.#z = !0;
    const i = this.fullpath();
    this.#e.readdir(i, { withFileTypes: !0 }, (s, o) => {
      if (s)
        this.#C(s.code), r.provisional = 0;
      else {
        for (const a of o)
          this.#F(a, r);
        this.#k(r);
      }
      this.#H(r.slice(0, r.provisional));
    });
  }
  #B;
  /**
   * Return an array of known child entries.
   *
   * If the Path cannot or does not contain any children, then an empty array
   * is returned.
   *
   * Results are cached, and thus may be out of date if the filesystem is
   * mutated.
   */
  async readdir() {
    if (!this.canReaddir())
      return [];
    const t = this.children();
    if (this.calledReaddir())
      return t.slice(0, t.provisional);
    const n = this.fullpath();
    if (this.#B)
      await this.#B;
    else {
      let r = () => {
      };
      this.#B = new Promise((i) => r = i);
      try {
        for (const i of await this.#e.promises.readdir(n, {
          withFileTypes: !0
        }))
          this.#F(i, t);
        this.#k(t);
      } catch (i) {
        this.#C(i.code), t.provisional = 0;
      }
      this.#B = void 0, r();
    }
    return t.slice(0, t.provisional);
  }
  /**
   * synchronous {@link PathBase.readdir}
   */
  readdirSync() {
    if (!this.canReaddir())
      return [];
    const t = this.children();
    if (this.calledReaddir())
      return t.slice(0, t.provisional);
    const n = this.fullpath();
    try {
      for (const r of this.#e.readdirSync(n, {
        withFileTypes: !0
      }))
        this.#F(r, t);
      this.#k(t);
    } catch (r) {
      this.#C(r.code), t.provisional = 0;
    }
    return t.slice(0, t.provisional);
  }
  canReaddir() {
    if (this.#i & im)
      return !1;
    const t = Sn & this.#i;
    return t === On || t === sr || t === Ri;
  }
  shouldWalk(t, n) {
    return (this.#i & sr) === sr && !(this.#i & im) && !t.has(this) && (!n || n(this));
  }
  /**
   * Return the Path object corresponding to path as resolved
   * by realpath(3).
   *
   * If the realpath call fails for any reason, `undefined` is returned.
   *
   * Result is cached, and thus may be outdated if the filesystem is mutated.
   * On success, returns a Path object.
   */
  async realpath() {
    if (this.#A)
      return this.#A;
    if (!((cl | ka | qn) & this.#i))
      try {
        const t = await this.#e.promises.realpath(this.fullpath());
        return this.#A = this.resolve(t);
      } catch {
        this.#I();
      }
  }
  /**
   * Synchronous {@link realpath}
   */
  realpathSync() {
    if (this.#A)
      return this.#A;
    if (!((cl | ka | qn) & this.#i))
      try {
        const t = this.#e.realpathSync(this.fullpath());
        return this.#A = this.resolve(t);
      } catch {
        this.#I();
      }
  }
  /**
   * Internal method to mark this Path object as the scurry cwd,
   * called by {@link PathScurry#chdir}
   *
   * @internal
   */
  [W0](t) {
    if (t === this)
      return;
    t.isCWD = !1, this.isCWD = !0;
    const n = /* @__PURE__ */ new Set([]);
    let r = [], i = this;
    for (; i && i.parent; )
      n.add(i), i.#R = r.join(this.sep), i.#N = r.join("/"), i = i.parent, r.push("..");
    for (i = t; i && i.parent && !n.has(i); )
      i.#R = void 0, i.#N = void 0, i = i.parent;
  }
}
$t.PathBase = nn;
class aa extends nn {
  /**
   * Separator for generating path strings.
   */
  sep = "\\";
  /**
   * Separator for parsing path strings.
   */
  splitSep = QS;
  /**
   * Do not create new Path objects directly.  They should always be accessed
   * via the PathScurry class or other methods on the Path class.
   *
   * @internal
   */
  constructor(t, n = On, r, i, s, o, a) {
    super(t, n, r, i, s, o, a);
  }
  /**
   * @internal
   */
  newChild(t, n = On, r = {}) {
    return new aa(t, n, this.root, this.roots, this.nocase, this.childrenCache(), r);
  }
  /**
   * @internal
   */
  getRootString(t) {
    return xl.win32.parse(t).root;
  }
  /**
   * @internal
   */
  getRoot(t) {
    if (t = WS(t.toUpperCase()), t === this.root.name)
      return this.root;
    for (const [n, r] of Object.entries(this.roots))
      if (this.sameRoot(t, n))
        return this.roots[t] = r;
    return this.roots[t] = new kd(t, this).root;
  }
  /**
   * @internal
   */
  sameRoot(t, n = this.root.name) {
    return t = t.toUpperCase().replace(/\//g, "\\").replace(U0, "$1\\"), t === n;
  }
}
$t.PathWin32 = aa;
class la extends nn {
  /**
   * separator for parsing path strings
   */
  splitSep = "/";
  /**
   * separator for generating path strings
   */
  sep = "/";
  /**
   * Do not create new Path objects directly.  They should always be accessed
   * via the PathScurry class or other methods on the Path class.
   *
   * @internal
   */
  constructor(t, n = On, r, i, s, o, a) {
    super(t, n, r, i, s, o, a);
  }
  /**
   * @internal
   */
  getRootString(t) {
    return t.startsWith("/") ? "/" : "";
  }
  /**
   * @internal
   */
  getRoot(t) {
    return this.root;
  }
  /**
   * @internal
   */
  newChild(t, n = On, r = {}) {
    return new la(t, n, this.root, this.roots, this.nocase, this.childrenCache(), r);
  }
}
$t.PathPosix = la;
class Pd {
  /**
   * The root Path entry for the current working directory of this Scurry
   */
  root;
  /**
   * The string path for the root of this Scurry's current working directory
   */
  rootPath;
  /**
   * A collection of all roots encountered, referenced by rootPath
   */
  roots;
  /**
   * The Path entry corresponding to this PathScurry's current working directory.
   */
  cwd;
  #e;
  #t;
  #s;
  /**
   * Perform path comparisons case-insensitively.
   *
   * Defaults true on Darwin and Windows systems, false elsewhere.
   */
  nocase;
  #n;
  /**
   * This class should not be instantiated directly.
   *
   * Use PathScurryWin32, PathScurryDarwin, PathScurryPosix, or PathScurry
   *
   * @internal
   */
  constructor(t = process.cwd(), n, r, { nocase: i, childrenCacheSize: s = 16 * 1024, fs: o = wo } = {}) {
    this.#n = F0(o), (t instanceof URL || t.startsWith("file://")) && (t = (0, zS.fileURLToPath)(t));
    const a = n.resolve(t);
    this.roots = /* @__PURE__ */ Object.create(null), this.rootPath = this.parseRootPath(a), this.#e = new Cf(), this.#t = new Cf(), this.#s = new H0(s);
    const l = a.substring(this.rootPath.length).split(r);
    if (l.length === 1 && !l[0] && l.pop(), i === void 0)
      throw new TypeError("must provide nocase setting to PathScurryBase ctor");
    this.nocase = i, this.root = this.newRoot(this.#n), this.roots[this.rootPath] = this.root;
    let c = this.root, u = l.length - 1;
    const f = n.sep;
    let d = this.rootPath, p = !1;
    for (const h of l) {
      const m = u--;
      c = c.child(h, {
        relative: new Array(m).fill("..").join(f),
        relativePosix: new Array(m).fill("..").join("/"),
        fullpath: d += (p ? "" : f) + h
      }), p = !0;
    }
    this.cwd = c;
  }
  /**
   * Get the depth of a provided path, string, or the cwd
   */
  depth(t = this.cwd) {
    return typeof t == "string" && (t = this.cwd.resolve(t)), t.depth();
  }
  /**
   * Return the cache of child entries.  Exposed so subclasses can create
   * child Path objects in a platform-specific way.
   *
   * @internal
   */
  childrenCache() {
    return this.#s;
  }
  /**
   * Resolve one or more path strings to a resolved string
   *
   * Same interface as require('path').resolve.
   *
   * Much faster than path.resolve() when called multiple times for the same
   * path, because the resolved Path objects are cached.  Much slower
   * otherwise.
   */
  resolve(...t) {
    let n = "";
    for (let s = t.length - 1; s >= 0; s--) {
      const o = t[s];
      if (!(!o || o === ".") && (n = n ? `${o}/${n}` : o, this.isAbsolute(o)))
        break;
    }
    const r = this.#e.get(n);
    if (r !== void 0)
      return r;
    const i = this.cwd.resolve(n).fullpath();
    return this.#e.set(n, i), i;
  }
  /**
   * Resolve one or more path strings to a resolved string, returning
   * the posix path.  Identical to .resolve() on posix systems, but on
   * windows will return a forward-slash separated UNC path.
   *
   * Same interface as require('path').resolve.
   *
   * Much faster than path.resolve() when called multiple times for the same
   * path, because the resolved Path objects are cached.  Much slower
   * otherwise.
   */
  resolvePosix(...t) {
    let n = "";
    for (let s = t.length - 1; s >= 0; s--) {
      const o = t[s];
      if (!(!o || o === ".") && (n = n ? `${o}/${n}` : o, this.isAbsolute(o)))
        break;
    }
    const r = this.#t.get(n);
    if (r !== void 0)
      return r;
    const i = this.cwd.resolve(n).fullpathPosix();
    return this.#t.set(n, i), i;
  }
  /**
   * find the relative path from the cwd to the supplied path string or entry
   */
  relative(t = this.cwd) {
    return typeof t == "string" && (t = this.cwd.resolve(t)), t.relative();
  }
  /**
   * find the relative path from the cwd to the supplied path string or
   * entry, using / as the path delimiter, even on Windows.
   */
  relativePosix(t = this.cwd) {
    return typeof t == "string" && (t = this.cwd.resolve(t)), t.relativePosix();
  }
  /**
   * Return the basename for the provided string or Path object
   */
  basename(t = this.cwd) {
    return typeof t == "string" && (t = this.cwd.resolve(t)), t.name;
  }
  /**
   * Return the dirname for the provided string or Path object
   */
  dirname(t = this.cwd) {
    return typeof t == "string" && (t = this.cwd.resolve(t)), (t.parent || t).fullpath();
  }
  async readdir(t = this.cwd, n = {
    withFileTypes: !0
  }) {
    typeof t == "string" ? t = this.cwd.resolve(t) : t instanceof nn || (n = t, t = this.cwd);
    const { withFileTypes: r } = n;
    if (t.canReaddir()) {
      const i = await t.readdir();
      return r ? i : i.map((s) => s.name);
    } else
      return [];
  }
  readdirSync(t = this.cwd, n = {
    withFileTypes: !0
  }) {
    typeof t == "string" ? t = this.cwd.resolve(t) : t instanceof nn || (n = t, t = this.cwd);
    const { withFileTypes: r = !0 } = n;
    return t.canReaddir() ? r ? t.readdirSync() : t.readdirSync().map((i) => i.name) : [];
  }
  /**
   * Call lstat() on the string or Path object, and update all known
   * information that can be determined.
   *
   * Note that unlike `fs.lstat()`, the returned value does not contain some
   * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
   * information is required, you will need to call `fs.lstat` yourself.
   *
   * If the Path refers to a nonexistent file, or if the lstat call fails for
   * any reason, `undefined` is returned.  Otherwise the updated Path object is
   * returned.
   *
   * Results are cached, and thus may be out of date if the filesystem is
   * mutated.
   */
  async lstat(t = this.cwd) {
    return typeof t == "string" && (t = this.cwd.resolve(t)), t.lstat();
  }
  /**
   * synchronous {@link PathScurryBase.lstat}
   */
  lstatSync(t = this.cwd) {
    return typeof t == "string" && (t = this.cwd.resolve(t)), t.lstatSync();
  }
  async readlink(t = this.cwd, { withFileTypes: n } = {
    withFileTypes: !1
  }) {
    typeof t == "string" ? t = this.cwd.resolve(t) : t instanceof nn || (n = t.withFileTypes, t = this.cwd);
    const r = await t.readlink();
    return n ? r : r?.fullpath();
  }
  readlinkSync(t = this.cwd, { withFileTypes: n } = {
    withFileTypes: !1
  }) {
    typeof t == "string" ? t = this.cwd.resolve(t) : t instanceof nn || (n = t.withFileTypes, t = this.cwd);
    const r = t.readlinkSync();
    return n ? r : r?.fullpath();
  }
  async realpath(t = this.cwd, { withFileTypes: n } = {
    withFileTypes: !1
  }) {
    typeof t == "string" ? t = this.cwd.resolve(t) : t instanceof nn || (n = t.withFileTypes, t = this.cwd);
    const r = await t.realpath();
    return n ? r : r?.fullpath();
  }
  realpathSync(t = this.cwd, { withFileTypes: n } = {
    withFileTypes: !1
  }) {
    typeof t == "string" ? t = this.cwd.resolve(t) : t instanceof nn || (n = t.withFileTypes, t = this.cwd);
    const r = t.realpathSync();
    return n ? r : r?.fullpath();
  }
  async walk(t = this.cwd, n = {}) {
    typeof t == "string" ? t = this.cwd.resolve(t) : t instanceof nn || (n = t, t = this.cwd);
    const { withFileTypes: r = !0, follow: i = !1, filter: s, walkFilter: o } = n, a = [];
    (!s || s(t)) && a.push(r ? t : t.fullpath());
    const l = /* @__PURE__ */ new Set(), c = (f, d) => {
      l.add(f), f.readdirCB((p, h) => {
        if (p)
          return d(p);
        let m = h.length;
        if (!m)
          return d();
        const v = () => {
          --m === 0 && d();
        };
        for (const b of h)
          (!s || s(b)) && a.push(r ? b : b.fullpath()), i && b.isSymbolicLink() ? b.realpath().then((E) => E?.isUnknown() ? E.lstat() : E).then((E) => E?.shouldWalk(l, o) ? c(E, v) : v()) : b.shouldWalk(l, o) ? c(b, v) : v();
      }, !0);
    }, u = t;
    return new Promise((f, d) => {
      c(u, (p) => {
        if (p)
          return d(p);
        f(a);
      });
    });
  }
  walkSync(t = this.cwd, n = {}) {
    typeof t == "string" ? t = this.cwd.resolve(t) : t instanceof nn || (n = t, t = this.cwd);
    const { withFileTypes: r = !0, follow: i = !1, filter: s, walkFilter: o } = n, a = [];
    (!s || s(t)) && a.push(r ? t : t.fullpath());
    const l = /* @__PURE__ */ new Set([t]);
    for (const c of l) {
      const u = c.readdirSync();
      for (const f of u) {
        (!s || s(f)) && a.push(r ? f : f.fullpath());
        let d = f;
        if (f.isSymbolicLink()) {
          if (!(i && (d = f.realpathSync())))
            continue;
          d.isUnknown() && d.lstatSync();
        }
        d.shouldWalk(l, o) && l.add(d);
      }
    }
    return a;
  }
  /**
   * Support for `for await`
   *
   * Alias for {@link PathScurryBase.iterate}
   *
   * Note: As of Node 19, this is very slow, compared to other methods of
   * walking.  Consider using {@link PathScurryBase.stream} if memory overhead
   * and backpressure are concerns, or {@link PathScurryBase.walk} if not.
   */
  [Symbol.asyncIterator]() {
    return this.iterate();
  }
  iterate(t = this.cwd, n = {}) {
    return typeof t == "string" ? t = this.cwd.resolve(t) : t instanceof nn || (n = t, t = this.cwd), this.stream(t, n)[Symbol.asyncIterator]();
  }
  /**
   * Iterating over a PathScurry performs a synchronous walk.
   *
   * Alias for {@link PathScurryBase.iterateSync}
   */
  [Symbol.iterator]() {
    return this.iterateSync();
  }
  *iterateSync(t = this.cwd, n = {}) {
    typeof t == "string" ? t = this.cwd.resolve(t) : t instanceof nn || (n = t, t = this.cwd);
    const { withFileTypes: r = !0, follow: i = !1, filter: s, walkFilter: o } = n;
    (!s || s(t)) && (yield r ? t : t.fullpath());
    const a = /* @__PURE__ */ new Set([t]);
    for (const l of a) {
      const c = l.readdirSync();
      for (const u of c) {
        (!s || s(u)) && (yield r ? u : u.fullpath());
        let f = u;
        if (u.isSymbolicLink()) {
          if (!(i && (f = u.realpathSync())))
            continue;
          f.isUnknown() && f.lstatSync();
        }
        f.shouldWalk(a, o) && a.add(f);
      }
    }
  }
  stream(t = this.cwd, n = {}) {
    typeof t == "string" ? t = this.cwd.resolve(t) : t instanceof nn || (n = t, t = this.cwd);
    const { withFileTypes: r = !0, follow: i = !1, filter: s, walkFilter: o } = n, a = new nm.Minipass({ objectMode: !0 });
    (!s || s(t)) && a.write(r ? t : t.fullpath());
    const l = /* @__PURE__ */ new Set(), c = [t];
    let u = 0;
    const f = () => {
      let d = !1;
      for (; !d; ) {
        const p = c.shift();
        if (!p) {
          u === 0 && a.end();
          return;
        }
        u++, l.add(p);
        const h = (v, b, E = !1) => {
          if (v)
            return a.emit("error", v);
          if (i && !E) {
            const y = [];
            for (const D of b)
              D.isSymbolicLink() && y.push(D.realpath().then((F) => F?.isUnknown() ? F.lstat() : F));
            if (y.length) {
              Promise.all(y).then(() => h(null, b, !0));
              return;
            }
          }
          for (const y of b)
            y && (!s || s(y)) && (a.write(r ? y : y.fullpath()) || (d = !0));
          u--;
          for (const y of b) {
            const D = y.realpathCached() || y;
            D.shouldWalk(l, o) && c.push(D);
          }
          d && !a.flowing ? a.once("drain", f) : m || f();
        };
        let m = !0;
        p.readdirCB(h, !0), m = !1;
      }
    };
    return f(), a;
  }
  streamSync(t = this.cwd, n = {}) {
    typeof t == "string" ? t = this.cwd.resolve(t) : t instanceof nn || (n = t, t = this.cwd);
    const { withFileTypes: r = !0, follow: i = !1, filter: s, walkFilter: o } = n, a = new nm.Minipass({ objectMode: !0 }), l = /* @__PURE__ */ new Set();
    (!s || s(t)) && a.write(r ? t : t.fullpath());
    const c = [t];
    let u = 0;
    const f = () => {
      let d = !1;
      for (; !d; ) {
        const p = c.shift();
        if (!p) {
          u === 0 && a.end();
          return;
        }
        u++, l.add(p);
        const h = p.readdirSync();
        for (const m of h)
          (!s || s(m)) && (a.write(r ? m : m.fullpath()) || (d = !0));
        u--;
        for (const m of h) {
          let v = m;
          if (m.isSymbolicLink()) {
            if (!(i && (v = m.realpathSync())))
              continue;
            v.isUnknown() && v.lstatSync();
          }
          v.shouldWalk(l, o) && c.push(v);
        }
      }
      d && !a.flowing && a.once("drain", f);
    };
    return f(), a;
  }
  chdir(t = this.cwd) {
    const n = this.cwd;
    this.cwd = typeof t == "string" ? this.cwd.resolve(t) : t, this.cwd[W0](n);
  }
}
$t.PathScurryBase = Pd;
class kd extends Pd {
  /**
   * separator for generating path strings
   */
  sep = "\\";
  constructor(t = process.cwd(), n = {}) {
    const { nocase: r = !0 } = n;
    super(t, xl.win32, "\\", { ...n, nocase: r }), this.nocase = r;
    for (let i = this.cwd; i; i = i.parent)
      i.nocase = this.nocase;
  }
  /**
   * @internal
   */
  parseRootPath(t) {
    return xl.win32.parse(t).root.toUpperCase();
  }
  /**
   * @internal
   */
  newRoot(t) {
    return new aa(this.rootPath, sr, void 0, this.roots, this.nocase, this.childrenCache(), { fs: t });
  }
  /**
   * Return true if the provided path string is an absolute path
   */
  isAbsolute(t) {
    return t.startsWith("/") || t.startsWith("\\") || /^[a-z]:(\/|\\)/i.test(t);
  }
}
$t.PathScurryWin32 = kd;
class Ld extends Pd {
  /**
   * separator for generating path strings
   */
  sep = "/";
  constructor(t = process.cwd(), n = {}) {
    const { nocase: r = !1 } = n;
    super(t, xl.posix, "/", { ...n, nocase: r }), this.nocase = r;
  }
  /**
   * @internal
   */
  parseRootPath(t) {
    return "/";
  }
  /**
   * @internal
   */
  newRoot(t) {
    return new la(this.rootPath, sr, void 0, this.roots, this.nocase, this.childrenCache(), { fs: t });
  }
  /**
   * Return true if the provided path string is an absolute path
   */
  isAbsolute(t) {
    return t.startsWith("/");
  }
}
$t.PathScurryPosix = Ld;
class Q0 extends Ld {
  constructor(t = process.cwd(), n = {}) {
    const { nocase: r = !0 } = n;
    super(t, { ...n, nocase: r });
  }
}
$t.PathScurryDarwin = Q0;
$t.Path = process.platform === "win32" ? aa : la;
$t.PathScurry = process.platform === "win32" ? kd : process.platform === "darwin" ? Q0 : Ld;
var ua = {};
Object.defineProperty(ua, "__esModule", { value: !0 });
ua.Pattern = void 0;
const KS = li, YS = (e) => e.length >= 1, XS = (e) => e.length >= 1;
class jd {
  #e;
  #t;
  #s;
  length;
  #n;
  #o;
  #g;
  #u;
  #c;
  #a;
  #l = !0;
  constructor(t, n, r, i) {
    if (!YS(t))
      throw new TypeError("empty pattern list");
    if (!XS(n))
      throw new TypeError("empty glob list");
    if (n.length !== t.length)
      throw new TypeError("mismatched pattern list and glob list lengths");
    if (this.length = t.length, r < 0 || r >= this.length)
      throw new TypeError("index out of range");
    if (this.#e = t, this.#t = n, this.#s = r, this.#n = i, this.#s === 0) {
      if (this.isUNC()) {
        const [s, o, a, l, ...c] = this.#e, [u, f, d, p, ...h] = this.#t;
        c[0] === "" && (c.shift(), h.shift());
        const m = [s, o, a, l, ""].join("/"), v = [u, f, d, p, ""].join("/");
        this.#e = [m, ...c], this.#t = [v, ...h], this.length = this.#e.length;
      } else if (this.isDrive() || this.isAbsolute()) {
        const [s, ...o] = this.#e, [a, ...l] = this.#t;
        o[0] === "" && (o.shift(), l.shift());
        const c = s + "/", u = a + "/";
        this.#e = [c, ...o], this.#t = [u, ...l], this.length = this.#e.length;
      }
    }
  }
  /**
   * The first entry in the parsed list of patterns
   */
  pattern() {
    return this.#e[this.#s];
  }
  /**
   * true of if pattern() returns a string
   */
  isString() {
    return typeof this.#e[this.#s] == "string";
  }
  /**
   * true of if pattern() returns GLOBSTAR
   */
  isGlobstar() {
    return this.#e[this.#s] === KS.GLOBSTAR;
  }
  /**
   * true if pattern() returns a regexp
   */
  isRegExp() {
    return this.#e[this.#s] instanceof RegExp;
  }
  /**
   * The /-joined set of glob parts that make up this pattern
   */
  globString() {
    return this.#g = this.#g || (this.#s === 0 ? this.isAbsolute() ? this.#t[0] + this.#t.slice(1).join("/") : this.#t.join("/") : this.#t.slice(this.#s).join("/"));
  }
  /**
   * true if there are more pattern parts after this one
   */
  hasMore() {
    return this.length > this.#s + 1;
  }
  /**
   * The rest of the pattern after this part, or null if this is the end
   */
  rest() {
    return this.#o !== void 0 ? this.#o : this.hasMore() ? (this.#o = new jd(this.#e, this.#t, this.#s + 1, this.#n), this.#o.#a = this.#a, this.#o.#c = this.#c, this.#o.#u = this.#u, this.#o) : this.#o = null;
  }
  /**
   * true if the pattern represents a //unc/path/ on windows
   */
  isUNC() {
    const t = this.#e;
    return this.#c !== void 0 ? this.#c : this.#c = this.#n === "win32" && this.#s === 0 && t[0] === "" && t[1] === "" && typeof t[2] == "string" && !!t[2] && typeof t[3] == "string" && !!t[3];
  }
  // pattern like C:/...
  // split = ['C:', ...]
  // XXX: would be nice to handle patterns like `c:*` to test the cwd
  // in c: for *, but I don't know of a way to even figure out what that
  // cwd is without actually chdir'ing into it?
  /**
   * True if the pattern starts with a drive letter on Windows
   */
  isDrive() {
    const t = this.#e;
    return this.#u !== void 0 ? this.#u : this.#u = this.#n === "win32" && this.#s === 0 && this.length > 1 && typeof t[0] == "string" && /^[a-z]:$/i.test(t[0]);
  }
  // pattern = '/' or '/...' or '/x/...'
  // split = ['', ''] or ['', ...] or ['', 'x', ...]
  // Drive and UNC both considered absolute on windows
  /**
   * True if the pattern is rooted on an absolute path
   */
  isAbsolute() {
    const t = this.#e;
    return this.#a !== void 0 ? this.#a : this.#a = t[0] === "" && t.length > 1 || this.isDrive() || this.isUNC();
  }
  /**
   * consume the root of the pattern, and return it
   */
  root() {
    const t = this.#e[0];
    return typeof t == "string" && this.isAbsolute() && this.#s === 0 ? t : "";
  }
  /**
   * Check to see if the current globstar pattern is allowed to follow
   * a symbolic link.
   */
  checkFollowGlobstar() {
    return !(this.#s === 0 || !this.isGlobstar() || !this.#l);
  }
  /**
   * Mark that the current globstar pattern is following a symbolic link
   */
  markFollowGlobstar() {
    return this.#s === 0 || !this.isGlobstar() || !this.#l ? !1 : (this.#l = !1, !0);
  }
}
ua.Pattern = jd;
var ii = {}, ca = {};
Object.defineProperty(ca, "__esModule", { value: !0 });
ca.Ignore = void 0;
const am = li, ZS = ua, eT = typeof process == "object" && process && typeof process.platform == "string" ? process.platform : "linux";
class tT {
  relative;
  relativeChildren;
  absolute;
  absoluteChildren;
  platform;
  mmopts;
  constructor(t, { nobrace: n, nocase: r, noext: i, noglobstar: s, platform: o = eT }) {
    this.relative = [], this.absolute = [], this.relativeChildren = [], this.absoluteChildren = [], this.platform = o, this.mmopts = {
      dot: !0,
      nobrace: n,
      nocase: r,
      noext: i,
      noglobstar: s,
      optimizationLevel: 2,
      platform: o,
      nocomment: !0,
      nonegate: !0
    };
    for (const a of t)
      this.add(a);
  }
  add(t) {
    const n = new am.Minimatch(t, this.mmopts);
    for (let r = 0; r < n.set.length; r++) {
      const i = n.set[r], s = n.globParts[r];
      if (!i || !s)
        throw new Error("invalid pattern object");
      for (; i[0] === "." && s[0] === "."; )
        i.shift(), s.shift();
      const o = new ZS.Pattern(i, s, 0, this.platform), a = new am.Minimatch(o.globString(), this.mmopts), l = s[s.length - 1] === "**", c = o.isAbsolute();
      c ? this.absolute.push(a) : this.relative.push(a), l && (c ? this.absoluteChildren.push(a) : this.relativeChildren.push(a));
    }
  }
  ignored(t) {
    const n = t.fullpath(), r = `${n}/`, i = t.relative() || ".", s = `${i}/`;
    for (const o of this.relative)
      if (o.match(i) || o.match(s))
        return !0;
    for (const o of this.absolute)
      if (o.match(n) || o.match(r))
        return !0;
    return !1;
  }
  childrenIgnored(t) {
    const n = t.fullpath() + "/", r = (t.relative() || ".") + "/";
    for (const i of this.relativeChildren)
      if (i.match(r))
        return !0;
    for (const i of this.absoluteChildren)
      if (i.match(n))
        return !0;
    return !1;
  }
}
ca.Ignore = tT;
var cr = {};
Object.defineProperty(cr, "__esModule", { value: !0 });
cr.Processor = cr.SubWalks = cr.MatchRecord = cr.HasWalkedCache = void 0;
const lm = li;
class hu {
  store;
  constructor(t = /* @__PURE__ */ new Map()) {
    this.store = t;
  }
  copy() {
    return new hu(new Map(this.store));
  }
  hasWalked(t, n) {
    return this.store.get(t.fullpath())?.has(n.globString());
  }
  storeWalked(t, n) {
    const r = t.fullpath(), i = this.store.get(r);
    i ? i.add(n.globString()) : this.store.set(r, /* @__PURE__ */ new Set([n.globString()]));
  }
}
cr.HasWalkedCache = hu;
class J0 {
  store = /* @__PURE__ */ new Map();
  add(t, n, r) {
    const i = (n ? 2 : 0) | (r ? 1 : 0), s = this.store.get(t);
    this.store.set(t, s === void 0 ? i : i & s);
  }
  // match, absolute, ifdir
  entries() {
    return [...this.store.entries()].map(([t, n]) => [
      t,
      !!(n & 2),
      !!(n & 1)
    ]);
  }
}
cr.MatchRecord = J0;
class K0 {
  store = /* @__PURE__ */ new Map();
  add(t, n) {
    if (!t.canReaddir())
      return;
    const r = this.store.get(t);
    r ? r.find((i) => i.globString() === n.globString()) || r.push(n) : this.store.set(t, [n]);
  }
  get(t) {
    const n = this.store.get(t);
    if (!n)
      throw new Error("attempting to walk unknown path");
    return n;
  }
  entries() {
    return this.keys().map((t) => [t, this.store.get(t)]);
  }
  keys() {
    return [...this.store.keys()].filter((t) => t.canReaddir());
  }
}
cr.SubWalks = K0;
class Cd {
  hasWalkedCache;
  matches = new J0();
  subwalks = new K0();
  patterns;
  follow;
  dot;
  opts;
  constructor(t, n) {
    this.opts = t, this.follow = !!t.follow, this.dot = !!t.dot, this.hasWalkedCache = n ? n.copy() : new hu();
  }
  processPatterns(t, n) {
    this.patterns = n;
    const r = n.map((i) => [t, i]);
    for (let [i, s] of r) {
      this.hasWalkedCache.storeWalked(i, s);
      const o = s.root(), a = s.isAbsolute() && this.opts.absolute !== !1;
      if (o) {
        i = i.resolve(o === "/" && this.opts.root !== void 0 ? this.opts.root : o);
        const f = s.rest();
        if (f)
          s = f;
        else {
          this.matches.add(i, !0, !1);
          continue;
        }
      }
      if (i.isENOENT())
        continue;
      let l, c, u = !1;
      for (; typeof (l = s.pattern()) == "string" && (c = s.rest()); )
        i = i.resolve(l), s = c, u = !0;
      if (l = s.pattern(), c = s.rest(), u) {
        if (this.hasWalkedCache.hasWalked(i, s))
          continue;
        this.hasWalkedCache.storeWalked(i, s);
      }
      if (typeof l == "string") {
        const f = l === ".." || l === "" || l === ".";
        this.matches.add(i.resolve(l), a, f);
        continue;
      } else if (l === lm.GLOBSTAR) {
        (!i.isSymbolicLink() || this.follow || s.checkFollowGlobstar()) && this.subwalks.add(i, s);
        const f = c?.pattern(), d = c?.rest();
        if (!c || (f === "" || f === ".") && !d)
          this.matches.add(i, a, f === "" || f === ".");
        else if (f === "..") {
          const p = i.parent || i;
          d ? this.hasWalkedCache.hasWalked(p, d) || this.subwalks.add(p, d) : this.matches.add(p, a, !0);
        }
      } else
        l instanceof RegExp && this.subwalks.add(i, s);
    }
    return this;
  }
  subwalkTargets() {
    return this.subwalks.keys();
  }
  child() {
    return new Cd(this.opts, this.hasWalkedCache);
  }
  // return a new Processor containing the subwalks for each
  // child entry, and a set of matches, and
  // a hasWalkedCache that's a copy of this one
  // then we're going to call
  filterEntries(t, n) {
    const r = this.subwalks.get(t), i = this.child();
    for (const s of n)
      for (const o of r) {
        const a = o.isAbsolute(), l = o.pattern(), c = o.rest();
        l === lm.GLOBSTAR ? i.testGlobstar(s, o, c, a) : l instanceof RegExp ? i.testRegExp(s, l, c, a) : i.testString(s, l, c, a);
      }
    return i;
  }
  testGlobstar(t, n, r, i) {
    if ((this.dot || !t.name.startsWith(".")) && (n.hasMore() || this.matches.add(t, i, !1), t.canReaddir() && (this.follow || !t.isSymbolicLink() ? this.subwalks.add(t, n) : t.isSymbolicLink() && (r && n.checkFollowGlobstar() ? this.subwalks.add(t, r) : n.markFollowGlobstar() && this.subwalks.add(t, n)))), r) {
      const s = r.pattern();
      if (typeof s == "string" && // dots and empty were handled already
      s !== ".." && s !== "" && s !== ".")
        this.testString(t, s, r.rest(), i);
      else if (s === "..") {
        const o = t.parent || t;
        this.subwalks.add(o, r);
      } else
        s instanceof RegExp && this.testRegExp(t, s, r.rest(), i);
    }
  }
  testRegExp(t, n, r, i) {
    n.test(t.name) && (r ? this.subwalks.add(t, r) : this.matches.add(t, i, !1));
  }
  testString(t, n, r, i) {
    t.isNamed(n) && (r ? this.subwalks.add(t, r) : this.matches.add(t, i, !1));
  }
}
cr.Processor = Cd;
Object.defineProperty(ii, "__esModule", { value: !0 });
ii.GlobStream = ii.GlobWalker = ii.GlobUtil = void 0;
const nT = Dd, um = ca, cm = cr, rT = (e, t) => typeof e == "string" ? new um.Ignore([e], t) : Array.isArray(e) ? new um.Ignore(e, t) : e;
class Md {
  path;
  patterns;
  opts;
  seen = /* @__PURE__ */ new Set();
  paused = !1;
  aborted = !1;
  #e = [];
  #t;
  #s;
  signal;
  maxDepth;
  includeChildMatches;
  constructor(t, n, r) {
    if (this.patterns = t, this.path = n, this.opts = r, this.#s = !r.posix && r.platform === "win32" ? "\\" : "/", this.includeChildMatches = r.includeChildMatches !== !1, (r.ignore || !this.includeChildMatches) && (this.#t = rT(r.ignore ?? [], r), !this.includeChildMatches && typeof this.#t.add != "function")) {
      const i = "cannot ignore child matches, ignore lacks add() method.";
      throw new Error(i);
    }
    this.maxDepth = r.maxDepth || 1 / 0, r.signal && (this.signal = r.signal, this.signal.addEventListener("abort", () => {
      this.#e.length = 0;
    }));
  }
  #n(t) {
    return this.seen.has(t) || !!this.#t?.ignored?.(t);
  }
  #o(t) {
    return !!this.#t?.childrenIgnored?.(t);
  }
  // backpressure mechanism
  pause() {
    this.paused = !0;
  }
  resume() {
    if (this.signal?.aborted)
      return;
    this.paused = !1;
    let t;
    for (; !this.paused && (t = this.#e.shift()); )
      t();
  }
  onResume(t) {
    this.signal?.aborted || (this.paused ? this.#e.push(t) : t());
  }
  // do the requisite realpath/stat checking, and return the path
  // to add or undefined to filter it out.
  async matchCheck(t, n) {
    if (n && this.opts.nodir)
      return;
    let r;
    if (this.opts.realpath) {
      if (r = t.realpathCached() || await t.realpath(), !r)
        return;
      t = r;
    }
    const s = t.isUnknown() || this.opts.stat ? await t.lstat() : t;
    if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {
      const o = await s.realpath();
      o && (o.isUnknown() || this.opts.stat) && await o.lstat();
    }
    return this.matchCheckTest(s, n);
  }
  matchCheckTest(t, n) {
    return t && (this.maxDepth === 1 / 0 || t.depth() <= this.maxDepth) && (!n || t.canReaddir()) && (!this.opts.nodir || !t.isDirectory()) && (!this.opts.nodir || !this.opts.follow || !t.isSymbolicLink() || !t.realpathCached()?.isDirectory()) && !this.#n(t) ? t : void 0;
  }
  matchCheckSync(t, n) {
    if (n && this.opts.nodir)
      return;
    let r;
    if (this.opts.realpath) {
      if (r = t.realpathCached() || t.realpathSync(), !r)
        return;
      t = r;
    }
    const s = t.isUnknown() || this.opts.stat ? t.lstatSync() : t;
    if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {
      const o = s.realpathSync();
      o && (o?.isUnknown() || this.opts.stat) && o.lstatSync();
    }
    return this.matchCheckTest(s, n);
  }
  matchFinish(t, n) {
    if (this.#n(t))
      return;
    if (!this.includeChildMatches && this.#t?.add) {
      const s = `${t.relativePosix()}/**`;
      this.#t.add(s);
    }
    const r = this.opts.absolute === void 0 ? n : this.opts.absolute;
    this.seen.add(t);
    const i = this.opts.mark && t.isDirectory() ? this.#s : "";
    if (this.opts.withFileTypes)
      this.matchEmit(t);
    else if (r) {
      const s = this.opts.posix ? t.fullpathPosix() : t.fullpath();
      this.matchEmit(s + i);
    } else {
      const s = this.opts.posix ? t.relativePosix() : t.relative(), o = this.opts.dotRelative && !s.startsWith(".." + this.#s) ? "." + this.#s : "";
      this.matchEmit(s ? o + s + i : "." + i);
    }
  }
  async match(t, n, r) {
    const i = await this.matchCheck(t, r);
    i && this.matchFinish(i, n);
  }
  matchSync(t, n, r) {
    const i = this.matchCheckSync(t, r);
    i && this.matchFinish(i, n);
  }
  walkCB(t, n, r) {
    this.signal?.aborted && r(), this.walkCB2(t, n, new cm.Processor(this.opts), r);
  }
  walkCB2(t, n, r, i) {
    if (this.#o(t))
      return i();
    if (this.signal?.aborted && i(), this.paused) {
      this.onResume(() => this.walkCB2(t, n, r, i));
      return;
    }
    r.processPatterns(t, n);
    let s = 1;
    const o = () => {
      --s === 0 && i();
    };
    for (const [a, l, c] of r.matches.entries())
      this.#n(a) || (s++, this.match(a, l, c).then(() => o()));
    for (const a of r.subwalkTargets()) {
      if (this.maxDepth !== 1 / 0 && a.depth() >= this.maxDepth)
        continue;
      s++;
      const l = a.readdirCached();
      a.calledReaddir() ? this.walkCB3(a, l, r, o) : a.readdirCB((c, u) => this.walkCB3(a, u, r, o), !0);
    }
    o();
  }
  walkCB3(t, n, r, i) {
    r = r.filterEntries(t, n);
    let s = 1;
    const o = () => {
      --s === 0 && i();
    };
    for (const [a, l, c] of r.matches.entries())
      this.#n(a) || (s++, this.match(a, l, c).then(() => o()));
    for (const [a, l] of r.subwalks.entries())
      s++, this.walkCB2(a, l, r.child(), o);
    o();
  }
  walkCBSync(t, n, r) {
    this.signal?.aborted && r(), this.walkCB2Sync(t, n, new cm.Processor(this.opts), r);
  }
  walkCB2Sync(t, n, r, i) {
    if (this.#o(t))
      return i();
    if (this.signal?.aborted && i(), this.paused) {
      this.onResume(() => this.walkCB2Sync(t, n, r, i));
      return;
    }
    r.processPatterns(t, n);
    let s = 1;
    const o = () => {
      --s === 0 && i();
    };
    for (const [a, l, c] of r.matches.entries())
      this.#n(a) || this.matchSync(a, l, c);
    for (const a of r.subwalkTargets()) {
      if (this.maxDepth !== 1 / 0 && a.depth() >= this.maxDepth)
        continue;
      s++;
      const l = a.readdirSync();
      this.walkCB3Sync(a, l, r, o);
    }
    o();
  }
  walkCB3Sync(t, n, r, i) {
    r = r.filterEntries(t, n);
    let s = 1;
    const o = () => {
      --s === 0 && i();
    };
    for (const [a, l, c] of r.matches.entries())
      this.#n(a) || this.matchSync(a, l, c);
    for (const [a, l] of r.subwalks.entries())
      s++, this.walkCB2Sync(a, l, r.child(), o);
    o();
  }
}
ii.GlobUtil = Md;
class iT extends Md {
  matches = /* @__PURE__ */ new Set();
  constructor(t, n, r) {
    super(t, n, r);
  }
  matchEmit(t) {
    this.matches.add(t);
  }
  async walk() {
    if (this.signal?.aborted)
      throw this.signal.reason;
    return this.path.isUnknown() && await this.path.lstat(), await new Promise((t, n) => {
      this.walkCB(this.path, this.patterns, () => {
        this.signal?.aborted ? n(this.signal.reason) : t(this.matches);
      });
    }), this.matches;
  }
  walkSync() {
    if (this.signal?.aborted)
      throw this.signal.reason;
    return this.path.isUnknown() && this.path.lstatSync(), this.walkCBSync(this.path, this.patterns, () => {
      if (this.signal?.aborted)
        throw this.signal.reason;
    }), this.matches;
  }
}
ii.GlobWalker = iT;
class sT extends Md {
  results;
  constructor(t, n, r) {
    super(t, n, r), this.results = new nT.Minipass({
      signal: this.signal,
      objectMode: !0
    }), this.results.on("drain", () => this.resume()), this.results.on("resume", () => this.resume());
  }
  matchEmit(t) {
    this.results.write(t), this.results.flowing || this.pause();
  }
  stream() {
    const t = this.path;
    return t.isUnknown() ? t.lstat().then(() => {
      this.walkCB(t, this.patterns, () => this.results.end());
    }) : this.walkCB(t, this.patterns, () => this.results.end()), this.results;
  }
  streamSync() {
    return this.path.isUnknown() && this.path.lstatSync(), this.walkCBSync(this.path, this.patterns, () => this.results.end()), this.results;
  }
}
ii.GlobStream = sT;
Object.defineProperty(Go, "__esModule", { value: !0 });
Go.Glob = void 0;
const oT = li, aT = at, ja = $t, lT = ua, Ca = ii, uT = typeof process == "object" && process && typeof process.platform == "string" ? process.platform : "linux";
class cT {
  absolute;
  cwd;
  root;
  dot;
  dotRelative;
  follow;
  ignore;
  magicalBraces;
  mark;
  matchBase;
  maxDepth;
  nobrace;
  nocase;
  nodir;
  noext;
  noglobstar;
  pattern;
  platform;
  realpath;
  scurry;
  stat;
  signal;
  windowsPathsNoEscape;
  withFileTypes;
  includeChildMatches;
  /**
   * The options provided to the constructor.
   */
  opts;
  /**
   * An array of parsed immutable {@link Pattern} objects.
   */
  patterns;
  /**
   * All options are stored as properties on the `Glob` object.
   *
   * See {@link GlobOptions} for full options descriptions.
   *
   * Note that a previous `Glob` object can be passed as the
   * `GlobOptions` to another `Glob` instantiation to re-use settings
   * and caches with a new pattern.
   *
   * Traversal functions can be called multiple times to run the walk
   * again.
   */
  constructor(t, n) {
    if (!n)
      throw new TypeError("glob options required");
    if (this.withFileTypes = !!n.withFileTypes, this.signal = n.signal, this.follow = !!n.follow, this.dot = !!n.dot, this.dotRelative = !!n.dotRelative, this.nodir = !!n.nodir, this.mark = !!n.mark, n.cwd ? (n.cwd instanceof URL || n.cwd.startsWith("file://")) && (n.cwd = (0, aT.fileURLToPath)(n.cwd)) : this.cwd = "", this.cwd = n.cwd || "", this.root = n.root, this.magicalBraces = !!n.magicalBraces, this.nobrace = !!n.nobrace, this.noext = !!n.noext, this.realpath = !!n.realpath, this.absolute = n.absolute, this.includeChildMatches = n.includeChildMatches !== !1, this.noglobstar = !!n.noglobstar, this.matchBase = !!n.matchBase, this.maxDepth = typeof n.maxDepth == "number" ? n.maxDepth : 1 / 0, this.stat = !!n.stat, this.ignore = n.ignore, this.withFileTypes && this.absolute !== void 0)
      throw new Error("cannot set absolute and withFileTypes:true");
    if (typeof t == "string" && (t = [t]), this.windowsPathsNoEscape = !!n.windowsPathsNoEscape || n.allowWindowsEscape === !1, this.windowsPathsNoEscape && (t = t.map((l) => l.replace(/\\/g, "/"))), this.matchBase) {
      if (n.noglobstar)
        throw new TypeError("base matching requires globstar");
      t = t.map((l) => l.includes("/") ? l : `./**/${l}`);
    }
    if (this.pattern = t, this.platform = n.platform || uT, this.opts = { ...n, platform: this.platform }, n.scurry) {
      if (this.scurry = n.scurry, n.nocase !== void 0 && n.nocase !== n.scurry.nocase)
        throw new Error("nocase option contradicts provided scurry option");
    } else {
      const l = n.platform === "win32" ? ja.PathScurryWin32 : n.platform === "darwin" ? ja.PathScurryDarwin : n.platform ? ja.PathScurryPosix : ja.PathScurry;
      this.scurry = new l(this.cwd, {
        nocase: n.nocase,
        fs: n.fs
      });
    }
    this.nocase = this.scurry.nocase;
    const r = this.platform === "darwin" || this.platform === "win32", i = {
      // default nocase based on platform
      ...n,
      dot: this.dot,
      matchBase: this.matchBase,
      nobrace: this.nobrace,
      nocase: this.nocase,
      nocaseMagicOnly: r,
      nocomment: !0,
      noext: this.noext,
      nonegate: !0,
      optimizationLevel: 2,
      platform: this.platform,
      windowsPathsNoEscape: this.windowsPathsNoEscape,
      debug: !!this.opts.debug
    }, s = this.pattern.map((l) => new oT.Minimatch(l, i)), [o, a] = s.reduce((l, c) => (l[0].push(...c.set), l[1].push(...c.globParts), l), [[], []]);
    this.patterns = o.map((l, c) => {
      const u = a[c];
      if (!u)
        throw new Error("invalid pattern object");
      return new lT.Pattern(l, u, 0, this.platform);
    });
  }
  async walk() {
    return [
      ...await new Ca.GlobWalker(this.patterns, this.scurry.cwd, {
        ...this.opts,
        maxDepth: this.maxDepth !== 1 / 0 ? this.maxDepth + this.scurry.cwd.depth() : 1 / 0,
        platform: this.platform,
        nocase: this.nocase,
        includeChildMatches: this.includeChildMatches
      }).walk()
    ];
  }
  walkSync() {
    return [
      ...new Ca.GlobWalker(this.patterns, this.scurry.cwd, {
        ...this.opts,
        maxDepth: this.maxDepth !== 1 / 0 ? this.maxDepth + this.scurry.cwd.depth() : 1 / 0,
        platform: this.platform,
        nocase: this.nocase,
        includeChildMatches: this.includeChildMatches
      }).walkSync()
    ];
  }
  stream() {
    return new Ca.GlobStream(this.patterns, this.scurry.cwd, {
      ...this.opts,
      maxDepth: this.maxDepth !== 1 / 0 ? this.maxDepth + this.scurry.cwd.depth() : 1 / 0,
      platform: this.platform,
      nocase: this.nocase,
      includeChildMatches: this.includeChildMatches
    }).stream();
  }
  streamSync() {
    return new Ca.GlobStream(this.patterns, this.scurry.cwd, {
      ...this.opts,
      maxDepth: this.maxDepth !== 1 / 0 ? this.maxDepth + this.scurry.cwd.depth() : 1 / 0,
      platform: this.platform,
      nocase: this.nocase,
      includeChildMatches: this.includeChildMatches
    }).streamSync();
  }
  /**
   * Default sync iteration function. Returns a Generator that
   * iterates over the results.
   */
  iterateSync() {
    return this.streamSync()[Symbol.iterator]();
  }
  [Symbol.iterator]() {
    return this.iterateSync();
  }
  /**
   * Default async iteration function. Returns an AsyncGenerator that
   * iterates over the results.
   */
  iterate() {
    return this.stream()[Symbol.asyncIterator]();
  }
  [Symbol.asyncIterator]() {
    return this.iterate();
  }
}
Go.Glob = cT;
var zo = {};
Object.defineProperty(zo, "__esModule", { value: !0 });
zo.hasMagic = void 0;
const fT = li, dT = (e, t = {}) => {
  Array.isArray(e) || (e = [e]);
  for (const n of e)
    if (new fT.Minimatch(n, t).hasMagic())
      return !0;
  return !1;
};
zo.hasMagic = dT;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.glob = e.sync = e.iterate = e.iterateSync = e.stream = e.streamSync = e.Ignore = e.hasMagic = e.Glob = e.unescape = e.escape = void 0, e.globStreamSync = l, e.globStream = c, e.globSync = u, e.globIterateSync = d, e.globIterate = p;
  const t = li, n = Go, r = zo;
  var i = li;
  Object.defineProperty(e, "escape", { enumerable: !0, get: function() {
    return i.escape;
  } }), Object.defineProperty(e, "unescape", { enumerable: !0, get: function() {
    return i.unescape;
  } });
  var s = Go;
  Object.defineProperty(e, "Glob", { enumerable: !0, get: function() {
    return s.Glob;
  } });
  var o = zo;
  Object.defineProperty(e, "hasMagic", { enumerable: !0, get: function() {
    return o.hasMagic;
  } });
  var a = ca;
  Object.defineProperty(e, "Ignore", { enumerable: !0, get: function() {
    return a.Ignore;
  } });
  function l(h, m = {}) {
    return new n.Glob(h, m).streamSync();
  }
  function c(h, m = {}) {
    return new n.Glob(h, m).stream();
  }
  function u(h, m = {}) {
    return new n.Glob(h, m).walkSync();
  }
  async function f(h, m = {}) {
    return new n.Glob(h, m).walk();
  }
  function d(h, m = {}) {
    return new n.Glob(h, m).iterateSync();
  }
  function p(h, m = {}) {
    return new n.Glob(h, m).iterate();
  }
  e.streamSync = l, e.stream = Object.assign(c, { sync: l }), e.iterateSync = d, e.iterate = Object.assign(p, {
    sync: d
  }), e.sync = Object.assign(u, {
    stream: l,
    iterate: d
  }), e.glob = Object.assign(f, {
    glob: f,
    globSync: u,
    sync: e.sync,
    globStream: c,
    stream: e.stream,
    globStreamSync: l,
    streamSync: e.streamSync,
    globIterate: p,
    iterate: e.iterate,
    globIterateSync: d,
    iterateSync: e.iterateSync,
    Glob: n.Glob,
    hasMagic: r.hasMagic,
    escape: t.escape,
    unescape: t.unescape
  }), e.glob.glob = e.glob;
})(N0);
var Wi = { exports: {} }, Fd = {};
function pT(e) {
  const t = e.length;
  return t > 21 && e.indexOf("application/javascript") === 0 || t > 14 && e.indexOf("application/json") === 0 || t > 5 && e.indexOf("text/") === 0;
}
Fd.isUtf8MimeType = pT;
function mu() {
  this._types = /* @__PURE__ */ Object.create(null), this._extensions = /* @__PURE__ */ Object.create(null);
  for (let e = 0; e < arguments.length; e++)
    this.define(arguments[e]);
  this.define = this.define.bind(this), this.getType = this.getType.bind(this), this.getExtension = this.getExtension.bind(this);
}
mu.prototype.define = function(e, t) {
  for (let n in e) {
    let r = e[n].map(function(i) {
      return i.toLowerCase();
    });
    n = n.toLowerCase();
    for (let i = 0; i < r.length; i++) {
      const s = r[i];
      if (s[0] !== "*") {
        if (!t && s in this._types)
          throw new Error(
            'Attempt to change mapping for "' + s + '" extension from "' + this._types[s] + '" to "' + n + '". Pass `force=true` to allow this, otherwise remove "' + s + '" from the list of extensions for "' + n + '".'
          );
        this._types[s] = n;
      }
    }
    if (t || !this._extensions[n]) {
      const i = r[0];
      this._extensions[n] = i[0] !== "*" ? i : i.substr(1);
    }
  }
};
mu.prototype.getType = function(e) {
  e = String(e);
  let t = e.replace(/^.*[/\\]/, "").toLowerCase(), n = t.replace(/^.*\./, "").toLowerCase(), r = t.length < e.length;
  return (n.length < t.length - 1 || !r) && this._types[n] || null;
};
mu.prototype.getExtension = function(e) {
  return e = /^\s*([^;\s]*)/.test(e) && RegExp.$1, e && this._extensions[e.toLowerCase()] || null;
};
var hT = mu, mT = { "application/andrew-inset": ["ez"], "application/applixware": ["aw"], "application/atom+xml": ["atom"], "application/atomcat+xml": ["atomcat"], "application/atomdeleted+xml": ["atomdeleted"], "application/atomsvc+xml": ["atomsvc"], "application/atsc-dwd+xml": ["dwd"], "application/atsc-held+xml": ["held"], "application/atsc-rsat+xml": ["rsat"], "application/bdoc": ["bdoc"], "application/calendar+xml": ["xcs"], "application/ccxml+xml": ["ccxml"], "application/cdfx+xml": ["cdfx"], "application/cdmi-capability": ["cdmia"], "application/cdmi-container": ["cdmic"], "application/cdmi-domain": ["cdmid"], "application/cdmi-object": ["cdmio"], "application/cdmi-queue": ["cdmiq"], "application/cu-seeme": ["cu"], "application/dash+xml": ["mpd"], "application/davmount+xml": ["davmount"], "application/docbook+xml": ["dbk"], "application/dssc+der": ["dssc"], "application/dssc+xml": ["xdssc"], "application/ecmascript": ["es", "ecma"], "application/emma+xml": ["emma"], "application/emotionml+xml": ["emotionml"], "application/epub+zip": ["epub"], "application/exi": ["exi"], "application/express": ["exp"], "application/fdt+xml": ["fdt"], "application/font-tdpfr": ["pfr"], "application/geo+json": ["geojson"], "application/gml+xml": ["gml"], "application/gpx+xml": ["gpx"], "application/gxf": ["gxf"], "application/gzip": ["gz"], "application/hjson": ["hjson"], "application/hyperstudio": ["stk"], "application/inkml+xml": ["ink", "inkml"], "application/ipfix": ["ipfix"], "application/its+xml": ["its"], "application/java-archive": ["jar", "war", "ear"], "application/java-serialized-object": ["ser"], "application/java-vm": ["class"], "application/javascript": ["js", "mjs"], "application/json": ["json", "map"], "application/json5": ["json5"], "application/jsonml+json": ["jsonml"], "application/ld+json": ["jsonld"], "application/lgr+xml": ["lgr"], "application/lost+xml": ["lostxml"], "application/mac-binhex40": ["hqx"], "application/mac-compactpro": ["cpt"], "application/mads+xml": ["mads"], "application/manifest+json": ["webmanifest"], "application/marc": ["mrc"], "application/marcxml+xml": ["mrcx"], "application/mathematica": ["ma", "nb", "mb"], "application/mathml+xml": ["mathml"], "application/mbox": ["mbox"], "application/mediaservercontrol+xml": ["mscml"], "application/metalink+xml": ["metalink"], "application/metalink4+xml": ["meta4"], "application/mets+xml": ["mets"], "application/mmt-aei+xml": ["maei"], "application/mmt-usd+xml": ["musd"], "application/mods+xml": ["mods"], "application/mp21": ["m21", "mp21"], "application/mp4": ["mp4s", "m4p"], "application/msword": ["doc", "dot"], "application/mxf": ["mxf"], "application/n-quads": ["nq"], "application/n-triples": ["nt"], "application/node": ["cjs"], "application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"], "application/oda": ["oda"], "application/oebps-package+xml": ["opf"], "application/ogg": ["ogx"], "application/omdoc+xml": ["omdoc"], "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"], "application/oxps": ["oxps"], "application/p2p-overlay+xml": ["relo"], "application/patch-ops-error+xml": ["xer"], "application/pdf": ["pdf"], "application/pgp-encrypted": ["pgp"], "application/pgp-signature": ["asc", "sig"], "application/pics-rules": ["prf"], "application/pkcs10": ["p10"], "application/pkcs7-mime": ["p7m", "p7c"], "application/pkcs7-signature": ["p7s"], "application/pkcs8": ["p8"], "application/pkix-attr-cert": ["ac"], "application/pkix-cert": ["cer"], "application/pkix-crl": ["crl"], "application/pkix-pkipath": ["pkipath"], "application/pkixcmp": ["pki"], "application/pls+xml": ["pls"], "application/postscript": ["ai", "eps", "ps"], "application/provenance+xml": ["provx"], "application/pskc+xml": ["pskcxml"], "application/raml+yaml": ["raml"], "application/rdf+xml": ["rdf", "owl"], "application/reginfo+xml": ["rif"], "application/relax-ng-compact-syntax": ["rnc"], "application/resource-lists+xml": ["rl"], "application/resource-lists-diff+xml": ["rld"], "application/rls-services+xml": ["rs"], "application/route-apd+xml": ["rapd"], "application/route-s-tsid+xml": ["sls"], "application/route-usd+xml": ["rusd"], "application/rpki-ghostbusters": ["gbr"], "application/rpki-manifest": ["mft"], "application/rpki-roa": ["roa"], "application/rsd+xml": ["rsd"], "application/rss+xml": ["rss"], "application/rtf": ["rtf"], "application/sbml+xml": ["sbml"], "application/scvp-cv-request": ["scq"], "application/scvp-cv-response": ["scs"], "application/scvp-vp-request": ["spq"], "application/scvp-vp-response": ["spp"], "application/sdp": ["sdp"], "application/senml+xml": ["senmlx"], "application/sensml+xml": ["sensmlx"], "application/set-payment-initiation": ["setpay"], "application/set-registration-initiation": ["setreg"], "application/shf+xml": ["shf"], "application/sieve": ["siv", "sieve"], "application/smil+xml": ["smi", "smil"], "application/sparql-query": ["rq"], "application/sparql-results+xml": ["srx"], "application/srgs": ["gram"], "application/srgs+xml": ["grxml"], "application/sru+xml": ["sru"], "application/ssdl+xml": ["ssdl"], "application/ssml+xml": ["ssml"], "application/swid+xml": ["swidtag"], "application/tei+xml": ["tei", "teicorpus"], "application/thraud+xml": ["tfi"], "application/timestamped-data": ["tsd"], "application/toml": ["toml"], "application/trig": ["trig"], "application/ttml+xml": ["ttml"], "application/ubjson": ["ubj"], "application/urc-ressheet+xml": ["rsheet"], "application/urc-targetdesc+xml": ["td"], "application/voicexml+xml": ["vxml"], "application/wasm": ["wasm"], "application/widget": ["wgt"], "application/winhlp": ["hlp"], "application/wsdl+xml": ["wsdl"], "application/wspolicy+xml": ["wspolicy"], "application/xaml+xml": ["xaml"], "application/xcap-att+xml": ["xav"], "application/xcap-caps+xml": ["xca"], "application/xcap-diff+xml": ["xdf"], "application/xcap-el+xml": ["xel"], "application/xcap-ns+xml": ["xns"], "application/xenc+xml": ["xenc"], "application/xhtml+xml": ["xhtml", "xht"], "application/xliff+xml": ["xlf"], "application/xml": ["xml", "xsl", "xsd", "rng"], "application/xml-dtd": ["dtd"], "application/xop+xml": ["xop"], "application/xproc+xml": ["xpl"], "application/xslt+xml": ["*xsl", "xslt"], "application/xspf+xml": ["xspf"], "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"], "application/yang": ["yang"], "application/yin+xml": ["yin"], "application/zip": ["zip"], "audio/3gpp": ["*3gpp"], "audio/adpcm": ["adp"], "audio/amr": ["amr"], "audio/basic": ["au", "snd"], "audio/midi": ["mid", "midi", "kar", "rmi"], "audio/mobile-xmf": ["mxmf"], "audio/mp3": ["*mp3"], "audio/mp4": ["m4a", "mp4a"], "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"], "audio/ogg": ["oga", "ogg", "spx", "opus"], "audio/s3m": ["s3m"], "audio/silk": ["sil"], "audio/wav": ["wav"], "audio/wave": ["*wav"], "audio/webm": ["weba"], "audio/xm": ["xm"], "font/collection": ["ttc"], "font/otf": ["otf"], "font/ttf": ["ttf"], "font/woff": ["woff"], "font/woff2": ["woff2"], "image/aces": ["exr"], "image/apng": ["apng"], "image/avif": ["avif"], "image/bmp": ["bmp"], "image/cgm": ["cgm"], "image/dicom-rle": ["drle"], "image/emf": ["emf"], "image/fits": ["fits"], "image/g3fax": ["g3"], "image/gif": ["gif"], "image/heic": ["heic"], "image/heic-sequence": ["heics"], "image/heif": ["heif"], "image/heif-sequence": ["heifs"], "image/hej2k": ["hej2"], "image/hsj2": ["hsj2"], "image/ief": ["ief"], "image/jls": ["jls"], "image/jp2": ["jp2", "jpg2"], "image/jpeg": ["jpeg", "jpg", "jpe"], "image/jph": ["jph"], "image/jphc": ["jhc"], "image/jpm": ["jpm"], "image/jpx": ["jpx", "jpf"], "image/jxr": ["jxr"], "image/jxra": ["jxra"], "image/jxrs": ["jxrs"], "image/jxs": ["jxs"], "image/jxsc": ["jxsc"], "image/jxsi": ["jxsi"], "image/jxss": ["jxss"], "image/ktx": ["ktx"], "image/ktx2": ["ktx2"], "image/png": ["png"], "image/sgi": ["sgi"], "image/svg+xml": ["svg", "svgz"], "image/t38": ["t38"], "image/tiff": ["tif", "tiff"], "image/tiff-fx": ["tfx"], "image/webp": ["webp"], "image/wmf": ["wmf"], "message/disposition-notification": ["disposition-notification"], "message/global": ["u8msg"], "message/global-delivery-status": ["u8dsn"], "message/global-disposition-notification": ["u8mdn"], "message/global-headers": ["u8hdr"], "message/rfc822": ["eml", "mime"], "model/3mf": ["3mf"], "model/gltf+json": ["gltf"], "model/gltf-binary": ["glb"], "model/iges": ["igs", "iges"], "model/mesh": ["msh", "mesh", "silo"], "model/mtl": ["mtl"], "model/obj": ["obj"], "model/step+xml": ["stpx"], "model/step+zip": ["stpz"], "model/step-xml+zip": ["stpxz"], "model/stl": ["stl"], "model/vrml": ["wrl", "vrml"], "model/x3d+binary": ["*x3db", "x3dbz"], "model/x3d+fastinfoset": ["x3db"], "model/x3d+vrml": ["*x3dv", "x3dvz"], "model/x3d+xml": ["x3d", "x3dz"], "model/x3d-vrml": ["x3dv"], "text/cache-manifest": ["appcache", "manifest"], "text/calendar": ["ics", "ifb"], "text/coffeescript": ["coffee", "litcoffee"], "text/css": ["css"], "text/csv": ["csv"], "text/html": ["html", "htm", "shtml"], "text/jade": ["jade"], "text/jsx": ["jsx"], "text/less": ["less"], "text/markdown": ["markdown", "md"], "text/mathml": ["mml"], "text/mdx": ["mdx"], "text/n3": ["n3"], "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"], "text/richtext": ["rtx"], "text/rtf": ["*rtf"], "text/sgml": ["sgml", "sgm"], "text/shex": ["shex"], "text/slim": ["slim", "slm"], "text/spdx": ["spdx"], "text/stylus": ["stylus", "styl"], "text/tab-separated-values": ["tsv"], "text/troff": ["t", "tr", "roff", "man", "me", "ms"], "text/turtle": ["ttl"], "text/uri-list": ["uri", "uris", "urls"], "text/vcard": ["vcard"], "text/vtt": ["vtt"], "text/xml": ["*xml"], "text/yaml": ["yaml", "yml"], "video/3gpp": ["3gp", "3gpp"], "video/3gpp2": ["3g2"], "video/h261": ["h261"], "video/h263": ["h263"], "video/h264": ["h264"], "video/iso.segment": ["m4s"], "video/jpeg": ["jpgv"], "video/jpm": ["*jpm", "jpgm"], "video/mj2": ["mj2", "mjp2"], "video/mp2t": ["ts"], "video/mp4": ["mp4", "mp4v", "mpg4"], "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"], "video/ogg": ["ogv"], "video/quicktime": ["qt", "mov"], "video/webm": ["webm"] }, yT = { "application/prs.cww": ["cww"], "application/vnd.1000minds.decision-model+xml": ["1km"], "application/vnd.3gpp.pic-bw-large": ["plb"], "application/vnd.3gpp.pic-bw-small": ["psb"], "application/vnd.3gpp.pic-bw-var": ["pvb"], "application/vnd.3gpp2.tcap": ["tcap"], "application/vnd.3m.post-it-notes": ["pwn"], "application/vnd.accpac.simply.aso": ["aso"], "application/vnd.accpac.simply.imp": ["imp"], "application/vnd.acucobol": ["acu"], "application/vnd.acucorp": ["atc", "acutc"], "application/vnd.adobe.air-application-installer-package+zip": ["air"], "application/vnd.adobe.formscentral.fcdt": ["fcdt"], "application/vnd.adobe.fxp": ["fxp", "fxpl"], "application/vnd.adobe.xdp+xml": ["xdp"], "application/vnd.adobe.xfdf": ["xfdf"], "application/vnd.ahead.space": ["ahead"], "application/vnd.airzip.filesecure.azf": ["azf"], "application/vnd.airzip.filesecure.azs": ["azs"], "application/vnd.amazon.ebook": ["azw"], "application/vnd.americandynamics.acc": ["acc"], "application/vnd.amiga.ami": ["ami"], "application/vnd.android.package-archive": ["apk"], "application/vnd.anser-web-certificate-issue-initiation": ["cii"], "application/vnd.anser-web-funds-transfer-initiation": ["fti"], "application/vnd.antix.game-component": ["atx"], "application/vnd.apple.installer+xml": ["mpkg"], "application/vnd.apple.keynote": ["key"], "application/vnd.apple.mpegurl": ["m3u8"], "application/vnd.apple.numbers": ["numbers"], "application/vnd.apple.pages": ["pages"], "application/vnd.apple.pkpass": ["pkpass"], "application/vnd.aristanetworks.swi": ["swi"], "application/vnd.astraea-software.iota": ["iota"], "application/vnd.audiograph": ["aep"], "application/vnd.balsamiq.bmml+xml": ["bmml"], "application/vnd.blueice.multipass": ["mpm"], "application/vnd.bmi": ["bmi"], "application/vnd.businessobjects": ["rep"], "application/vnd.chemdraw+xml": ["cdxml"], "application/vnd.chipnuts.karaoke-mmd": ["mmd"], "application/vnd.cinderella": ["cdy"], "application/vnd.citationstyles.style+xml": ["csl"], "application/vnd.claymore": ["cla"], "application/vnd.cloanto.rp9": ["rp9"], "application/vnd.clonk.c4group": ["c4g", "c4d", "c4f", "c4p", "c4u"], "application/vnd.cluetrust.cartomobile-config": ["c11amc"], "application/vnd.cluetrust.cartomobile-config-pkg": ["c11amz"], "application/vnd.commonspace": ["csp"], "application/vnd.contact.cmsg": ["cdbcmsg"], "application/vnd.cosmocaller": ["cmc"], "application/vnd.crick.clicker": ["clkx"], "application/vnd.crick.clicker.keyboard": ["clkk"], "application/vnd.crick.clicker.palette": ["clkp"], "application/vnd.crick.clicker.template": ["clkt"], "application/vnd.crick.clicker.wordbank": ["clkw"], "application/vnd.criticaltools.wbs+xml": ["wbs"], "application/vnd.ctc-posml": ["pml"], "application/vnd.cups-ppd": ["ppd"], "application/vnd.curl.car": ["car"], "application/vnd.curl.pcurl": ["pcurl"], "application/vnd.dart": ["dart"], "application/vnd.data-vision.rdz": ["rdz"], "application/vnd.dbf": ["dbf"], "application/vnd.dece.data": ["uvf", "uvvf", "uvd", "uvvd"], "application/vnd.dece.ttml+xml": ["uvt", "uvvt"], "application/vnd.dece.unspecified": ["uvx", "uvvx"], "application/vnd.dece.zip": ["uvz", "uvvz"], "application/vnd.denovo.fcselayout-link": ["fe_launch"], "application/vnd.dna": ["dna"], "application/vnd.dolby.mlp": ["mlp"], "application/vnd.dpgraph": ["dpg"], "application/vnd.dreamfactory": ["dfac"], "application/vnd.ds-keypoint": ["kpxx"], "application/vnd.dvb.ait": ["ait"], "application/vnd.dvb.service": ["svc"], "application/vnd.dynageo": ["geo"], "application/vnd.ecowin.chart": ["mag"], "application/vnd.enliven": ["nml"], "application/vnd.epson.esf": ["esf"], "application/vnd.epson.msf": ["msf"], "application/vnd.epson.quickanime": ["qam"], "application/vnd.epson.salt": ["slt"], "application/vnd.epson.ssf": ["ssf"], "application/vnd.eszigno3+xml": ["es3", "et3"], "application/vnd.ezpix-album": ["ez2"], "application/vnd.ezpix-package": ["ez3"], "application/vnd.fdf": ["fdf"], "application/vnd.fdsn.mseed": ["mseed"], "application/vnd.fdsn.seed": ["seed", "dataless"], "application/vnd.flographit": ["gph"], "application/vnd.fluxtime.clip": ["ftc"], "application/vnd.framemaker": ["fm", "frame", "maker", "book"], "application/vnd.frogans.fnc": ["fnc"], "application/vnd.frogans.ltf": ["ltf"], "application/vnd.fsc.weblaunch": ["fsc"], "application/vnd.fujitsu.oasys": ["oas"], "application/vnd.fujitsu.oasys2": ["oa2"], "application/vnd.fujitsu.oasys3": ["oa3"], "application/vnd.fujitsu.oasysgp": ["fg5"], "application/vnd.fujitsu.oasysprs": ["bh2"], "application/vnd.fujixerox.ddd": ["ddd"], "application/vnd.fujixerox.docuworks": ["xdw"], "application/vnd.fujixerox.docuworks.binder": ["xbd"], "application/vnd.fuzzysheet": ["fzs"], "application/vnd.genomatix.tuxedo": ["txd"], "application/vnd.geogebra.file": ["ggb"], "application/vnd.geogebra.tool": ["ggt"], "application/vnd.geometry-explorer": ["gex", "gre"], "application/vnd.geonext": ["gxt"], "application/vnd.geoplan": ["g2w"], "application/vnd.geospace": ["g3w"], "application/vnd.gmx": ["gmx"], "application/vnd.google-apps.document": ["gdoc"], "application/vnd.google-apps.presentation": ["gslides"], "application/vnd.google-apps.spreadsheet": ["gsheet"], "application/vnd.google-earth.kml+xml": ["kml"], "application/vnd.google-earth.kmz": ["kmz"], "application/vnd.grafeq": ["gqf", "gqs"], "application/vnd.groove-account": ["gac"], "application/vnd.groove-help": ["ghf"], "application/vnd.groove-identity-message": ["gim"], "application/vnd.groove-injector": ["grv"], "application/vnd.groove-tool-message": ["gtm"], "application/vnd.groove-tool-template": ["tpl"], "application/vnd.groove-vcard": ["vcg"], "application/vnd.hal+xml": ["hal"], "application/vnd.handheld-entertainment+xml": ["zmm"], "application/vnd.hbci": ["hbci"], "application/vnd.hhe.lesson-player": ["les"], "application/vnd.hp-hpgl": ["hpgl"], "application/vnd.hp-hpid": ["hpid"], "application/vnd.hp-hps": ["hps"], "application/vnd.hp-jlyt": ["jlt"], "application/vnd.hp-pcl": ["pcl"], "application/vnd.hp-pclxl": ["pclxl"], "application/vnd.hydrostatix.sof-data": ["sfd-hdstx"], "application/vnd.ibm.minipay": ["mpy"], "application/vnd.ibm.modcap": ["afp", "listafp", "list3820"], "application/vnd.ibm.rights-management": ["irm"], "application/vnd.ibm.secure-container": ["sc"], "application/vnd.iccprofile": ["icc", "icm"], "application/vnd.igloader": ["igl"], "application/vnd.immervision-ivp": ["ivp"], "application/vnd.immervision-ivu": ["ivu"], "application/vnd.insors.igm": ["igm"], "application/vnd.intercon.formnet": ["xpw", "xpx"], "application/vnd.intergeo": ["i2g"], "application/vnd.intu.qbo": ["qbo"], "application/vnd.intu.qfx": ["qfx"], "application/vnd.ipunplugged.rcprofile": ["rcprofile"], "application/vnd.irepository.package+xml": ["irp"], "application/vnd.is-xpr": ["xpr"], "application/vnd.isac.fcs": ["fcs"], "application/vnd.jam": ["jam"], "application/vnd.jcp.javame.midlet-rms": ["rms"], "application/vnd.jisp": ["jisp"], "application/vnd.joost.joda-archive": ["joda"], "application/vnd.kahootz": ["ktz", "ktr"], "application/vnd.kde.karbon": ["karbon"], "application/vnd.kde.kchart": ["chrt"], "application/vnd.kde.kformula": ["kfo"], "application/vnd.kde.kivio": ["flw"], "application/vnd.kde.kontour": ["kon"], "application/vnd.kde.kpresenter": ["kpr", "kpt"], "application/vnd.kde.kspread": ["ksp"], "application/vnd.kde.kword": ["kwd", "kwt"], "application/vnd.kenameaapp": ["htke"], "application/vnd.kidspiration": ["kia"], "application/vnd.kinar": ["kne", "knp"], "application/vnd.koan": ["skp", "skd", "skt", "skm"], "application/vnd.kodak-descriptor": ["sse"], "application/vnd.las.las+xml": ["lasxml"], "application/vnd.llamagraphics.life-balance.desktop": ["lbd"], "application/vnd.llamagraphics.life-balance.exchange+xml": ["lbe"], "application/vnd.lotus-1-2-3": ["123"], "application/vnd.lotus-approach": ["apr"], "application/vnd.lotus-freelance": ["pre"], "application/vnd.lotus-notes": ["nsf"], "application/vnd.lotus-organizer": ["org"], "application/vnd.lotus-screencam": ["scm"], "application/vnd.lotus-wordpro": ["lwp"], "application/vnd.macports.portpkg": ["portpkg"], "application/vnd.mapbox-vector-tile": ["mvt"], "application/vnd.mcd": ["mcd"], "application/vnd.medcalcdata": ["mc1"], "application/vnd.mediastation.cdkey": ["cdkey"], "application/vnd.mfer": ["mwf"], "application/vnd.mfmp": ["mfm"], "application/vnd.micrografx.flo": ["flo"], "application/vnd.micrografx.igx": ["igx"], "application/vnd.mif": ["mif"], "application/vnd.mobius.daf": ["daf"], "application/vnd.mobius.dis": ["dis"], "application/vnd.mobius.mbk": ["mbk"], "application/vnd.mobius.mqy": ["mqy"], "application/vnd.mobius.msl": ["msl"], "application/vnd.mobius.plc": ["plc"], "application/vnd.mobius.txf": ["txf"], "application/vnd.mophun.application": ["mpn"], "application/vnd.mophun.certificate": ["mpc"], "application/vnd.mozilla.xul+xml": ["xul"], "application/vnd.ms-artgalry": ["cil"], "application/vnd.ms-cab-compressed": ["cab"], "application/vnd.ms-excel": ["xls", "xlm", "xla", "xlc", "xlt", "xlw"], "application/vnd.ms-excel.addin.macroenabled.12": ["xlam"], "application/vnd.ms-excel.sheet.binary.macroenabled.12": ["xlsb"], "application/vnd.ms-excel.sheet.macroenabled.12": ["xlsm"], "application/vnd.ms-excel.template.macroenabled.12": ["xltm"], "application/vnd.ms-fontobject": ["eot"], "application/vnd.ms-htmlhelp": ["chm"], "application/vnd.ms-ims": ["ims"], "application/vnd.ms-lrm": ["lrm"], "application/vnd.ms-officetheme": ["thmx"], "application/vnd.ms-outlook": ["msg"], "application/vnd.ms-pki.seccat": ["cat"], "application/vnd.ms-pki.stl": ["*stl"], "application/vnd.ms-powerpoint": ["ppt", "pps", "pot"], "application/vnd.ms-powerpoint.addin.macroenabled.12": ["ppam"], "application/vnd.ms-powerpoint.presentation.macroenabled.12": ["pptm"], "application/vnd.ms-powerpoint.slide.macroenabled.12": ["sldm"], "application/vnd.ms-powerpoint.slideshow.macroenabled.12": ["ppsm"], "application/vnd.ms-powerpoint.template.macroenabled.12": ["potm"], "application/vnd.ms-project": ["mpp", "mpt"], "application/vnd.ms-word.document.macroenabled.12": ["docm"], "application/vnd.ms-word.template.macroenabled.12": ["dotm"], "application/vnd.ms-works": ["wps", "wks", "wcm", "wdb"], "application/vnd.ms-wpl": ["wpl"], "application/vnd.ms-xpsdocument": ["xps"], "application/vnd.mseq": ["mseq"], "application/vnd.musician": ["mus"], "application/vnd.muvee.style": ["msty"], "application/vnd.mynfc": ["taglet"], "application/vnd.neurolanguage.nlu": ["nlu"], "application/vnd.nitf": ["ntf", "nitf"], "application/vnd.noblenet-directory": ["nnd"], "application/vnd.noblenet-sealer": ["nns"], "application/vnd.noblenet-web": ["nnw"], "application/vnd.nokia.n-gage.ac+xml": ["*ac"], "application/vnd.nokia.n-gage.data": ["ngdat"], "application/vnd.nokia.n-gage.symbian.install": ["n-gage"], "application/vnd.nokia.radio-preset": ["rpst"], "application/vnd.nokia.radio-presets": ["rpss"], "application/vnd.novadigm.edm": ["edm"], "application/vnd.novadigm.edx": ["edx"], "application/vnd.novadigm.ext": ["ext"], "application/vnd.oasis.opendocument.chart": ["odc"], "application/vnd.oasis.opendocument.chart-template": ["otc"], "application/vnd.oasis.opendocument.database": ["odb"], "application/vnd.oasis.opendocument.formula": ["odf"], "application/vnd.oasis.opendocument.formula-template": ["odft"], "application/vnd.oasis.opendocument.graphics": ["odg"], "application/vnd.oasis.opendocument.graphics-template": ["otg"], "application/vnd.oasis.opendocument.image": ["odi"], "application/vnd.oasis.opendocument.image-template": ["oti"], "application/vnd.oasis.opendocument.presentation": ["odp"], "application/vnd.oasis.opendocument.presentation-template": ["otp"], "application/vnd.oasis.opendocument.spreadsheet": ["ods"], "application/vnd.oasis.opendocument.spreadsheet-template": ["ots"], "application/vnd.oasis.opendocument.text": ["odt"], "application/vnd.oasis.opendocument.text-master": ["odm"], "application/vnd.oasis.opendocument.text-template": ["ott"], "application/vnd.oasis.opendocument.text-web": ["oth"], "application/vnd.olpc-sugar": ["xo"], "application/vnd.oma.dd2+xml": ["dd2"], "application/vnd.openblox.game+xml": ["obgx"], "application/vnd.openofficeorg.extension": ["oxt"], "application/vnd.openstreetmap.data+xml": ["osm"], "application/vnd.openxmlformats-officedocument.presentationml.presentation": ["pptx"], "application/vnd.openxmlformats-officedocument.presentationml.slide": ["sldx"], "application/vnd.openxmlformats-officedocument.presentationml.slideshow": ["ppsx"], "application/vnd.openxmlformats-officedocument.presentationml.template": ["potx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": ["xlsx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.template": ["xltx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.document": ["docx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.template": ["dotx"], "application/vnd.osgeo.mapguide.package": ["mgp"], "application/vnd.osgi.dp": ["dp"], "application/vnd.osgi.subsystem": ["esa"], "application/vnd.palm": ["pdb", "pqa", "oprc"], "application/vnd.pawaafile": ["paw"], "application/vnd.pg.format": ["str"], "application/vnd.pg.osasli": ["ei6"], "application/vnd.picsel": ["efif"], "application/vnd.pmi.widget": ["wg"], "application/vnd.pocketlearn": ["plf"], "application/vnd.powerbuilder6": ["pbd"], "application/vnd.previewsystems.box": ["box"], "application/vnd.proteus.magazine": ["mgz"], "application/vnd.publishare-delta-tree": ["qps"], "application/vnd.pvi.ptid1": ["ptid"], "application/vnd.quark.quarkxpress": ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"], "application/vnd.rar": ["rar"], "application/vnd.realvnc.bed": ["bed"], "application/vnd.recordare.musicxml": ["mxl"], "application/vnd.recordare.musicxml+xml": ["musicxml"], "application/vnd.rig.cryptonote": ["cryptonote"], "application/vnd.rim.cod": ["cod"], "application/vnd.rn-realmedia": ["rm"], "application/vnd.rn-realmedia-vbr": ["rmvb"], "application/vnd.route66.link66+xml": ["link66"], "application/vnd.sailingtracker.track": ["st"], "application/vnd.seemail": ["see"], "application/vnd.sema": ["sema"], "application/vnd.semd": ["semd"], "application/vnd.semf": ["semf"], "application/vnd.shana.informed.formdata": ["ifm"], "application/vnd.shana.informed.formtemplate": ["itp"], "application/vnd.shana.informed.interchange": ["iif"], "application/vnd.shana.informed.package": ["ipk"], "application/vnd.simtech-mindmapper": ["twd", "twds"], "application/vnd.smaf": ["mmf"], "application/vnd.smart.teacher": ["teacher"], "application/vnd.software602.filler.form+xml": ["fo"], "application/vnd.solent.sdkm+xml": ["sdkm", "sdkd"], "application/vnd.spotfire.dxp": ["dxp"], "application/vnd.spotfire.sfs": ["sfs"], "application/vnd.stardivision.calc": ["sdc"], "application/vnd.stardivision.draw": ["sda"], "application/vnd.stardivision.impress": ["sdd"], "application/vnd.stardivision.math": ["smf"], "application/vnd.stardivision.writer": ["sdw", "vor"], "application/vnd.stardivision.writer-global": ["sgl"], "application/vnd.stepmania.package": ["smzip"], "application/vnd.stepmania.stepchart": ["sm"], "application/vnd.sun.wadl+xml": ["wadl"], "application/vnd.sun.xml.calc": ["sxc"], "application/vnd.sun.xml.calc.template": ["stc"], "application/vnd.sun.xml.draw": ["sxd"], "application/vnd.sun.xml.draw.template": ["std"], "application/vnd.sun.xml.impress": ["sxi"], "application/vnd.sun.xml.impress.template": ["sti"], "application/vnd.sun.xml.math": ["sxm"], "application/vnd.sun.xml.writer": ["sxw"], "application/vnd.sun.xml.writer.global": ["sxg"], "application/vnd.sun.xml.writer.template": ["stw"], "application/vnd.sus-calendar": ["sus", "susp"], "application/vnd.svd": ["svd"], "application/vnd.symbian.install": ["sis", "sisx"], "application/vnd.syncml+xml": ["xsm"], "application/vnd.syncml.dm+wbxml": ["bdm"], "application/vnd.syncml.dm+xml": ["xdm"], "application/vnd.syncml.dmddf+xml": ["ddf"], "application/vnd.tao.intent-module-archive": ["tao"], "application/vnd.tcpdump.pcap": ["pcap", "cap", "dmp"], "application/vnd.tmobile-livetv": ["tmo"], "application/vnd.trid.tpt": ["tpt"], "application/vnd.triscape.mxs": ["mxs"], "application/vnd.trueapp": ["tra"], "application/vnd.ufdl": ["ufd", "ufdl"], "application/vnd.uiq.theme": ["utz"], "application/vnd.umajin": ["umj"], "application/vnd.unity": ["unityweb"], "application/vnd.uoml+xml": ["uoml"], "application/vnd.vcx": ["vcx"], "application/vnd.visio": ["vsd", "vst", "vss", "vsw"], "application/vnd.visionary": ["vis"], "application/vnd.vsf": ["vsf"], "application/vnd.wap.wbxml": ["wbxml"], "application/vnd.wap.wmlc": ["wmlc"], "application/vnd.wap.wmlscriptc": ["wmlsc"], "application/vnd.webturbo": ["wtb"], "application/vnd.wolfram.player": ["nbp"], "application/vnd.wordperfect": ["wpd"], "application/vnd.wqd": ["wqd"], "application/vnd.wt.stf": ["stf"], "application/vnd.xara": ["xar"], "application/vnd.xfdl": ["xfdl"], "application/vnd.yamaha.hv-dic": ["hvd"], "application/vnd.yamaha.hv-script": ["hvs"], "application/vnd.yamaha.hv-voice": ["hvp"], "application/vnd.yamaha.openscoreformat": ["osf"], "application/vnd.yamaha.openscoreformat.osfpvg+xml": ["osfpvg"], "application/vnd.yamaha.smaf-audio": ["saf"], "application/vnd.yamaha.smaf-phrase": ["spf"], "application/vnd.yellowriver-custom-menu": ["cmp"], "application/vnd.zul": ["zir", "zirz"], "application/vnd.zzazz.deck+xml": ["zaz"], "application/x-7z-compressed": ["7z"], "application/x-abiword": ["abw"], "application/x-ace-compressed": ["ace"], "application/x-apple-diskimage": ["*dmg"], "application/x-arj": ["arj"], "application/x-authorware-bin": ["aab", "x32", "u32", "vox"], "application/x-authorware-map": ["aam"], "application/x-authorware-seg": ["aas"], "application/x-bcpio": ["bcpio"], "application/x-bdoc": ["*bdoc"], "application/x-bittorrent": ["torrent"], "application/x-blorb": ["blb", "blorb"], "application/x-bzip": ["bz"], "application/x-bzip2": ["bz2", "boz"], "application/x-cbr": ["cbr", "cba", "cbt", "cbz", "cb7"], "application/x-cdlink": ["vcd"], "application/x-cfs-compressed": ["cfs"], "application/x-chat": ["chat"], "application/x-chess-pgn": ["pgn"], "application/x-chrome-extension": ["crx"], "application/x-cocoa": ["cco"], "application/x-conference": ["nsc"], "application/x-cpio": ["cpio"], "application/x-csh": ["csh"], "application/x-debian-package": ["*deb", "udeb"], "application/x-dgc-compressed": ["dgc"], "application/x-director": ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"], "application/x-doom": ["wad"], "application/x-dtbncx+xml": ["ncx"], "application/x-dtbook+xml": ["dtb"], "application/x-dtbresource+xml": ["res"], "application/x-dvi": ["dvi"], "application/x-envoy": ["evy"], "application/x-eva": ["eva"], "application/x-font-bdf": ["bdf"], "application/x-font-ghostscript": ["gsf"], "application/x-font-linux-psf": ["psf"], "application/x-font-pcf": ["pcf"], "application/x-font-snf": ["snf"], "application/x-font-type1": ["pfa", "pfb", "pfm", "afm"], "application/x-freearc": ["arc"], "application/x-futuresplash": ["spl"], "application/x-gca-compressed": ["gca"], "application/x-glulx": ["ulx"], "application/x-gnumeric": ["gnumeric"], "application/x-gramps-xml": ["gramps"], "application/x-gtar": ["gtar"], "application/x-hdf": ["hdf"], "application/x-httpd-php": ["php"], "application/x-install-instructions": ["install"], "application/x-iso9660-image": ["*iso"], "application/x-iwork-keynote-sffkey": ["*key"], "application/x-iwork-numbers-sffnumbers": ["*numbers"], "application/x-iwork-pages-sffpages": ["*pages"], "application/x-java-archive-diff": ["jardiff"], "application/x-java-jnlp-file": ["jnlp"], "application/x-keepass2": ["kdbx"], "application/x-latex": ["latex"], "application/x-lua-bytecode": ["luac"], "application/x-lzh-compressed": ["lzh", "lha"], "application/x-makeself": ["run"], "application/x-mie": ["mie"], "application/x-mobipocket-ebook": ["prc", "mobi"], "application/x-ms-application": ["application"], "application/x-ms-shortcut": ["lnk"], "application/x-ms-wmd": ["wmd"], "application/x-ms-wmz": ["wmz"], "application/x-ms-xbap": ["xbap"], "application/x-msaccess": ["mdb"], "application/x-msbinder": ["obd"], "application/x-mscardfile": ["crd"], "application/x-msclip": ["clp"], "application/x-msdos-program": ["*exe"], "application/x-msdownload": ["*exe", "*dll", "com", "bat", "*msi"], "application/x-msmediaview": ["mvb", "m13", "m14"], "application/x-msmetafile": ["*wmf", "*wmz", "*emf", "emz"], "application/x-msmoney": ["mny"], "application/x-mspublisher": ["pub"], "application/x-msschedule": ["scd"], "application/x-msterminal": ["trm"], "application/x-mswrite": ["wri"], "application/x-netcdf": ["nc", "cdf"], "application/x-ns-proxy-autoconfig": ["pac"], "application/x-nzb": ["nzb"], "application/x-perl": ["pl", "pm"], "application/x-pilot": ["*prc", "*pdb"], "application/x-pkcs12": ["p12", "pfx"], "application/x-pkcs7-certificates": ["p7b", "spc"], "application/x-pkcs7-certreqresp": ["p7r"], "application/x-rar-compressed": ["*rar"], "application/x-redhat-package-manager": ["rpm"], "application/x-research-info-systems": ["ris"], "application/x-sea": ["sea"], "application/x-sh": ["sh"], "application/x-shar": ["shar"], "application/x-shockwave-flash": ["swf"], "application/x-silverlight-app": ["xap"], "application/x-sql": ["sql"], "application/x-stuffit": ["sit"], "application/x-stuffitx": ["sitx"], "application/x-subrip": ["srt"], "application/x-sv4cpio": ["sv4cpio"], "application/x-sv4crc": ["sv4crc"], "application/x-t3vm-image": ["t3"], "application/x-tads": ["gam"], "application/x-tar": ["tar"], "application/x-tcl": ["tcl", "tk"], "application/x-tex": ["tex"], "application/x-tex-tfm": ["tfm"], "application/x-texinfo": ["texinfo", "texi"], "application/x-tgif": ["*obj"], "application/x-ustar": ["ustar"], "application/x-virtualbox-hdd": ["hdd"], "application/x-virtualbox-ova": ["ova"], "application/x-virtualbox-ovf": ["ovf"], "application/x-virtualbox-vbox": ["vbox"], "application/x-virtualbox-vbox-extpack": ["vbox-extpack"], "application/x-virtualbox-vdi": ["vdi"], "application/x-virtualbox-vhd": ["vhd"], "application/x-virtualbox-vmdk": ["vmdk"], "application/x-wais-source": ["src"], "application/x-web-app-manifest+json": ["webapp"], "application/x-x509-ca-cert": ["der", "crt", "pem"], "application/x-xfig": ["fig"], "application/x-xliff+xml": ["*xlf"], "application/x-xpinstall": ["xpi"], "application/x-xz": ["xz"], "application/x-zmachine": ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"], "audio/vnd.dece.audio": ["uva", "uvva"], "audio/vnd.digital-winds": ["eol"], "audio/vnd.dra": ["dra"], "audio/vnd.dts": ["dts"], "audio/vnd.dts.hd": ["dtshd"], "audio/vnd.lucent.voice": ["lvp"], "audio/vnd.ms-playready.media.pya": ["pya"], "audio/vnd.nuera.ecelp4800": ["ecelp4800"], "audio/vnd.nuera.ecelp7470": ["ecelp7470"], "audio/vnd.nuera.ecelp9600": ["ecelp9600"], "audio/vnd.rip": ["rip"], "audio/x-aac": ["aac"], "audio/x-aiff": ["aif", "aiff", "aifc"], "audio/x-caf": ["caf"], "audio/x-flac": ["flac"], "audio/x-m4a": ["*m4a"], "audio/x-matroska": ["mka"], "audio/x-mpegurl": ["m3u"], "audio/x-ms-wax": ["wax"], "audio/x-ms-wma": ["wma"], "audio/x-pn-realaudio": ["ram", "ra"], "audio/x-pn-realaudio-plugin": ["rmp"], "audio/x-realaudio": ["*ra"], "audio/x-wav": ["*wav"], "chemical/x-cdx": ["cdx"], "chemical/x-cif": ["cif"], "chemical/x-cmdf": ["cmdf"], "chemical/x-cml": ["cml"], "chemical/x-csml": ["csml"], "chemical/x-xyz": ["xyz"], "image/prs.btif": ["btif"], "image/prs.pti": ["pti"], "image/vnd.adobe.photoshop": ["psd"], "image/vnd.airzip.accelerator.azv": ["azv"], "image/vnd.dece.graphic": ["uvi", "uvvi", "uvg", "uvvg"], "image/vnd.djvu": ["djvu", "djv"], "image/vnd.dvb.subtitle": ["*sub"], "image/vnd.dwg": ["dwg"], "image/vnd.dxf": ["dxf"], "image/vnd.fastbidsheet": ["fbs"], "image/vnd.fpx": ["fpx"], "image/vnd.fst": ["fst"], "image/vnd.fujixerox.edmics-mmr": ["mmr"], "image/vnd.fujixerox.edmics-rlc": ["rlc"], "image/vnd.microsoft.icon": ["ico"], "image/vnd.ms-dds": ["dds"], "image/vnd.ms-modi": ["mdi"], "image/vnd.ms-photo": ["wdp"], "image/vnd.net-fpx": ["npx"], "image/vnd.pco.b16": ["b16"], "image/vnd.tencent.tap": ["tap"], "image/vnd.valve.source.texture": ["vtf"], "image/vnd.wap.wbmp": ["wbmp"], "image/vnd.xiff": ["xif"], "image/vnd.zbrush.pcx": ["pcx"], "image/x-3ds": ["3ds"], "image/x-cmu-raster": ["ras"], "image/x-cmx": ["cmx"], "image/x-freehand": ["fh", "fhc", "fh4", "fh5", "fh7"], "image/x-icon": ["*ico"], "image/x-jng": ["jng"], "image/x-mrsid-image": ["sid"], "image/x-ms-bmp": ["*bmp"], "image/x-pcx": ["*pcx"], "image/x-pict": ["pic", "pct"], "image/x-portable-anymap": ["pnm"], "image/x-portable-bitmap": ["pbm"], "image/x-portable-graymap": ["pgm"], "image/x-portable-pixmap": ["ppm"], "image/x-rgb": ["rgb"], "image/x-tga": ["tga"], "image/x-xbitmap": ["xbm"], "image/x-xpixmap": ["xpm"], "image/x-xwindowdump": ["xwd"], "message/vnd.wfa.wsc": ["wsc"], "model/vnd.collada+xml": ["dae"], "model/vnd.dwf": ["dwf"], "model/vnd.gdl": ["gdl"], "model/vnd.gtw": ["gtw"], "model/vnd.mts": ["mts"], "model/vnd.opengex": ["ogex"], "model/vnd.parasolid.transmit.binary": ["x_b"], "model/vnd.parasolid.transmit.text": ["x_t"], "model/vnd.sap.vds": ["vds"], "model/vnd.usdz+zip": ["usdz"], "model/vnd.valve.source.compiled-map": ["bsp"], "model/vnd.vtu": ["vtu"], "text/prs.lines.tag": ["dsc"], "text/vnd.curl": ["curl"], "text/vnd.curl.dcurl": ["dcurl"], "text/vnd.curl.mcurl": ["mcurl"], "text/vnd.curl.scurl": ["scurl"], "text/vnd.dvb.subtitle": ["sub"], "text/vnd.fly": ["fly"], "text/vnd.fmi.flexstor": ["flx"], "text/vnd.graphviz": ["gv"], "text/vnd.in3d.3dml": ["3dml"], "text/vnd.in3d.spot": ["spot"], "text/vnd.sun.j2me.app-descriptor": ["jad"], "text/vnd.wap.wml": ["wml"], "text/vnd.wap.wmlscript": ["wmls"], "text/x-asm": ["s", "asm"], "text/x-c": ["c", "cc", "cxx", "cpp", "h", "hh", "dic"], "text/x-component": ["htc"], "text/x-fortran": ["f", "for", "f77", "f90"], "text/x-handlebars-template": ["hbs"], "text/x-java-source": ["java"], "text/x-lua": ["lua"], "text/x-markdown": ["mkd"], "text/x-nfo": ["nfo"], "text/x-opml": ["opml"], "text/x-org": ["*org"], "text/x-pascal": ["p", "pas"], "text/x-processing": ["pde"], "text/x-sass": ["sass"], "text/x-scss": ["scss"], "text/x-setext": ["etx"], "text/x-sfv": ["sfv"], "text/x-suse-ymp": ["ymp"], "text/x-uuencode": ["uu"], "text/x-vcalendar": ["vcs"], "text/x-vcard": ["vcf"], "video/vnd.dece.hd": ["uvh", "uvvh"], "video/vnd.dece.mobile": ["uvm", "uvvm"], "video/vnd.dece.pd": ["uvp", "uvvp"], "video/vnd.dece.sd": ["uvs", "uvvs"], "video/vnd.dece.video": ["uvv", "uvvv"], "video/vnd.dvb.file": ["dvb"], "video/vnd.fvt": ["fvt"], "video/vnd.mpegurl": ["mxu", "m4u"], "video/vnd.ms-playready.media.pyv": ["pyv"], "video/vnd.uvvu.mp4": ["uvu", "uvvu"], "video/vnd.vivo": ["viv"], "video/x-f4v": ["f4v"], "video/x-fli": ["fli"], "video/x-flv": ["flv"], "video/x-m4v": ["m4v"], "video/x-matroska": ["mkv", "mk3d", "mks"], "video/x-mng": ["mng"], "video/x-ms-asf": ["asf", "asx"], "video/x-ms-vob": ["vob"], "video/x-ms-wm": ["wm"], "video/x-ms-wmv": ["wmv"], "video/x-ms-wmx": ["wmx"], "video/x-ms-wvx": ["wvx"], "video/x-msvideo": ["avi"], "video/x-sgi-movie": ["movie"], "video/x-smv": ["smv"], "x-conference/x-cooltalk": ["ice"] };
let gT = hT;
var Y0 = new gT(mT, yT), fm = 12, bT = 0, Fc = [
  // The first part of the table maps bytes to character to a transition.
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  4,
  4,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  6,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  8,
  7,
  7,
  10,
  9,
  9,
  9,
  11,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  // The second part of the table maps a state to a new state when adding a
  // transition.
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  12,
  0,
  0,
  0,
  0,
  24,
  36,
  48,
  60,
  72,
  84,
  96,
  0,
  12,
  12,
  12,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  24,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  24,
  24,
  24,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  24,
  24,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  48,
  48,
  48,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  48,
  48,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  48,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  // The third part maps the current transition to a mask that needs to apply
  // to the byte.
  127,
  63,
  63,
  63,
  0,
  31,
  15,
  15,
  15,
  7,
  7,
  7
];
function vT(e) {
  var t = e.indexOf("%");
  if (t === -1)
    return e;
  for (var n = e.length, r = "", i = 0, s = 0, o = t, a = fm; t > -1 && t < n; ) {
    var l = dm(e[t + 1], 4), c = dm(e[t + 2], 0), u = l | c, f = Fc[u];
    if (a = Fc[256 + a + f], s = s << 6 | u & Fc[364 + f], a === fm)
      r += e.slice(i, o), r += s <= 65535 ? String.fromCharCode(s) : String.fromCharCode(
        55232 + (s >> 10),
        56320 + (s & 1023)
      ), s = 0, i = t + 3, t = o = e.indexOf("%", i);
    else {
      if (a === bT)
        return null;
      if (t += 3, t < n && e.charCodeAt(t) === 37)
        continue;
      return null;
    }
  }
  return r + e.slice(i);
}
var _T = {
  0: 0,
  1: 1,
  2: 2,
  3: 3,
  4: 4,
  5: 5,
  6: 6,
  7: 7,
  8: 8,
  9: 9,
  a: 10,
  A: 10,
  b: 11,
  B: 11,
  c: 12,
  C: 12,
  d: 13,
  D: 13,
  e: 14,
  E: 14,
  f: 15,
  F: 15
};
function dm(e, t) {
  var n = _T[e];
  return n === void 0 ? 255 : n << t;
}
var wT = vT;
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */
var ET = /["'&<>]/, ST = TT;
function TT(e) {
  var t = "" + e, n = ET.exec(t);
  if (!n)
    return t;
  var r, i = "", s = 0, o = 0;
  for (s = n.index; s < t.length; s++) {
    switch (t.charCodeAt(s)) {
      case 34:
        r = "&quot;";
        break;
      case 38:
        r = "&amp;";
        break;
      case 39:
        r = "&#39;";
        break;
      case 60:
        r = "&lt;";
        break;
      case 62:
        r = "&gt;";
        break;
      default:
        continue;
    }
    o !== s && (i += t.substring(o, s)), o = s + 1, i += r;
  }
  return o !== s ? i + t.substring(o, s) : i;
}
var Ud = {}, $T = /^(-?(?:\d+)?\.?\d+) *(m(?:illiseconds?|s(?:ecs?)?))?(s(?:ec(?:onds?|s)?)?)?(m(?:in(?:utes?|s)?)?)?(h(?:ours?|rs?)?)?(d(?:ays?)?)?(w(?:eeks?|ks?)?)?(y(?:ears?|rs?)?)?$/, Dl = 1e3, Pl = Dl * 60, kl = Pl * 60, qo = kl * 24, Mf = qo * 365.25;
function NT(e) {
  var t, n = e.toLowerCase().match($T);
  if (n != null && (t = parseFloat(n[1])))
    return n[3] != null ? t * Dl : n[4] != null ? t * Pl : n[5] != null ? t * kl : n[6] != null ? t * qo : n[7] != null ? t * qo * 7 : n[8] != null ? t * Mf : t;
}
function ao(e, t, n, r) {
  var i = (e | 0) === e ? e : ~~(e + 0.5);
  return t + i + (r ? " " + n + (i != 1 ? "s" : "") : n[0]);
}
function OT(e, t) {
  var n = e < 0 ? "-" : "", r = e < 0 ? -e : e;
  return r < Dl ? e + (t ? " ms" : "ms") : r < Pl ? ao(r / Dl, n, "second", t) : r < kl ? ao(r / Pl, n, "minute", t) : r < qo ? ao(r / kl, n, "hour", t) : r < Mf ? ao(r / qo, n, "day", t) : ao(r / Mf, n, "year", t);
}
Ud.format = OT;
Ud.parse = NT;
var X0 = {};
/*!
 * send
 * Copyright(c) 2012 TJ Holowaychuk
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
function IT(e) {
  const t = e.getHeaderNames();
  for (let n = 0; n < t.length; n++)
    e.removeHeader(t[n]);
}
X0.clearHeaders = IT;
var Z0 = {};
function RT(e) {
  if (e[0] !== "/" || e[1] !== "/")
    return e;
  for (let t = 2, n = e.length; t < n; ++t)
    if (e[t] !== "/")
      return e.slice(t - 1);
}
Z0.collapseLeadingSlashes = RT;
var eb = {};
/*!
 * send
 * Copyright(c) 2012 TJ Holowaychuk
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
function AT(e) {
  for (let t = 0, n = e.length; t < n; ++t)
    if (e[t].length !== 1 && e[t][0] === ".")
      return !0;
  return !1;
}
eb.containsDotFile = AT;
var tb = {};
/*!
 * send
 * Copyright(c) 2012 TJ Holowaychuk
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
function xT(e, t, n) {
  return e + " " + (n ? n.start + "-" + n.end : "*") + "/" + t;
}
tb.contentRange = xT;
var nb = {};
/*!
 * send
 * Copyright(c) 2012 TJ Holowaychuk
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
function DT(e, t) {
  const n = `<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>` + e + `</title>
</head>
<body>
<pre>` + t + `</pre>
</body>
</html>
`;
  return [n, Buffer.byteLength(n)];
}
nb.createHtmlDocument = DT;
var rb = {}, ib = { exports: {} };
/*!
 * depd
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var PT = kT;
function kT(e) {
  if (!e)
    throw new TypeError("argument namespace is required");
  function t(n) {
  }
  return t._file = void 0, t._ignored = !0, t._namespace = e, t._traced = !1, t._warned = /* @__PURE__ */ Object.create(null), t.function = LT, t.property = jT, t;
}
function LT(e, t) {
  if (typeof e != "function")
    throw new TypeError("argument fn must be a function");
  return e;
}
function jT(e, t, n) {
  if (!e || typeof e != "object" && typeof e != "function")
    throw new TypeError("argument obj must be object");
  var r = Object.getOwnPropertyDescriptor(e, t);
  if (!r)
    throw new TypeError("must call property on owner object");
  if (!r.configurable)
    throw new TypeError("property must be configurable");
}
var CT = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? MT : FT);
function MT(e, t) {
  return e.__proto__ = t, e;
}
function FT(e, t) {
  for (var n in t)
    Object.prototype.hasOwnProperty.call(e, n) || (e[n] = t[n]);
  return e;
}
const UT = {
  100: "Continue",
  101: "Switching Protocols",
  102: "Processing",
  103: "Early Hints",
  200: "OK",
  201: "Created",
  202: "Accepted",
  203: "Non-Authoritative Information",
  204: "No Content",
  205: "Reset Content",
  206: "Partial Content",
  207: "Multi-Status",
  208: "Already Reported",
  226: "IM Used",
  300: "Multiple Choices",
  301: "Moved Permanently",
  302: "Found",
  303: "See Other",
  304: "Not Modified",
  305: "Use Proxy",
  307: "Temporary Redirect",
  308: "Permanent Redirect",
  400: "Bad Request",
  401: "Unauthorized",
  402: "Payment Required",
  403: "Forbidden",
  404: "Not Found",
  405: "Method Not Allowed",
  406: "Not Acceptable",
  407: "Proxy Authentication Required",
  408: "Request Timeout",
  409: "Conflict",
  410: "Gone",
  411: "Length Required",
  412: "Precondition Failed",
  413: "Payload Too Large",
  414: "URI Too Long",
  415: "Unsupported Media Type",
  416: "Range Not Satisfiable",
  417: "Expectation Failed",
  418: "I'm a Teapot",
  421: "Misdirected Request",
  422: "Unprocessable Entity",
  423: "Locked",
  424: "Failed Dependency",
  425: "Too Early",
  426: "Upgrade Required",
  428: "Precondition Required",
  429: "Too Many Requests",
  431: "Request Header Fields Too Large",
  451: "Unavailable For Legal Reasons",
  500: "Internal Server Error",
  501: "Not Implemented",
  502: "Bad Gateway",
  503: "Service Unavailable",
  504: "Gateway Timeout",
  505: "HTTP Version Not Supported",
  506: "Variant Also Negotiates",
  507: "Insufficient Storage",
  508: "Loop Detected",
  509: "Bandwidth Limit Exceeded",
  510: "Not Extended",
  511: "Network Authentication Required"
};
/*!
 * statuses
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var Vd = UT, VT = Xn;
Xn.message = Vd;
Xn.code = BT(Vd);
Xn.codes = GT(Vd);
Xn.redirect = {
  300: !0,
  301: !0,
  302: !0,
  303: !0,
  305: !0,
  307: !0,
  308: !0
};
Xn.empty = {
  204: !0,
  205: !0,
  304: !0
};
Xn.retry = {
  502: !0,
  503: !0,
  504: !0
};
function BT(e) {
  var t = {};
  return Object.keys(e).forEach(function(r) {
    var i = e[r], s = Number(r);
    t[i.toLowerCase()] = s;
  }), t;
}
function GT(e) {
  return Object.keys(e).map(function(n) {
    return Number(n);
  });
}
function zT(e) {
  var t = e.toLowerCase();
  if (!Object.prototype.hasOwnProperty.call(Xn.code, t))
    throw new Error('invalid status message: "' + e + '"');
  return Xn.code[t];
}
function pm(e) {
  if (!Object.prototype.hasOwnProperty.call(Xn.message, e))
    throw new Error("invalid status code: " + e);
  return Xn.message[e];
}
function Xn(e) {
  if (typeof e == "number")
    return pm(e);
  if (typeof e != "string")
    throw new TypeError("code must be a number or string");
  var t = parseInt(e, 10);
  return isNaN(t) ? zT(e) : pm(t);
}
var Ff = { exports: {} };
typeof Object.create == "function" ? Ff.exports = function(t, n) {
  n && (t.super_ = n, t.prototype = Object.create(n.prototype, {
    constructor: {
      value: t,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }));
} : Ff.exports = function(t, n) {
  if (n) {
    t.super_ = n;
    var r = function() {
    };
    r.prototype = n.prototype, t.prototype = new r(), t.prototype.constructor = t;
  }
};
var Qi = Ff.exports;
/*!
 * toidentifier
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var qT = HT;
function HT(e) {
  return e.split(" ").map(function(t) {
    return t.slice(0, 1).toUpperCase() + t.slice(1);
  }).join("").replace(/[^ _0-9a-z]/gi, "");
}
/*!
 * http-errors
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
(function(e) {
  PT("http-errors");
  var t = CT, n = VT, r = Qi, i = qT;
  e.exports = o, e.exports.HttpError = a(), e.exports.isHttpError = c(e.exports.HttpError), d(e.exports, n.codes, e.exports.HttpError);
  function s(h) {
    return +(String(h).charAt(0) + "00");
  }
  function o() {
    for (var h, m, v = 500, b = {}, E = 0; E < arguments.length; E++) {
      var y = arguments[E], D = typeof y;
      if (D === "object" && y instanceof Error)
        h = y, v = h.status || h.statusCode || v;
      else if (D === "number" && E === 0)
        v = y;
      else if (D === "string")
        m = y;
      else if (D === "object")
        b = y;
      else
        throw new TypeError("argument #" + (E + 1) + " unsupported type " + D);
    }
    (typeof v != "number" || !n.message[v] && (v < 400 || v >= 600)) && (v = 500);
    var F = o[v] || o[s(v)];
    h || (h = F ? new F(m) : new Error(m || n.message[v]), Error.captureStackTrace(h, o)), (!F || !(h instanceof F) || h.status !== v) && (h.expose = v < 500, h.status = h.statusCode = v);
    for (var W in b)
      W !== "status" && W !== "statusCode" && (h[W] = b[W]);
    return h;
  }
  function a() {
    function h() {
      throw new TypeError("cannot construct abstract class");
    }
    return r(h, Error), h;
  }
  function l(h, m, v) {
    var b = p(m);
    function E(y) {
      var D = y ?? n.message[v], F = new Error(D);
      return Error.captureStackTrace(F, E), t(F, E.prototype), Object.defineProperty(F, "message", {
        enumerable: !0,
        configurable: !0,
        value: D,
        writable: !0
      }), Object.defineProperty(F, "name", {
        enumerable: !1,
        configurable: !0,
        value: b,
        writable: !0
      }), F;
    }
    return r(E, h), f(E, b), E.prototype.status = v, E.prototype.statusCode = v, E.prototype.expose = !0, E;
  }
  function c(h) {
    return function(v) {
      return !v || typeof v != "object" ? !1 : v instanceof h ? !0 : v instanceof Error && typeof v.expose == "boolean" && typeof v.statusCode == "number" && v.status === v.statusCode;
    };
  }
  function u(h, m, v) {
    var b = p(m);
    function E(y) {
      var D = y ?? n.message[v], F = new Error(D);
      return Error.captureStackTrace(F, E), t(F, E.prototype), Object.defineProperty(F, "message", {
        enumerable: !0,
        configurable: !0,
        value: D,
        writable: !0
      }), Object.defineProperty(F, "name", {
        enumerable: !1,
        configurable: !0,
        value: b,
        writable: !0
      }), F;
    }
    return r(E, h), f(E, b), E.prototype.status = v, E.prototype.statusCode = v, E.prototype.expose = !1, E;
  }
  function f(h, m) {
    var v = Object.getOwnPropertyDescriptor(h, "name");
    v && v.configurable && (v.value = m, Object.defineProperty(h, "name", v));
  }
  function d(h, m, v) {
    m.forEach(function(E) {
      var y, D = i(n.message[E]);
      switch (s(E)) {
        case 400:
          y = l(v, D, E);
          break;
        case 500:
          y = u(v, D, E);
          break;
      }
      y && (h[E] = y, h[D] = y);
    });
  }
  function p(h) {
    return h.substr(-5) !== "Error" ? h + "Error" : h;
  }
})(ib);
var WT = ib.exports;
const Uc = WT;
function QT(e, t) {
  return t ? t instanceof Error ? Uc(e, t, { expose: !1 }) : Uc(e, t) : Uc(e);
}
rb.createHttpError = QT;
var sb = {};
function JT(e, t) {
  if (typeof e == "string")
    return [e];
  if (e === !1)
    return [];
  if (Array.isArray(e)) {
    for (let n = 0, r = e.length; n < r; ++n)
      if (typeof e[n] != "string")
        throw new TypeError(t + " must be array of strings or false");
    return e;
  } else
    throw new TypeError(t + " must be array of strings or false");
}
sb.normalizeList = JT;
var ob = {};
/*!
 * Based on range-parser
 *
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015-2016 Douglas Christopher Wilson
 * MIT Licensed
 */
function KT(e, t) {
  const n = t.slice(t.indexOf("=") + 1), r = [], i = n.length;
  let s = 0, o = 0, a = 0, l, c, u = n.indexOf(","), f = n.indexOf("-"), d = -1;
  for (; u === -1 && (u = i), l = parseInt(n.slice(d + 1, f), 10), c = parseInt(n.slice(f + 1, u), 10), l !== l ? (l = e - c, c = e - 1) : (c !== c || c > e - 1) && (c = e - 1), // eslint-disable-next-line no-self-compare
  l === l && // fast path of isNaN(number)
  // eslint-disable-next-line no-self-compare
  c === c && // fast path of isNaN(number)
  l > -1 && l <= c && r.push({
    start: l,
    end: c,
    index: a++
  }), u !== i; )
    d = u++, f = n.indexOf("-", u), u = n.indexOf(",", u);
  if (a < 2)
    return r;
  for (r.sort(XT), o = a, a = 0, s = 1; s < o; ) {
    const p = r[s++], h = r[a];
    p.start > h.end + 1 ? r[++a] = p : p.end > h.end && (h.end = p.end, h.index > p.index && (h.index = p.index));
  }
  return r.length = a + 1, r.sort(YT), r;
}
function YT(e, t) {
  return e.index - t.index;
}
function XT(e, t) {
  return e.start - t.start;
}
ob.parseBytesRange = KT;
var ab = {};
const hm = String.prototype.slice;
function ZT(e, t) {
  let n = 0, r = 0, i;
  for (let s = 0, o = e.length; s < o; s++)
    switch (e.charCodeAt(s)) {
      case 32:
        r === n && (r = n = s + 1);
        break;
      case 44:
        if (r !== n && (i = t(hm.call(e, r, n)), i !== void 0))
          return i;
        r = n = s + 1;
        break;
      default:
        n = s + 1;
        break;
    }
  if (r !== n)
    return t(hm.call(e, r, n));
}
ab.parseTokenList = ZT;
var lb = {};
function e$(e, t) {
  const n = Object.keys(t);
  for (let r = 0; r < n.length; r++) {
    const i = n[r];
    e.setHeader(i, t[i]);
  }
}
lb.setHeaders = e$;
/*!
 * send
 * Copyright(c) 2012 TJ Holowaychuk
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
const Ll = at, fa = at, ub = at, t$ = at, At = at.debuglog("send"), n$ = wT, mm = ST, ym = Y0, r$ = Ud, { clearHeaders: i$ } = X0, { collapseLeadingSlashes: s$ } = Z0, { containsDotFile: o$ } = eb, { contentRange: gm } = tb, { createHtmlDocument: Ai } = nb, { createHttpError: a$ } = rb, { isUtf8MimeType: l$ } = Fd, { normalizeList: bm } = sb, { parseBytesRange: u$ } = ob, { parseTokenList: cb } = ab, { setHeaders: c$ } = lb, f$ = fa.extname, fb = fa.join, Vc = fa.normalize, Bd = fa.resolve, fl = fa.sep, d$ = /^ *bytes=/, p$ = 60 * 60 * 24 * 365 * 1e3, vm = /(?:^|[\\/])\.\.(?:[\\/]|$)/, h$ = {
  400: Ai("Error", "Bad Request"),
  403: Ai("Error", "Forbidden"),
  404: Ai("Error", "Not Found"),
  412: Ai("Error", "Precondition Failed"),
  416: Ai("Error", "Range Not Satisfiable"),
  500: Ai("Error", "Internal Server Error")
}, m$ = [
  "allow",
  "ignore",
  "deny"
];
function It(e, t, n) {
  if (!new.target)
    return new It(e, t, n);
  ub.call(this);
  const r = n || {};
  if (this.options = r, this.path = t, this.req = e, this._acceptRanges = r.acceptRanges !== void 0 ? !!r.acceptRanges : !0, this._cacheControl = r.cacheControl !== void 0 ? !!r.cacheControl : !0, this._etag = r.etag !== void 0 ? !!r.etag : !0, this._dotfiles = r.dotfiles !== void 0 ? m$.indexOf(r.dotfiles) : 1, this._dotfiles === -1)
    throw new TypeError('dotfiles option must be "allow", "deny", or "ignore"');
  this._extensions = r.extensions !== void 0 ? bm(r.extensions, "extensions option") : [], this._immutable = r.immutable !== void 0 ? !!r.immutable : !1, this._index = r.index !== void 0 ? bm(r.index, "index option") : ["index.html"], this._lastModified = r.lastModified !== void 0 ? !!r.lastModified : !0, this._maxage = r.maxAge || r.maxage, this._maxage = typeof this._maxage == "string" ? r$.parse(this._maxage) : Number(this._maxage), this._maxage = this._maxage === this._maxage ? Math.min(Math.max(0, this._maxage), p$) : 0, this._root = r.root ? Bd(r.root) : null;
}
t$.inherits(It, ub);
It.prototype.root = function(t) {
  return this._root = Bd(String(t)), At("root %s", this._root), this;
};
It.prototype.error = function(t, n) {
  if (this.listenerCount("error") > 0)
    return this.emit("error", a$(t, n));
  const r = this.res;
  i$(r), n && n.headers && c$(r, n.headers);
  const i = h$[t];
  r.statusCode = t, r.setHeader("Content-Type", "text/html; charset=UTF-8"), r.setHeader("Content-Length", i[1]), r.setHeader("Content-Security-Policy", "default-src 'none'"), r.setHeader("X-Content-Type-Options", "nosniff"), r.end(i[0]);
};
It.prototype.hasTrailingSlash = function() {
  return this.path[this.path.length - 1] === "/";
};
It.prototype.isConditionalGET = function() {
  return this.req.headers["if-match"] || this.req.headers["if-unmodified-since"] || this.req.headers["if-none-match"] || this.req.headers["if-modified-since"];
};
It.prototype.isNotModifiedFailure = function() {
  const t = this.req, n = this.res;
  if ("cache-control" in t.headers && t.headers["cache-control"].indexOf("no-cache") !== -1)
    return !1;
  if ("if-none-match" in t.headers) {
    const r = t.headers["if-none-match"];
    if (r === "*")
      return !0;
    const i = n.getHeader("etag");
    if (typeof i != "string")
      return !1;
    const s = i.length;
    return !!cb(r, function(a) {
      const l = a.length;
      if (s === l && a === i || s > l && "W/" + a === i)
        return !0;
    });
  }
  if ("if-modified-since" in t.headers) {
    const r = t.headers["if-modified-since"], i = n.getHeader("last-modified");
    if (!i || Date.parse(i) <= Date.parse(r))
      return !0;
  }
  return !1;
};
It.prototype.isPreconditionFailure = function() {
  const t = this.req, n = this.res, r = t.headers["if-match"];
  if (r) {
    const i = n.getHeader("ETag");
    if (r !== "*" && (cb(r, function(o) {
      if (o === i || "W/" + o === i)
        return !0;
    }) || !1) !== !0)
      return !0;
  }
  if ("if-unmodified-since" in t.headers) {
    const i = t.headers["if-unmodified-since"], s = Date.parse(i);
    if (s === s) {
      const o = Date.parse(n.getHeader("Last-Modified"));
      if (
        // eslint-disable-next-line no-self-compare
        o !== o || // fast path of isNaN(number)
        o > s
      )
        return !0;
    }
  }
  return !1;
};
It.prototype.removeContentHeaderFields = function() {
  const t = this.res;
  t.removeHeader("Content-Encoding"), t.removeHeader("Content-Language"), t.removeHeader("Content-Length"), t.removeHeader("Content-Range"), t.removeHeader("Content-Type");
};
It.prototype.notModified = function() {
  const t = this.res;
  At("not modified"), this.removeContentHeaderFields(), t.statusCode = 304, t.end();
};
It.prototype.headersAlreadySent = function() {
  const t = new Error("Can't set headers after they are sent.");
  At("headers already sent"), this.error(500, t);
};
It.prototype.isCachable = function() {
  const t = this.res.statusCode;
  return t >= 200 && t < 300 || t === 304;
};
It.prototype.onStatError = function(t) {
  switch (t.code) {
    case "ENAMETOOLONG":
    case "ENOTDIR":
    case "ENOENT":
      this.error(404, t);
      break;
    default:
      this.error(500, t);
      break;
  }
};
It.prototype.isRangeFresh = function() {
  if (!("if-range" in this.req.headers))
    return !0;
  const t = this.req.headers["if-range"];
  if (t.indexOf('"') !== -1) {
    const i = this.res.getHeader("ETag");
    return i && t.indexOf(i) !== -1 || !1;
  }
  const n = Date.parse(t);
  if (n !== n)
    return !1;
  const r = Date.parse(this.res.getHeader("Last-Modified"));
  return (
    // eslint-disable-next-line no-self-compare
    r !== r || // fast path of isNaN(number)
    r <= n
  );
};
It.prototype.redirect = function(t) {
  const n = this.res;
  if (this.listenerCount("directory") > 0) {
    this.emit("directory", n, t);
    return;
  }
  if (this.hasTrailingSlash()) {
    this.error(403);
    return;
  }
  const r = encodeURI(s$(this.path + "/")), i = Ai("Redirecting", 'Redirecting to <a href="' + mm(r) + '">' + mm(r) + "</a>");
  n.statusCode = 301, n.setHeader("Content-Type", "text/html; charset=UTF-8"), n.setHeader("Content-Length", i[1]), n.setHeader("Content-Security-Policy", "default-src 'none'"), n.setHeader("X-Content-Type-Options", "nosniff"), n.setHeader("Location", r), n.end(i[0]);
};
It.prototype.pipe = function(t) {
  const n = this._root;
  this.res = t;
  let r = n$(this.path);
  if (r === null)
    return this.error(400), t;
  if (~r.indexOf("\0"))
    return this.error(400), t;
  let i;
  if (n !== null) {
    if (r && (r = Vc("." + fl + r)), vm.test(r))
      return At('malicious path "%s"', r), this.error(403), t;
    i = r.split(fl), r = Vc(fb(n, r));
  } else {
    if (vm.test(r))
      return At('malicious path "%s"', r), this.error(403), t;
    i = Vc(r).split(fl), r = Bd(r);
  }
  if ((At.enabled || // if debugging is enabled, then check for all cases to log allow case
  this._dotfiles !== 0) && o$(i))
    switch (this._dotfiles) {
      case 0:
        At('allow dotfile "%s"', r);
        break;
      case 2:
        return At('deny dotfile "%s"', r), this.error(403), t;
      case 1:
      default:
        return At('ignore dotfile "%s"', r), this.error(404), t;
    }
  return this._index.length && this.hasTrailingSlash() ? (this.sendIndex(r), t) : (this.sendFile(r), t);
};
It.prototype.send = function(t, n) {
  let r = n.size;
  const i = this.options, s = {}, o = this.res, a = this.req;
  let l = i.start || 0;
  if (o.headersSent) {
    this.headersAlreadySent();
    return;
  }
  if (At('pipe "%s"', t), this.setHeader(t, n), this.type(t), this.isConditionalGET()) {
    if (this.isPreconditionFailure()) {
      this.error(412);
      return;
    }
    if (this.isCachable() && this.isNotModifiedFailure()) {
      this.notModified();
      return;
    }
  }
  if (r = Math.max(0, r - l), i.end !== void 0) {
    const c = i.end - l + 1;
    r > c && (r = c);
  }
  if (this._acceptRanges) {
    const c = a.headers.range;
    if (c !== void 0 && d$.test(c))
      if (this.isRangeFresh()) {
        const u = u$(r, c);
        if (u.length === 0)
          return At("range unsatisfiable"), o.setHeader("Content-Range", gm("bytes", r)), this.error(416, {
            headers: { "Content-Range": o.getHeader("Content-Range") }
          });
        u.length === 1 && (At("range %j", u), o.statusCode = 206, o.setHeader("Content-Range", gm("bytes", r, u[0])), l += u[0].start, r = u[0].end - u[0].start + 1);
      } else
        At("range stale");
  }
  for (const c in i)
    s[c] = i[c];
  if (s.start = l, s.end = Math.max(l, l + r - 1), o.setHeader("Content-Length", r), a.method === "HEAD") {
    o.end();
    return;
  }
  this.stream(t, s);
};
It.prototype.sendFile = function(t) {
  let n = 0;
  const r = this;
  At('stat "%s"', t), Ll.stat(t, function(o, a) {
    if (o && o.code === "ENOENT" && !f$(t) && t[t.length - 1] !== fl)
      return i(o);
    if (o)
      return r.onStatError(o);
    if (a.isDirectory())
      return r.redirect(t);
    r.emit("file", t, a), r.send(t, a);
  });
  function i(s) {
    if (r._extensions.length <= n)
      return s ? r.onStatError(s) : r.error(404);
    const o = t + "." + r._extensions[n++];
    At('stat "%s"', o), Ll.stat(o, function(a, l) {
      if (a)
        return i(a);
      if (l.isDirectory())
        return i();
      r.emit("file", o, l), r.send(o, l);
    });
  }
};
It.prototype.sendIndex = function(t) {
  let n = -1;
  const r = this;
  function i(s) {
    if (++n >= r._index.length)
      return s ? r.onStatError(s) : r.error(404);
    const o = fb(t, r._index[n]);
    At('stat "%s"', o), Ll.stat(o, function(a, l) {
      if (a)
        return i(a);
      if (l.isDirectory())
        return i();
      r.emit("file", o, l), r.send(o, l);
    });
  }
  i();
};
It.prototype.stream = function(t, n) {
  const r = this, i = this.res, s = Ll.createReadStream(t, n);
  this.emit("stream", s), s.pipe(i);
  let o = !1;
  function a() {
    o || (o = !0, s.destroy());
  }
  i.once("finish", a), s.on("error", function(c) {
    a(), r.onStatError(c);
  }), s.on("end", function() {
    r.emit("end");
  });
};
It.prototype.type = function(t) {
  const n = this.res;
  if (n.getHeader("Content-Type"))
    return;
  const r = ym.getType(t) || ym.default_type;
  if (!r) {
    At("no content-type");
    return;
  }
  At("content-type %s", r), l$(r) ? n.setHeader("Content-Type", r + "; charset=UTF-8") : n.setHeader("Content-Type", r);
};
It.prototype.setHeader = function(t, n) {
  const r = this.res;
  if (this.emit("headers", r, t, n), this._acceptRanges && !r.getHeader("Accept-Ranges") && (At("accept ranges"), r.setHeader("Accept-Ranges", "bytes")), this._cacheControl && !r.getHeader("Cache-Control")) {
    let i = "public, max-age=" + Math.floor(this._maxage / 1e3);
    this._immutable && (i += ", immutable"), At("cache-control %s", i), r.setHeader("Cache-Control", i);
  }
  if (this._lastModified && !r.getHeader("Last-Modified")) {
    const i = n.mtime.toUTCString();
    At("modified %s", i), r.setHeader("Last-Modified", i);
  }
  if (this._etag && !r.getHeader("ETag")) {
    const i = 'W/"' + n.size.toString(16) + "-" + n.mtime.getTime().toString(16) + '"';
    At("etag %s", i), r.setHeader("ETag", i);
  }
};
var y$ = It;
/*!
 * send
 * Copyright(c) 2012 TJ Holowaychuk
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
const g$ = Fd.isUtf8MimeType, b$ = Y0, db = y$;
function Gd(e, t, n) {
  return new db(e, t, n);
}
Wi.exports = Gd;
Wi.exports.default = Gd;
Wi.exports.send = Gd;
Wi.exports.SendStream = db;
Wi.exports.isUtf8MimeType = g$;
Wi.exports.mime = b$;
var v$ = Wi.exports, da = { exports: {} };
function zd(e) {
  if (!new.target)
    return new zd(e);
  const {
    supportedValues: t = [],
    cache: n
  } = e && typeof e == "object" && e || {};
  this.supportedValues = t, this.cache = n;
}
zd.prototype.negotiate = function(e) {
  return typeof e != "string" ? null : this.cache ? (this.cache.has(e) || this.cache.set(e, Ho(e, this.supportedValues)), this.cache.get(e)) : Ho(e, this.supportedValues);
};
function Ho(e, t) {
  if (!e || !Array.isArray(t) || t.length === 0)
    return null;
  if (e === "*")
    return t[0];
  let n = null, r = 1 / 0, i = 0;
  function s(o, a) {
    if (a === 0 || i > a)
      return !1;
    const l = o === "*" && t[0] || o, c = t.indexOf(l);
    return c === -1 ? !1 : c === 0 && a === 1 ? (n = l, !0) : ((i < a || r > c) && (n = l, r = c, i = a), !1);
  }
  return _$(e, s), n;
}
const lo = 0, uo = 1, Ma = 2, Bc = 3;
function _$(e, t) {
  let n = "", r, i = lo;
  for (let s = 0, o = e.length; s < o; ++s) {
    const a = e[s];
    if (!(a === " " || a === "	")) {
      if (a === ";") {
        i === uo && (i = Ma, r = "");
        continue;
      } else if (a === ",") {
        if (i === uo) {
          if (t(n, 1)) {
            i = Bc;
            break;
          }
          i = lo, n = "";
        } else if (i === Ma) {
          if (t(n, parseFloat(r) || 0)) {
            i = Bc;
            break;
          }
          i = lo, n = "", r = "";
        }
        continue;
      } else if (i === Ma) {
        if (a === "q" || a === "=")
          continue;
        if (a === "." || a === "1" || a === "0" || a === "2" || a === "3" || a === "4" || a === "5" || a === "6" || a === "7" || a === "8" || a === "9") {
          r += a;
          continue;
        }
      } else if (i === lo) {
        i = uo, n += a;
        continue;
      }
      if (i === uo) {
        const l = e[s - 1];
        (l === " " || l === "	") && (n = ""), n += a;
        continue;
      }
      if (t(n, parseFloat(r) || 0)) {
        i = Bc;
        break;
      }
      i = lo, n = a, r = "";
    }
  }
  i === uo ? t(n, 1) : i === Ma && t(n, parseFloat(r) || 0);
}
da.exports = Ho;
da.exports.default = Ho;
da.exports.negotiate = Ho;
da.exports.Negotiator = zd;
var w$ = da.exports, qd = { exports: {} }, Uf = { exports: {} }, jn = {}, yu = {};
yu.byteLength = T$;
yu.toByteArray = N$;
yu.fromByteArray = R$;
var lr = [], Tn = [], E$ = typeof Uint8Array < "u" ? Uint8Array : Array, Gc = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var os = 0, S$ = Gc.length; os < S$; ++os)
  lr[os] = Gc[os], Tn[Gc.charCodeAt(os)] = os;
Tn["-".charCodeAt(0)] = 62;
Tn["_".charCodeAt(0)] = 63;
function pb(e) {
  var t = e.length;
  if (t % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var n = e.indexOf("=");
  n === -1 && (n = t);
  var r = n === t ? 0 : 4 - n % 4;
  return [n, r];
}
function T$(e) {
  var t = pb(e), n = t[0], r = t[1];
  return (n + r) * 3 / 4 - r;
}
function $$(e, t, n) {
  return (t + n) * 3 / 4 - n;
}
function N$(e) {
  var t, n = pb(e), r = n[0], i = n[1], s = new E$($$(e, r, i)), o = 0, a = i > 0 ? r - 4 : r, l;
  for (l = 0; l < a; l += 4)
    t = Tn[e.charCodeAt(l)] << 18 | Tn[e.charCodeAt(l + 1)] << 12 | Tn[e.charCodeAt(l + 2)] << 6 | Tn[e.charCodeAt(l + 3)], s[o++] = t >> 16 & 255, s[o++] = t >> 8 & 255, s[o++] = t & 255;
  return i === 2 && (t = Tn[e.charCodeAt(l)] << 2 | Tn[e.charCodeAt(l + 1)] >> 4, s[o++] = t & 255), i === 1 && (t = Tn[e.charCodeAt(l)] << 10 | Tn[e.charCodeAt(l + 1)] << 4 | Tn[e.charCodeAt(l + 2)] >> 2, s[o++] = t >> 8 & 255, s[o++] = t & 255), s;
}
function O$(e) {
  return lr[e >> 18 & 63] + lr[e >> 12 & 63] + lr[e >> 6 & 63] + lr[e & 63];
}
function I$(e, t, n) {
  for (var r, i = [], s = t; s < n; s += 3)
    r = (e[s] << 16 & 16711680) + (e[s + 1] << 8 & 65280) + (e[s + 2] & 255), i.push(O$(r));
  return i.join("");
}
function R$(e) {
  for (var t, n = e.length, r = n % 3, i = [], s = 16383, o = 0, a = n - r; o < a; o += s)
    i.push(I$(e, o, o + s > a ? a : o + s));
  return r === 1 ? (t = e[n - 1], i.push(
    lr[t >> 2] + lr[t << 4 & 63] + "=="
  )) : r === 2 && (t = (e[n - 2] << 8) + e[n - 1], i.push(
    lr[t >> 10] + lr[t >> 4 & 63] + lr[t << 2 & 63] + "="
  )), i.join("");
}
var Hd = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
Hd.read = function(e, t, n, r, i) {
  var s, o, a = i * 8 - r - 1, l = (1 << a) - 1, c = l >> 1, u = -7, f = n ? i - 1 : 0, d = n ? -1 : 1, p = e[t + f];
  for (f += d, s = p & (1 << -u) - 1, p >>= -u, u += a; u > 0; s = s * 256 + e[t + f], f += d, u -= 8)
    ;
  for (o = s & (1 << -u) - 1, s >>= -u, u += r; u > 0; o = o * 256 + e[t + f], f += d, u -= 8)
    ;
  if (s === 0)
    s = 1 - c;
  else {
    if (s === l)
      return o ? NaN : (p ? -1 : 1) * (1 / 0);
    o = o + Math.pow(2, r), s = s - c;
  }
  return (p ? -1 : 1) * o * Math.pow(2, s - r);
};
Hd.write = function(e, t, n, r, i, s) {
  var o, a, l, c = s * 8 - i - 1, u = (1 << c) - 1, f = u >> 1, d = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, p = r ? 0 : s - 1, h = r ? 1 : -1, m = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
  for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (a = isNaN(t) ? 1 : 0, o = u) : (o = Math.floor(Math.log(t) / Math.LN2), t * (l = Math.pow(2, -o)) < 1 && (o--, l *= 2), o + f >= 1 ? t += d / l : t += d * Math.pow(2, 1 - f), t * l >= 2 && (o++, l /= 2), o + f >= u ? (a = 0, o = u) : o + f >= 1 ? (a = (t * l - 1) * Math.pow(2, i), o = o + f) : (a = t * Math.pow(2, f - 1) * Math.pow(2, i), o = 0)); i >= 8; e[n + p] = a & 255, p += h, a /= 256, i -= 8)
    ;
  for (o = o << i | a, c += i; c > 0; e[n + p] = o & 255, p += h, o /= 256, c -= 8)
    ;
  e[n + p - h] |= m * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(e) {
  const t = yu, n = Hd, r = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  e.Buffer = a, e.SlowBuffer = E, e.INSPECT_MAX_BYTES = 50;
  const i = 2147483647;
  e.kMaxLength = i, a.TYPED_ARRAY_SUPPORT = s(), !a.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function s() {
    try {
      const x = new Uint8Array(1), g = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(g, Uint8Array.prototype), Object.setPrototypeOf(x, g), x.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(a.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (a.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(a.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (a.isBuffer(this))
        return this.byteOffset;
    }
  });
  function o(x) {
    if (x > i)
      throw new RangeError('The value "' + x + '" is invalid for option "size"');
    const g = new Uint8Array(x);
    return Object.setPrototypeOf(g, a.prototype), g;
  }
  function a(x, g, _) {
    if (typeof x == "number") {
      if (typeof g == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return f(x);
    }
    return l(x, g, _);
  }
  a.poolSize = 8192;
  function l(x, g, _) {
    if (typeof x == "string")
      return d(x, g);
    if (ArrayBuffer.isView(x))
      return h(x);
    if (x == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof x
      );
    if (we(x, ArrayBuffer) || x && we(x.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (we(x, SharedArrayBuffer) || x && we(x.buffer, SharedArrayBuffer)))
      return m(x, g, _);
    if (typeof x == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const V = x.valueOf && x.valueOf();
    if (V != null && V !== x)
      return a.from(V, g, _);
    const X = v(x);
    if (X)
      return X;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof x[Symbol.toPrimitive] == "function")
      return a.from(x[Symbol.toPrimitive]("string"), g, _);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof x
    );
  }
  a.from = function(x, g, _) {
    return l(x, g, _);
  }, Object.setPrototypeOf(a.prototype, Uint8Array.prototype), Object.setPrototypeOf(a, Uint8Array);
  function c(x) {
    if (typeof x != "number")
      throw new TypeError('"size" argument must be of type number');
    if (x < 0)
      throw new RangeError('The value "' + x + '" is invalid for option "size"');
  }
  function u(x, g, _) {
    return c(x), x <= 0 ? o(x) : g !== void 0 ? typeof _ == "string" ? o(x).fill(g, _) : o(x).fill(g) : o(x);
  }
  a.alloc = function(x, g, _) {
    return u(x, g, _);
  };
  function f(x) {
    return c(x), o(x < 0 ? 0 : b(x) | 0);
  }
  a.allocUnsafe = function(x) {
    return f(x);
  }, a.allocUnsafeSlow = function(x) {
    return f(x);
  };
  function d(x, g) {
    if ((typeof g != "string" || g === "") && (g = "utf8"), !a.isEncoding(g))
      throw new TypeError("Unknown encoding: " + g);
    const _ = y(x, g) | 0;
    let V = o(_);
    const X = V.write(x, g);
    return X !== _ && (V = V.slice(0, X)), V;
  }
  function p(x) {
    const g = x.length < 0 ? 0 : b(x.length) | 0, _ = o(g);
    for (let V = 0; V < g; V += 1)
      _[V] = x[V] & 255;
    return _;
  }
  function h(x) {
    if (we(x, Uint8Array)) {
      const g = new Uint8Array(x);
      return m(g.buffer, g.byteOffset, g.byteLength);
    }
    return p(x);
  }
  function m(x, g, _) {
    if (g < 0 || x.byteLength < g)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (x.byteLength < g + (_ || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let V;
    return g === void 0 && _ === void 0 ? V = new Uint8Array(x) : _ === void 0 ? V = new Uint8Array(x, g) : V = new Uint8Array(x, g, _), Object.setPrototypeOf(V, a.prototype), V;
  }
  function v(x) {
    if (a.isBuffer(x)) {
      const g = b(x.length) | 0, _ = o(g);
      return _.length === 0 || x.copy(_, 0, 0, g), _;
    }
    if (x.length !== void 0)
      return typeof x.length != "number" || Le(x.length) ? o(0) : p(x);
    if (x.type === "Buffer" && Array.isArray(x.data))
      return p(x.data);
  }
  function b(x) {
    if (x >= i)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + i.toString(16) + " bytes");
    return x | 0;
  }
  function E(x) {
    return +x != x && (x = 0), a.alloc(+x);
  }
  a.isBuffer = function(g) {
    return g != null && g._isBuffer === !0 && g !== a.prototype;
  }, a.compare = function(g, _) {
    if (we(g, Uint8Array) && (g = a.from(g, g.offset, g.byteLength)), we(_, Uint8Array) && (_ = a.from(_, _.offset, _.byteLength)), !a.isBuffer(g) || !a.isBuffer(_))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (g === _)
      return 0;
    let V = g.length, X = _.length;
    for (let pe = 0, ye = Math.min(V, X); pe < ye; ++pe)
      if (g[pe] !== _[pe]) {
        V = g[pe], X = _[pe];
        break;
      }
    return V < X ? -1 : X < V ? 1 : 0;
  }, a.isEncoding = function(g) {
    switch (String(g).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, a.concat = function(g, _) {
    if (!Array.isArray(g))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (g.length === 0)
      return a.alloc(0);
    let V;
    if (_ === void 0)
      for (_ = 0, V = 0; V < g.length; ++V)
        _ += g[V].length;
    const X = a.allocUnsafe(_);
    let pe = 0;
    for (V = 0; V < g.length; ++V) {
      let ye = g[V];
      if (we(ye, Uint8Array))
        pe + ye.length > X.length ? (a.isBuffer(ye) || (ye = a.from(ye)), ye.copy(X, pe)) : Uint8Array.prototype.set.call(
          X,
          ye,
          pe
        );
      else if (a.isBuffer(ye))
        ye.copy(X, pe);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      pe += ye.length;
    }
    return X;
  };
  function y(x, g) {
    if (a.isBuffer(x))
      return x.length;
    if (ArrayBuffer.isView(x) || we(x, ArrayBuffer))
      return x.byteLength;
    if (typeof x != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof x
      );
    const _ = x.length, V = arguments.length > 2 && arguments[2] === !0;
    if (!V && _ === 0)
      return 0;
    let X = !1;
    for (; ; )
      switch (g) {
        case "ascii":
        case "latin1":
        case "binary":
          return _;
        case "utf8":
        case "utf-8":
          return ae(x).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return _ * 2;
        case "hex":
          return _ >>> 1;
        case "base64":
          return Te(x).length;
        default:
          if (X)
            return V ? -1 : ae(x).length;
          g = ("" + g).toLowerCase(), X = !0;
      }
  }
  a.byteLength = y;
  function D(x, g, _) {
    let V = !1;
    if ((g === void 0 || g < 0) && (g = 0), g > this.length || ((_ === void 0 || _ > this.length) && (_ = this.length), _ <= 0) || (_ >>>= 0, g >>>= 0, _ <= g))
      return "";
    for (x || (x = "utf8"); ; )
      switch (x) {
        case "hex":
          return ue(this, g, _);
        case "utf8":
        case "utf-8":
          return z(this, g, _);
        case "ascii":
          return se(this, g, _);
        case "latin1":
        case "binary":
          return re(this, g, _);
        case "base64":
          return U(this, g, _);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return te(this, g, _);
        default:
          if (V)
            throw new TypeError("Unknown encoding: " + x);
          x = (x + "").toLowerCase(), V = !0;
      }
  }
  a.prototype._isBuffer = !0;
  function F(x, g, _) {
    const V = x[g];
    x[g] = x[_], x[_] = V;
  }
  a.prototype.swap16 = function() {
    const g = this.length;
    if (g % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let _ = 0; _ < g; _ += 2)
      F(this, _, _ + 1);
    return this;
  }, a.prototype.swap32 = function() {
    const g = this.length;
    if (g % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let _ = 0; _ < g; _ += 4)
      F(this, _, _ + 3), F(this, _ + 1, _ + 2);
    return this;
  }, a.prototype.swap64 = function() {
    const g = this.length;
    if (g % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let _ = 0; _ < g; _ += 8)
      F(this, _, _ + 7), F(this, _ + 1, _ + 6), F(this, _ + 2, _ + 5), F(this, _ + 3, _ + 4);
    return this;
  }, a.prototype.toString = function() {
    const g = this.length;
    return g === 0 ? "" : arguments.length === 0 ? z(this, 0, g) : D.apply(this, arguments);
  }, a.prototype.toLocaleString = a.prototype.toString, a.prototype.equals = function(g) {
    if (!a.isBuffer(g))
      throw new TypeError("Argument must be a Buffer");
    return this === g ? !0 : a.compare(this, g) === 0;
  }, a.prototype.inspect = function() {
    let g = "";
    const _ = e.INSPECT_MAX_BYTES;
    return g = this.toString("hex", 0, _).replace(/(.{2})/g, "$1 ").trim(), this.length > _ && (g += " ... "), "<Buffer " + g + ">";
  }, r && (a.prototype[r] = a.prototype.inspect), a.prototype.compare = function(g, _, V, X, pe) {
    if (we(g, Uint8Array) && (g = a.from(g, g.offset, g.byteLength)), !a.isBuffer(g))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof g
      );
    if (_ === void 0 && (_ = 0), V === void 0 && (V = g ? g.length : 0), X === void 0 && (X = 0), pe === void 0 && (pe = this.length), _ < 0 || V > g.length || X < 0 || pe > this.length)
      throw new RangeError("out of range index");
    if (X >= pe && _ >= V)
      return 0;
    if (X >= pe)
      return -1;
    if (_ >= V)
      return 1;
    if (_ >>>= 0, V >>>= 0, X >>>= 0, pe >>>= 0, this === g)
      return 0;
    let ye = pe - X, Ge = V - _;
    const ft = Math.min(ye, Ge), ze = this.slice(X, pe), st = g.slice(_, V);
    for (let nt = 0; nt < ft; ++nt)
      if (ze[nt] !== st[nt]) {
        ye = ze[nt], Ge = st[nt];
        break;
      }
    return ye < Ge ? -1 : Ge < ye ? 1 : 0;
  };
  function W(x, g, _, V, X) {
    if (x.length === 0)
      return -1;
    if (typeof _ == "string" ? (V = _, _ = 0) : _ > 2147483647 ? _ = 2147483647 : _ < -2147483648 && (_ = -2147483648), _ = +_, Le(_) && (_ = X ? 0 : x.length - 1), _ < 0 && (_ = x.length + _), _ >= x.length) {
      if (X)
        return -1;
      _ = x.length - 1;
    } else if (_ < 0)
      if (X)
        _ = 0;
      else
        return -1;
    if (typeof g == "string" && (g = a.from(g, V)), a.isBuffer(g))
      return g.length === 0 ? -1 : J(x, g, _, V, X);
    if (typeof g == "number")
      return g = g & 255, typeof Uint8Array.prototype.indexOf == "function" ? X ? Uint8Array.prototype.indexOf.call(x, g, _) : Uint8Array.prototype.lastIndexOf.call(x, g, _) : J(x, [g], _, V, X);
    throw new TypeError("val must be string, number or Buffer");
  }
  function J(x, g, _, V, X) {
    let pe = 1, ye = x.length, Ge = g.length;
    if (V !== void 0 && (V = String(V).toLowerCase(), V === "ucs2" || V === "ucs-2" || V === "utf16le" || V === "utf-16le")) {
      if (x.length < 2 || g.length < 2)
        return -1;
      pe = 2, ye /= 2, Ge /= 2, _ /= 2;
    }
    function ft(st, nt) {
      return pe === 1 ? st[nt] : st.readUInt16BE(nt * pe);
    }
    let ze;
    if (X) {
      let st = -1;
      for (ze = _; ze < ye; ze++)
        if (ft(x, ze) === ft(g, st === -1 ? 0 : ze - st)) {
          if (st === -1 && (st = ze), ze - st + 1 === Ge)
            return st * pe;
        } else
          st !== -1 && (ze -= ze - st), st = -1;
    } else
      for (_ + Ge > ye && (_ = ye - Ge), ze = _; ze >= 0; ze--) {
        let st = !0;
        for (let nt = 0; nt < Ge; nt++)
          if (ft(x, ze + nt) !== ft(g, nt)) {
            st = !1;
            break;
          }
        if (st)
          return ze;
      }
    return -1;
  }
  a.prototype.includes = function(g, _, V) {
    return this.indexOf(g, _, V) !== -1;
  }, a.prototype.indexOf = function(g, _, V) {
    return W(this, g, _, V, !0);
  }, a.prototype.lastIndexOf = function(g, _, V) {
    return W(this, g, _, V, !1);
  };
  function Z(x, g, _, V) {
    _ = Number(_) || 0;
    const X = x.length - _;
    V ? (V = Number(V), V > X && (V = X)) : V = X;
    const pe = g.length;
    V > pe / 2 && (V = pe / 2);
    let ye;
    for (ye = 0; ye < V; ++ye) {
      const Ge = parseInt(g.substr(ye * 2, 2), 16);
      if (Le(Ge))
        return ye;
      x[_ + ye] = Ge;
    }
    return ye;
  }
  function j(x, g, _, V) {
    return Me(ae(g, x.length - _), x, _, V);
  }
  function ee(x, g, _, V) {
    return Me(Ee(g), x, _, V);
  }
  function le(x, g, _, V) {
    return Me(Te(g), x, _, V);
  }
  function ce(x, g, _, V) {
    return Me(Oe(g, x.length - _), x, _, V);
  }
  a.prototype.write = function(g, _, V, X) {
    if (_ === void 0)
      X = "utf8", V = this.length, _ = 0;
    else if (V === void 0 && typeof _ == "string")
      X = _, V = this.length, _ = 0;
    else if (isFinite(_))
      _ = _ >>> 0, isFinite(V) ? (V = V >>> 0, X === void 0 && (X = "utf8")) : (X = V, V = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const pe = this.length - _;
    if ((V === void 0 || V > pe) && (V = pe), g.length > 0 && (V < 0 || _ < 0) || _ > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    X || (X = "utf8");
    let ye = !1;
    for (; ; )
      switch (X) {
        case "hex":
          return Z(this, g, _, V);
        case "utf8":
        case "utf-8":
          return j(this, g, _, V);
        case "ascii":
        case "latin1":
        case "binary":
          return ee(this, g, _, V);
        case "base64":
          return le(this, g, _, V);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ce(this, g, _, V);
        default:
          if (ye)
            throw new TypeError("Unknown encoding: " + X);
          X = ("" + X).toLowerCase(), ye = !0;
      }
  }, a.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function U(x, g, _) {
    return g === 0 && _ === x.length ? t.fromByteArray(x) : t.fromByteArray(x.slice(g, _));
  }
  function z(x, g, _) {
    _ = Math.min(x.length, _);
    const V = [];
    let X = g;
    for (; X < _; ) {
      const pe = x[X];
      let ye = null, Ge = pe > 239 ? 4 : pe > 223 ? 3 : pe > 191 ? 2 : 1;
      if (X + Ge <= _) {
        let ft, ze, st, nt;
        switch (Ge) {
          case 1:
            pe < 128 && (ye = pe);
            break;
          case 2:
            ft = x[X + 1], (ft & 192) === 128 && (nt = (pe & 31) << 6 | ft & 63, nt > 127 && (ye = nt));
            break;
          case 3:
            ft = x[X + 1], ze = x[X + 2], (ft & 192) === 128 && (ze & 192) === 128 && (nt = (pe & 15) << 12 | (ft & 63) << 6 | ze & 63, nt > 2047 && (nt < 55296 || nt > 57343) && (ye = nt));
            break;
          case 4:
            ft = x[X + 1], ze = x[X + 2], st = x[X + 3], (ft & 192) === 128 && (ze & 192) === 128 && (st & 192) === 128 && (nt = (pe & 15) << 18 | (ft & 63) << 12 | (ze & 63) << 6 | st & 63, nt > 65535 && nt < 1114112 && (ye = nt));
        }
      }
      ye === null ? (ye = 65533, Ge = 1) : ye > 65535 && (ye -= 65536, V.push(ye >>> 10 & 1023 | 55296), ye = 56320 | ye & 1023), V.push(ye), X += Ge;
    }
    return K(V);
  }
  const ne = 4096;
  function K(x) {
    const g = x.length;
    if (g <= ne)
      return String.fromCharCode.apply(String, x);
    let _ = "", V = 0;
    for (; V < g; )
      _ += String.fromCharCode.apply(
        String,
        x.slice(V, V += ne)
      );
    return _;
  }
  function se(x, g, _) {
    let V = "";
    _ = Math.min(x.length, _);
    for (let X = g; X < _; ++X)
      V += String.fromCharCode(x[X] & 127);
    return V;
  }
  function re(x, g, _) {
    let V = "";
    _ = Math.min(x.length, _);
    for (let X = g; X < _; ++X)
      V += String.fromCharCode(x[X]);
    return V;
  }
  function ue(x, g, _) {
    const V = x.length;
    (!g || g < 0) && (g = 0), (!_ || _ < 0 || _ > V) && (_ = V);
    let X = "";
    for (let pe = g; pe < _; ++pe)
      X += ut[x[pe]];
    return X;
  }
  function te(x, g, _) {
    const V = x.slice(g, _);
    let X = "";
    for (let pe = 0; pe < V.length - 1; pe += 2)
      X += String.fromCharCode(V[pe] + V[pe + 1] * 256);
    return X;
  }
  a.prototype.slice = function(g, _) {
    const V = this.length;
    g = ~~g, _ = _ === void 0 ? V : ~~_, g < 0 ? (g += V, g < 0 && (g = 0)) : g > V && (g = V), _ < 0 ? (_ += V, _ < 0 && (_ = 0)) : _ > V && (_ = V), _ < g && (_ = g);
    const X = this.subarray(g, _);
    return Object.setPrototypeOf(X, a.prototype), X;
  };
  function B(x, g, _) {
    if (x % 1 !== 0 || x < 0)
      throw new RangeError("offset is not uint");
    if (x + g > _)
      throw new RangeError("Trying to access beyond buffer length");
  }
  a.prototype.readUintLE = a.prototype.readUIntLE = function(g, _, V) {
    g = g >>> 0, _ = _ >>> 0, V || B(g, _, this.length);
    let X = this[g], pe = 1, ye = 0;
    for (; ++ye < _ && (pe *= 256); )
      X += this[g + ye] * pe;
    return X;
  }, a.prototype.readUintBE = a.prototype.readUIntBE = function(g, _, V) {
    g = g >>> 0, _ = _ >>> 0, V || B(g, _, this.length);
    let X = this[g + --_], pe = 1;
    for (; _ > 0 && (pe *= 256); )
      X += this[g + --_] * pe;
    return X;
  }, a.prototype.readUint8 = a.prototype.readUInt8 = function(g, _) {
    return g = g >>> 0, _ || B(g, 1, this.length), this[g];
  }, a.prototype.readUint16LE = a.prototype.readUInt16LE = function(g, _) {
    return g = g >>> 0, _ || B(g, 2, this.length), this[g] | this[g + 1] << 8;
  }, a.prototype.readUint16BE = a.prototype.readUInt16BE = function(g, _) {
    return g = g >>> 0, _ || B(g, 2, this.length), this[g] << 8 | this[g + 1];
  }, a.prototype.readUint32LE = a.prototype.readUInt32LE = function(g, _) {
    return g = g >>> 0, _ || B(g, 4, this.length), (this[g] | this[g + 1] << 8 | this[g + 2] << 16) + this[g + 3] * 16777216;
  }, a.prototype.readUint32BE = a.prototype.readUInt32BE = function(g, _) {
    return g = g >>> 0, _ || B(g, 4, this.length), this[g] * 16777216 + (this[g + 1] << 16 | this[g + 2] << 8 | this[g + 3]);
  }, a.prototype.readBigUInt64LE = Je(function(g) {
    g = g >>> 0, O(g, "offset");
    const _ = this[g], V = this[g + 7];
    (_ === void 0 || V === void 0) && I(g, this.length - 8);
    const X = _ + this[++g] * 2 ** 8 + this[++g] * 2 ** 16 + this[++g] * 2 ** 24, pe = this[++g] + this[++g] * 2 ** 8 + this[++g] * 2 ** 16 + V * 2 ** 24;
    return BigInt(X) + (BigInt(pe) << BigInt(32));
  }), a.prototype.readBigUInt64BE = Je(function(g) {
    g = g >>> 0, O(g, "offset");
    const _ = this[g], V = this[g + 7];
    (_ === void 0 || V === void 0) && I(g, this.length - 8);
    const X = _ * 2 ** 24 + this[++g] * 2 ** 16 + this[++g] * 2 ** 8 + this[++g], pe = this[++g] * 2 ** 24 + this[++g] * 2 ** 16 + this[++g] * 2 ** 8 + V;
    return (BigInt(X) << BigInt(32)) + BigInt(pe);
  }), a.prototype.readIntLE = function(g, _, V) {
    g = g >>> 0, _ = _ >>> 0, V || B(g, _, this.length);
    let X = this[g], pe = 1, ye = 0;
    for (; ++ye < _ && (pe *= 256); )
      X += this[g + ye] * pe;
    return pe *= 128, X >= pe && (X -= Math.pow(2, 8 * _)), X;
  }, a.prototype.readIntBE = function(g, _, V) {
    g = g >>> 0, _ = _ >>> 0, V || B(g, _, this.length);
    let X = _, pe = 1, ye = this[g + --X];
    for (; X > 0 && (pe *= 256); )
      ye += this[g + --X] * pe;
    return pe *= 128, ye >= pe && (ye -= Math.pow(2, 8 * _)), ye;
  }, a.prototype.readInt8 = function(g, _) {
    return g = g >>> 0, _ || B(g, 1, this.length), this[g] & 128 ? (255 - this[g] + 1) * -1 : this[g];
  }, a.prototype.readInt16LE = function(g, _) {
    g = g >>> 0, _ || B(g, 2, this.length);
    const V = this[g] | this[g + 1] << 8;
    return V & 32768 ? V | 4294901760 : V;
  }, a.prototype.readInt16BE = function(g, _) {
    g = g >>> 0, _ || B(g, 2, this.length);
    const V = this[g + 1] | this[g] << 8;
    return V & 32768 ? V | 4294901760 : V;
  }, a.prototype.readInt32LE = function(g, _) {
    return g = g >>> 0, _ || B(g, 4, this.length), this[g] | this[g + 1] << 8 | this[g + 2] << 16 | this[g + 3] << 24;
  }, a.prototype.readInt32BE = function(g, _) {
    return g = g >>> 0, _ || B(g, 4, this.length), this[g] << 24 | this[g + 1] << 16 | this[g + 2] << 8 | this[g + 3];
  }, a.prototype.readBigInt64LE = Je(function(g) {
    g = g >>> 0, O(g, "offset");
    const _ = this[g], V = this[g + 7];
    (_ === void 0 || V === void 0) && I(g, this.length - 8);
    const X = this[g + 4] + this[g + 5] * 2 ** 8 + this[g + 6] * 2 ** 16 + (V << 24);
    return (BigInt(X) << BigInt(32)) + BigInt(_ + this[++g] * 2 ** 8 + this[++g] * 2 ** 16 + this[++g] * 2 ** 24);
  }), a.prototype.readBigInt64BE = Je(function(g) {
    g = g >>> 0, O(g, "offset");
    const _ = this[g], V = this[g + 7];
    (_ === void 0 || V === void 0) && I(g, this.length - 8);
    const X = (_ << 24) + // Overflow
    this[++g] * 2 ** 16 + this[++g] * 2 ** 8 + this[++g];
    return (BigInt(X) << BigInt(32)) + BigInt(this[++g] * 2 ** 24 + this[++g] * 2 ** 16 + this[++g] * 2 ** 8 + V);
  }), a.prototype.readFloatLE = function(g, _) {
    return g = g >>> 0, _ || B(g, 4, this.length), n.read(this, g, !0, 23, 4);
  }, a.prototype.readFloatBE = function(g, _) {
    return g = g >>> 0, _ || B(g, 4, this.length), n.read(this, g, !1, 23, 4);
  }, a.prototype.readDoubleLE = function(g, _) {
    return g = g >>> 0, _ || B(g, 8, this.length), n.read(this, g, !0, 52, 8);
  }, a.prototype.readDoubleBE = function(g, _) {
    return g = g >>> 0, _ || B(g, 8, this.length), n.read(this, g, !1, 52, 8);
  };
  function M(x, g, _, V, X, pe) {
    if (!a.isBuffer(x))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (g > X || g < pe)
      throw new RangeError('"value" argument is out of bounds');
    if (_ + V > x.length)
      throw new RangeError("Index out of range");
  }
  a.prototype.writeUintLE = a.prototype.writeUIntLE = function(g, _, V, X) {
    if (g = +g, _ = _ >>> 0, V = V >>> 0, !X) {
      const Ge = Math.pow(2, 8 * V) - 1;
      M(this, g, _, V, Ge, 0);
    }
    let pe = 1, ye = 0;
    for (this[_] = g & 255; ++ye < V && (pe *= 256); )
      this[_ + ye] = g / pe & 255;
    return _ + V;
  }, a.prototype.writeUintBE = a.prototype.writeUIntBE = function(g, _, V, X) {
    if (g = +g, _ = _ >>> 0, V = V >>> 0, !X) {
      const Ge = Math.pow(2, 8 * V) - 1;
      M(this, g, _, V, Ge, 0);
    }
    let pe = V - 1, ye = 1;
    for (this[_ + pe] = g & 255; --pe >= 0 && (ye *= 256); )
      this[_ + pe] = g / ye & 255;
    return _ + V;
  }, a.prototype.writeUint8 = a.prototype.writeUInt8 = function(g, _, V) {
    return g = +g, _ = _ >>> 0, V || M(this, g, _, 1, 255, 0), this[_] = g & 255, _ + 1;
  }, a.prototype.writeUint16LE = a.prototype.writeUInt16LE = function(g, _, V) {
    return g = +g, _ = _ >>> 0, V || M(this, g, _, 2, 65535, 0), this[_] = g & 255, this[_ + 1] = g >>> 8, _ + 2;
  }, a.prototype.writeUint16BE = a.prototype.writeUInt16BE = function(g, _, V) {
    return g = +g, _ = _ >>> 0, V || M(this, g, _, 2, 65535, 0), this[_] = g >>> 8, this[_ + 1] = g & 255, _ + 2;
  }, a.prototype.writeUint32LE = a.prototype.writeUInt32LE = function(g, _, V) {
    return g = +g, _ = _ >>> 0, V || M(this, g, _, 4, 4294967295, 0), this[_ + 3] = g >>> 24, this[_ + 2] = g >>> 16, this[_ + 1] = g >>> 8, this[_] = g & 255, _ + 4;
  }, a.prototype.writeUint32BE = a.prototype.writeUInt32BE = function(g, _, V) {
    return g = +g, _ = _ >>> 0, V || M(this, g, _, 4, 4294967295, 0), this[_] = g >>> 24, this[_ + 1] = g >>> 16, this[_ + 2] = g >>> 8, this[_ + 3] = g & 255, _ + 4;
  };
  function N(x, g, _, V, X) {
    $(g, V, X, x, _, 7);
    let pe = Number(g & BigInt(4294967295));
    x[_++] = pe, pe = pe >> 8, x[_++] = pe, pe = pe >> 8, x[_++] = pe, pe = pe >> 8, x[_++] = pe;
    let ye = Number(g >> BigInt(32) & BigInt(4294967295));
    return x[_++] = ye, ye = ye >> 8, x[_++] = ye, ye = ye >> 8, x[_++] = ye, ye = ye >> 8, x[_++] = ye, _;
  }
  function T(x, g, _, V, X) {
    $(g, V, X, x, _, 7);
    let pe = Number(g & BigInt(4294967295));
    x[_ + 7] = pe, pe = pe >> 8, x[_ + 6] = pe, pe = pe >> 8, x[_ + 5] = pe, pe = pe >> 8, x[_ + 4] = pe;
    let ye = Number(g >> BigInt(32) & BigInt(4294967295));
    return x[_ + 3] = ye, ye = ye >> 8, x[_ + 2] = ye, ye = ye >> 8, x[_ + 1] = ye, ye = ye >> 8, x[_] = ye, _ + 8;
  }
  a.prototype.writeBigUInt64LE = Je(function(g, _ = 0) {
    return N(this, g, _, BigInt(0), BigInt("0xffffffffffffffff"));
  }), a.prototype.writeBigUInt64BE = Je(function(g, _ = 0) {
    return T(this, g, _, BigInt(0), BigInt("0xffffffffffffffff"));
  }), a.prototype.writeIntLE = function(g, _, V, X) {
    if (g = +g, _ = _ >>> 0, !X) {
      const ft = Math.pow(2, 8 * V - 1);
      M(this, g, _, V, ft - 1, -ft);
    }
    let pe = 0, ye = 1, Ge = 0;
    for (this[_] = g & 255; ++pe < V && (ye *= 256); )
      g < 0 && Ge === 0 && this[_ + pe - 1] !== 0 && (Ge = 1), this[_ + pe] = (g / ye >> 0) - Ge & 255;
    return _ + V;
  }, a.prototype.writeIntBE = function(g, _, V, X) {
    if (g = +g, _ = _ >>> 0, !X) {
      const ft = Math.pow(2, 8 * V - 1);
      M(this, g, _, V, ft - 1, -ft);
    }
    let pe = V - 1, ye = 1, Ge = 0;
    for (this[_ + pe] = g & 255; --pe >= 0 && (ye *= 256); )
      g < 0 && Ge === 0 && this[_ + pe + 1] !== 0 && (Ge = 1), this[_ + pe] = (g / ye >> 0) - Ge & 255;
    return _ + V;
  }, a.prototype.writeInt8 = function(g, _, V) {
    return g = +g, _ = _ >>> 0, V || M(this, g, _, 1, 127, -128), g < 0 && (g = 255 + g + 1), this[_] = g & 255, _ + 1;
  }, a.prototype.writeInt16LE = function(g, _, V) {
    return g = +g, _ = _ >>> 0, V || M(this, g, _, 2, 32767, -32768), this[_] = g & 255, this[_ + 1] = g >>> 8, _ + 2;
  }, a.prototype.writeInt16BE = function(g, _, V) {
    return g = +g, _ = _ >>> 0, V || M(this, g, _, 2, 32767, -32768), this[_] = g >>> 8, this[_ + 1] = g & 255, _ + 2;
  }, a.prototype.writeInt32LE = function(g, _, V) {
    return g = +g, _ = _ >>> 0, V || M(this, g, _, 4, 2147483647, -2147483648), this[_] = g & 255, this[_ + 1] = g >>> 8, this[_ + 2] = g >>> 16, this[_ + 3] = g >>> 24, _ + 4;
  }, a.prototype.writeInt32BE = function(g, _, V) {
    return g = +g, _ = _ >>> 0, V || M(this, g, _, 4, 2147483647, -2147483648), g < 0 && (g = 4294967295 + g + 1), this[_] = g >>> 24, this[_ + 1] = g >>> 16, this[_ + 2] = g >>> 8, this[_ + 3] = g & 255, _ + 4;
  }, a.prototype.writeBigInt64LE = Je(function(g, _ = 0) {
    return N(this, g, _, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), a.prototype.writeBigInt64BE = Je(function(g, _ = 0) {
    return T(this, g, _, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function P(x, g, _, V, X, pe) {
    if (_ + V > x.length)
      throw new RangeError("Index out of range");
    if (_ < 0)
      throw new RangeError("Index out of range");
  }
  function k(x, g, _, V, X) {
    return g = +g, _ = _ >>> 0, X || P(x, g, _, 4), n.write(x, g, _, V, 23, 4), _ + 4;
  }
  a.prototype.writeFloatLE = function(g, _, V) {
    return k(this, g, _, !0, V);
  }, a.prototype.writeFloatBE = function(g, _, V) {
    return k(this, g, _, !1, V);
  };
  function q(x, g, _, V, X) {
    return g = +g, _ = _ >>> 0, X || P(x, g, _, 8), n.write(x, g, _, V, 52, 8), _ + 8;
  }
  a.prototype.writeDoubleLE = function(g, _, V) {
    return q(this, g, _, !0, V);
  }, a.prototype.writeDoubleBE = function(g, _, V) {
    return q(this, g, _, !1, V);
  }, a.prototype.copy = function(g, _, V, X) {
    if (!a.isBuffer(g))
      throw new TypeError("argument should be a Buffer");
    if (V || (V = 0), !X && X !== 0 && (X = this.length), _ >= g.length && (_ = g.length), _ || (_ = 0), X > 0 && X < V && (X = V), X === V || g.length === 0 || this.length === 0)
      return 0;
    if (_ < 0)
      throw new RangeError("targetStart out of bounds");
    if (V < 0 || V >= this.length)
      throw new RangeError("Index out of range");
    if (X < 0)
      throw new RangeError("sourceEnd out of bounds");
    X > this.length && (X = this.length), g.length - _ < X - V && (X = g.length - _ + V);
    const pe = X - V;
    return this === g && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(_, V, X) : Uint8Array.prototype.set.call(
      g,
      this.subarray(V, X),
      _
    ), pe;
  }, a.prototype.fill = function(g, _, V, X) {
    if (typeof g == "string") {
      if (typeof _ == "string" ? (X = _, _ = 0, V = this.length) : typeof V == "string" && (X = V, V = this.length), X !== void 0 && typeof X != "string")
        throw new TypeError("encoding must be a string");
      if (typeof X == "string" && !a.isEncoding(X))
        throw new TypeError("Unknown encoding: " + X);
      if (g.length === 1) {
        const ye = g.charCodeAt(0);
        (X === "utf8" && ye < 128 || X === "latin1") && (g = ye);
      }
    } else
      typeof g == "number" ? g = g & 255 : typeof g == "boolean" && (g = Number(g));
    if (_ < 0 || this.length < _ || this.length < V)
      throw new RangeError("Out of range index");
    if (V <= _)
      return this;
    _ = _ >>> 0, V = V === void 0 ? this.length : V >>> 0, g || (g = 0);
    let pe;
    if (typeof g == "number")
      for (pe = _; pe < V; ++pe)
        this[pe] = g;
    else {
      const ye = a.isBuffer(g) ? g : a.from(g, X), Ge = ye.length;
      if (Ge === 0)
        throw new TypeError('The value "' + g + '" is invalid for argument "value"');
      for (pe = 0; pe < V - _; ++pe)
        this[pe + _] = ye[pe % Ge];
    }
    return this;
  };
  const Y = {};
  function ve(x, g, _) {
    Y[x] = class extends _ {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: g.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${x}]`, this.stack, delete this.name;
      }
      get code() {
        return x;
      }
      set code(X) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: X,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${x}]: ${this.message}`;
      }
    };
  }
  ve(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(x) {
      return x ? `${x} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), ve(
    "ERR_INVALID_ARG_TYPE",
    function(x, g) {
      return `The "${x}" argument must be of type number. Received type ${typeof g}`;
    },
    TypeError
  ), ve(
    "ERR_OUT_OF_RANGE",
    function(x, g, _) {
      let V = `The value of "${x}" is out of range.`, X = _;
      return Number.isInteger(_) && Math.abs(_) > 2 ** 32 ? X = oe(String(_)) : typeof _ == "bigint" && (X = String(_), (_ > BigInt(2) ** BigInt(32) || _ < -(BigInt(2) ** BigInt(32))) && (X = oe(X)), X += "n"), V += ` It must be ${g}. Received ${X}`, V;
    },
    RangeError
  );
  function oe(x) {
    let g = "", _ = x.length;
    const V = x[0] === "-" ? 1 : 0;
    for (; _ >= V + 4; _ -= 3)
      g = `_${x.slice(_ - 3, _)}${g}`;
    return `${x.slice(0, _)}${g}`;
  }
  function S(x, g, _) {
    O(g, "offset"), (x[g] === void 0 || x[g + _] === void 0) && I(g, x.length - (_ + 1));
  }
  function $(x, g, _, V, X, pe) {
    if (x > _ || x < g) {
      const ye = typeof g == "bigint" ? "n" : "";
      let Ge;
      throw pe > 3 ? g === 0 || g === BigInt(0) ? Ge = `>= 0${ye} and < 2${ye} ** ${(pe + 1) * 8}${ye}` : Ge = `>= -(2${ye} ** ${(pe + 1) * 8 - 1}${ye}) and < 2 ** ${(pe + 1) * 8 - 1}${ye}` : Ge = `>= ${g}${ye} and <= ${_}${ye}`, new Y.ERR_OUT_OF_RANGE("value", Ge, x);
    }
    S(V, X, pe);
  }
  function O(x, g) {
    if (typeof x != "number")
      throw new Y.ERR_INVALID_ARG_TYPE(g, "number", x);
  }
  function I(x, g, _) {
    throw Math.floor(x) !== x ? (O(x, _), new Y.ERR_OUT_OF_RANGE(_ || "offset", "an integer", x)) : g < 0 ? new Y.ERR_BUFFER_OUT_OF_BOUNDS() : new Y.ERR_OUT_OF_RANGE(
      _ || "offset",
      `>= ${_ ? 1 : 0} and <= ${g}`,
      x
    );
  }
  const L = /[^+/0-9A-Za-z-_]/g;
  function H(x) {
    if (x = x.split("=")[0], x = x.trim().replace(L, ""), x.length < 2)
      return "";
    for (; x.length % 4 !== 0; )
      x = x + "=";
    return x;
  }
  function ae(x, g) {
    g = g || 1 / 0;
    let _;
    const V = x.length;
    let X = null;
    const pe = [];
    for (let ye = 0; ye < V; ++ye) {
      if (_ = x.charCodeAt(ye), _ > 55295 && _ < 57344) {
        if (!X) {
          if (_ > 56319) {
            (g -= 3) > -1 && pe.push(239, 191, 189);
            continue;
          } else if (ye + 1 === V) {
            (g -= 3) > -1 && pe.push(239, 191, 189);
            continue;
          }
          X = _;
          continue;
        }
        if (_ < 56320) {
          (g -= 3) > -1 && pe.push(239, 191, 189), X = _;
          continue;
        }
        _ = (X - 55296 << 10 | _ - 56320) + 65536;
      } else
        X && (g -= 3) > -1 && pe.push(239, 191, 189);
      if (X = null, _ < 128) {
        if ((g -= 1) < 0)
          break;
        pe.push(_);
      } else if (_ < 2048) {
        if ((g -= 2) < 0)
          break;
        pe.push(
          _ >> 6 | 192,
          _ & 63 | 128
        );
      } else if (_ < 65536) {
        if ((g -= 3) < 0)
          break;
        pe.push(
          _ >> 12 | 224,
          _ >> 6 & 63 | 128,
          _ & 63 | 128
        );
      } else if (_ < 1114112) {
        if ((g -= 4) < 0)
          break;
        pe.push(
          _ >> 18 | 240,
          _ >> 12 & 63 | 128,
          _ >> 6 & 63 | 128,
          _ & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return pe;
  }
  function Ee(x) {
    const g = [];
    for (let _ = 0; _ < x.length; ++_)
      g.push(x.charCodeAt(_) & 255);
    return g;
  }
  function Oe(x, g) {
    let _, V, X;
    const pe = [];
    for (let ye = 0; ye < x.length && !((g -= 2) < 0); ++ye)
      _ = x.charCodeAt(ye), V = _ >> 8, X = _ % 256, pe.push(X), pe.push(V);
    return pe;
  }
  function Te(x) {
    return t.toByteArray(H(x));
  }
  function Me(x, g, _, V) {
    let X;
    for (X = 0; X < V && !(X + _ >= g.length || X >= x.length); ++X)
      g[X + _] = x[X];
    return X;
  }
  function we(x, g) {
    return x instanceof g || x != null && x.constructor != null && x.constructor.name != null && x.constructor.name === g.name;
  }
  function Le(x) {
    return x !== x;
  }
  const ut = function() {
    const x = "0123456789abcdef", g = new Array(256);
    for (let _ = 0; _ < 16; ++_) {
      const V = _ * 16;
      for (let X = 0; X < 16; ++X)
        g[V + X] = x[_] + x[X];
    }
    return g;
  }();
  function Je(x) {
    return typeof BigInt > "u" ? bt : x;
  }
  function bt() {
    throw new Error("BigInt not supported");
  }
})(jn);
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(e, t) {
  var n = jn, r = n.Buffer;
  function i(o, a) {
    for (var l in o)
      a[l] = o[l];
  }
  r.from && r.alloc && r.allocUnsafe && r.allocUnsafeSlow ? e.exports = n : (i(n, t), t.Buffer = s);
  function s(o, a, l) {
    return r(o, a, l);
  }
  s.prototype = Object.create(r.prototype), i(r, s), s.from = function(o, a, l) {
    if (typeof o == "number")
      throw new TypeError("Argument must not be a number");
    return r(o, a, l);
  }, s.alloc = function(o, a, l) {
    if (typeof o != "number")
      throw new TypeError("Argument must be a number");
    var c = r(o);
    return a !== void 0 ? typeof l == "string" ? c.fill(a, l) : c.fill(a) : c.fill(0), c;
  }, s.allocUnsafe = function(o) {
    if (typeof o != "number")
      throw new TypeError("Argument must be a number");
    return r(o);
  }, s.allocUnsafeSlow = function(o) {
    if (typeof o != "number")
      throw new TypeError("Argument must be a number");
    return n.SlowBuffer(o);
  };
})(Uf, Uf.exports);
var hb = Uf.exports;
/*!
 * content-disposition
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
qd.exports = U$;
qd.exports.parse = z$;
var _m = at.basename, A$ = hb.Buffer, x$ = /[\x00-\x20"'()*,/:;<=>?@[\\\]{}\x7f]/g, D$ = /%[0-9A-Fa-f]{2}/, P$ = /%([0-9A-Fa-f]{2})/g, mb = /[^\x20-\x7e\xa0-\xff]/g, k$ = /\\([\u0000-\u007f])/g, L$ = /([\\"])/g, wm = /;[\x09\x20]*([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*=[\x09\x20]*("(?:[\x20!\x23-\x5b\x5d-\x7e\x80-\xff]|\\[\x20-\x7e])*"|[!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*/g, j$ = /^[\x20-\x7e\x80-\xff]+$/, C$ = /^[!#$%&'*+.0-9A-Z^_`a-z|~-]+$/, M$ = /^([A-Za-z0-9!#$%&+\-^_`{}~]+)'(?:[A-Za-z]{2,3}(?:-[A-Za-z]{3}){0,3}|[A-Za-z]{4,8}|)'((?:%[0-9A-Fa-f]{2}|[A-Za-z0-9!#$&+.^_`|~-])+)$/, F$ = /^([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*(?:$|;)/;
function U$(e, t) {
  var n = t || {}, r = n.type || "attachment", i = V$(e, n.fallback);
  return B$(new gb(r, i));
}
function V$(e, t) {
  if (e !== void 0) {
    var n = {};
    if (typeof e != "string")
      throw new TypeError("filename must be a string");
    if (t === void 0 && (t = !0), typeof t != "string" && typeof t != "boolean")
      throw new TypeError("fallback must be a string or boolean");
    if (typeof t == "string" && mb.test(t))
      throw new TypeError("fallback must be ISO-8859-1 string");
    var r = _m(e), i = j$.test(r), s = typeof t != "string" ? t && yb(r) : _m(t), o = typeof s == "string" && s !== r;
    return (o || !i || D$.test(r)) && (n["filename*"] = r), (i || o) && (n.filename = o ? s : r), n;
  }
}
function B$(e) {
  var t = e.parameters, n = e.type;
  if (!n || typeof n != "string" || !C$.test(n))
    throw new TypeError("invalid type");
  var r = String(n).toLowerCase();
  if (t && typeof t == "object")
    for (var i, s = Object.keys(t).sort(), o = 0; o < s.length; o++) {
      i = s[o];
      var a = i.substr(-1) === "*" ? Q$(t[i]) : W$(t[i]);
      r += "; " + i + "=" + a;
    }
  return r;
}
function G$(e) {
  var t = M$.exec(e);
  if (!t)
    throw new TypeError("invalid extended field value");
  var n = t[1].toLowerCase(), r = t[2], i, s = r.replace(P$, q$);
  switch (n) {
    case "iso-8859-1":
      i = yb(s);
      break;
    case "utf-8":
      i = A$.from(s, "binary").toString("utf8");
      break;
    default:
      throw new TypeError("unsupported charset in extended field");
  }
  return i;
}
function yb(e) {
  return String(e).replace(mb, "?");
}
function z$(e) {
  if (!e || typeof e != "string")
    throw new TypeError("argument string is required");
  var t = F$.exec(e);
  if (!t)
    throw new TypeError("invalid type format");
  var n = t[0].length, r = t[1].toLowerCase(), i, s = [], o = {}, a;
  for (n = wm.lastIndex = t[0].substr(-1) === ";" ? n - 1 : n; t = wm.exec(e); ) {
    if (t.index !== n)
      throw new TypeError("invalid parameter format");
    if (n += t[0].length, i = t[1].toLowerCase(), a = t[2], s.indexOf(i) !== -1)
      throw new TypeError("invalid duplicate parameter");
    if (s.push(i), i.indexOf("*") + 1 === i.length) {
      i = i.slice(0, -1), a = G$(a), o[i] = a;
      continue;
    }
    typeof o[i] != "string" && (a[0] === '"' && (a = a.substr(1, a.length - 2).replace(k$, "$1")), o[i] = a);
  }
  if (n !== -1 && n !== e.length)
    throw new TypeError("invalid parameter format");
  return new gb(r, o);
}
function q$(e, t) {
  return String.fromCharCode(parseInt(t, 16));
}
function H$(e) {
  return "%" + String(e).charCodeAt(0).toString(16).toUpperCase();
}
function W$(e) {
  var t = String(e);
  return '"' + t.replace(L$, "\\$1") + '"';
}
function Q$(e) {
  var t = String(e), n = encodeURIComponent(t).replace(x$, H$);
  return "UTF-8''" + n;
}
function gb(e, t) {
  this.type = e, this.parameters = t;
}
var J$ = qd.exports, Wd = { exports: {} };
function K$(e) {
  var t = new e(), n = t;
  function r() {
    var s = t;
    return s.next ? t = s.next : (t = new e(), n = t), s.next = null, s;
  }
  function i(s) {
    n.next = s, n = s;
  }
  return {
    get: r,
    release: i
  };
}
var bb = K$, Y$ = bb;
function vb(e, t, n) {
  if (typeof e == "function" && (n = t, t = e, e = null), !(n >= 1))
    throw new Error("fastqueue concurrency must be equal to or greater than 1");
  var r = Y$(X$), i = null, s = null, o = 0, a = null, l = {
    push: m,
    drain: In,
    saturated: In,
    pause: u,
    paused: !1,
    get concurrency() {
      return n;
    },
    set concurrency(F) {
      if (!(F >= 1))
        throw new Error("fastqueue concurrency must be equal to or greater than 1");
      if (n = F, !l.paused)
        for (; i && o < n; )
          o++, b();
    },
    running: c,
    resume: p,
    idle: h,
    length: f,
    getQueue: d,
    unshift: v,
    empty: In,
    kill: E,
    killAndDrain: y,
    error: D
  };
  return l;
  function c() {
    return o;
  }
  function u() {
    l.paused = !0;
  }
  function f() {
    for (var F = i, W = 0; F; )
      F = F.next, W++;
    return W;
  }
  function d() {
    for (var F = i, W = []; F; )
      W.push(F.value), F = F.next;
    return W;
  }
  function p() {
    if (l.paused) {
      if (l.paused = !1, i === null) {
        o++, b();
        return;
      }
      for (; i && o < n; )
        o++, b();
    }
  }
  function h() {
    return o === 0 && l.length() === 0;
  }
  function m(F, W) {
    var J = r.get();
    J.context = e, J.release = b, J.value = F, J.callback = W || In, J.errorHandler = a, o >= n || l.paused ? s ? (s.next = J, s = J) : (i = J, s = J, l.saturated()) : (o++, t.call(e, J.value, J.worked));
  }
  function v(F, W) {
    var J = r.get();
    J.context = e, J.release = b, J.value = F, J.callback = W || In, J.errorHandler = a, o >= n || l.paused ? i ? (J.next = i, i = J) : (i = J, s = J, l.saturated()) : (o++, t.call(e, J.value, J.worked));
  }
  function b(F) {
    F && r.release(F);
    var W = i;
    W && o <= n ? l.paused ? o-- : (s === i && (s = null), i = W.next, W.next = null, t.call(e, W.value, W.worked), s === null && l.empty()) : --o === 0 && l.drain();
  }
  function E() {
    i = null, s = null, l.drain = In;
  }
  function y() {
    i = null, s = null, l.drain(), l.drain = In;
  }
  function D(F) {
    a = F;
  }
}
function In() {
}
function X$() {
  this.value = null, this.callback = In, this.next = null, this.release = In, this.context = null, this.errorHandler = null;
  var e = this;
  this.worked = function(n, r) {
    var i = e.callback, s = e.errorHandler, o = e.value;
    e.value = null, e.callback = In, e.errorHandler && s(n, o), i.call(e.context, n, r), e.release(e);
  };
}
function Z$(e, t, n) {
  typeof e == "function" && (n = t, t = e, e = null);
  function r(u, f) {
    t.call(this, u).then(function(d) {
      f(null, d);
    }, f);
  }
  var i = vb(e, r, n), s = i.push, o = i.unshift;
  return i.push = a, i.unshift = l, i.drained = c, i;
  function a(u) {
    var f = new Promise(function(d, p) {
      s(u, function(h, m) {
        if (h) {
          p(h);
          return;
        }
        d(m);
      });
    });
    return f.catch(In), f;
  }
  function l(u) {
    var f = new Promise(function(d, p) {
      o(u, function(h, m) {
        if (h) {
          p(h);
          return;
        }
        d(m);
      });
    });
    return f.catch(In), f;
  }
  function c() {
    if (i.idle())
      return new Promise(function(d) {
        d();
      });
    var u = i.drain, f = new Promise(function(d) {
      i.drain = function() {
        u(), d();
      };
    });
    return f;
  }
}
Wd.exports = vb;
Wd.exports.promise = Z$;
var e1 = Wd.exports;
const t1 = at, mn = at, Fa = at, Em = e1, Sm = Math.max(1, t1.cpus().length - 1), xi = {
  _getExtendedInfo: async function(e, t) {
    const n = e.split(mn.sep).length, r = await Fa.readdir(e), i = async (o) => {
      const a = mn.join(e, o);
      let l;
      try {
        l = await Fa.stat(a);
      } catch {
        return;
      }
      l.isDirectory() ? (t.totalFolderCount++, a.split(mn.sep).length === n + 1 && t.folderCount++, await xi._getExtendedInfo(a, t)) : (t.totalSize += l.size, t.totalFileCount++, a.split(mn.sep).length === n + 1 && t.fileCount++, t.lastModified = Math.max(t.lastModified, l.mtimeMs));
    }, s = Em.promise(i, Sm);
    await Promise.all(r.map((o) => s.push(o)));
  },
  /**
   * get extended info about a folder
   * @param {string} folderPath full path fs dir
   * @return {Promise<ExtendedInfo>}
   */
  getExtendedInfo: async function(e) {
    const t = {
      totalSize: 0,
      fileCount: 0,
      totalFileCount: 0,
      folderCount: 0,
      totalFolderCount: 0,
      lastModified: 0
    };
    return await xi._getExtendedInfo(e, t), t;
  },
  /**
   * get files and dirs from dir, or error
   * @param {string} dir full path fs dir
   * @param {(boolean | ListOptionsJsonFormat | ListOptionsHtmlFormat)} options
   * @param {string} dotfiles
   * note: can't use glob because don't get error on non existing dir
   */
  list: async function(e, t, n) {
    const r = { dirs: [], files: [] };
    let i = await Fa.readdir(e);
    if ((n === "deny" || n === "ignore") && (i = i.filter((a) => a.charAt(0) !== ".")), i.length < 1)
      return r;
    const s = async (a) => {
      let l;
      try {
        l = await Fa.stat(mn.join(e, a));
      } catch {
        return;
      }
      const c = { name: a, stats: l };
      l.isDirectory() ? (t.extendedFolderInfo && (c.extendedInfo = await xi.getExtendedInfo(mn.join(e, a))), r.dirs.push(c)) : r.files.push(c);
    }, o = Em.promise(s, Sm);
    return await Promise.all(i.map((a) => o.push(a))), r.dirs.sort((a, l) => a.name.localeCompare(l.name)), r.files.sort((a, l) => a.name.localeCompare(l.name)), r;
  },
  /**
   * send dir list content, or 404 on error
   * @param {Fastify.Reply} reply
   * @param {string} dir full path fs dir
   * @param {(boolean | ListOptionsJsonFormat | ListOptionsHtmlFormat)} options
   * @param {string} route request route
   * @param {string} dotfiles
   */
  send: async function({ reply: e, dir: t, options: n, route: r, prefix: i, dotfiles: s }) {
    if (e.request.query.format === "html" && typeof n.render != "function")
      throw new Error("The `list.render` option must be a function and is required with the URL parameter `format=html`");
    let o;
    try {
      o = await xi.list(t, n, s);
    } catch {
      return e.callNotFound();
    }
    if ((e.request.query.format || n.format) !== "html") {
      if (n.jsonFormat !== "extended") {
        const c = { dirs: [], files: [] };
        o.dirs.forEach((u) => c.dirs.push(u.name)), o.files.forEach((u) => c.files.push(u.name)), e.send(c);
      } else
        e.send(o);
      return;
    }
    const l = n.render(
      o.dirs.map((c) => xi.htmlInfo(c, r, i, n)),
      o.files.map((c) => xi.htmlInfo(c, r, i, n))
    );
    e.type("text/html").send(l);
  },
  /**
   * provide the html information about entry and route, to get name and full route
   * @param entry file or dir name and stats
   * @param {string} route request route
   * @return {ListFile}
   */
  htmlInfo: function(e, t, n, r) {
    return r.names?.includes(mn.basename(t)) && (t = mn.normalize(mn.join(t, ".."))), {
      href: encodeURI(mn.join(n, t, e.name).replace(/\\/gu, "/")),
      name: e.name,
      stats: e.stats,
      extendedInfo: e.extendedInfo
    };
  },
  /**
   * say if the route can be handled by dir list or not
   * @param {string} route request route
   * @param {(boolean | ListOptionsJsonFormat | ListOptionsHtmlFormat)} options
   * @return {boolean}
   */
  handle: function(e, t) {
    return t.names?.includes(mn.basename(e)) || // match trailing slash
    ((t.names?.includes("/") && e[e.length - 1] === "/") ?? !1);
  },
  /**
   * get path from route and fs root paths, considering trailing slash
   * @param {string} root fs root path
   * @param {string} route request route
   */
  path: function(e, t) {
    const n = t[t.length - 1] === "/" ? t + "none" : t;
    return mn.dirname(mn.join(e, n));
  },
  /**
   * validate options
   * @return {Error}
   */
  validateOptions: function(e) {
    if (e.list) {
      if (Array.isArray(e.root))
        return new TypeError("multi-root with list option is not supported");
      if (e.list.format && e.list.format !== "json" && e.list.format !== "html")
        return new TypeError("The `list.format` option must be json or html");
      if (e.list.names && !Array.isArray(e.list.names))
        return new TypeError("The `list.names` option must be an array");
      if (e.list.jsonFormat != null && e.list.jsonFormat !== "names" && e.list.jsonFormat !== "extended")
        return new TypeError("The `list.jsonFormat` option must be name or extended");
      if (e.list.format === "html" && typeof e.list.render != "function")
        return new TypeError("The `list.render` option must be a function and is required with html format");
    }
  }
};
var n1 = xi;
const { PassThrough: r1 } = at, Zr = at, { fileURLToPath: Tm } = at, { statSync: _b } = at, { glob: i1 } = N0, s1 = oa, xo = v$, o1 = w$, a1 = J$, co = n1, $m = /\/$/u, l1 = /\*/gu, u1 = ["br", "gzip", "deflate"];
xo.mime.default_type = "application/octet-stream";
async function Qd(e, t) {
  t.root = c1(t.root), f1(e, t.root);
  const n = t.setHeaders;
  if (n !== void 0 && typeof n != "function")
    throw new TypeError("The `setHeaders` option must be a function");
  const r = co.validateOptions(t);
  if (r)
    throw r;
  t.dotfiles === void 0 && (t.dotfiles = "allow");
  const i = {
    root: t.root,
    acceptRanges: t.acceptRanges,
    cacheControl: t.cacheControl,
    dotfiles: t.dotfiles,
    etag: t.etag,
    extensions: t.extensions,
    immutable: t.immutable,
    index: t.index,
    lastModified: t.lastModified,
    maxAge: t.maxAge
  };
  let s = t.prefix ?? (t.prefix = "/");
  t.prefixAvoidTrailingSlash || (s = s[s.length - 1] === "/" ? s : s + "/");
  const o = {
    constraints: t.constraints,
    schema: {
      hide: t.schemaHide !== void 0 ? t.schemaHide : !0
    },
    errorHandler(f, d, p) {
      if (f?.code === "ERR_STREAM_PREMATURE_CLOSE") {
        p.request.raw.destroy();
        return;
      }
      e.errorHandler(f, d, p);
    }
  };
  if (t.decorateReply !== !1 && (e.decorateReply("sendFile", function(f, d, p) {
    const h = typeof d == "object" ? d : p, m = typeof d == "string" ? d : h && h.root;
    return l(
      this.request,
      this,
      f,
      m || i.root,
      0,
      h
    ), this;
  }), e.decorateReply(
    "download",
    function(f, d, p = {}) {
      const { root: h, ...m } = typeof d == "object" ? d : p;
      return d = typeof d == "string" ? d : f, this.header("content-disposition", a1(d)), l(this.request, this, f, h, 0, m), this;
    }
  )), t.serve !== !1) {
    if (t.wildcard && typeof t.wildcard != "boolean")
      throw new Error('"wildcard" option must be a boolean');
    if (t.wildcard === void 0 || t.wildcard === !0)
      e.route({
        ...o,
        method: ["HEAD", "GET"],
        path: s + "*",
        handler(f, d) {
          l(f, d, "/" + f.params["*"], i.root);
        }
      }), t.redirect === !0 && s !== t.prefix && e.get(t.prefix, o, (f, d) => {
        d.redirect(301, Im(f.raw.url));
      });
    else {
      const f = t.index === void 0 ? ["index.html"] : [].concat(t.index), d = /* @__PURE__ */ new Map(), p = /* @__PURE__ */ new Set(), h = Array.isArray(i.root) ? i.root : [i.root];
      for (let m of h) {
        m = m.split(Zr.win32.sep).join(Zr.posix.sep), !m.endsWith("/") && (m += "/");
        const v = await i1("**/**", {
          cwd: m,
          absolute: !1,
          follow: !0,
          nodir: !0,
          dot: t.serveDotFiles
        });
        for (let b of v) {
          b = b.split(Zr.win32.sep).join(Zr.posix.sep);
          const E = s + b;
          if (p.has(E))
            continue;
          p.add(E), c(o, E, `/${b}`, m);
          const y = Zr.posix.basename(E);
          f.includes(y) && !d.has(y) && d.set(Zr.posix.dirname(E), m);
        }
      }
      for (const [m, v] of d.entries()) {
        const b = m + (m.endsWith("/") ? "" : "/"), E = "/" + b.replace(s, "");
        c(o, b, E, v), t.redirect === !0 && c(o, b.replace($m, ""), E.replace($m, ""), v);
      }
    }
  }
  const a = t.allowedPath;
  function l(f, d, p, h, m = 0, v, b) {
    const E = p, y = Object.assign({}, i, v);
    if (h && (Array.isArray(h) ? y.root = h[m] : y.root = h), a && !a(p, y.root, f))
      return d.callNotFound();
    let D, F = p;
    if (t.preCompressed && (b || (b = /* @__PURE__ */ new Set()), D = p1(f.headers, b), D))
      if (p.endsWith("/")) {
        if (p = zc(p, y.root, y.index), !p)
          return d.callNotFound();
        F = F + p + "." + Om(D);
      } else
        F = p + "." + Om(D);
    const W = xo(f.raw, encodeURI(F), y);
    let J;
    W.on("file", function(j) {
      J = j;
    });
    const Z = new r1({
      flush(j) {
        this.finished = !0, d.raw.statusCode === 304 && d.send(""), j();
      }
    });
    Z.getHeader = d.getHeader.bind(d), Z.setHeader = d.header.bind(d), Z.removeHeader = () => {
    }, Z.finished = !1, Object.defineProperty(Z, "filename", {
      get() {
        return J;
      }
    }), Object.defineProperty(Z, "statusCode", {
      get() {
        return d.raw.statusCode;
      },
      set(j) {
        d.code(j);
      }
    }), f.method === "HEAD" ? Z.on("finish", d.send.bind(d)) : Z.on("pipe", function() {
      D && (d.header("content-type", d1(p)), d.header("content-encoding", D)), d.send(Z);
    }), n !== void 0 && W.on("headers", n), W.on("directory", function(j, ee) {
      if (t.list) {
        co.send({
          reply: d,
          dir: ee,
          options: t.list,
          route: p,
          prefix: s,
          dotfiles: t.dotfiles
        }).catch((le) => d.send(le));
        return;
      }
      if (t.redirect === !0)
        try {
          d.redirect(301, Im(f.raw.url));
        } catch (le) {
          d.send(le);
        }
      else {
        if (!p.endsWith("/") && zc(p, y.root, y.index))
          return l(
            f,
            d,
            p + "/",
            h,
            void 0,
            void 0,
            b
          );
        d.callNotFound();
      }
    }), W.on("error", function(j) {
      if (j.code === "ENOENT") {
        if (t.preCompressed && D && zc(p, y.root, y.index))
          return l(
            f,
            d,
            p + "/",
            h,
            void 0,
            void 0,
            b
          );
        if (t.list && co.handle(p, t.list)) {
          co.send({
            reply: d,
            dir: co.path(t.root, p),
            options: t.list,
            route: p,
            prefix: s,
            dotfiles: t.dotfiles
          }).catch((ee) => d.send(ee));
          return;
        }
        return Array.isArray(h) && m < h.length - 1 ? l(f, d, p, h, m + 1) : t.preCompressed && !b.has(D) ? (b.add(D), l(
          f,
          d,
          E,
          h,
          m,
          void 0,
          b
        )) : d.callNotFound();
      }
      if (j.status === 404)
        return d.callNotFound();
      d.send(j);
    }), W.pipe(Z);
  }
  function c(f, d, p, h) {
    const m = Object.assign({}, f, {
      method: ["HEAD", "GET"],
      url: d,
      handler: u
    });
    m.config = m.config || {}, m.config.file = p, m.config.rootPath = h, e.route(m);
  }
  function u(f, d) {
    const p = f.routeOptions?.config || f.routeConfig;
    l(f, d, p.file, p.rootPath);
  }
}
function c1(e) {
  if (e === void 0)
    return e;
  if (e instanceof URL && e.protocol === "file:")
    return Tm(e);
  if (Array.isArray(e)) {
    const t = [];
    for (let n = 0, r = e.length; n < r; ++n)
      e[n] instanceof URL && e[n].protocol === "file:" ? t.push(Tm(e[n])) : t.push(e[n]);
    return t;
  }
  return e;
}
function f1(e, t) {
  if (t === void 0)
    throw new Error('"root" option is required');
  if (Array.isArray(t)) {
    if (!t.length)
      throw new Error('"root" option array requires one or more paths');
    if (new Set(t).size !== t.length)
      throw new Error(
        '"root" option array contains one or more duplicate paths'
      );
    t.map((n) => Nm(e, n));
    return;
  }
  if (typeof t == "string")
    return Nm(e, t);
  throw new Error('"root" option must be a string or array of strings');
}
function Nm(e, t) {
  if (typeof t != "string")
    throw new Error('"root" option must be a string');
  if (Zr.isAbsolute(t) === !1)
    throw new Error('"root" option must be an absolute path');
  let n;
  try {
    n = _b(t);
  } catch (r) {
    if (r.code === "ENOENT") {
      e.log.warn(`"root" path "${t}" must exist`);
      return;
    }
    throw r;
  }
  if (n.isDirectory() === !1)
    throw new Error('"root" option must point to a directory');
}
function d1(e) {
  const t = xo.mime.getType(e) || xo.mime.default_type;
  return xo.isUtf8MimeType(t) ? `${t}; charset=UTF-8` : t;
}
function zc(e, t, n = ["index.html"]) {
  return Array.isArray(n) ? n.find((r) => {
    const i = Zr.join(t, e, r);
    try {
      return !_b(i).isDirectory();
    } catch {
      return !1;
    }
  }) : !1;
}
function p1(e, t) {
  if (!("accept-encoding" in e))
    return;
  const n = e["accept-encoding"].toLowerCase().replace(l1, "gzip");
  return o1.negotiate(
    n,
    u1.filter((r) => !t.has(r))
  );
}
function Om(e) {
  switch (e) {
    case "br":
      return "br";
    case "gzip":
      return "gz";
  }
}
function Im(e) {
  let t = 0;
  for (; t < e.length && !(e[t] !== "/" && e[t] !== "\\"); ++t)
    ;
  e = "/" + e.substr(t);
  try {
    const n = new URL(e, "http://localhost.com/"), r = n.pathname;
    return r + (r[r.length - 1] !== "/" ? "/" : "") + (n.search || "");
  } catch {
    const n = new Error(`Invalid redirect URL: ${e}`);
    throw n.statusCode = 400, n;
  }
}
cu.exports = s1(Qd, {
  fastify: "4.x",
  name: "@fastify/static"
});
cu.exports.default = Qd;
cu.exports.fastifyStatic = Qd;
var h1 = cu.exports, gu = { exports: {} }, m1 = function() {
  throw new Error(
    "ws does not work in the browser. Browser clients must use the native WebSocket object"
  );
}, Vf = { exports: {} }, Jd = { exports: {} }, ps = typeof Reflect == "object" ? Reflect : null, Rm = ps && typeof ps.apply == "function" ? ps.apply : function(t, n, r) {
  return Function.prototype.apply.call(t, n, r);
}, dl;
ps && typeof ps.ownKeys == "function" ? dl = ps.ownKeys : Object.getOwnPropertySymbols ? dl = function(t) {
  return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t));
} : dl = function(t) {
  return Object.getOwnPropertyNames(t);
};
function y1(e) {
  console && console.warn && console.warn(e);
}
var wb = Number.isNaN || function(t) {
  return t !== t;
};
function mt() {
  mt.init.call(this);
}
Jd.exports = mt;
Jd.exports.once = _1;
mt.EventEmitter = mt;
mt.prototype._events = void 0;
mt.prototype._eventsCount = 0;
mt.prototype._maxListeners = void 0;
var Am = 10;
function bu(e) {
  if (typeof e != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e);
}
Object.defineProperty(mt, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return Am;
  },
  set: function(e) {
    if (typeof e != "number" || e < 0 || wb(e))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e + ".");
    Am = e;
  }
});
mt.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
mt.prototype.setMaxListeners = function(t) {
  if (typeof t != "number" || t < 0 || wb(t))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + ".");
  return this._maxListeners = t, this;
};
function Eb(e) {
  return e._maxListeners === void 0 ? mt.defaultMaxListeners : e._maxListeners;
}
mt.prototype.getMaxListeners = function() {
  return Eb(this);
};
mt.prototype.emit = function(t) {
  for (var n = [], r = 1; r < arguments.length; r++)
    n.push(arguments[r]);
  var i = t === "error", s = this._events;
  if (s !== void 0)
    i = i && s.error === void 0;
  else if (!i)
    return !1;
  if (i) {
    var o;
    if (n.length > 0 && (o = n[0]), o instanceof Error)
      throw o;
    var a = new Error("Unhandled error." + (o ? " (" + o.message + ")" : ""));
    throw a.context = o, a;
  }
  var l = s[t];
  if (l === void 0)
    return !1;
  if (typeof l == "function")
    Rm(l, this, n);
  else
    for (var c = l.length, u = Ob(l, c), r = 0; r < c; ++r)
      Rm(u[r], this, n);
  return !0;
};
function Sb(e, t, n, r) {
  var i, s, o;
  if (bu(n), s = e._events, s === void 0 ? (s = e._events = /* @__PURE__ */ Object.create(null), e._eventsCount = 0) : (s.newListener !== void 0 && (e.emit(
    "newListener",
    t,
    n.listener ? n.listener : n
  ), s = e._events), o = s[t]), o === void 0)
    o = s[t] = n, ++e._eventsCount;
  else if (typeof o == "function" ? o = s[t] = r ? [n, o] : [o, n] : r ? o.unshift(n) : o.push(n), i = Eb(e), i > 0 && o.length > i && !o.warned) {
    o.warned = !0;
    var a = new Error("Possible EventEmitter memory leak detected. " + o.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    a.name = "MaxListenersExceededWarning", a.emitter = e, a.type = t, a.count = o.length, y1(a);
  }
  return e;
}
mt.prototype.addListener = function(t, n) {
  return Sb(this, t, n, !1);
};
mt.prototype.on = mt.prototype.addListener;
mt.prototype.prependListener = function(t, n) {
  return Sb(this, t, n, !0);
};
function g1() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function Tb(e, t, n) {
  var r = { fired: !1, wrapFn: void 0, target: e, type: t, listener: n }, i = g1.bind(r);
  return i.listener = n, r.wrapFn = i, i;
}
mt.prototype.once = function(t, n) {
  return bu(n), this.on(t, Tb(this, t, n)), this;
};
mt.prototype.prependOnceListener = function(t, n) {
  return bu(n), this.prependListener(t, Tb(this, t, n)), this;
};
mt.prototype.removeListener = function(t, n) {
  var r, i, s, o, a;
  if (bu(n), i = this._events, i === void 0)
    return this;
  if (r = i[t], r === void 0)
    return this;
  if (r === n || r.listener === n)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete i[t], i.removeListener && this.emit("removeListener", t, r.listener || n));
  else if (typeof r != "function") {
    for (s = -1, o = r.length - 1; o >= 0; o--)
      if (r[o] === n || r[o].listener === n) {
        a = r[o].listener, s = o;
        break;
      }
    if (s < 0)
      return this;
    s === 0 ? r.shift() : b1(r, s), r.length === 1 && (i[t] = r[0]), i.removeListener !== void 0 && this.emit("removeListener", t, a || n);
  }
  return this;
};
mt.prototype.off = mt.prototype.removeListener;
mt.prototype.removeAllListeners = function(t) {
  var n, r, i;
  if (r = this._events, r === void 0)
    return this;
  if (r.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : r[t] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete r[t]), this;
  if (arguments.length === 0) {
    var s = Object.keys(r), o;
    for (i = 0; i < s.length; ++i)
      o = s[i], o !== "removeListener" && this.removeAllListeners(o);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (n = r[t], typeof n == "function")
    this.removeListener(t, n);
  else if (n !== void 0)
    for (i = n.length - 1; i >= 0; i--)
      this.removeListener(t, n[i]);
  return this;
};
function $b(e, t, n) {
  var r = e._events;
  if (r === void 0)
    return [];
  var i = r[t];
  return i === void 0 ? [] : typeof i == "function" ? n ? [i.listener || i] : [i] : n ? v1(i) : Ob(i, i.length);
}
mt.prototype.listeners = function(t) {
  return $b(this, t, !0);
};
mt.prototype.rawListeners = function(t) {
  return $b(this, t, !1);
};
mt.listenerCount = function(e, t) {
  return typeof e.listenerCount == "function" ? e.listenerCount(t) : Nb.call(e, t);
};
mt.prototype.listenerCount = Nb;
function Nb(e) {
  var t = this._events;
  if (t !== void 0) {
    var n = t[e];
    if (typeof n == "function")
      return 1;
    if (n !== void 0)
      return n.length;
  }
  return 0;
}
mt.prototype.eventNames = function() {
  return this._eventsCount > 0 ? dl(this._events) : [];
};
function Ob(e, t) {
  for (var n = new Array(t), r = 0; r < t; ++r)
    n[r] = e[r];
  return n;
}
function b1(e, t) {
  for (; t + 1 < e.length; t++)
    e[t] = e[t + 1];
  e.pop();
}
function v1(e) {
  for (var t = new Array(e.length), n = 0; n < t.length; ++n)
    t[n] = e[n].listener || e[n];
  return t;
}
function _1(e, t) {
  return new Promise(function(n, r) {
    function i(o) {
      e.removeListener(t, s), r(o);
    }
    function s() {
      typeof e.removeListener == "function" && e.removeListener("error", i), n([].slice.call(arguments));
    }
    Ib(e, t, s, { once: !0 }), t !== "error" && w1(e, i, { once: !0 });
  });
}
function w1(e, t, n) {
  typeof e.on == "function" && Ib(e, "error", t, n);
}
function Ib(e, t, n, r) {
  if (typeof e.on == "function")
    r.once ? e.once(t, n) : e.on(t, n);
  else if (typeof e.addEventListener == "function")
    e.addEventListener(t, function i(s) {
      r.once && e.removeEventListener(t, i), n(s);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e);
}
var Ji = Jd.exports, Rb = Ji.EventEmitter, qc, xm;
function E1() {
  if (xm)
    return qc;
  xm = 1;
  function e(h, m) {
    var v = Object.keys(h);
    if (Object.getOwnPropertySymbols) {
      var b = Object.getOwnPropertySymbols(h);
      m && (b = b.filter(function(E) {
        return Object.getOwnPropertyDescriptor(h, E).enumerable;
      })), v.push.apply(v, b);
    }
    return v;
  }
  function t(h) {
    for (var m = 1; m < arguments.length; m++) {
      var v = arguments[m] != null ? arguments[m] : {};
      m % 2 ? e(Object(v), !0).forEach(function(b) {
        n(h, b, v[b]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(h, Object.getOwnPropertyDescriptors(v)) : e(Object(v)).forEach(function(b) {
        Object.defineProperty(h, b, Object.getOwnPropertyDescriptor(v, b));
      });
    }
    return h;
  }
  function n(h, m, v) {
    return m = o(m), m in h ? Object.defineProperty(h, m, { value: v, enumerable: !0, configurable: !0, writable: !0 }) : h[m] = v, h;
  }
  function r(h, m) {
    if (!(h instanceof m))
      throw new TypeError("Cannot call a class as a function");
  }
  function i(h, m) {
    for (var v = 0; v < m.length; v++) {
      var b = m[v];
      b.enumerable = b.enumerable || !1, b.configurable = !0, "value" in b && (b.writable = !0), Object.defineProperty(h, o(b.key), b);
    }
  }
  function s(h, m, v) {
    return m && i(h.prototype, m), v && i(h, v), Object.defineProperty(h, "prototype", { writable: !1 }), h;
  }
  function o(h) {
    var m = a(h, "string");
    return typeof m == "symbol" ? m : String(m);
  }
  function a(h, m) {
    if (typeof h != "object" || h === null)
      return h;
    var v = h[Symbol.toPrimitive];
    if (v !== void 0) {
      var b = v.call(h, m || "default");
      if (typeof b != "object")
        return b;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (m === "string" ? String : Number)(h);
  }
  var l = jn, c = l.Buffer, u = at, f = u.inspect, d = f && f.custom || "inspect";
  function p(h, m, v) {
    c.prototype.copy.call(h, m, v);
  }
  return qc = /* @__PURE__ */ function() {
    function h() {
      r(this, h), this.head = null, this.tail = null, this.length = 0;
    }
    return s(h, [{
      key: "push",
      value: function(v) {
        var b = {
          data: v,
          next: null
        };
        this.length > 0 ? this.tail.next = b : this.head = b, this.tail = b, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(v) {
        var b = {
          data: v,
          next: this.head
        };
        this.length === 0 && (this.tail = b), this.head = b, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var v = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, v;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(v) {
        if (this.length === 0)
          return "";
        for (var b = this.head, E = "" + b.data; b = b.next; )
          E += v + b.data;
        return E;
      }
    }, {
      key: "concat",
      value: function(v) {
        if (this.length === 0)
          return c.alloc(0);
        for (var b = c.allocUnsafe(v >>> 0), E = this.head, y = 0; E; )
          p(E.data, b, y), y += E.data.length, E = E.next;
        return b;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(v, b) {
        var E;
        return v < this.head.data.length ? (E = this.head.data.slice(0, v), this.head.data = this.head.data.slice(v)) : v === this.head.data.length ? E = this.shift() : E = b ? this._getString(v) : this._getBuffer(v), E;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(v) {
        var b = this.head, E = 1, y = b.data;
        for (v -= y.length; b = b.next; ) {
          var D = b.data, F = v > D.length ? D.length : v;
          if (F === D.length ? y += D : y += D.slice(0, v), v -= F, v === 0) {
            F === D.length ? (++E, b.next ? this.head = b.next : this.head = this.tail = null) : (this.head = b, b.data = D.slice(F));
            break;
          }
          ++E;
        }
        return this.length -= E, y;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(v) {
        var b = c.allocUnsafe(v), E = this.head, y = 1;
        for (E.data.copy(b), v -= E.data.length; E = E.next; ) {
          var D = E.data, F = v > D.length ? D.length : v;
          if (D.copy(b, b.length - v, 0, F), v -= F, v === 0) {
            F === D.length ? (++y, E.next ? this.head = E.next : this.head = this.tail = null) : (this.head = E, E.data = D.slice(F));
            break;
          }
          ++y;
        }
        return this.length -= y, b;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: d,
      value: function(v, b) {
        return f(this, t(t({}, b), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), h;
  }(), qc;
}
function S1(e, t) {
  var n = this, r = this._readableState && this._readableState.destroyed, i = this._writableState && this._writableState.destroyed;
  return r || i ? (t ? t(e) : e && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, process.nextTick(Bf, this, e)) : process.nextTick(Bf, this, e)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(e || null, function(s) {
    !t && s ? n._writableState ? n._writableState.errorEmitted ? process.nextTick(pl, n) : (n._writableState.errorEmitted = !0, process.nextTick(Dm, n, s)) : process.nextTick(Dm, n, s) : t ? (process.nextTick(pl, n), t(s)) : process.nextTick(pl, n);
  }), this);
}
function Dm(e, t) {
  Bf(e, t), pl(e);
}
function pl(e) {
  e._writableState && !e._writableState.emitClose || e._readableState && !e._readableState.emitClose || e.emit("close");
}
function T1() {
  this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
}
function Bf(e, t) {
  e.emit("error", t);
}
function $1(e, t) {
  var n = e._readableState, r = e._writableState;
  n && n.autoDestroy || r && r.autoDestroy ? e.destroy(t) : e.emit("error", t);
}
var Ab = {
  destroy: S1,
  undestroy: T1,
  errorOrDestroy: $1
}, Ki = {};
function N1(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, e.__proto__ = t;
}
var xb = {};
function Cn(e, t, n) {
  n || (n = Error);
  function r(s, o, a) {
    return typeof t == "string" ? t : t(s, o, a);
  }
  var i = /* @__PURE__ */ function(s) {
    N1(o, s);
    function o(a, l, c) {
      return s.call(this, r(a, l, c)) || this;
    }
    return o;
  }(n);
  i.prototype.name = n.name, i.prototype.code = e, xb[e] = i;
}
function Pm(e, t) {
  if (Array.isArray(e)) {
    var n = e.length;
    return e = e.map(function(r) {
      return String(r);
    }), n > 2 ? "one of ".concat(t, " ").concat(e.slice(0, n - 1).join(", "), ", or ") + e[n - 1] : n === 2 ? "one of ".concat(t, " ").concat(e[0], " or ").concat(e[1]) : "of ".concat(t, " ").concat(e[0]);
  } else
    return "of ".concat(t, " ").concat(String(e));
}
function O1(e, t, n) {
  return e.substr(!n || n < 0 ? 0 : +n, t.length) === t;
}
function I1(e, t, n) {
  return (n === void 0 || n > e.length) && (n = e.length), e.substring(n - t.length, n) === t;
}
function R1(e, t, n) {
  return typeof n != "number" && (n = 0), n + t.length > e.length ? !1 : e.indexOf(t, n) !== -1;
}
Cn("ERR_INVALID_OPT_VALUE", function(e, t) {
  return 'The value "' + t + '" is invalid for option "' + e + '"';
}, TypeError);
Cn("ERR_INVALID_ARG_TYPE", function(e, t, n) {
  var r;
  typeof t == "string" && O1(t, "not ") ? (r = "must not be", t = t.replace(/^not /, "")) : r = "must be";
  var i;
  if (I1(e, " argument"))
    i = "The ".concat(e, " ").concat(r, " ").concat(Pm(t, "type"));
  else {
    var s = R1(e, ".") ? "property" : "argument";
    i = 'The "'.concat(e, '" ').concat(s, " ").concat(r, " ").concat(Pm(t, "type"));
  }
  return i += ". Received type ".concat(typeof n), i;
}, TypeError);
Cn("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
Cn("ERR_METHOD_NOT_IMPLEMENTED", function(e) {
  return "The " + e + " method is not implemented";
});
Cn("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
Cn("ERR_STREAM_DESTROYED", function(e) {
  return "Cannot call " + e + " after a stream was destroyed";
});
Cn("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
Cn("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
Cn("ERR_STREAM_WRITE_AFTER_END", "write after end");
Cn("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
Cn("ERR_UNKNOWN_ENCODING", function(e) {
  return "Unknown encoding: " + e;
}, TypeError);
Cn("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
Ki.codes = xb;
var A1 = Ki.codes.ERR_INVALID_OPT_VALUE;
function x1(e, t, n) {
  return e.highWaterMark != null ? e.highWaterMark : t ? e[n] : null;
}
function D1(e, t, n, r) {
  var i = x1(t, r, n);
  if (i != null) {
    if (!(isFinite(i) && Math.floor(i) === i) || i < 0) {
      var s = r ? n : "highWaterMark";
      throw new A1(s, i);
    }
    return Math.floor(i);
  }
  return e.objectMode ? 16 : 16 * 1024;
}
var Db = {
  getHighWaterMark: D1
}, P1 = k1;
function k1(e, t) {
  if (Hc("noDeprecation"))
    return e;
  var n = !1;
  function r() {
    if (!n) {
      if (Hc("throwDeprecation"))
        throw new Error(t);
      Hc("traceDeprecation") ? console.trace(t) : console.warn(t), n = !0;
    }
    return e.apply(this, arguments);
  }
  return r;
}
function Hc(e) {
  try {
    if (!We.localStorage)
      return !1;
  } catch {
    return !1;
  }
  var t = We.localStorage[e];
  return t == null ? !1 : String(t).toLowerCase() === "true";
}
var Wc, km;
function Pb() {
  if (km)
    return Wc;
  km = 1, Wc = Z;
  function e(k) {
    var q = this;
    this.next = null, this.entry = null, this.finish = function() {
      P(q, k);
    };
  }
  var t;
  Z.WritableState = W;
  var n = {
    deprecate: P1
  }, r = Rb, i = jn.Buffer, s = (typeof We < "u" ? We : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function o(k) {
    return i.from(k);
  }
  function a(k) {
    return i.isBuffer(k) || k instanceof s;
  }
  var l = Ab, c = Db, u = c.getHighWaterMark, f = Ki.codes, d = f.ERR_INVALID_ARG_TYPE, p = f.ERR_METHOD_NOT_IMPLEMENTED, h = f.ERR_MULTIPLE_CALLBACK, m = f.ERR_STREAM_CANNOT_PIPE, v = f.ERR_STREAM_DESTROYED, b = f.ERR_STREAM_NULL_VALUES, E = f.ERR_STREAM_WRITE_AFTER_END, y = f.ERR_UNKNOWN_ENCODING, D = l.errorOrDestroy;
  Qi(Z, r);
  function F() {
  }
  function W(k, q, Y) {
    t = t || ws(), k = k || {}, typeof Y != "boolean" && (Y = q instanceof t), this.objectMode = !!k.objectMode, Y && (this.objectMode = this.objectMode || !!k.writableObjectMode), this.highWaterMark = u(this, k, "writableHighWaterMark", Y), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var ve = k.decodeStrings === !1;
    this.decodeStrings = !ve, this.defaultEncoding = k.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(oe) {
      K(q, oe);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = k.emitClose !== !1, this.autoDestroy = !!k.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new e(this);
  }
  W.prototype.getBuffer = function() {
    for (var q = this.bufferedRequest, Y = []; q; )
      Y.push(q), q = q.next;
    return Y;
  }, function() {
    try {
      Object.defineProperty(W.prototype, "buffer", {
        get: n.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var J;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (J = Function.prototype[Symbol.hasInstance], Object.defineProperty(Z, Symbol.hasInstance, {
    value: function(q) {
      return J.call(this, q) ? !0 : this !== Z ? !1 : q && q._writableState instanceof W;
    }
  })) : J = function(q) {
    return q instanceof this;
  };
  function Z(k) {
    t = t || ws();
    var q = this instanceof t;
    if (!q && !J.call(Z, this))
      return new Z(k);
    this._writableState = new W(k, this, q), this.writable = !0, k && (typeof k.write == "function" && (this._write = k.write), typeof k.writev == "function" && (this._writev = k.writev), typeof k.destroy == "function" && (this._destroy = k.destroy), typeof k.final == "function" && (this._final = k.final)), r.call(this);
  }
  Z.prototype.pipe = function() {
    D(this, new m());
  };
  function j(k, q) {
    var Y = new E();
    D(k, Y), process.nextTick(q, Y);
  }
  function ee(k, q, Y, ve) {
    var oe;
    return Y === null ? oe = new b() : typeof Y != "string" && !q.objectMode && (oe = new d("chunk", ["string", "Buffer"], Y)), oe ? (D(k, oe), process.nextTick(ve, oe), !1) : !0;
  }
  Z.prototype.write = function(k, q, Y) {
    var ve = this._writableState, oe = !1, S = !ve.objectMode && a(k);
    return S && !i.isBuffer(k) && (k = o(k)), typeof q == "function" && (Y = q, q = null), S ? q = "buffer" : q || (q = ve.defaultEncoding), typeof Y != "function" && (Y = F), ve.ending ? j(this, Y) : (S || ee(this, ve, k, Y)) && (ve.pendingcb++, oe = ce(this, ve, S, k, q, Y)), oe;
  }, Z.prototype.cork = function() {
    this._writableState.corked++;
  }, Z.prototype.uncork = function() {
    var k = this._writableState;
    k.corked && (k.corked--, !k.writing && !k.corked && !k.bufferProcessing && k.bufferedRequest && ue(this, k));
  }, Z.prototype.setDefaultEncoding = function(q) {
    if (typeof q == "string" && (q = q.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((q + "").toLowerCase()) > -1))
      throw new y(q);
    return this._writableState.defaultEncoding = q, this;
  }, Object.defineProperty(Z.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function le(k, q, Y) {
    return !k.objectMode && k.decodeStrings !== !1 && typeof q == "string" && (q = i.from(q, Y)), q;
  }
  Object.defineProperty(Z.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function ce(k, q, Y, ve, oe, S) {
    if (!Y) {
      var $ = le(q, ve, oe);
      ve !== $ && (Y = !0, oe = "buffer", ve = $);
    }
    var O = q.objectMode ? 1 : ve.length;
    q.length += O;
    var I = q.length < q.highWaterMark;
    if (I || (q.needDrain = !0), q.writing || q.corked) {
      var L = q.lastBufferedRequest;
      q.lastBufferedRequest = {
        chunk: ve,
        encoding: oe,
        isBuf: Y,
        callback: S,
        next: null
      }, L ? L.next = q.lastBufferedRequest : q.bufferedRequest = q.lastBufferedRequest, q.bufferedRequestCount += 1;
    } else
      U(k, q, !1, O, ve, oe, S);
    return I;
  }
  function U(k, q, Y, ve, oe, S, $) {
    q.writelen = ve, q.writecb = $, q.writing = !0, q.sync = !0, q.destroyed ? q.onwrite(new v("write")) : Y ? k._writev(oe, q.onwrite) : k._write(oe, S, q.onwrite), q.sync = !1;
  }
  function z(k, q, Y, ve, oe) {
    --q.pendingcb, Y ? (process.nextTick(oe, ve), process.nextTick(N, k, q), k._writableState.errorEmitted = !0, D(k, ve)) : (oe(ve), k._writableState.errorEmitted = !0, D(k, ve), N(k, q));
  }
  function ne(k) {
    k.writing = !1, k.writecb = null, k.length -= k.writelen, k.writelen = 0;
  }
  function K(k, q) {
    var Y = k._writableState, ve = Y.sync, oe = Y.writecb;
    if (typeof oe != "function")
      throw new h();
    if (ne(Y), q)
      z(k, Y, ve, q, oe);
    else {
      var S = te(Y) || k.destroyed;
      !S && !Y.corked && !Y.bufferProcessing && Y.bufferedRequest && ue(k, Y), ve ? process.nextTick(se, k, Y, S, oe) : se(k, Y, S, oe);
    }
  }
  function se(k, q, Y, ve) {
    Y || re(k, q), q.pendingcb--, ve(), N(k, q);
  }
  function re(k, q) {
    q.length === 0 && q.needDrain && (q.needDrain = !1, k.emit("drain"));
  }
  function ue(k, q) {
    q.bufferProcessing = !0;
    var Y = q.bufferedRequest;
    if (k._writev && Y && Y.next) {
      var ve = q.bufferedRequestCount, oe = new Array(ve), S = q.corkedRequestsFree;
      S.entry = Y;
      for (var $ = 0, O = !0; Y; )
        oe[$] = Y, Y.isBuf || (O = !1), Y = Y.next, $ += 1;
      oe.allBuffers = O, U(k, q, !0, q.length, oe, "", S.finish), q.pendingcb++, q.lastBufferedRequest = null, S.next ? (q.corkedRequestsFree = S.next, S.next = null) : q.corkedRequestsFree = new e(q), q.bufferedRequestCount = 0;
    } else {
      for (; Y; ) {
        var I = Y.chunk, L = Y.encoding, H = Y.callback, ae = q.objectMode ? 1 : I.length;
        if (U(k, q, !1, ae, I, L, H), Y = Y.next, q.bufferedRequestCount--, q.writing)
          break;
      }
      Y === null && (q.lastBufferedRequest = null);
    }
    q.bufferedRequest = Y, q.bufferProcessing = !1;
  }
  Z.prototype._write = function(k, q, Y) {
    Y(new p("_write()"));
  }, Z.prototype._writev = null, Z.prototype.end = function(k, q, Y) {
    var ve = this._writableState;
    return typeof k == "function" ? (Y = k, k = null, q = null) : typeof q == "function" && (Y = q, q = null), k != null && this.write(k, q), ve.corked && (ve.corked = 1, this.uncork()), ve.ending || T(this, ve, Y), this;
  }, Object.defineProperty(Z.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function te(k) {
    return k.ending && k.length === 0 && k.bufferedRequest === null && !k.finished && !k.writing;
  }
  function B(k, q) {
    k._final(function(Y) {
      q.pendingcb--, Y && D(k, Y), q.prefinished = !0, k.emit("prefinish"), N(k, q);
    });
  }
  function M(k, q) {
    !q.prefinished && !q.finalCalled && (typeof k._final == "function" && !q.destroyed ? (q.pendingcb++, q.finalCalled = !0, process.nextTick(B, k, q)) : (q.prefinished = !0, k.emit("prefinish")));
  }
  function N(k, q) {
    var Y = te(q);
    if (Y && (M(k, q), q.pendingcb === 0 && (q.finished = !0, k.emit("finish"), q.autoDestroy))) {
      var ve = k._readableState;
      (!ve || ve.autoDestroy && ve.endEmitted) && k.destroy();
    }
    return Y;
  }
  function T(k, q, Y) {
    q.ending = !0, N(k, q), Y && (q.finished ? process.nextTick(Y) : k.once("finish", Y)), q.ended = !0, k.writable = !1;
  }
  function P(k, q, Y) {
    var ve = k.entry;
    for (k.entry = null; ve; ) {
      var oe = ve.callback;
      q.pendingcb--, oe(Y), ve = ve.next;
    }
    q.corkedRequestsFree.next = k;
  }
  return Object.defineProperty(Z.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(q) {
      this._writableState && (this._writableState.destroyed = q);
    }
  }), Z.prototype.destroy = l.destroy, Z.prototype._undestroy = l.undestroy, Z.prototype._destroy = function(k, q) {
    q(k);
  }, Wc;
}
var Qc, Lm;
function ws() {
  if (Lm)
    return Qc;
  Lm = 1;
  var e = Object.keys || function(c) {
    var u = [];
    for (var f in c)
      u.push(f);
    return u;
  };
  Qc = o;
  var t = Lb(), n = Pb();
  Qi(o, t);
  for (var r = e(n.prototype), i = 0; i < r.length; i++) {
    var s = r[i];
    o.prototype[s] || (o.prototype[s] = n.prototype[s]);
  }
  function o(c) {
    if (!(this instanceof o))
      return new o(c);
    t.call(this, c), n.call(this, c), this.allowHalfOpen = !0, c && (c.readable === !1 && (this.readable = !1), c.writable === !1 && (this.writable = !1), c.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", a)));
  }
  Object.defineProperty(o.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(o.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(o.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function a() {
    this._writableState.ended || process.nextTick(l, this);
  }
  function l(c) {
    c.end();
  }
  return Object.defineProperty(o.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(u) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = u, this._writableState.destroyed = u);
    }
  }), Qc;
}
var jl = {}, Kd = hb.Buffer, jm = Kd.isEncoding || function(e) {
  switch (e = "" + e, e && e.toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
    case "raw":
      return !0;
    default:
      return !1;
  }
};
function L1(e) {
  if (!e)
    return "utf8";
  for (var t; ; )
    switch (e) {
      case "utf8":
      case "utf-8":
        return "utf8";
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return "utf16le";
      case "latin1":
      case "binary":
        return "latin1";
      case "base64":
      case "ascii":
      case "hex":
        return e;
      default:
        if (t)
          return;
        e = ("" + e).toLowerCase(), t = !0;
    }
}
function j1(e) {
  var t = L1(e);
  if (typeof t != "string" && (Kd.isEncoding === jm || !jm(e)))
    throw new Error("Unknown encoding: " + e);
  return t || e;
}
jl.StringDecoder = pa;
function pa(e) {
  this.encoding = j1(e);
  var t;
  switch (this.encoding) {
    case "utf16le":
      this.text = B1, this.end = G1, t = 4;
      break;
    case "utf8":
      this.fillLast = F1, t = 4;
      break;
    case "base64":
      this.text = z1, this.end = q1, t = 3;
      break;
    default:
      this.write = H1, this.end = W1;
      return;
  }
  this.lastNeed = 0, this.lastTotal = 0, this.lastChar = Kd.allocUnsafe(t);
}
pa.prototype.write = function(e) {
  if (e.length === 0)
    return "";
  var t, n;
  if (this.lastNeed) {
    if (t = this.fillLast(e), t === void 0)
      return "";
    n = this.lastNeed, this.lastNeed = 0;
  } else
    n = 0;
  return n < e.length ? t ? t + this.text(e, n) : this.text(e, n) : t || "";
};
pa.prototype.end = V1;
pa.prototype.text = U1;
pa.prototype.fillLast = function(e) {
  if (this.lastNeed <= e.length)
    return e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
  e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, e.length), this.lastNeed -= e.length;
};
function Jc(e) {
  return e <= 127 ? 0 : e >> 5 === 6 ? 2 : e >> 4 === 14 ? 3 : e >> 3 === 30 ? 4 : e >> 6 === 2 ? -1 : -2;
}
function C1(e, t, n) {
  var r = t.length - 1;
  if (r < n)
    return 0;
  var i = Jc(t[r]);
  return i >= 0 ? (i > 0 && (e.lastNeed = i - 1), i) : --r < n || i === -2 ? 0 : (i = Jc(t[r]), i >= 0 ? (i > 0 && (e.lastNeed = i - 2), i) : --r < n || i === -2 ? 0 : (i = Jc(t[r]), i >= 0 ? (i > 0 && (i === 2 ? i = 0 : e.lastNeed = i - 3), i) : 0));
}
function M1(e, t, n) {
  if ((t[0] & 192) !== 128)
    return e.lastNeed = 0, "";
  if (e.lastNeed > 1 && t.length > 1) {
    if ((t[1] & 192) !== 128)
      return e.lastNeed = 1, "";
    if (e.lastNeed > 2 && t.length > 2 && (t[2] & 192) !== 128)
      return e.lastNeed = 2, "";
  }
}
function F1(e) {
  var t = this.lastTotal - this.lastNeed, n = M1(this, e);
  if (n !== void 0)
    return n;
  if (this.lastNeed <= e.length)
    return e.copy(this.lastChar, t, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
  e.copy(this.lastChar, t, 0, e.length), this.lastNeed -= e.length;
}
function U1(e, t) {
  var n = C1(this, e, t);
  if (!this.lastNeed)
    return e.toString("utf8", t);
  this.lastTotal = n;
  var r = e.length - (n - this.lastNeed);
  return e.copy(this.lastChar, 0, r), e.toString("utf8", t, r);
}
function V1(e) {
  var t = e && e.length ? this.write(e) : "";
  return this.lastNeed ? t + "" : t;
}
function B1(e, t) {
  if ((e.length - t) % 2 === 0) {
    var n = e.toString("utf16le", t);
    if (n) {
      var r = n.charCodeAt(n.length - 1);
      if (r >= 55296 && r <= 56319)
        return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = e[e.length - 2], this.lastChar[1] = e[e.length - 1], n.slice(0, -1);
    }
    return n;
  }
  return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = e[e.length - 1], e.toString("utf16le", t, e.length - 1);
}
function G1(e) {
  var t = e && e.length ? this.write(e) : "";
  if (this.lastNeed) {
    var n = this.lastTotal - this.lastNeed;
    return t + this.lastChar.toString("utf16le", 0, n);
  }
  return t;
}
function z1(e, t) {
  var n = (e.length - t) % 3;
  return n === 0 ? e.toString("base64", t) : (this.lastNeed = 3 - n, this.lastTotal = 3, n === 1 ? this.lastChar[0] = e[e.length - 1] : (this.lastChar[0] = e[e.length - 2], this.lastChar[1] = e[e.length - 1]), e.toString("base64", t, e.length - n));
}
function q1(e) {
  var t = e && e.length ? this.write(e) : "";
  return this.lastNeed ? t + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : t;
}
function H1(e) {
  return e.toString(this.encoding);
}
function W1(e) {
  return e && e.length ? this.write(e) : "";
}
var Cm = Ki.codes.ERR_STREAM_PREMATURE_CLOSE;
function Q1(e) {
  var t = !1;
  return function() {
    if (!t) {
      t = !0;
      for (var n = arguments.length, r = new Array(n), i = 0; i < n; i++)
        r[i] = arguments[i];
      e.apply(this, r);
    }
  };
}
function J1() {
}
function K1(e) {
  return e.setHeader && typeof e.abort == "function";
}
function kb(e, t, n) {
  if (typeof t == "function")
    return kb(e, null, t);
  t || (t = {}), n = Q1(n || J1);
  var r = t.readable || t.readable !== !1 && e.readable, i = t.writable || t.writable !== !1 && e.writable, s = function() {
    e.writable || a();
  }, o = e._writableState && e._writableState.finished, a = function() {
    i = !1, o = !0, r || n.call(e);
  }, l = e._readableState && e._readableState.endEmitted, c = function() {
    r = !1, l = !0, i || n.call(e);
  }, u = function(h) {
    n.call(e, h);
  }, f = function() {
    var h;
    if (r && !l)
      return (!e._readableState || !e._readableState.ended) && (h = new Cm()), n.call(e, h);
    if (i && !o)
      return (!e._writableState || !e._writableState.ended) && (h = new Cm()), n.call(e, h);
  }, d = function() {
    e.req.on("finish", a);
  };
  return K1(e) ? (e.on("complete", a), e.on("abort", f), e.req ? d() : e.on("request", d)) : i && !e._writableState && (e.on("end", s), e.on("close", s)), e.on("end", c), e.on("finish", a), t.error !== !1 && e.on("error", u), e.on("close", f), function() {
    e.removeListener("complete", a), e.removeListener("abort", f), e.removeListener("request", d), e.req && e.req.removeListener("finish", a), e.removeListener("end", s), e.removeListener("close", s), e.removeListener("finish", a), e.removeListener("end", c), e.removeListener("error", u), e.removeListener("close", f);
  };
}
var Yd = kb, Kc, Mm;
function Y1() {
  if (Mm)
    return Kc;
  Mm = 1;
  var e;
  function t(y, D, F) {
    return D = n(D), D in y ? Object.defineProperty(y, D, { value: F, enumerable: !0, configurable: !0, writable: !0 }) : y[D] = F, y;
  }
  function n(y) {
    var D = r(y, "string");
    return typeof D == "symbol" ? D : String(D);
  }
  function r(y, D) {
    if (typeof y != "object" || y === null)
      return y;
    var F = y[Symbol.toPrimitive];
    if (F !== void 0) {
      var W = F.call(y, D || "default");
      if (typeof W != "object")
        return W;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (D === "string" ? String : Number)(y);
  }
  var i = Yd, s = Symbol("lastResolve"), o = Symbol("lastReject"), a = Symbol("error"), l = Symbol("ended"), c = Symbol("lastPromise"), u = Symbol("handlePromise"), f = Symbol("stream");
  function d(y, D) {
    return {
      value: y,
      done: D
    };
  }
  function p(y) {
    var D = y[s];
    if (D !== null) {
      var F = y[f].read();
      F !== null && (y[c] = null, y[s] = null, y[o] = null, D(d(F, !1)));
    }
  }
  function h(y) {
    process.nextTick(p, y);
  }
  function m(y, D) {
    return function(F, W) {
      y.then(function() {
        if (D[l]) {
          F(d(void 0, !0));
          return;
        }
        D[u](F, W);
      }, W);
    };
  }
  var v = Object.getPrototypeOf(function() {
  }), b = Object.setPrototypeOf((e = {
    get stream() {
      return this[f];
    },
    next: function() {
      var D = this, F = this[a];
      if (F !== null)
        return Promise.reject(F);
      if (this[l])
        return Promise.resolve(d(void 0, !0));
      if (this[f].destroyed)
        return new Promise(function(j, ee) {
          process.nextTick(function() {
            D[a] ? ee(D[a]) : j(d(void 0, !0));
          });
        });
      var W = this[c], J;
      if (W)
        J = new Promise(m(W, this));
      else {
        var Z = this[f].read();
        if (Z !== null)
          return Promise.resolve(d(Z, !1));
        J = new Promise(this[u]);
      }
      return this[c] = J, J;
    }
  }, t(e, Symbol.asyncIterator, function() {
    return this;
  }), t(e, "return", function() {
    var D = this;
    return new Promise(function(F, W) {
      D[f].destroy(null, function(J) {
        if (J) {
          W(J);
          return;
        }
        F(d(void 0, !0));
      });
    });
  }), e), v), E = function(D) {
    var F, W = Object.create(b, (F = {}, t(F, f, {
      value: D,
      writable: !0
    }), t(F, s, {
      value: null,
      writable: !0
    }), t(F, o, {
      value: null,
      writable: !0
    }), t(F, a, {
      value: null,
      writable: !0
    }), t(F, l, {
      value: D._readableState.endEmitted,
      writable: !0
    }), t(F, u, {
      value: function(Z, j) {
        var ee = W[f].read();
        ee ? (W[c] = null, W[s] = null, W[o] = null, Z(d(ee, !1))) : (W[s] = Z, W[o] = j);
      },
      writable: !0
    }), F));
    return W[c] = null, i(D, function(J) {
      if (J && J.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var Z = W[o];
        Z !== null && (W[c] = null, W[s] = null, W[o] = null, Z(J)), W[a] = J;
        return;
      }
      var j = W[s];
      j !== null && (W[c] = null, W[s] = null, W[o] = null, j(d(void 0, !0))), W[l] = !0;
    }), D.on("readable", h.bind(null, W)), W;
  };
  return Kc = E, Kc;
}
var Yc, Fm;
function X1() {
  return Fm || (Fm = 1, Yc = function() {
    throw new Error("Readable.from is not available in the browser");
  }), Yc;
}
var Xc, Um;
function Lb() {
  if (Um)
    return Xc;
  Um = 1, Xc = j;
  var e;
  j.ReadableState = Z, Ji.EventEmitter;
  var t = function($, O) {
    return $.listeners(O).length;
  }, n = Rb, r = jn.Buffer, i = (typeof We < "u" ? We : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function s(S) {
    return r.from(S);
  }
  function o(S) {
    return r.isBuffer(S) || S instanceof i;
  }
  var a = at, l;
  a && a.debuglog ? l = a.debuglog("stream") : l = function() {
  };
  var c = E1(), u = Ab, f = Db, d = f.getHighWaterMark, p = Ki.codes, h = p.ERR_INVALID_ARG_TYPE, m = p.ERR_STREAM_PUSH_AFTER_EOF, v = p.ERR_METHOD_NOT_IMPLEMENTED, b = p.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, E, y, D;
  Qi(j, n);
  var F = u.errorOrDestroy, W = ["error", "close", "destroy", "pause", "resume"];
  function J(S, $, O) {
    if (typeof S.prependListener == "function")
      return S.prependListener($, O);
    !S._events || !S._events[$] ? S.on($, O) : Array.isArray(S._events[$]) ? S._events[$].unshift(O) : S._events[$] = [O, S._events[$]];
  }
  function Z(S, $, O) {
    e = e || ws(), S = S || {}, typeof O != "boolean" && (O = $ instanceof e), this.objectMode = !!S.objectMode, O && (this.objectMode = this.objectMode || !!S.readableObjectMode), this.highWaterMark = d(this, S, "readableHighWaterMark", O), this.buffer = new c(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = S.emitClose !== !1, this.autoDestroy = !!S.autoDestroy, this.destroyed = !1, this.defaultEncoding = S.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, S.encoding && (E || (E = jl.StringDecoder), this.decoder = new E(S.encoding), this.encoding = S.encoding);
  }
  function j(S) {
    if (e = e || ws(), !(this instanceof j))
      return new j(S);
    var $ = this instanceof e;
    this._readableState = new Z(S, this, $), this.readable = !0, S && (typeof S.read == "function" && (this._read = S.read), typeof S.destroy == "function" && (this._destroy = S.destroy)), n.call(this);
  }
  Object.defineProperty(j.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function($) {
      this._readableState && (this._readableState.destroyed = $);
    }
  }), j.prototype.destroy = u.destroy, j.prototype._undestroy = u.undestroy, j.prototype._destroy = function(S, $) {
    $(S);
  }, j.prototype.push = function(S, $) {
    var O = this._readableState, I;
    return O.objectMode ? I = !0 : typeof S == "string" && ($ = $ || O.defaultEncoding, $ !== O.encoding && (S = r.from(S, $), $ = ""), I = !0), ee(this, S, $, !1, I);
  }, j.prototype.unshift = function(S) {
    return ee(this, S, null, !0, !1);
  };
  function ee(S, $, O, I, L) {
    l("readableAddChunk", $);
    var H = S._readableState;
    if ($ === null)
      H.reading = !1, K(S, H);
    else {
      var ae;
      if (L || (ae = ce(H, $)), ae)
        F(S, ae);
      else if (H.objectMode || $ && $.length > 0)
        if (typeof $ != "string" && !H.objectMode && Object.getPrototypeOf($) !== r.prototype && ($ = s($)), I)
          H.endEmitted ? F(S, new b()) : le(S, H, $, !0);
        else if (H.ended)
          F(S, new m());
        else {
          if (H.destroyed)
            return !1;
          H.reading = !1, H.decoder && !O ? ($ = H.decoder.write($), H.objectMode || $.length !== 0 ? le(S, H, $, !1) : ue(S, H)) : le(S, H, $, !1);
        }
      else
        I || (H.reading = !1, ue(S, H));
    }
    return !H.ended && (H.length < H.highWaterMark || H.length === 0);
  }
  function le(S, $, O, I) {
    $.flowing && $.length === 0 && !$.sync ? ($.awaitDrain = 0, S.emit("data", O)) : ($.length += $.objectMode ? 1 : O.length, I ? $.buffer.unshift(O) : $.buffer.push(O), $.needReadable && se(S)), ue(S, $);
  }
  function ce(S, $) {
    var O;
    return !o($) && typeof $ != "string" && $ !== void 0 && !S.objectMode && (O = new h("chunk", ["string", "Buffer", "Uint8Array"], $)), O;
  }
  j.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, j.prototype.setEncoding = function(S) {
    E || (E = jl.StringDecoder);
    var $ = new E(S);
    this._readableState.decoder = $, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var O = this._readableState.buffer.head, I = ""; O !== null; )
      I += $.write(O.data), O = O.next;
    return this._readableState.buffer.clear(), I !== "" && this._readableState.buffer.push(I), this._readableState.length = I.length, this;
  };
  var U = 1073741824;
  function z(S) {
    return S >= U ? S = U : (S--, S |= S >>> 1, S |= S >>> 2, S |= S >>> 4, S |= S >>> 8, S |= S >>> 16, S++), S;
  }
  function ne(S, $) {
    return S <= 0 || $.length === 0 && $.ended ? 0 : $.objectMode ? 1 : S !== S ? $.flowing && $.length ? $.buffer.head.data.length : $.length : (S > $.highWaterMark && ($.highWaterMark = z(S)), S <= $.length ? S : $.ended ? $.length : ($.needReadable = !0, 0));
  }
  j.prototype.read = function(S) {
    l("read", S), S = parseInt(S, 10);
    var $ = this._readableState, O = S;
    if (S !== 0 && ($.emittedReadable = !1), S === 0 && $.needReadable && (($.highWaterMark !== 0 ? $.length >= $.highWaterMark : $.length > 0) || $.ended))
      return l("read: emitReadable", $.length, $.ended), $.length === 0 && $.ended ? Y(this) : se(this), null;
    if (S = ne(S, $), S === 0 && $.ended)
      return $.length === 0 && Y(this), null;
    var I = $.needReadable;
    l("need readable", I), ($.length === 0 || $.length - S < $.highWaterMark) && (I = !0, l("length less than watermark", I)), $.ended || $.reading ? (I = !1, l("reading or ended", I)) : I && (l("do read"), $.reading = !0, $.sync = !0, $.length === 0 && ($.needReadable = !0), this._read($.highWaterMark), $.sync = !1, $.reading || (S = ne(O, $)));
    var L;
    return S > 0 ? L = q(S, $) : L = null, L === null ? ($.needReadable = $.length <= $.highWaterMark, S = 0) : ($.length -= S, $.awaitDrain = 0), $.length === 0 && ($.ended || ($.needReadable = !0), O !== S && $.ended && Y(this)), L !== null && this.emit("data", L), L;
  };
  function K(S, $) {
    if (l("onEofChunk"), !$.ended) {
      if ($.decoder) {
        var O = $.decoder.end();
        O && O.length && ($.buffer.push(O), $.length += $.objectMode ? 1 : O.length);
      }
      $.ended = !0, $.sync ? se(S) : ($.needReadable = !1, $.emittedReadable || ($.emittedReadable = !0, re(S)));
    }
  }
  function se(S) {
    var $ = S._readableState;
    l("emitReadable", $.needReadable, $.emittedReadable), $.needReadable = !1, $.emittedReadable || (l("emitReadable", $.flowing), $.emittedReadable = !0, process.nextTick(re, S));
  }
  function re(S) {
    var $ = S._readableState;
    l("emitReadable_", $.destroyed, $.length, $.ended), !$.destroyed && ($.length || $.ended) && (S.emit("readable"), $.emittedReadable = !1), $.needReadable = !$.flowing && !$.ended && $.length <= $.highWaterMark, k(S);
  }
  function ue(S, $) {
    $.readingMore || ($.readingMore = !0, process.nextTick(te, S, $));
  }
  function te(S, $) {
    for (; !$.reading && !$.ended && ($.length < $.highWaterMark || $.flowing && $.length === 0); ) {
      var O = $.length;
      if (l("maybeReadMore read 0"), S.read(0), O === $.length)
        break;
    }
    $.readingMore = !1;
  }
  j.prototype._read = function(S) {
    F(this, new v("_read()"));
  }, j.prototype.pipe = function(S, $) {
    var O = this, I = this._readableState;
    switch (I.pipesCount) {
      case 0:
        I.pipes = S;
        break;
      case 1:
        I.pipes = [I.pipes, S];
        break;
      default:
        I.pipes.push(S);
        break;
    }
    I.pipesCount += 1, l("pipe count=%d opts=%j", I.pipesCount, $);
    var L = (!$ || $.end !== !1) && S !== process.stdout && S !== process.stderr, H = L ? Ee : bt;
    I.endEmitted ? process.nextTick(H) : O.once("end", H), S.on("unpipe", ae);
    function ae(x, g) {
      l("onunpipe"), x === O && g && g.hasUnpiped === !1 && (g.hasUnpiped = !0, Me());
    }
    function Ee() {
      l("onend"), S.end();
    }
    var Oe = B(O);
    S.on("drain", Oe);
    var Te = !1;
    function Me() {
      l("cleanup"), S.removeListener("close", ut), S.removeListener("finish", Je), S.removeListener("drain", Oe), S.removeListener("error", Le), S.removeListener("unpipe", ae), O.removeListener("end", Ee), O.removeListener("end", bt), O.removeListener("data", we), Te = !0, I.awaitDrain && (!S._writableState || S._writableState.needDrain) && Oe();
    }
    O.on("data", we);
    function we(x) {
      l("ondata");
      var g = S.write(x);
      l("dest.write", g), g === !1 && ((I.pipesCount === 1 && I.pipes === S || I.pipesCount > 1 && oe(I.pipes, S) !== -1) && !Te && (l("false write response, pause", I.awaitDrain), I.awaitDrain++), O.pause());
    }
    function Le(x) {
      l("onerror", x), bt(), S.removeListener("error", Le), t(S, "error") === 0 && F(S, x);
    }
    J(S, "error", Le);
    function ut() {
      S.removeListener("finish", Je), bt();
    }
    S.once("close", ut);
    function Je() {
      l("onfinish"), S.removeListener("close", ut), bt();
    }
    S.once("finish", Je);
    function bt() {
      l("unpipe"), O.unpipe(S);
    }
    return S.emit("pipe", O), I.flowing || (l("pipe resume"), O.resume()), S;
  };
  function B(S) {
    return function() {
      var O = S._readableState;
      l("pipeOnDrain", O.awaitDrain), O.awaitDrain && O.awaitDrain--, O.awaitDrain === 0 && t(S, "data") && (O.flowing = !0, k(S));
    };
  }
  j.prototype.unpipe = function(S) {
    var $ = this._readableState, O = {
      hasUnpiped: !1
    };
    if ($.pipesCount === 0)
      return this;
    if ($.pipesCount === 1)
      return S && S !== $.pipes ? this : (S || (S = $.pipes), $.pipes = null, $.pipesCount = 0, $.flowing = !1, S && S.emit("unpipe", this, O), this);
    if (!S) {
      var I = $.pipes, L = $.pipesCount;
      $.pipes = null, $.pipesCount = 0, $.flowing = !1;
      for (var H = 0; H < L; H++)
        I[H].emit("unpipe", this, {
          hasUnpiped: !1
        });
      return this;
    }
    var ae = oe($.pipes, S);
    return ae === -1 ? this : ($.pipes.splice(ae, 1), $.pipesCount -= 1, $.pipesCount === 1 && ($.pipes = $.pipes[0]), S.emit("unpipe", this, O), this);
  }, j.prototype.on = function(S, $) {
    var O = n.prototype.on.call(this, S, $), I = this._readableState;
    return S === "data" ? (I.readableListening = this.listenerCount("readable") > 0, I.flowing !== !1 && this.resume()) : S === "readable" && !I.endEmitted && !I.readableListening && (I.readableListening = I.needReadable = !0, I.flowing = !1, I.emittedReadable = !1, l("on readable", I.length, I.reading), I.length ? se(this) : I.reading || process.nextTick(N, this)), O;
  }, j.prototype.addListener = j.prototype.on, j.prototype.removeListener = function(S, $) {
    var O = n.prototype.removeListener.call(this, S, $);
    return S === "readable" && process.nextTick(M, this), O;
  }, j.prototype.removeAllListeners = function(S) {
    var $ = n.prototype.removeAllListeners.apply(this, arguments);
    return (S === "readable" || S === void 0) && process.nextTick(M, this), $;
  };
  function M(S) {
    var $ = S._readableState;
    $.readableListening = S.listenerCount("readable") > 0, $.resumeScheduled && !$.paused ? $.flowing = !0 : S.listenerCount("data") > 0 && S.resume();
  }
  function N(S) {
    l("readable nexttick read 0"), S.read(0);
  }
  j.prototype.resume = function() {
    var S = this._readableState;
    return S.flowing || (l("resume"), S.flowing = !S.readableListening, T(this, S)), S.paused = !1, this;
  };
  function T(S, $) {
    $.resumeScheduled || ($.resumeScheduled = !0, process.nextTick(P, S, $));
  }
  function P(S, $) {
    l("resume", $.reading), $.reading || S.read(0), $.resumeScheduled = !1, S.emit("resume"), k(S), $.flowing && !$.reading && S.read(0);
  }
  j.prototype.pause = function() {
    return l("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (l("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function k(S) {
    var $ = S._readableState;
    for (l("flow", $.flowing); $.flowing && S.read() !== null; )
      ;
  }
  j.prototype.wrap = function(S) {
    var $ = this, O = this._readableState, I = !1;
    S.on("end", function() {
      if (l("wrapped end"), O.decoder && !O.ended) {
        var ae = O.decoder.end();
        ae && ae.length && $.push(ae);
      }
      $.push(null);
    }), S.on("data", function(ae) {
      if (l("wrapped data"), O.decoder && (ae = O.decoder.write(ae)), !(O.objectMode && ae == null) && !(!O.objectMode && (!ae || !ae.length))) {
        var Ee = $.push(ae);
        Ee || (I = !0, S.pause());
      }
    });
    for (var L in S)
      this[L] === void 0 && typeof S[L] == "function" && (this[L] = function(Ee) {
        return function() {
          return S[Ee].apply(S, arguments);
        };
      }(L));
    for (var H = 0; H < W.length; H++)
      S.on(W[H], this.emit.bind(this, W[H]));
    return this._read = function(ae) {
      l("wrapped _read", ae), I && (I = !1, S.resume());
    }, this;
  }, typeof Symbol == "function" && (j.prototype[Symbol.asyncIterator] = function() {
    return y === void 0 && (y = Y1()), y(this);
  }), Object.defineProperty(j.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(j.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(j.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function($) {
      this._readableState && (this._readableState.flowing = $);
    }
  }), j._fromList = q, Object.defineProperty(j.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function q(S, $) {
    if ($.length === 0)
      return null;
    var O;
    return $.objectMode ? O = $.buffer.shift() : !S || S >= $.length ? ($.decoder ? O = $.buffer.join("") : $.buffer.length === 1 ? O = $.buffer.first() : O = $.buffer.concat($.length), $.buffer.clear()) : O = $.buffer.consume(S, $.decoder), O;
  }
  function Y(S) {
    var $ = S._readableState;
    l("endReadable", $.endEmitted), $.endEmitted || ($.ended = !0, process.nextTick(ve, $, S));
  }
  function ve(S, $) {
    if (l("endReadableNT", S.endEmitted, S.length), !S.endEmitted && S.length === 0 && (S.endEmitted = !0, $.readable = !1, $.emit("end"), S.autoDestroy)) {
      var O = $._writableState;
      (!O || O.autoDestroy && O.finished) && $.destroy();
    }
  }
  typeof Symbol == "function" && (j.from = function(S, $) {
    return D === void 0 && (D = X1()), D(j, S, $);
  });
  function oe(S, $) {
    for (var O = 0, I = S.length; O < I; O++)
      if (S[O] === $)
        return O;
    return -1;
  }
  return Xc;
}
var jb = Mr, vu = Ki.codes, Z1 = vu.ERR_METHOD_NOT_IMPLEMENTED, eN = vu.ERR_MULTIPLE_CALLBACK, tN = vu.ERR_TRANSFORM_ALREADY_TRANSFORMING, nN = vu.ERR_TRANSFORM_WITH_LENGTH_0, _u = ws();
Qi(Mr, _u);
function rN(e, t) {
  var n = this._transformState;
  n.transforming = !1;
  var r = n.writecb;
  if (r === null)
    return this.emit("error", new eN());
  n.writechunk = null, n.writecb = null, t != null && this.push(t), r(e);
  var i = this._readableState;
  i.reading = !1, (i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark);
}
function Mr(e) {
  if (!(this instanceof Mr))
    return new Mr(e);
  _u.call(this, e), this._transformState = {
    afterTransform: rN.bind(this),
    needTransform: !1,
    transforming: !1,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }, this._readableState.needReadable = !0, this._readableState.sync = !1, e && (typeof e.transform == "function" && (this._transform = e.transform), typeof e.flush == "function" && (this._flush = e.flush)), this.on("prefinish", iN);
}
function iN() {
  var e = this;
  typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(t, n) {
    Vm(e, t, n);
  }) : Vm(this, null, null);
}
Mr.prototype.push = function(e, t) {
  return this._transformState.needTransform = !1, _u.prototype.push.call(this, e, t);
};
Mr.prototype._transform = function(e, t, n) {
  n(new Z1("_transform()"));
};
Mr.prototype._write = function(e, t, n) {
  var r = this._transformState;
  if (r.writecb = n, r.writechunk = e, r.writeencoding = t, !r.transforming) {
    var i = this._readableState;
    (r.needTransform || i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark);
  }
};
Mr.prototype._read = function(e) {
  var t = this._transformState;
  t.writechunk !== null && !t.transforming ? (t.transforming = !0, this._transform(t.writechunk, t.writeencoding, t.afterTransform)) : t.needTransform = !0;
};
Mr.prototype._destroy = function(e, t) {
  _u.prototype._destroy.call(this, e, function(n) {
    t(n);
  });
};
function Vm(e, t, n) {
  if (t)
    return e.emit("error", t);
  if (n != null && e.push(n), e._writableState.length)
    throw new nN();
  if (e._transformState.transforming)
    throw new tN();
  return e.push(null);
}
var sN = Wo, Cb = jb;
Qi(Wo, Cb);
function Wo(e) {
  if (!(this instanceof Wo))
    return new Wo(e);
  Cb.call(this, e);
}
Wo.prototype._transform = function(e, t, n) {
  n(null, e);
};
var Zc;
function oN(e) {
  var t = !1;
  return function() {
    t || (t = !0, e.apply(void 0, arguments));
  };
}
var Mb = Ki.codes, aN = Mb.ERR_MISSING_ARGS, lN = Mb.ERR_STREAM_DESTROYED;
function Bm(e) {
  if (e)
    throw e;
}
function uN(e) {
  return e.setHeader && typeof e.abort == "function";
}
function cN(e, t, n, r) {
  r = oN(r);
  var i = !1;
  e.on("close", function() {
    i = !0;
  }), Zc === void 0 && (Zc = Yd), Zc(e, {
    readable: t,
    writable: n
  }, function(o) {
    if (o)
      return r(o);
    i = !0, r();
  });
  var s = !1;
  return function(o) {
    if (!i && !s) {
      if (s = !0, uN(e))
        return e.abort();
      if (typeof e.destroy == "function")
        return e.destroy();
      r(o || new lN("pipe"));
    }
  };
}
function Gm(e) {
  e();
}
function fN(e, t) {
  return e.pipe(t);
}
function dN(e) {
  return !e.length || typeof e[e.length - 1] != "function" ? Bm : e.pop();
}
function pN() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  var r = dN(t);
  if (Array.isArray(t[0]) && (t = t[0]), t.length < 2)
    throw new aN("streams");
  var i, s = t.map(function(o, a) {
    var l = a < t.length - 1, c = a > 0;
    return cN(o, l, c, function(u) {
      i || (i = u), u && s.forEach(Gm), !l && (s.forEach(Gm), r(i));
    });
  });
  return t.reduce(fN);
}
var hN = pN;
(function(e, t) {
  t = e.exports = Lb(), t.Stream = t, t.Readable = t, t.Writable = Pb(), t.Duplex = ws(), t.Transform = jb, t.PassThrough = sN, t.finished = Yd, t.pipeline = hN;
})(Vf, Vf.exports);
var mN = Vf.exports, Xd = { exports: {} }, yN = Fb;
function Fb(e, t) {
  if (e && t)
    return Fb(e)(t);
  if (typeof e != "function")
    throw new TypeError("need wrapper function");
  return Object.keys(e).forEach(function(r) {
    n[r] = e[r];
  }), n;
  function n() {
    for (var r = new Array(arguments.length), i = 0; i < r.length; i++)
      r[i] = arguments[i];
    var s = e.apply(this, r), o = r[r.length - 1];
    return typeof s == "function" && s !== o && Object.keys(o).forEach(function(a) {
      s[a] = o[a];
    }), s;
  }
}
var Ub = yN;
Xd.exports = Ub(hl);
Xd.exports.strict = Ub(Vb);
hl.proto = hl(function() {
  Object.defineProperty(Function.prototype, "once", {
    value: function() {
      return hl(this);
    },
    configurable: !0
  }), Object.defineProperty(Function.prototype, "onceStrict", {
    value: function() {
      return Vb(this);
    },
    configurable: !0
  });
});
function hl(e) {
  var t = function() {
    return t.called ? t.value : (t.called = !0, t.value = e.apply(this, arguments));
  };
  return t.called = !1, t;
}
function Vb(e) {
  var t = function() {
    if (t.called)
      throw new Error(t.onceError);
    return t.called = !0, t.value = e.apply(this, arguments);
  }, n = e.name || "Function wrapped with `once`";
  return t.onceError = n + " shouldn't be called more than once", t.called = !1, t;
}
var gN = Xd.exports, bN = gN, vN = function() {
}, _N = function(e) {
  return e.setHeader && typeof e.abort == "function";
}, wN = function(e) {
  return e.stdio && Array.isArray(e.stdio) && e.stdio.length === 3;
}, Bb = function(e, t, n) {
  if (typeof t == "function")
    return Bb(e, null, t);
  t || (t = {}), n = bN(n || vN);
  var r = e._writableState, i = e._readableState, s = t.readable || t.readable !== !1 && e.readable, o = t.writable || t.writable !== !1 && e.writable, a = !1, l = function() {
    e.writable || c();
  }, c = function() {
    o = !1, s || n.call(e);
  }, u = function() {
    s = !1, o || n.call(e);
  }, f = function(v) {
    n.call(e, v ? new Error("exited with error code: " + v) : null);
  }, d = function(v) {
    n.call(e, v);
  }, p = function() {
    process.nextTick(h);
  }, h = function() {
    if (!a) {
      if (s && !(i && i.ended && !i.destroyed))
        return n.call(e, new Error("premature close"));
      if (o && !(r && r.ended && !r.destroyed))
        return n.call(e, new Error("premature close"));
    }
  }, m = function() {
    e.req.on("finish", c);
  };
  return _N(e) ? (e.on("complete", c), e.on("abort", p), e.req ? m() : e.on("request", m)) : o && !r && (e.on("end", l), e.on("close", l)), wN(e) && e.on("exit", f), e.on("end", u), e.on("finish", c), t.error !== !1 && e.on("error", d), e.on("close", p), function() {
    a = !0, e.removeListener("complete", c), e.removeListener("abort", p), e.removeListener("request", m), e.req && e.req.removeListener("finish", c), e.removeListener("end", l), e.removeListener("close", l), e.removeListener("finish", c), e.removeListener("exit", f), e.removeListener("end", u), e.removeListener("error", d), e.removeListener("close", p);
  };
}, EN = Bb, SN = TN;
function TN(e) {
  var t = e._readableState;
  return t ? t.objectMode || typeof e._duplexState == "number" ? e.read() : e.read($N(t)) : null;
}
function $N(e) {
  if (e.buffer.length) {
    var t = e.bufferIndex || 0;
    if (e.buffer.head)
      return e.buffer.head.data.length;
    if (e.buffer.length - t > 0 && e.buffer[t])
      return e.buffer[t].length;
  }
  return e.length;
}
var wu = mN, Gb = EN, NN = Qi, ON = SN, zb = Buffer.from && Buffer.from !== Uint8Array.from ? Buffer.from([0]) : new Buffer([0]), Gf = function(e, t) {
  e._corked ? e.once("uncork", t) : t();
}, IN = function(e, t) {
  e._autoDestroy && e.destroy(t);
}, qb = function(e, t) {
  return function(n) {
    n ? IN(e, n.message === "premature close" ? null : n) : t && !e._ended && e.end();
  };
}, RN = function(e, t) {
  if (!e || e._writableState && e._writableState.finished)
    return t();
  if (e._writableState)
    return e.end(t);
  e.end(), t();
}, AN = function() {
}, xN = function(e) {
  return new wu.Readable({ objectMode: !0, highWaterMark: 16 }).wrap(e);
}, Yt = function(e, t, n) {
  if (!(this instanceof Yt))
    return new Yt(e, t, n);
  wu.Duplex.call(this, n), this._writable = null, this._readable = null, this._readable2 = null, this._autoDestroy = !n || n.autoDestroy !== !1, this._forwardDestroy = !n || n.destroy !== !1, this._forwardEnd = !n || n.end !== !1, this._corked = 1, this._ondrain = null, this._drained = !1, this._forwarding = !1, this._unwrite = null, this._unread = null, this._ended = !1, this.destroyed = !1, e && this.setWritable(e), t && this.setReadable(t);
};
NN(Yt, wu.Duplex);
Yt.obj = function(e, t, n) {
  return n || (n = {}), n.objectMode = !0, n.highWaterMark = 16, new Yt(e, t, n);
};
Yt.prototype.cork = function() {
  ++this._corked === 1 && this.emit("cork");
};
Yt.prototype.uncork = function() {
  this._corked && --this._corked === 0 && this.emit("uncork");
};
Yt.prototype.setWritable = function(e) {
  if (this._unwrite && this._unwrite(), this.destroyed) {
    e && e.destroy && e.destroy();
    return;
  }
  if (e === null || e === !1) {
    this.end();
    return;
  }
  var t = this, n = Gb(e, { writable: !0, readable: !1 }, qb(this, this._forwardEnd)), r = function() {
    var s = t._ondrain;
    t._ondrain = null, s && s();
  }, i = function() {
    t._writable.removeListener("drain", r), n();
  };
  this._unwrite && process.nextTick(r), this._writable = e, this._writable.on("drain", r), this._unwrite = i, this.uncork();
};
Yt.prototype.setReadable = function(e) {
  if (this._unread && this._unread(), this.destroyed) {
    e && e.destroy && e.destroy();
    return;
  }
  if (e === null || e === !1) {
    this.push(null), this.resume();
    return;
  }
  var t = this, n = Gb(e, { writable: !1, readable: !0 }, qb(this)), r = function() {
    t._forward();
  }, i = function() {
    t.push(null);
  }, s = function() {
    t._readable2.removeListener("readable", r), t._readable2.removeListener("end", i), n();
  };
  this._drained = !0, this._readable = e, this._readable2 = e._readableState ? e : xN(e), this._readable2.on("readable", r), this._readable2.on("end", i), this._unread = s, this._forward();
};
Yt.prototype._read = function() {
  this._drained = !0, this._forward();
};
Yt.prototype._forward = function() {
  if (!(this._forwarding || !this._readable2 || !this._drained)) {
    this._forwarding = !0;
    for (var e; this._drained && (e = ON(this._readable2)) !== null; )
      this.destroyed || (this._drained = this.push(e));
    this._forwarding = !1;
  }
};
Yt.prototype.destroy = function(e, t) {
  if (t || (t = AN), this.destroyed)
    return t(null);
  this.destroyed = !0;
  var n = this;
  process.nextTick(function() {
    n._destroy(e), t(null);
  });
};
Yt.prototype._destroy = function(e) {
  if (e) {
    var t = this._ondrain;
    this._ondrain = null, t ? t(e) : this.emit("error", e);
  }
  this._forwardDestroy && (this._readable && this._readable.destroy && this._readable.destroy(), this._writable && this._writable.destroy && this._writable.destroy()), this.emit("close");
};
Yt.prototype._write = function(e, t, n) {
  if (!this.destroyed) {
    if (this._corked)
      return Gf(this, this._write.bind(this, e, t, n));
    if (e === zb)
      return this._finish(n);
    if (!this._writable)
      return n();
    this._writable.write(e) === !1 ? this._ondrain = n : this.destroyed || n();
  }
};
Yt.prototype._finish = function(e) {
  var t = this;
  this.emit("preend"), Gf(this, function() {
    RN(t._forwardEnd && t._writable, function() {
      t._writableState.prefinished === !1 && (t._writableState.prefinished = !0), t.emit("prefinish"), Gf(t, e);
    });
  });
};
Yt.prototype.end = function(e, t, n) {
  return typeof e == "function" ? this.end(null, null, e) : typeof t == "function" ? this.end(e, null, t) : (this._ended = !0, e && this.write(e), !this._writableState.ending && !this._writableState.destroyed && this.write(zb), wu.Writable.prototype.end.call(this, n));
};
var DN = Yt;
const { ServerResponse: PN } = at, { PassThrough: zm } = at, { randomBytes: kN } = at, LN = oa, qm = m1, Hm = DN, Ti = Symbol("ws-socket"), Ua = Symbol("ws-head");
function Zd(e, t, n) {
  e.decorateRequest("ws", null);
  let r = p;
  if (t.errorHandler) {
    if (typeof t.errorHandler != "function")
      return n(new Error("invalid errorHandler function"));
    r = t.errorHandler;
  }
  let i = f;
  if (t && t.preClose) {
    if (typeof t.preClose != "function")
      return n(new Error("invalid preClose function"));
    i = t.preClose;
  }
  if (t.options && t.options.noServer)
    return n(new Error("fastify-websocket doesn't support the ws noServer option. If you want to create a websocket server detatched from fastify, use the ws library directly."));
  const s = Object.assign({ noServer: !0 }, t.options);
  s.path && e.log.warn("ws server path option shouldn't be provided, use a route instead");
  const o = s.server || e.server;
  delete s.server;
  const a = new qm.Server(s);
  e.decorate("websocketServer", a);
  async function l(h = "/", m = {}) {
    const v = new zm(), b = new zm(), E = new Hm(v, b), y = new Hm(b, v), D = new qm(), F = Buffer.from([]);
    let W, J;
    const Z = new Promise((le, ce) => {
      W = le, J = ce;
    });
    D.on("open", () => {
      y.removeListener("data", j), W(D);
    });
    const j = (le) => {
      if (le.toString().includes("HTTP/1.1 101 Switching Protocols"))
        D._isServer = !1, D.setSocket(y, F, { maxPayload: 0 });
      else {
        y.removeListener("data", j);
        const ce = Number(le.toString().match(/HTTP\/1.1 (\d+)/)[1]);
        J(new Error("Unexpected server response: " + ce));
      }
    };
    y.on("data", j);
    const ee = {
      ...m,
      method: "GET",
      headers: {
        ...m.headers,
        connection: "upgrade",
        upgrade: "websocket",
        "sec-websocket-version": 13,
        "sec-websocket-key": kN(16).toString("base64")
      },
      httpVersion: "1.1",
      url: h,
      [Ti]: E,
      [Ua]: F
    };
    return o.emit("upgrade", ee, ee[Ti], ee[Ua]), Z;
  }
  e.decorate("injectWS", l);
  function c(h, m, v) {
    h[Ti] = m, h[Ua] = v;
    const b = new PN(h);
    try {
      b.assignSocket(m), e.routing(h, b);
    } catch (E) {
      e.log.warn({ err: E }, "websocket upgrade failed");
    }
  }
  o.on("upgrade", c);
  const u = (h, m) => {
    a.handleUpgrade(h, h[Ti], h[Ua], (v) => {
      a.emit("connection", v, h), v.on("error", (b) => {
        e.log.error(b);
      }), m(v);
    });
  };
  e.addHook("onRequest", (h, m, v) => {
    h.raw[Ti] ? h.ws = !0 : h.ws = !1, v();
  }), e.addHook("onResponse", (h, m, v) => {
    h.ws && h.raw[Ti].destroy(), v();
  }), e.addHook("onRoute", (h) => {
    let m = !1, v = h.wsHandler, b = h.handler;
    if (h.websocket || h.wsHandler) {
      if (h.method === "HEAD")
        return;
      if (h.method !== "GET")
        throw new Error("websocket handler can only be declared in GET method");
      if (m = !0, h.websocket && (v = h.handler, b = function(E, y) {
        y.code(404).send();
      }), typeof v != "function")
        throw new Error("invalid wsHandler function");
    }
    h.handler = function(E, y) {
      if (E.raw[Ti])
        y.hijack(), u(E.raw, (D) => {
          let F;
          try {
            m ? F = v.call(this, D, E) : F = d.call(this, D, E);
          } catch (W) {
            return r.call(this, W, D, E, y);
          }
          F && typeof F.catch == "function" && F.catch((W) => r.call(this, W, D, E, y));
        });
      else
        return b.call(this, E, y);
    };
  }), e.addHook("preClose", i);
  function f(h) {
    const m = this.websocketServer;
    if (m.clients)
      for (const v of m.clients)
        v.close();
    e.server.removeListener("upgrade", c), m.close(h), h();
  }
  function d(h, m) {
    this.log.info({ path: m.url }, "closed incoming websocket connection for path with no websocket handler"), h.close();
  }
  function p(h, m, v) {
    v.log.error(h), m.terminate();
  }
  n();
}
gu.exports = LN(Zd, {
  fastify: "^4.16.0",
  name: "@fastify/websocket"
});
gu.exports.default = Zd;
gu.exports.fastifyWebsocket = Zd;
var jN = gu.exports, Yi = { exports: {} }, Eu = { exports: {} };
const { format: CN } = at;
function MN() {
  return `${this.name} [${this.code}]: ${this.message}`;
}
function ep(e, t, n = 500, r = Error) {
  if (!e)
    throw new Error("Fastify error code must not be empty");
  if (!t)
    throw new Error("Fastify error message must not be empty");
  e = e.toUpperCase(), !n && (n = void 0);
  function i(...s) {
    if (!new.target)
      return new i(...s);
    this.code = e, this.name = "FastifyError", this.statusCode = n;
    const o = s.length - 1;
    o !== -1 && s[o] && typeof s[o] == "object" && "cause" in s[o] && (this.cause = s.pop().cause), this.message = CN(t, ...s), Error.stackTraceLimit !== 0 && Error.captureStackTrace(this, i);
  }
  return i.prototype = Object.create(r.prototype, {
    constructor: {
      value: i,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }), i.prototype[Symbol.toStringTag] = "Error", i.prototype.toString = MN, i;
}
Eu.exports = ep;
Eu.exports.default = ep;
Eu.exports.createError = ep;
var FN = Eu.exports;
const { GraphQLError: Wm } = Ln, Wt = FN;
let UN = class extends Error {
  constructor(t, n, r) {
    super(t), this.extensions = n, this.statusCode = r || 200;
  }
};
function tp(e) {
  if (e instanceof Wm)
    return e;
  const t = new Wm(
    e.message,
    e.nodes,
    e.source,
    e.positions,
    e.path,
    e,
    e.extensions
  );
  return t.locations = e.locations, t;
}
function VN(e, t) {
  const n = t.reply ? t.reply.log : t.app.log;
  let r = e.data ? 200 : e.statusCode || 200;
  const i = e.errors.map((s) => (n.info({ err: s }, s.message), s.originalError?.errors && Array.isArray(s.originalError.errors) ? s.originalError.errors.map(tp) : s)).reduce((s, o) => s.concat(o), []).map((s) => s.toJSON());
  return !e.data && typeof e.statusCode > "u" && e.errors.length > 0 && i.length === 1 && (typeof e.errors[0].originalError < "u" && typeof e.errors[0].originalError.statusCode == "number" ? r = e.errors[0].originalError.statusCode : r = 200), {
    statusCode: r,
    response: {
      data: e.data || null,
      errors: i
    }
  };
}
function BN(e, t) {
  if (t) {
    let n;
    e.errors ? n = e.errors.concat(t) : n = t, e.errors = n.map((r) => tp(r));
  }
  return e;
}
function GN(e, t) {
  let n;
  e.errors !== null ? n = e.errors.concat(t) : n = t, e.errors = n;
}
const zN = {
  /**
   * General errors
   */
  MER_ERR_INVALID_OPTS: Wt(
    "MER_ERR_INVALID_OPTS",
    "Invalid options: %s"
  ),
  MER_ERR_INVALID_METHOD: Wt(
    "MER_ERR_INVALID_METHOD",
    "Invalid method: %s"
  ),
  MER_ERR_METHOD_NOT_ALLOWED: Wt(
    "MER_ERR_METHOD_NOT_ALLOWED",
    "Method not allowed",
    405
  ),
  /**
   * General graphql errors
   */
  MER_ERR_GQL_INVALID_SCHEMA: Wt(
    "MER_ERR_GQL_INVALID_SCHEMA",
    "Invalid schema: check out the .errors property on the Error"
  ),
  MER_ERR_GQL_VALIDATION: Wt(
    "MER_ERR_GQL_VALIDATION",
    "Graphql validation error",
    400
  ),
  MER_ERR_GQL_QUERY_DEPTH: Wt(
    "MER_ERR_GQL_QUERY_DEPTH",
    "`%s query depth (%s) exceeds the query depth limit of %s`"
  ),
  /**
   * Persisted query errors
   */
  MER_ERR_GQL_PERSISTED_QUERY_NOT_FOUND: Wt(
    "MER_ERR_GQL_PERSISTED_QUERY_NOT_FOUND",
    "%s",
    400
  ),
  MER_ERR_GQL_PERSISTED_QUERY_NOT_SUPPORTED: Wt(
    "MER_ERR_GQL_PERSISTED_QUERY_NOT_SUPPORTED",
    "%s",
    400
  ),
  /**
   * Subscription errors
   */
  MER_ERR_GQL_SUBSCRIPTION_CONNECTION_NOT_READY: Wt(
    "MER_ERR_GQL_SUBSCRIPTION_CONNECTION_NOT_READY",
    "Connection is not ready"
  ),
  MER_ERR_GQL_SUBSCRIPTION_FORBIDDEN: Wt(
    "MER_ERR_GQL_SUBSCRIPTION_FORBIDDEN",
    "Forbidden"
  ),
  MER_ERR_GQL_SUBSCRIPTION_UNKNOWN_EXTENSION: Wt(
    "MER_ERR_GQL_SUBSCRIPTION_UNKNOWN_EXTENSION",
    "Unknown extension %s"
  ),
  MER_ERR_GQL_SUBSCRIPTION_MESSAGE_INVALID: Wt(
    "MER_ERR_GQL_SUBSCRIPTION_MESSAGE_INVALID",
    "Invalid message received: %s"
  ),
  MER_ERR_GQL_SUBSCRIPTION_INVALID_OPERATION: Wt(
    "MER_ERR_GQL_SUBSCRIPTION_INVALID_OPERATION",
    "Invalid operation: %s"
  ),
  /**
   * Hooks errors
   */
  MER_ERR_HOOK_INVALID_TYPE: Wt(
    "MER_ERR_HOOK_INVALID_TYPE",
    "The hook name must be a string",
    500,
    TypeError
  ),
  MER_ERR_HOOK_INVALID_HANDLER: Wt(
    "MER_ERR_HOOK_INVALID_HANDLER",
    "The hook callback must be a function",
    500,
    TypeError
  ),
  MER_ERR_HOOK_UNSUPPORTED_HOOK: Wt(
    "MER_ERR_HOOK_UNSUPPORTED_HOOK",
    "%s hook not supported!",
    500
  ),
  MER_ERR_SERVICE_RETRY_FAILED: Wt(
    "MER_ERR_SERVICE_RETRY_FAILED",
    "Mandatory services retry failed - [%s]",
    500
  )
};
Yi.exports = zN;
Yi.exports.ErrorWithProps = UN;
Yi.exports.defaultErrorFormatter = VN;
Yi.exports.addErrorsToExecutionResult = BN;
Yi.exports.addErrorsToContext = GN;
Yi.exports.toGraphQLError = tp;
var xs = Yi.exports;
const qN = [
  "onExtendSchema"
], HN = [
  "preParsing",
  "preValidation",
  "preExecution",
  "onResolution",
  "preSubscriptionParsing",
  "preSubscriptionExecution",
  "onSubscriptionResolution",
  "onSubscriptionEnd"
], WN = HN.concat(qN), { MER_ERR_HOOK_INVALID_TYPE: QN, MER_ERR_HOOK_INVALID_HANDLER: JN, MER_ERR_HOOK_UNSUPPORTED_HOOK: KN } = xs;
function np() {
  this.preParsing = [], this.preValidation = [], this.preExecution = [], this.onResolution = [], this.preSubscriptionParsing = [], this.preSubscriptionExecution = [], this.onSubscriptionResolution = [], this.onSubscriptionEnd = [], this.onExtendSchema = [];
}
np.prototype.validate = function(e, t) {
  if (typeof e != "string")
    throw new QN();
  if (typeof t != "function")
    throw new JN();
  if (WN.indexOf(e) === -1)
    throw new KN(e);
};
np.prototype.add = function(e, t) {
  this.validate(e, t), this[e].push(t);
};
function YN(e, t) {
  const n = {
    preParsing: null,
    preValidation: null,
    preExecution: null,
    onResolution: null,
    preSubscriptionParsing: null,
    preSubscriptionExecution: null,
    onSubscriptionResolution: null,
    onSubscriptionEnd: null
  };
  return t.preParsing.length > 0 && (n.preParsing = t.preParsing.slice()), t.preValidation.length > 0 && (n.preValidation = t.preValidation.slice()), t.preExecution.length > 0 && (n.preExecution = t.preExecution.slice()), t.onResolution.length > 0 && (n.onResolution = t.onResolution.slice()), t.preSubscriptionParsing.length > 0 && (n.preSubscriptionParsing = t.preSubscriptionParsing.slice()), t.preSubscriptionExecution.length > 0 && (n.preSubscriptionExecution = t.preSubscriptionExecution.slice()), t.onSubscriptionResolution.length > 0 && (n.onSubscriptionResolution = t.onSubscriptionResolution.slice()), t.onSubscriptionEnd.length > 0 && (n.onSubscriptionEnd = t.onSubscriptionEnd.slice()), Object.assign(e, n);
}
function XN(e, t) {
  const n = {
    onExtendSchema: null
  };
  return t.onExtendSchema.length > 0 && (n.onExtendSchema = t.onExtendSchema.slice()), Object.assign(e, n);
}
async function ZN(e, t, n) {
  for (const r of e)
    await t(r, n);
}
async function eO(e, t) {
  let n = [], r, i, s;
  for (const o of e) {
    const a = await o(
      r || t.schema,
      i || t.document,
      t.context,
      s || t.variables
    );
    a && (typeof a.schema < "u" && (r = a.schema), typeof a.document < "u" && (i = a.document), typeof a.variables < "u" && (s = a.variables), typeof a.errors < "u" && (n = n.concat(a.errors)));
  }
  return { errors: n, modifiedDocument: i, modifiedSchema: r, modifiedVariables: s };
}
function tO(e, t) {
  return e(t.schema, t.document, t.context);
}
function nO(e, t) {
  return e(t.schema, t.source, t.context);
}
function rO(e, t) {
  return e(t.execution, t.context);
}
function iO(e, t) {
  return e(t.context, t.id);
}
var rp = {
  Hooks: np,
  assignLifeCycleHooksToContext: YN,
  assignApplicationHooksToContext: XN,
  hooksRunner: ZN,
  preExecutionHooksRunner: eO,
  hookRunner: tO,
  preParsingHookRunner: nO,
  onResolutionHookRunner: rO,
  onEndHookRunner: iO
};
const sO = {
  kLoaders: Symbol("mercurius.loaders"),
  kFactory: Symbol("mercurius.loadersFactory"),
  kSubscriptionFactory: Symbol("mercurius.subscriptionLoadersFactory"),
  kHooks: Symbol("mercurius.hooks"),
  kRequestContext: Symbol("mercurius.requestContext")
};
var Su = sO, Hb = { exports: {} }, ef = { exports: {} }, Pt = {
  ArrayIsArray(e) {
    return Array.isArray(e);
  },
  ArrayPrototypeIncludes(e, t) {
    return e.includes(t);
  },
  ArrayPrototypeIndexOf(e, t) {
    return e.indexOf(t);
  },
  ArrayPrototypeJoin(e, t) {
    return e.join(t);
  },
  ArrayPrototypeMap(e, t) {
    return e.map(t);
  },
  ArrayPrototypePop(e, t) {
    return e.pop(t);
  },
  ArrayPrototypePush(e, t) {
    return e.push(t);
  },
  ArrayPrototypeSlice(e, t, n) {
    return e.slice(t, n);
  },
  Error,
  FunctionPrototypeCall(e, t, ...n) {
    return e.call(t, ...n);
  },
  FunctionPrototypeSymbolHasInstance(e, t) {
    return Function.prototype[Symbol.hasInstance].call(e, t);
  },
  MathFloor: Math.floor,
  Number,
  NumberIsInteger: Number.isInteger,
  NumberIsNaN: Number.isNaN,
  NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,
  NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,
  NumberParseInt: Number.parseInt,
  ObjectDefineProperties(e, t) {
    return Object.defineProperties(e, t);
  },
  ObjectDefineProperty(e, t, n) {
    return Object.defineProperty(e, t, n);
  },
  ObjectGetOwnPropertyDescriptor(e, t) {
    return Object.getOwnPropertyDescriptor(e, t);
  },
  ObjectKeys(e) {
    return Object.keys(e);
  },
  ObjectSetPrototypeOf(e, t) {
    return Object.setPrototypeOf(e, t);
  },
  Promise,
  PromisePrototypeCatch(e, t) {
    return e.catch(t);
  },
  PromisePrototypeThen(e, t, n) {
    return e.then(t, n);
  },
  PromiseReject(e) {
    return Promise.reject(e);
  },
  PromiseResolve(e) {
    return Promise.resolve(e);
  },
  ReflectApply: Reflect.apply,
  RegExpPrototypeTest(e, t) {
    return e.test(t);
  },
  SafeSet: Set,
  String,
  StringPrototypeSlice(e, t, n) {
    return e.slice(t, n);
  },
  StringPrototypeToLowerCase(e) {
    return e.toLowerCase();
  },
  StringPrototypeToUpperCase(e) {
    return e.toUpperCase();
  },
  StringPrototypeTrim(e) {
    return e.trim();
  },
  Symbol,
  SymbolFor: Symbol.for,
  SymbolAsyncIterator: Symbol.asyncIterator,
  SymbolHasInstance: Symbol.hasInstance,
  SymbolIterator: Symbol.iterator,
  SymbolDispose: Symbol.dispose || Symbol("Symbol.dispose"),
  SymbolAsyncDispose: Symbol.asyncDispose || Symbol("Symbol.asyncDispose"),
  TypedArrayPrototypeSet(e, t, n) {
    return e.set(t, n);
  },
  Boolean,
  Uint8Array
}, Wb = { exports: {} }, fo = { exports: {} }, Qm;
function Qo() {
  if (Qm)
    return fo.exports;
  Qm = 1;
  const { AbortController: e, AbortSignal: t } = typeof self < "u" ? self : typeof window < "u" ? window : (
    /* otherwise */
    void 0
  );
  return fo.exports = e, fo.exports.AbortSignal = t, fo.exports.default = e, fo.exports;
}
(function(e) {
  const t = jn, { kResistStopPropagation: n, SymbolDispose: r } = Pt, i = globalThis.AbortSignal || Qo().AbortSignal, s = globalThis.AbortController || Qo().AbortController, o = Object.getPrototypeOf(async function() {
  }).constructor, a = globalThis.Blob || t.Blob, l = typeof a < "u" ? function(p) {
    return p instanceof a;
  } : function(p) {
    return !1;
  }, c = (d, p) => {
    if (d !== void 0 && (d === null || typeof d != "object" || !("aborted" in d)))
      throw new ERR_INVALID_ARG_TYPE(p, "AbortSignal", d);
  }, u = (d, p) => {
    if (typeof d != "function")
      throw new ERR_INVALID_ARG_TYPE(p, "Function", d);
  };
  class f extends Error {
    constructor(p) {
      if (!Array.isArray(p))
        throw new TypeError(`Expected input to be an Array, got ${typeof p}`);
      let h = "";
      for (let m = 0; m < p.length; m++)
        h += `    ${p[m].stack}
`;
      super(h), this.name = "AggregateError", this.errors = p;
    }
  }
  e.exports = {
    AggregateError: f,
    kEmptyObject: Object.freeze({}),
    once(d) {
      let p = !1;
      return function(...h) {
        p || (p = !0, d.apply(this, h));
      };
    },
    createDeferredPromise: function() {
      let d, p;
      return {
        promise: new Promise((m, v) => {
          d = m, p = v;
        }),
        resolve: d,
        reject: p
      };
    },
    promisify(d) {
      return new Promise((p, h) => {
        d((m, ...v) => m ? h(m) : p(...v));
      });
    },
    debuglog() {
      return function() {
      };
    },
    format(d, ...p) {
      return d.replace(/%([sdifj])/g, function(...[h, m]) {
        const v = p.shift();
        return m === "f" ? v.toFixed(6) : m === "j" ? JSON.stringify(v) : m === "s" && typeof v == "object" ? `${v.constructor !== Object ? v.constructor.name : ""} {}`.trim() : v.toString();
      });
    },
    inspect(d) {
      switch (typeof d) {
        case "string":
          if (d.includes("'"))
            if (d.includes('"')) {
              if (!d.includes("`") && !d.includes("${"))
                return `\`${d}\``;
            } else
              return `"${d}"`;
          return `'${d}'`;
        case "number":
          return isNaN(d) ? "NaN" : Object.is(d, -0) ? String(d) : d;
        case "bigint":
          return `${String(d)}n`;
        case "boolean":
        case "undefined":
          return String(d);
        case "object":
          return "{}";
      }
    },
    types: {
      isAsyncFunction(d) {
        return d instanceof o;
      },
      isArrayBufferView(d) {
        return ArrayBuffer.isView(d);
      }
    },
    isBlob: l,
    deprecate(d, p) {
      return d;
    },
    addAbortListener: Ji.addAbortListener || function(p, h) {
      if (p === void 0)
        throw new ERR_INVALID_ARG_TYPE("signal", "AbortSignal", p);
      c(p, "signal"), u(h, "listener");
      let m;
      return p.aborted ? queueMicrotask(() => h()) : (p.addEventListener("abort", h, {
        __proto__: null,
        once: !0,
        [n]: !0
      }), m = () => {
        p.removeEventListener("abort", h);
      }), {
        __proto__: null,
        [r]() {
          var v;
          (v = m) === null || v === void 0 || v();
        }
      };
    },
    AbortSignalAny: i.any || function(p) {
      if (p.length === 1)
        return p[0];
      const h = new s(), m = () => h.abort();
      return p.forEach((v) => {
        c(v, "signals"), v.addEventListener("abort", m, {
          once: !0
        });
      }), h.signal.addEventListener(
        "abort",
        () => {
          p.forEach((v) => v.removeEventListener("abort", m));
        },
        {
          once: !0
        }
      ), h.signal;
    }
  }, e.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
})(Wb);
var on = Wb.exports, ip = {};
const { format: oO, inspect: Cl, AggregateError: aO } = on, lO = globalThis.AggregateError || aO, uO = Symbol("kIsNodeError"), cO = [
  "string",
  "function",
  "number",
  "object",
  // Accept 'Function' and 'Object' as alternative to the lower cased version.
  "Function",
  "Object",
  "boolean",
  "bigint",
  "symbol"
], fO = /^([A-Z][a-z0-9]*)+$/, dO = "__node_internal_", Tu = {};
function Ci(e, t) {
  if (!e)
    throw new Tu.ERR_INTERNAL_ASSERTION(t);
}
function Jm(e) {
  let t = "", n = e.length;
  const r = e[0] === "-" ? 1 : 0;
  for (; n >= r + 4; n -= 3)
    t = `_${e.slice(n - 3, n)}${t}`;
  return `${e.slice(0, n)}${t}`;
}
function pO(e, t, n) {
  if (typeof t == "function")
    return Ci(
      t.length <= n.length,
      // Default options do not count.
      `Code: ${e}; The provided arguments length (${n.length}) does not match the required ones (${t.length}).`
    ), t(...n);
  const r = (t.match(/%[dfijoOs]/g) || []).length;
  return Ci(
    r === n.length,
    `Code: ${e}; The provided arguments length (${n.length}) does not match the required ones (${r}).`
  ), n.length === 0 ? t : oO(t, ...n);
}
function Xt(e, t, n) {
  n || (n = Error);
  class r extends n {
    constructor(...s) {
      super(pO(e, t, s));
    }
    toString() {
      return `${this.name} [${e}]: ${this.message}`;
    }
  }
  Object.defineProperties(r.prototype, {
    name: {
      value: n.name,
      writable: !0,
      enumerable: !1,
      configurable: !0
    },
    toString: {
      value() {
        return `${this.name} [${e}]: ${this.message}`;
      },
      writable: !0,
      enumerable: !1,
      configurable: !0
    }
  }), r.prototype.code = e, r.prototype[uO] = !0, Tu[e] = r;
}
function Km(e) {
  const t = dO + e.name;
  return Object.defineProperty(e, "name", {
    value: t
  }), e;
}
function hO(e, t) {
  if (e && t && e !== t) {
    if (Array.isArray(t.errors))
      return t.errors.push(e), t;
    const n = new lO([t, e], t.message);
    return n.code = t.code, n;
  }
  return e || t;
}
let mO = class extends Error {
  constructor(t = "The operation was aborted", n = void 0) {
    if (n !== void 0 && typeof n != "object")
      throw new Tu.ERR_INVALID_ARG_TYPE("options", "Object", n);
    super(t, n), this.code = "ABORT_ERR", this.name = "AbortError";
  }
};
Xt("ERR_ASSERTION", "%s", Error);
Xt(
  "ERR_INVALID_ARG_TYPE",
  (e, t, n) => {
    Ci(typeof e == "string", "'name' must be a string"), Array.isArray(t) || (t = [t]);
    let r = "The ";
    e.endsWith(" argument") ? r += `${e} ` : r += `"${e}" ${e.includes(".") ? "property" : "argument"} `, r += "must be ";
    const i = [], s = [], o = [];
    for (const l of t)
      Ci(typeof l == "string", "All expected entries have to be of type string"), cO.includes(l) ? i.push(l.toLowerCase()) : fO.test(l) ? s.push(l) : (Ci(l !== "object", 'The value "object" should be written as "Object"'), o.push(l));
    if (s.length > 0) {
      const l = i.indexOf("object");
      l !== -1 && (i.splice(i, l, 1), s.push("Object"));
    }
    if (i.length > 0) {
      switch (i.length) {
        case 1:
          r += `of type ${i[0]}`;
          break;
        case 2:
          r += `one of type ${i[0]} or ${i[1]}`;
          break;
        default: {
          const l = i.pop();
          r += `one of type ${i.join(", ")}, or ${l}`;
        }
      }
      (s.length > 0 || o.length > 0) && (r += " or ");
    }
    if (s.length > 0) {
      switch (s.length) {
        case 1:
          r += `an instance of ${s[0]}`;
          break;
        case 2:
          r += `an instance of ${s[0]} or ${s[1]}`;
          break;
        default: {
          const l = s.pop();
          r += `an instance of ${s.join(", ")}, or ${l}`;
        }
      }
      o.length > 0 && (r += " or ");
    }
    switch (o.length) {
      case 0:
        break;
      case 1:
        o[0].toLowerCase() !== o[0] && (r += "an "), r += `${o[0]}`;
        break;
      case 2:
        r += `one of ${o[0]} or ${o[1]}`;
        break;
      default: {
        const l = o.pop();
        r += `one of ${o.join(", ")}, or ${l}`;
      }
    }
    if (n == null)
      r += `. Received ${n}`;
    else if (typeof n == "function" && n.name)
      r += `. Received function ${n.name}`;
    else if (typeof n == "object") {
      var a;
      if ((a = n.constructor) !== null && a !== void 0 && a.name)
        r += `. Received an instance of ${n.constructor.name}`;
      else {
        const l = Cl(n, {
          depth: -1
        });
        r += `. Received ${l}`;
      }
    } else {
      let l = Cl(n, {
        colors: !1
      });
      l.length > 25 && (l = `${l.slice(0, 25)}...`), r += `. Received type ${typeof n} (${l})`;
    }
    return r;
  },
  TypeError
);
Xt(
  "ERR_INVALID_ARG_VALUE",
  (e, t, n = "is invalid") => {
    let r = Cl(t);
    return r.length > 128 && (r = r.slice(0, 128) + "..."), `The ${e.includes(".") ? "property" : "argument"} '${e}' ${n}. Received ${r}`;
  },
  TypeError
);
Xt(
  "ERR_INVALID_RETURN_VALUE",
  (e, t, n) => {
    var r;
    const i = n != null && (r = n.constructor) !== null && r !== void 0 && r.name ? `instance of ${n.constructor.name}` : `type ${typeof n}`;
    return `Expected ${e} to be returned from the "${t}" function but got ${i}.`;
  },
  TypeError
);
Xt(
  "ERR_MISSING_ARGS",
  (...e) => {
    Ci(e.length > 0, "At least one arg needs to be specified");
    let t;
    const n = e.length;
    switch (e = (Array.isArray(e) ? e : [e]).map((r) => `"${r}"`).join(" or "), n) {
      case 1:
        t += `The ${e[0]} argument`;
        break;
      case 2:
        t += `The ${e[0]} and ${e[1]} arguments`;
        break;
      default:
        {
          const r = e.pop();
          t += `The ${e.join(", ")}, and ${r} arguments`;
        }
        break;
    }
    return `${t} must be specified`;
  },
  TypeError
);
Xt(
  "ERR_OUT_OF_RANGE",
  (e, t, n) => {
    Ci(t, 'Missing "range" argument');
    let r;
    return Number.isInteger(n) && Math.abs(n) > 2 ** 32 ? r = Jm(String(n)) : typeof n == "bigint" ? (r = String(n), (n > 2n ** 32n || n < -(2n ** 32n)) && (r = Jm(r)), r += "n") : r = Cl(n), `The value of "${e}" is out of range. It must be ${t}. Received ${r}`;
  },
  RangeError
);
Xt("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
Xt("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error);
Xt("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error);
Xt("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
Xt("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error);
Xt("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
Xt("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
Xt("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
Xt("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error);
Xt("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
Xt("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
var hn = {
  AbortError: mO,
  aggregateTwoErrors: Km(hO),
  hideStackFrames: Km,
  codes: Tu
};
const {
  ArrayIsArray: sp,
  ArrayPrototypeIncludes: Qb,
  ArrayPrototypeJoin: Jb,
  ArrayPrototypeMap: yO,
  NumberIsInteger: op,
  NumberIsNaN: gO,
  NumberMAX_SAFE_INTEGER: bO,
  NumberMIN_SAFE_INTEGER: vO,
  NumberParseInt: _O,
  ObjectPrototypeHasOwnProperty: wO,
  RegExpPrototypeExec: Kb,
  String: EO,
  StringPrototypeToUpperCase: SO,
  StringPrototypeTrim: TO
} = Pt, {
  hideStackFrames: Mn,
  codes: { ERR_SOCKET_BAD_PORT: $O, ERR_INVALID_ARG_TYPE: en, ERR_INVALID_ARG_VALUE: Ds, ERR_OUT_OF_RANGE: Fi, ERR_UNKNOWN_SIGNAL: Ym }
} = hn, { normalizeEncoding: NO } = on, { isAsyncFunction: OO, isArrayBufferView: IO } = on.types, Xm = {};
function RO(e) {
  return e === (e | 0);
}
function AO(e) {
  return e === e >>> 0;
}
const xO = /^[0-7]+$/, DO = "must be a 32-bit unsigned integer or an octal string";
function PO(e, t, n) {
  if (typeof e > "u" && (e = n), typeof e == "string") {
    if (Kb(xO, e) === null)
      throw new Ds(t, e, DO);
    e = _O(e, 8);
  }
  return Yb(e, t), e;
}
const kO = Mn((e, t, n = vO, r = bO) => {
  if (typeof e != "number")
    throw new en(t, "number", e);
  if (!op(e))
    throw new Fi(t, "an integer", e);
  if (e < n || e > r)
    throw new Fi(t, `>= ${n} && <= ${r}`, e);
}), LO = Mn((e, t, n = -2147483648, r = 2147483647) => {
  if (typeof e != "number")
    throw new en(t, "number", e);
  if (!op(e))
    throw new Fi(t, "an integer", e);
  if (e < n || e > r)
    throw new Fi(t, `>= ${n} && <= ${r}`, e);
}), Yb = Mn((e, t, n = !1) => {
  if (typeof e != "number")
    throw new en(t, "number", e);
  if (!op(e))
    throw new Fi(t, "an integer", e);
  const r = n ? 1 : 0, i = 4294967295;
  if (e < r || e > i)
    throw new Fi(t, `>= ${r} && <= ${i}`, e);
});
function ap(e, t) {
  if (typeof e != "string")
    throw new en(t, "string", e);
}
function jO(e, t, n = void 0, r) {
  if (typeof e != "number")
    throw new en(t, "number", e);
  if (n != null && e < n || r != null && e > r || (n != null || r != null) && gO(e))
    throw new Fi(
      t,
      `${n != null ? `>= ${n}` : ""}${n != null && r != null ? " && " : ""}${r != null ? `<= ${r}` : ""}`,
      e
    );
}
const CO = Mn((e, t, n) => {
  if (!Qb(n, e)) {
    const i = "must be one of: " + Jb(
      yO(n, (s) => typeof s == "string" ? `'${s}'` : EO(s)),
      ", "
    );
    throw new Ds(t, e, i);
  }
});
function Xb(e, t) {
  if (typeof e != "boolean")
    throw new en(t, "boolean", e);
}
function tf(e, t, n) {
  return e == null || !wO(e, t) ? n : e[t];
}
const MO = Mn((e, t, n = null) => {
  const r = tf(n, "allowArray", !1), i = tf(n, "allowFunction", !1);
  if (!tf(n, "nullable", !1) && e === null || !r && sp(e) || typeof e != "object" && (!i || typeof e != "function"))
    throw new en(t, "Object", e);
}), FO = Mn((e, t) => {
  if (e != null && typeof e != "object" && typeof e != "function")
    throw new en(t, "a dictionary", e);
}), $u = Mn((e, t, n = 0) => {
  if (!sp(e))
    throw new en(t, "Array", e);
  if (e.length < n) {
    const r = `must be longer than ${n}`;
    throw new Ds(t, e, r);
  }
});
function UO(e, t) {
  $u(e, t);
  for (let n = 0; n < e.length; n++)
    ap(e[n], `${t}[${n}]`);
}
function VO(e, t) {
  $u(e, t);
  for (let n = 0; n < e.length; n++)
    Xb(e[n], `${t}[${n}]`);
}
function BO(e, t) {
  $u(e, t);
  for (let n = 0; n < e.length; n++) {
    const r = e[n], i = `${t}[${n}]`;
    if (r == null)
      throw new en(i, "AbortSignal", r);
    Zb(r, i);
  }
}
function GO(e, t = "signal") {
  if (ap(e, t), Xm[e] === void 0)
    throw Xm[SO(e)] !== void 0 ? new Ym(e + " (signals must use all capital letters)") : new Ym(e);
}
const zO = Mn((e, t = "buffer") => {
  if (!IO(e))
    throw new en(t, ["Buffer", "TypedArray", "DataView"], e);
});
function qO(e, t) {
  const n = NO(t), r = e.length;
  if (n === "hex" && r % 2 !== 0)
    throw new Ds("encoding", t, `is invalid for data of length ${r}`);
}
function HO(e, t = "Port", n = !0) {
  if (typeof e != "number" && typeof e != "string" || typeof e == "string" && TO(e).length === 0 || +e !== +e >>> 0 || e > 65535 || e === 0 && !n)
    throw new $O(t, e, n);
  return e | 0;
}
const Zb = Mn((e, t) => {
  if (e !== void 0 && (e === null || typeof e != "object" || !("aborted" in e)))
    throw new en(t, "AbortSignal", e);
}), WO = Mn((e, t) => {
  if (typeof e != "function")
    throw new en(t, "Function", e);
}), QO = Mn((e, t) => {
  if (typeof e != "function" || OO(e))
    throw new en(t, "Function", e);
}), JO = Mn((e, t) => {
  if (e !== void 0)
    throw new en(t, "undefined", e);
});
function KO(e, t, n) {
  if (!Qb(n, e))
    throw new en(t, `('${Jb(n, "|")}')`, e);
}
const YO = /^(?:<[^>]*>)(?:\s*;\s*[^;"\s]+(?:=(")?[^;"\s]*\1)?)*$/;
function Zm(e, t) {
  if (typeof e > "u" || !Kb(YO, e))
    throw new Ds(
      t,
      e,
      'must be an array or string of format "</styles.css>; rel=preload; as=style"'
    );
}
function XO(e) {
  if (typeof e == "string")
    return Zm(e, "hints"), e;
  if (sp(e)) {
    const t = e.length;
    let n = "";
    if (t === 0)
      return n;
    for (let r = 0; r < t; r++) {
      const i = e[r];
      Zm(i, "hints"), n += i, r !== t - 1 && (n += ", ");
    }
    return n;
  }
  throw new Ds(
    "hints",
    e,
    'must be an array or string of format "</styles.css>; rel=preload; as=style"'
  );
}
var ha = {
  isInt32: RO,
  isUint32: AO,
  parseFileMode: PO,
  validateArray: $u,
  validateStringArray: UO,
  validateBooleanArray: VO,
  validateAbortSignalArray: BO,
  validateBoolean: Xb,
  validateBuffer: zO,
  validateDictionary: FO,
  validateEncoding: qO,
  validateFunction: WO,
  validateInt32: LO,
  validateInteger: kO,
  validateNumber: jO,
  validateObject: MO,
  validateOneOf: CO,
  validatePlainFunction: QO,
  validatePort: HO,
  validateSignalName: GO,
  validateString: ap,
  validateUint32: Yb,
  validateUndefined: JO,
  validateUnion: KO,
  validateAbortSignal: Zb,
  validateLinkHeaderValue: XO
}, lp = { exports: {} }, ev = { exports: {} }, jt = ev.exports = {}, or, ar;
function zf() {
  throw new Error("setTimeout has not been defined");
}
function qf() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? or = setTimeout : or = zf;
  } catch {
    or = zf;
  }
  try {
    typeof clearTimeout == "function" ? ar = clearTimeout : ar = qf;
  } catch {
    ar = qf;
  }
})();
function tv(e) {
  if (or === setTimeout)
    return setTimeout(e, 0);
  if ((or === zf || !or) && setTimeout)
    return or = setTimeout, setTimeout(e, 0);
  try {
    return or(e, 0);
  } catch {
    try {
      return or.call(null, e, 0);
    } catch {
      return or.call(this, e, 0);
    }
  }
}
function ZO(e) {
  if (ar === clearTimeout)
    return clearTimeout(e);
  if ((ar === qf || !ar) && clearTimeout)
    return ar = clearTimeout, clearTimeout(e);
  try {
    return ar(e);
  } catch {
    try {
      return ar.call(null, e);
    } catch {
      return ar.call(this, e);
    }
  }
}
var Dr = [], hs = !1, ji, ml = -1;
function eI() {
  !hs || !ji || (hs = !1, ji.length ? Dr = ji.concat(Dr) : ml = -1, Dr.length && nv());
}
function nv() {
  if (!hs) {
    var e = tv(eI);
    hs = !0;
    for (var t = Dr.length; t; ) {
      for (ji = Dr, Dr = []; ++ml < t; )
        ji && ji[ml].run();
      ml = -1, t = Dr.length;
    }
    ji = null, hs = !1, ZO(e);
  }
}
jt.nextTick = function(e) {
  var t = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var n = 1; n < arguments.length; n++)
      t[n - 1] = arguments[n];
  Dr.push(new rv(e, t)), Dr.length === 1 && !hs && tv(nv);
};
function rv(e, t) {
  this.fun = e, this.array = t;
}
rv.prototype.run = function() {
  this.fun.apply(null, this.array);
};
jt.title = "browser";
jt.browser = !0;
jt.env = {};
jt.argv = [];
jt.version = "";
jt.versions = {};
function Hr() {
}
jt.on = Hr;
jt.addListener = Hr;
jt.once = Hr;
jt.off = Hr;
jt.removeListener = Hr;
jt.removeAllListeners = Hr;
jt.emit = Hr;
jt.prependListener = Hr;
jt.prependOnceListener = Hr;
jt.listeners = function(e) {
  return [];
};
jt.binding = function(e) {
  throw new Error("process.binding is not supported");
};
jt.cwd = function() {
  return "/";
};
jt.chdir = function(e) {
  throw new Error("process.chdir is not supported");
};
jt.umask = function() {
  return 0;
};
var Xi = ev.exports;
const { SymbolAsyncIterator: ey, SymbolIterator: ty, SymbolFor: Zi } = Pt, iv = Zi("nodejs.stream.destroyed"), sv = Zi("nodejs.stream.errored"), Hf = Zi("nodejs.stream.readable"), Wf = Zi("nodejs.stream.writable"), ov = Zi("nodejs.stream.disturbed"), tI = Zi("nodejs.webstream.isClosedPromise"), nI = Zi("nodejs.webstream.controllerErrorFunction");
function Nu(e, t = !1) {
  var n;
  return !!(e && typeof e.pipe == "function" && typeof e.on == "function" && (!t || typeof e.pause == "function" && typeof e.resume == "function") && (!e._writableState || ((n = e._readableState) === null || n === void 0 ? void 0 : n.readable) !== !1) && // Duplex
  (!e._writableState || e._readableState));
}
function Ou(e) {
  var t;
  return !!(e && typeof e.write == "function" && typeof e.on == "function" && (!e._readableState || ((t = e._writableState) === null || t === void 0 ? void 0 : t.writable) !== !1));
}
function rI(e) {
  return !!(e && typeof e.pipe == "function" && e._readableState && typeof e.on == "function" && typeof e.write == "function");
}
function Sr(e) {
  return e && (e._readableState || e._writableState || typeof e.write == "function" && typeof e.on == "function" || typeof e.pipe == "function" && typeof e.on == "function");
}
function av(e) {
  return !!(e && !Sr(e) && typeof e.pipeThrough == "function" && typeof e.getReader == "function" && typeof e.cancel == "function");
}
function lv(e) {
  return !!(e && !Sr(e) && typeof e.getWriter == "function" && typeof e.abort == "function");
}
function uv(e) {
  return !!(e && !Sr(e) && typeof e.readable == "object" && typeof e.writable == "object");
}
function iI(e) {
  return av(e) || lv(e) || uv(e);
}
function sI(e, t) {
  return e == null ? !1 : t === !0 ? typeof e[ey] == "function" : t === !1 ? typeof e[ty] == "function" : typeof e[ey] == "function" || typeof e[ty] == "function";
}
function Iu(e) {
  if (!Sr(e))
    return null;
  const t = e._writableState, n = e._readableState, r = t || n;
  return !!(e.destroyed || e[iv] || r != null && r.destroyed);
}
function cv(e) {
  if (!Ou(e))
    return null;
  if (e.writableEnded === !0)
    return !0;
  const t = e._writableState;
  return t != null && t.errored ? !1 : typeof t?.ended != "boolean" ? null : t.ended;
}
function oI(e, t) {
  if (!Ou(e))
    return null;
  if (e.writableFinished === !0)
    return !0;
  const n = e._writableState;
  return n != null && n.errored ? !1 : typeof n?.finished != "boolean" ? null : !!(n.finished || t === !1 && n.ended === !0 && n.length === 0);
}
function aI(e) {
  if (!Nu(e))
    return null;
  if (e.readableEnded === !0)
    return !0;
  const t = e._readableState;
  return !t || t.errored ? !1 : typeof t?.ended != "boolean" ? null : t.ended;
}
function fv(e, t) {
  if (!Nu(e))
    return null;
  const n = e._readableState;
  return n != null && n.errored ? !1 : typeof n?.endEmitted != "boolean" ? null : !!(n.endEmitted || t === !1 && n.ended === !0 && n.length === 0);
}
function dv(e) {
  return e && e[Hf] != null ? e[Hf] : typeof e?.readable != "boolean" ? null : Iu(e) ? !1 : Nu(e) && e.readable && !fv(e);
}
function pv(e) {
  return e && e[Wf] != null ? e[Wf] : typeof e?.writable != "boolean" ? null : Iu(e) ? !1 : Ou(e) && e.writable && !cv(e);
}
function lI(e, t) {
  return Sr(e) ? Iu(e) ? !0 : !(t?.readable !== !1 && dv(e) || t?.writable !== !1 && pv(e)) : null;
}
function uI(e) {
  var t, n;
  return Sr(e) ? e.writableErrored ? e.writableErrored : (t = (n = e._writableState) === null || n === void 0 ? void 0 : n.errored) !== null && t !== void 0 ? t : null : null;
}
function cI(e) {
  var t, n;
  return Sr(e) ? e.readableErrored ? e.readableErrored : (t = (n = e._readableState) === null || n === void 0 ? void 0 : n.errored) !== null && t !== void 0 ? t : null : null;
}
function fI(e) {
  if (!Sr(e))
    return null;
  if (typeof e.closed == "boolean")
    return e.closed;
  const t = e._writableState, n = e._readableState;
  return typeof t?.closed == "boolean" || typeof n?.closed == "boolean" ? t?.closed || n?.closed : typeof e._closed == "boolean" && hv(e) ? e._closed : null;
}
function hv(e) {
  return typeof e._closed == "boolean" && typeof e._defaultKeepAlive == "boolean" && typeof e._removedConnection == "boolean" && typeof e._removedContLen == "boolean";
}
function mv(e) {
  return typeof e._sent100 == "boolean" && hv(e);
}
function dI(e) {
  var t;
  return typeof e._consuming == "boolean" && typeof e._dumped == "boolean" && ((t = e.req) === null || t === void 0 ? void 0 : t.upgradeOrConnect) === void 0;
}
function pI(e) {
  if (!Sr(e))
    return null;
  const t = e._writableState, n = e._readableState, r = t || n;
  return !r && mv(e) || !!(r && r.autoDestroy && r.emitClose && r.closed === !1);
}
function hI(e) {
  var t;
  return !!(e && ((t = e[ov]) !== null && t !== void 0 ? t : e.readableDidRead || e.readableAborted));
}
function mI(e) {
  var t, n, r, i, s, o, a, l, c, u;
  return !!(e && ((t = (n = (r = (i = (s = (o = e[sv]) !== null && o !== void 0 ? o : e.readableErrored) !== null && s !== void 0 ? s : e.writableErrored) !== null && i !== void 0 ? i : (a = e._readableState) === null || a === void 0 ? void 0 : a.errorEmitted) !== null && r !== void 0 ? r : (l = e._writableState) === null || l === void 0 ? void 0 : l.errorEmitted) !== null && n !== void 0 ? n : (c = e._readableState) === null || c === void 0 ? void 0 : c.errored) !== null && t !== void 0 ? t : !((u = e._writableState) === null || u === void 0) && u.errored));
}
var Wr = {
  isDestroyed: Iu,
  kIsDestroyed: iv,
  isDisturbed: hI,
  kIsDisturbed: ov,
  isErrored: mI,
  kIsErrored: sv,
  isReadable: dv,
  kIsReadable: Hf,
  kIsClosedPromise: tI,
  kControllerErrorFunction: nI,
  kIsWritable: Wf,
  isClosed: fI,
  isDuplexNodeStream: rI,
  isFinished: lI,
  isIterable: sI,
  isReadableNodeStream: Nu,
  isReadableStream: av,
  isReadableEnded: aI,
  isReadableFinished: fv,
  isReadableErrored: cI,
  isNodeStream: Sr,
  isWebStream: iI,
  isWritable: pv,
  isWritableNodeStream: Ou,
  isWritableStream: lv,
  isWritableEnded: cv,
  isWritableFinished: oI,
  isWritableErrored: uI,
  isServerRequest: dI,
  isServerResponse: mv,
  willEmitClose: pI,
  isTransformStream: uv
};
const ei = Xi, { AbortError: yv, codes: yI } = hn, { ERR_INVALID_ARG_TYPE: gI, ERR_STREAM_PREMATURE_CLOSE: ny } = yI, { kEmptyObject: Qf, once: Jf } = on, { validateAbortSignal: bI, validateFunction: vI, validateObject: _I, validateBoolean: wI } = ha, { Promise: EI, PromisePrototypeThen: SI, SymbolDispose: gv } = Pt, {
  isClosed: TI,
  isReadable: ry,
  isReadableNodeStream: nf,
  isReadableStream: $I,
  isReadableFinished: iy,
  isReadableErrored: sy,
  isWritable: oy,
  isWritableNodeStream: ay,
  isWritableStream: NI,
  isWritableFinished: ly,
  isWritableErrored: uy,
  isNodeStream: OI,
  willEmitClose: II,
  kIsClosedPromise: RI
} = Wr;
let ms;
function AI(e) {
  return e.setHeader && typeof e.abort == "function";
}
const Kf = () => {
};
function bv(e, t, n) {
  var r, i;
  if (arguments.length === 2 ? (n = t, t = Qf) : t == null ? t = Qf : _I(t, "options"), vI(n, "callback"), bI(t.signal, "options.signal"), n = Jf(n), $I(e) || NI(e))
    return xI(e, t, n);
  if (!OI(e))
    throw new gI("stream", ["ReadableStream", "WritableStream", "Stream"], e);
  const s = (r = t.readable) !== null && r !== void 0 ? r : nf(e), o = (i = t.writable) !== null && i !== void 0 ? i : ay(e), a = e._writableState, l = e._readableState, c = () => {
    e.writable || d();
  };
  let u = II(e) && nf(e) === s && ay(e) === o, f = ly(e, !1);
  const d = () => {
    f = !0, e.destroyed && (u = !1), !(u && (!e.readable || s)) && (!s || p) && n.call(e);
  };
  let p = iy(e, !1);
  const h = () => {
    p = !0, e.destroyed && (u = !1), !(u && (!e.writable || o)) && (!o || f) && n.call(e);
  }, m = (F) => {
    n.call(e, F);
  };
  let v = TI(e);
  const b = () => {
    v = !0;
    const F = uy(e) || sy(e);
    if (F && typeof F != "boolean")
      return n.call(e, F);
    if (s && !p && nf(e, !0) && !iy(e, !1))
      return n.call(e, new ny());
    if (o && !f && !ly(e, !1))
      return n.call(e, new ny());
    n.call(e);
  }, E = () => {
    v = !0;
    const F = uy(e) || sy(e);
    if (F && typeof F != "boolean")
      return n.call(e, F);
    n.call(e);
  }, y = () => {
    e.req.on("finish", d);
  };
  AI(e) ? (e.on("complete", d), u || e.on("abort", b), e.req ? y() : e.on("request", y)) : o && !a && (e.on("end", c), e.on("close", c)), !u && typeof e.aborted == "boolean" && e.on("aborted", b), e.on("end", h), e.on("finish", d), t.error !== !1 && e.on("error", m), e.on("close", b), v ? ei.nextTick(b) : a != null && a.errorEmitted || l != null && l.errorEmitted ? u || ei.nextTick(E) : (!s && (!u || ry(e)) && (f || oy(e) === !1) || !o && (!u || oy(e)) && (p || ry(e) === !1) || l && e.req && e.aborted) && ei.nextTick(E);
  const D = () => {
    n = Kf, e.removeListener("aborted", b), e.removeListener("complete", d), e.removeListener("abort", b), e.removeListener("request", y), e.req && e.req.removeListener("finish", d), e.removeListener("end", c), e.removeListener("close", c), e.removeListener("finish", d), e.removeListener("end", h), e.removeListener("error", m), e.removeListener("close", b);
  };
  if (t.signal && !v) {
    const F = () => {
      const W = n;
      D(), W.call(
        e,
        new yv(void 0, {
          cause: t.signal.reason
        })
      );
    };
    if (t.signal.aborted)
      ei.nextTick(F);
    else {
      ms = ms || on.addAbortListener;
      const W = ms(t.signal, F), J = n;
      n = Jf((...Z) => {
        W[gv](), J.apply(e, Z);
      });
    }
  }
  return D;
}
function xI(e, t, n) {
  let r = !1, i = Kf;
  if (t.signal)
    if (i = () => {
      r = !0, n.call(
        e,
        new yv(void 0, {
          cause: t.signal.reason
        })
      );
    }, t.signal.aborted)
      ei.nextTick(i);
    else {
      ms = ms || on.addAbortListener;
      const o = ms(t.signal, i), a = n;
      n = Jf((...l) => {
        o[gv](), a.apply(e, l);
      });
    }
  const s = (...o) => {
    r || ei.nextTick(() => n.apply(e, o));
  };
  return SI(e[RI].promise, s, s), Kf;
}
function DI(e, t) {
  var n;
  let r = !1;
  return t === null && (t = Qf), (n = t) !== null && n !== void 0 && n.cleanup && (wI(t.cleanup, "cleanup"), r = t.cleanup), new EI((i, s) => {
    const o = bv(e, t, (a) => {
      r && o(), a ? s(a) : i();
    });
  });
}
lp.exports = bv;
lp.exports.finished = DI;
var ci = lp.exports;
const yr = Xi, {
  aggregateTwoErrors: PI,
  codes: { ERR_MULTIPLE_CALLBACK: kI },
  AbortError: LI
} = hn, { Symbol: vv } = Pt, { kIsDestroyed: jI, isDestroyed: CI, isFinished: MI, isServerRequest: FI } = Wr, _v = vv("kDestroy"), Yf = vv("kConstruct");
function wv(e, t, n) {
  e && (e.stack, t && !t.errored && (t.errored = e), n && !n.errored && (n.errored = e));
}
function UI(e, t) {
  const n = this._readableState, r = this._writableState, i = r || n;
  return r != null && r.destroyed || n != null && n.destroyed ? (typeof t == "function" && t(), this) : (wv(e, r, n), r && (r.destroyed = !0), n && (n.destroyed = !0), i.constructed ? cy(this, e, t) : this.once(_v, function(s) {
    cy(this, PI(s, e), t);
  }), this);
}
function cy(e, t, n) {
  let r = !1;
  function i(s) {
    if (r)
      return;
    r = !0;
    const o = e._readableState, a = e._writableState;
    wv(s, a, o), a && (a.closed = !0), o && (o.closed = !0), typeof n == "function" && n(s), s ? yr.nextTick(VI, e, s) : yr.nextTick(Ev, e);
  }
  try {
    e._destroy(t || null, i);
  } catch (s) {
    i(s);
  }
}
function VI(e, t) {
  Xf(e, t), Ev(e);
}
function Ev(e) {
  const t = e._readableState, n = e._writableState;
  n && (n.closeEmitted = !0), t && (t.closeEmitted = !0), (n != null && n.emitClose || t != null && t.emitClose) && e.emit("close");
}
function Xf(e, t) {
  const n = e._readableState, r = e._writableState;
  r != null && r.errorEmitted || n != null && n.errorEmitted || (r && (r.errorEmitted = !0), n && (n.errorEmitted = !0), e.emit("error", t));
}
function BI() {
  const e = this._readableState, t = this._writableState;
  e && (e.constructed = !0, e.closed = !1, e.closeEmitted = !1, e.destroyed = !1, e.errored = null, e.errorEmitted = !1, e.reading = !1, e.ended = e.readable === !1, e.endEmitted = e.readable === !1), t && (t.constructed = !0, t.destroyed = !1, t.closed = !1, t.closeEmitted = !1, t.errored = null, t.errorEmitted = !1, t.finalCalled = !1, t.prefinished = !1, t.ended = t.writable === !1, t.ending = t.writable === !1, t.finished = t.writable === !1);
}
function Zf(e, t, n) {
  const r = e._readableState, i = e._writableState;
  if (i != null && i.destroyed || r != null && r.destroyed)
    return this;
  r != null && r.autoDestroy || i != null && i.autoDestroy ? e.destroy(t) : t && (t.stack, i && !i.errored && (i.errored = t), r && !r.errored && (r.errored = t), n ? yr.nextTick(Xf, e, t) : Xf(e, t));
}
function GI(e, t) {
  if (typeof e._construct != "function")
    return;
  const n = e._readableState, r = e._writableState;
  n && (n.constructed = !1), r && (r.constructed = !1), e.once(Yf, t), !(e.listenerCount(Yf) > 1) && yr.nextTick(zI, e);
}
function zI(e) {
  let t = !1;
  function n(r) {
    if (t) {
      Zf(e, r ?? new kI());
      return;
    }
    t = !0;
    const i = e._readableState, s = e._writableState, o = s || i;
    i && (i.constructed = !0), s && (s.constructed = !0), o.destroyed ? e.emit(_v, r) : r ? Zf(e, r, !0) : yr.nextTick(qI, e);
  }
  try {
    e._construct((r) => {
      yr.nextTick(n, r);
    });
  } catch (r) {
    yr.nextTick(n, r);
  }
}
function qI(e) {
  e.emit(Yf);
}
function fy(e) {
  return e?.setHeader && typeof e.abort == "function";
}
function Sv(e) {
  e.emit("close");
}
function HI(e, t) {
  e.emit("error", t), yr.nextTick(Sv, e);
}
function WI(e, t) {
  !e || CI(e) || (!t && !MI(e) && (t = new LI()), FI(e) ? (e.socket = null, e.destroy(t)) : fy(e) ? e.abort() : fy(e.req) ? e.req.abort() : typeof e.destroy == "function" ? e.destroy(t) : typeof e.close == "function" ? e.close() : t ? yr.nextTick(HI, e, t) : yr.nextTick(Sv, e), e.destroyed || (e[jI] = !0));
}
var Ps = {
  construct: GI,
  destroyer: WI,
  destroy: UI,
  undestroy: BI,
  errorOrDestroy: Zf
};
const { ArrayIsArray: QI, ObjectSetPrototypeOf: Tv } = Pt, { EventEmitter: Ru } = Ji;
function Au(e) {
  Ru.call(this, e);
}
Tv(Au.prototype, Ru.prototype);
Tv(Au, Ru);
Au.prototype.pipe = function(e, t) {
  const n = this;
  function r(u) {
    e.writable && e.write(u) === !1 && n.pause && n.pause();
  }
  n.on("data", r);
  function i() {
    n.readable && n.resume && n.resume();
  }
  e.on("drain", i), !e._isStdio && (!t || t.end !== !1) && (n.on("end", o), n.on("close", a));
  let s = !1;
  function o() {
    s || (s = !0, e.end());
  }
  function a() {
    s || (s = !0, typeof e.destroy == "function" && e.destroy());
  }
  function l(u) {
    c(), Ru.listenerCount(this, "error") === 0 && this.emit("error", u);
  }
  ed(n, "error", l), ed(e, "error", l);
  function c() {
    n.removeListener("data", r), e.removeListener("drain", i), n.removeListener("end", o), n.removeListener("close", a), n.removeListener("error", l), e.removeListener("error", l), n.removeListener("end", c), n.removeListener("close", c), e.removeListener("close", c);
  }
  return n.on("end", c), n.on("close", c), e.on("close", c), e.emit("pipe", n), e;
};
function ed(e, t, n) {
  if (typeof e.prependListener == "function")
    return e.prependListener(t, n);
  !e._events || !e._events[t] ? e.on(t, n) : QI(e._events[t]) ? e._events[t].unshift(n) : e._events[t] = [n, e._events[t]];
}
var up = {
  Stream: Au,
  prependListener: ed
}, $v = { exports: {} };
(function(e) {
  const { SymbolDispose: t } = Pt, { AbortError: n, codes: r } = hn, { isNodeStream: i, isWebStream: s, kControllerErrorFunction: o } = Wr, a = ci, { ERR_INVALID_ARG_TYPE: l } = r;
  let c;
  const u = (f, d) => {
    if (typeof f != "object" || !("aborted" in f))
      throw new l(d, "AbortSignal", f);
  };
  e.exports.addAbortSignal = function(d, p) {
    if (u(d, "signal"), !i(p) && !s(p))
      throw new l("stream", ["ReadableStream", "WritableStream", "Stream"], p);
    return e.exports.addAbortSignalNoValidate(d, p);
  }, e.exports.addAbortSignalNoValidate = function(f, d) {
    if (typeof f != "object" || !("aborted" in f))
      return d;
    const p = i(d) ? () => {
      d.destroy(
        new n(void 0, {
          cause: f.reason
        })
      );
    } : () => {
      d[o](
        new n(void 0, {
          cause: f.reason
        })
      );
    };
    if (f.aborted)
      p();
    else {
      c = c || on.addAbortListener;
      const h = c(f, p);
      a(d, h[t]);
    }
    return d;
  };
})($v);
var xu = $v.exports;
const { StringPrototypeSlice: dy, SymbolIterator: JI, TypedArrayPrototypeSet: Va, Uint8Array: KI } = Pt, { Buffer: rf } = jn, { inspect: YI } = on;
var XI = class {
  constructor() {
    this.head = null, this.tail = null, this.length = 0;
  }
  push(t) {
    const n = {
      data: t,
      next: null
    };
    this.length > 0 ? this.tail.next = n : this.head = n, this.tail = n, ++this.length;
  }
  unshift(t) {
    const n = {
      data: t,
      next: this.head
    };
    this.length === 0 && (this.tail = n), this.head = n, ++this.length;
  }
  shift() {
    if (this.length === 0)
      return;
    const t = this.head.data;
    return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, t;
  }
  clear() {
    this.head = this.tail = null, this.length = 0;
  }
  join(t) {
    if (this.length === 0)
      return "";
    let n = this.head, r = "" + n.data;
    for (; (n = n.next) !== null; )
      r += t + n.data;
    return r;
  }
  concat(t) {
    if (this.length === 0)
      return rf.alloc(0);
    const n = rf.allocUnsafe(t >>> 0);
    let r = this.head, i = 0;
    for (; r; )
      Va(n, r.data, i), i += r.data.length, r = r.next;
    return n;
  }
  // Consumes a specified amount of bytes or characters from the buffered data.
  consume(t, n) {
    const r = this.head.data;
    if (t < r.length) {
      const i = r.slice(0, t);
      return this.head.data = r.slice(t), i;
    }
    return t === r.length ? this.shift() : n ? this._getString(t) : this._getBuffer(t);
  }
  first() {
    return this.head.data;
  }
  *[JI]() {
    for (let t = this.head; t; t = t.next)
      yield t.data;
  }
  // Consumes a specified amount of characters from the buffered data.
  _getString(t) {
    let n = "", r = this.head, i = 0;
    do {
      const s = r.data;
      if (t > s.length)
        n += s, t -= s.length;
      else {
        t === s.length ? (n += s, ++i, r.next ? this.head = r.next : this.head = this.tail = null) : (n += dy(s, 0, t), this.head = r, r.data = dy(s, t));
        break;
      }
      ++i;
    } while ((r = r.next) !== null);
    return this.length -= i, n;
  }
  // Consumes a specified amount of bytes from the buffered data.
  _getBuffer(t) {
    const n = rf.allocUnsafe(t), r = t;
    let i = this.head, s = 0;
    do {
      const o = i.data;
      if (t > o.length)
        Va(n, o, r - t), t -= o.length;
      else {
        t === o.length ? (Va(n, o, r - t), ++s, i.next ? this.head = i.next : this.head = this.tail = null) : (Va(n, new KI(o.buffer, o.byteOffset, t), r - t), this.head = i, i.data = o.slice(t));
        break;
      }
      ++s;
    } while ((i = i.next) !== null);
    return this.length -= s, n;
  }
  // Make sure the linked list only shows the minimal necessary information.
  [Symbol.for("nodejs.util.inspect.custom")](t, n) {
    return YI(this, {
      ...n,
      // Only inspect one level.
      depth: 0,
      // It should not recurse.
      customInspect: !1
    });
  }
};
const { MathFloor: ZI, NumberIsInteger: eR } = Pt, { validateInteger: tR } = ha, { ERR_INVALID_ARG_VALUE: nR } = hn.codes;
let Nv = 16 * 1024, Ov = 16;
function rR(e, t, n) {
  return e.highWaterMark != null ? e.highWaterMark : t ? e[n] : null;
}
function Iv(e) {
  return e ? Ov : Nv;
}
function iR(e, t) {
  tR(t, "value", 0), e ? Ov = t : Nv = t;
}
function sR(e, t, n, r) {
  const i = rR(t, r, n);
  if (i != null) {
    if (!eR(i) || i < 0) {
      const s = r ? `options.${n}` : "options.highWaterMark";
      throw new nR(s, i);
    }
    return ZI(i);
  }
  return Iv(e.objectMode);
}
var Du = {
  getHighWaterMark: sR,
  getDefaultHighWaterMark: Iv,
  setDefaultHighWaterMark: iR
};
const py = Xi, { PromisePrototypeThen: oR, SymbolAsyncIterator: hy, SymbolIterator: my } = Pt, { Buffer: aR } = jn, { ERR_INVALID_ARG_TYPE: lR, ERR_STREAM_NULL_VALUES: uR } = hn.codes;
function cR(e, t, n) {
  let r;
  if (typeof t == "string" || t instanceof aR)
    return new e({
      objectMode: !0,
      ...n,
      read() {
        this.push(t), this.push(null);
      }
    });
  let i;
  if (t && t[hy])
    i = !0, r = t[hy]();
  else if (t && t[my])
    i = !1, r = t[my]();
  else
    throw new lR("iterable", ["Iterable"], t);
  const s = new e({
    objectMode: !0,
    highWaterMark: 1,
    // TODO(ronag): What options should be allowed?
    ...n
  });
  let o = !1;
  s._read = function() {
    o || (o = !0, l());
  }, s._destroy = function(c, u) {
    oR(
      a(c),
      () => py.nextTick(u, c),
      // nextTick is here in case cb throws
      (f) => py.nextTick(u, f || c)
    );
  };
  async function a(c) {
    const u = c != null, f = typeof r.throw == "function";
    if (u && f) {
      const { value: d, done: p } = await r.throw(c);
      if (await d, p)
        return;
    }
    if (typeof r.return == "function") {
      const { value: d } = await r.return();
      await d;
    }
  }
  async function l() {
    for (; ; ) {
      try {
        const { value: c, done: u } = i ? await r.next() : r.next();
        if (u)
          s.push(null);
        else {
          const f = c && typeof c.then == "function" ? await c : c;
          if (f === null)
            throw o = !1, new uR();
          if (s.push(f))
            continue;
          o = !1;
        }
      } catch (c) {
        s.destroy(c);
      }
      break;
    }
  }
  return s;
}
var Rv = cR, sf, yy;
function Pu() {
  if (yy)
    return sf;
  yy = 1;
  const e = Xi, {
    ArrayPrototypeIndexOf: t,
    NumberIsInteger: n,
    NumberIsNaN: r,
    NumberParseInt: i,
    ObjectDefineProperties: s,
    ObjectKeys: o,
    ObjectSetPrototypeOf: a,
    Promise: l,
    SafeSet: c,
    SymbolAsyncDispose: u,
    SymbolAsyncIterator: f,
    Symbol: d
  } = Pt;
  sf = we, we.ReadableState = Me;
  const { EventEmitter: p } = Ji, { Stream: h, prependListener: m } = up, { Buffer: v } = jn, { addAbortSignal: b } = xu, E = ci;
  let y = on.debuglog("stream", (R) => {
    y = R;
  });
  const D = XI, F = Ps, { getHighWaterMark: W, getDefaultHighWaterMark: J } = Du, {
    aggregateTwoErrors: Z,
    codes: {
      ERR_INVALID_ARG_TYPE: j,
      ERR_METHOD_NOT_IMPLEMENTED: ee,
      ERR_OUT_OF_RANGE: le,
      ERR_STREAM_PUSH_AFTER_EOF: ce,
      ERR_STREAM_UNSHIFT_AFTER_END_EVENT: U
    },
    AbortError: z
  } = hn, { validateObject: ne } = ha, K = d("kPaused"), { StringDecoder: se } = jl, re = Rv;
  a(we.prototype, h.prototype), a(we, h);
  const ue = () => {
  }, { errorOrDestroy: te } = F, B = 1, M = 2, N = 4, T = 8, P = 16, k = 32, q = 64, Y = 128, ve = 256, oe = 512, S = 1024, $ = 2048, O = 4096, I = 8192, L = 16384, H = 32768, ae = 65536, Ee = 1 << 17, Oe = 1 << 18;
  function Te(R) {
    return {
      enumerable: !1,
      get() {
        return (this.state & R) !== 0;
      },
      set(C) {
        C ? this.state |= R : this.state &= ~R;
      }
    };
  }
  s(Me.prototype, {
    objectMode: Te(B),
    ended: Te(M),
    endEmitted: Te(N),
    reading: Te(T),
    // Stream is still being constructed and cannot be
    // destroyed until construction finished or failed.
    // Async construction is opt in, therefore we start as
    // constructed.
    constructed: Te(P),
    // A flag to be able to tell if the event 'readable'/'data' is emitted
    // immediately, or on a later tick.  We set this to true at first, because
    // any actions that shouldn't happen until "later" should generally also
    // not happen before the first read call.
    sync: Te(k),
    // Whenever we return null, then we set a flag to say
    // that we're awaiting a 'readable' event emission.
    needReadable: Te(q),
    emittedReadable: Te(Y),
    readableListening: Te(ve),
    resumeScheduled: Te(oe),
    // True if the error was already emitted and should not be thrown again.
    errorEmitted: Te(S),
    emitClose: Te($),
    autoDestroy: Te(O),
    // Has it been destroyed.
    destroyed: Te(I),
    // Indicates whether the stream has finished destroying.
    closed: Te(L),
    // True if close has been emitted or would have been emitted
    // depending on emitClose.
    closeEmitted: Te(H),
    multiAwaitDrain: Te(ae),
    // If true, a maybeReadMore has been scheduled.
    readingMore: Te(Ee),
    dataEmitted: Te(Oe)
  });
  function Me(R, C, fe) {
    typeof fe != "boolean" && (fe = C instanceof Fr()), this.state = $ | O | P | k, R && R.objectMode && (this.state |= B), fe && R && R.readableObjectMode && (this.state |= B), this.highWaterMark = R ? W(this, R, "readableHighWaterMark", fe) : J(!1), this.buffer = new D(), this.length = 0, this.pipes = [], this.flowing = null, this[K] = null, R && R.emitClose === !1 && (this.state &= ~$), R && R.autoDestroy === !1 && (this.state &= ~O), this.errored = null, this.defaultEncoding = R && R.defaultEncoding || "utf8", this.awaitDrainWriters = null, this.decoder = null, this.encoding = null, R && R.encoding && (this.decoder = new se(R.encoding), this.encoding = R.encoding);
  }
  function we(R) {
    if (!(this instanceof we))
      return new we(R);
    const C = this instanceof Fr();
    this._readableState = new Me(R, this, C), R && (typeof R.read == "function" && (this._read = R.read), typeof R.destroy == "function" && (this._destroy = R.destroy), typeof R.construct == "function" && (this._construct = R.construct), R.signal && !C && b(R.signal, this)), h.call(this, R), F.construct(this, () => {
      this._readableState.needReadable && X(this, this._readableState);
    });
  }
  we.prototype.destroy = F.destroy, we.prototype._undestroy = F.undestroy, we.prototype._destroy = function(R, C) {
    C(R);
  }, we.prototype[p.captureRejectionSymbol] = function(R) {
    this.destroy(R);
  }, we.prototype[u] = function() {
    let R;
    return this.destroyed || (R = this.readableEnded ? null : new z(), this.destroy(R)), new l((C, fe) => E(this, (de) => de && de !== R ? fe(de) : C(null)));
  }, we.prototype.push = function(R, C) {
    return Le(this, R, C, !1);
  }, we.prototype.unshift = function(R, C) {
    return Le(this, R, C, !0);
  };
  function Le(R, C, fe, de) {
    y("readableAddChunk", C);
    const he = R._readableState;
    let $e;
    if (he.state & B || (typeof C == "string" ? (fe = fe || he.defaultEncoding, he.encoding !== fe && (de && he.encoding ? C = v.from(C, fe).toString(he.encoding) : (C = v.from(C, fe), fe = ""))) : C instanceof v ? fe = "" : h._isUint8Array(C) ? (C = h._uint8ArrayToBuffer(C), fe = "") : C != null && ($e = new j("chunk", ["string", "Buffer", "Uint8Array"], C))), $e)
      te(R, $e);
    else if (C === null)
      he.state &= ~T, g(R, he);
    else if (he.state & B || C && C.length > 0)
      if (de)
        if (he.state & N)
          te(R, new U());
        else {
          if (he.destroyed || he.errored)
            return !1;
          ut(R, he, C, !0);
        }
      else if (he.ended)
        te(R, new ce());
      else {
        if (he.destroyed || he.errored)
          return !1;
        he.state &= ~T, he.decoder && !fe ? (C = he.decoder.write(C), he.objectMode || C.length !== 0 ? ut(R, he, C, !1) : X(R, he)) : ut(R, he, C, !1);
      }
    else
      de || (he.state &= ~T, X(R, he));
    return !he.ended && (he.length < he.highWaterMark || he.length === 0);
  }
  function ut(R, C, fe, de) {
    C.flowing && C.length === 0 && !C.sync && R.listenerCount("data") > 0 ? (C.state & ae ? C.awaitDrainWriters.clear() : C.awaitDrainWriters = null, C.dataEmitted = !0, R.emit("data", fe)) : (C.length += C.objectMode ? 1 : fe.length, de ? C.buffer.unshift(fe) : C.buffer.push(fe), C.state & q && _(R)), X(R, C);
  }
  we.prototype.isPaused = function() {
    const R = this._readableState;
    return R[K] === !0 || R.flowing === !1;
  }, we.prototype.setEncoding = function(R) {
    const C = new se(R);
    this._readableState.decoder = C, this._readableState.encoding = this._readableState.decoder.encoding;
    const fe = this._readableState.buffer;
    let de = "";
    for (const he of fe)
      de += C.write(he);
    return fe.clear(), de !== "" && fe.push(de), this._readableState.length = de.length, this;
  };
  const Je = 1073741824;
  function bt(R) {
    if (R > Je)
      throw new le("size", "<= 1GiB", R);
    return R--, R |= R >>> 1, R |= R >>> 2, R |= R >>> 4, R |= R >>> 8, R |= R >>> 16, R++, R;
  }
  function x(R, C) {
    return R <= 0 || C.length === 0 && C.ended ? 0 : C.state & B ? 1 : r(R) ? C.flowing && C.length ? C.buffer.first().length : C.length : R <= C.length ? R : C.ended ? C.length : 0;
  }
  we.prototype.read = function(R) {
    y("read", R), R === void 0 ? R = NaN : n(R) || (R = i(R, 10));
    const C = this._readableState, fe = R;
    if (R > C.highWaterMark && (C.highWaterMark = bt(R)), R !== 0 && (C.state &= ~Y), R === 0 && C.needReadable && ((C.highWaterMark !== 0 ? C.length >= C.highWaterMark : C.length > 0) || C.ended))
      return y("read: emitReadable", C.length, C.ended), C.length === 0 && C.ended ? Ut(this) : _(this), null;
    if (R = x(R, C), R === 0 && C.ended)
      return C.length === 0 && Ut(this), null;
    let de = (C.state & q) !== 0;
    if (y("need readable", de), (C.length === 0 || C.length - R < C.highWaterMark) && (de = !0, y("length less than watermark", de)), C.ended || C.reading || C.destroyed || C.errored || !C.constructed)
      de = !1, y("reading, ended or constructing", de);
    else if (de) {
      y("do read"), C.state |= T | k, C.length === 0 && (C.state |= q);
      try {
        this._read(C.highWaterMark);
      } catch ($e) {
        te(this, $e);
      }
      C.state &= ~k, C.reading || (R = x(fe, C));
    }
    let he;
    return R > 0 ? he = ir(R, C) : he = null, he === null ? (C.needReadable = C.length <= C.highWaterMark, R = 0) : (C.length -= R, C.multiAwaitDrain ? C.awaitDrainWriters.clear() : C.awaitDrainWriters = null), C.length === 0 && (C.ended || (C.needReadable = !0), fe !== R && C.ended && Ut(this)), he !== null && !C.errorEmitted && !C.closeEmitted && (C.dataEmitted = !0, this.emit("data", he)), he;
  };
  function g(R, C) {
    if (y("onEofChunk"), !C.ended) {
      if (C.decoder) {
        const fe = C.decoder.end();
        fe && fe.length && (C.buffer.push(fe), C.length += C.objectMode ? 1 : fe.length);
      }
      C.ended = !0, C.sync ? _(R) : (C.needReadable = !1, C.emittedReadable = !0, V(R));
    }
  }
  function _(R) {
    const C = R._readableState;
    y("emitReadable", C.needReadable, C.emittedReadable), C.needReadable = !1, C.emittedReadable || (y("emitReadable", C.flowing), C.emittedReadable = !0, e.nextTick(V, R));
  }
  function V(R) {
    const C = R._readableState;
    y("emitReadable_", C.destroyed, C.length, C.ended), !C.destroyed && !C.errored && (C.length || C.ended) && (R.emit("readable"), C.emittedReadable = !1), C.needReadable = !C.flowing && !C.ended && C.length <= C.highWaterMark, nt(R);
  }
  function X(R, C) {
    !C.readingMore && C.constructed && (C.readingMore = !0, e.nextTick(pe, R, C));
  }
  function pe(R, C) {
    for (; !C.reading && !C.ended && (C.length < C.highWaterMark || C.flowing && C.length === 0); ) {
      const fe = C.length;
      if (y("maybeReadMore read 0"), R.read(0), fe === C.length)
        break;
    }
    C.readingMore = !1;
  }
  we.prototype._read = function(R) {
    throw new ee("_read()");
  }, we.prototype.pipe = function(R, C) {
    const fe = this, de = this._readableState;
    de.pipes.length === 1 && (de.multiAwaitDrain || (de.multiAwaitDrain = !0, de.awaitDrainWriters = new c(de.awaitDrainWriters ? [de.awaitDrainWriters] : []))), de.pipes.push(R), y("pipe count=%d opts=%j", de.pipes.length, C);
    const $e = (!C || C.end !== !1) && R !== e.stdout && R !== e.stderr ? Ne : vt;
    de.endEmitted ? e.nextTick($e) : fe.once("end", $e), R.on("unpipe", De);
    function De(kt, Ct) {
      y("onunpipe"), kt === fe && Ct && Ct.hasUnpiped === !1 && (Ct.hasUnpiped = !0, rt());
    }
    function Ne() {
      y("onend"), R.end();
    }
    let Re, Ue = !1;
    function rt() {
      y("cleanup"), R.removeListener("close", et), R.removeListener("finish", qe), Re && R.removeListener("drain", Re), R.removeListener("error", Ze), R.removeListener("unpipe", De), fe.removeListener("end", Ne), fe.removeListener("end", vt), fe.removeListener("data", ct), Ue = !0, Re && de.awaitDrainWriters && (!R._writableState || R._writableState.needDrain) && Re();
    }
    function dt() {
      Ue || (de.pipes.length === 1 && de.pipes[0] === R ? (y("false write response, pause", 0), de.awaitDrainWriters = R, de.multiAwaitDrain = !1) : de.pipes.length > 1 && de.pipes.includes(R) && (y("false write response, pause", de.awaitDrainWriters.size), de.awaitDrainWriters.add(R)), fe.pause()), Re || (Re = ye(fe, R), R.on("drain", Re));
    }
    fe.on("data", ct);
    function ct(kt) {
      y("ondata");
      const Ct = R.write(kt);
      y("dest.write", Ct), Ct === !1 && dt();
    }
    function Ze(kt) {
      if (y("onerror", kt), vt(), R.removeListener("error", Ze), R.listenerCount("error") === 0) {
        const Ct = R._writableState || R._readableState;
        Ct && !Ct.errorEmitted ? te(R, kt) : R.emit("error", kt);
      }
    }
    m(R, "error", Ze);
    function et() {
      R.removeListener("finish", qe), vt();
    }
    R.once("close", et);
    function qe() {
      y("onfinish"), R.removeListener("close", et), vt();
    }
    R.once("finish", qe);
    function vt() {
      y("unpipe"), fe.unpipe(R);
    }
    return R.emit("pipe", fe), R.writableNeedDrain === !0 ? dt() : de.flowing || (y("pipe resume"), fe.resume()), R;
  };
  function ye(R, C) {
    return function() {
      const de = R._readableState;
      de.awaitDrainWriters === C ? (y("pipeOnDrain", 1), de.awaitDrainWriters = null) : de.multiAwaitDrain && (y("pipeOnDrain", de.awaitDrainWriters.size), de.awaitDrainWriters.delete(C)), (!de.awaitDrainWriters || de.awaitDrainWriters.size === 0) && R.listenerCount("data") && R.resume();
    };
  }
  we.prototype.unpipe = function(R) {
    const C = this._readableState, fe = {
      hasUnpiped: !1
    };
    if (C.pipes.length === 0)
      return this;
    if (!R) {
      const he = C.pipes;
      C.pipes = [], this.pause();
      for (let $e = 0; $e < he.length; $e++)
        he[$e].emit("unpipe", this, {
          hasUnpiped: !1
        });
      return this;
    }
    const de = t(C.pipes, R);
    return de === -1 ? this : (C.pipes.splice(de, 1), C.pipes.length === 0 && this.pause(), R.emit("unpipe", this, fe), this);
  }, we.prototype.on = function(R, C) {
    const fe = h.prototype.on.call(this, R, C), de = this._readableState;
    return R === "data" ? (de.readableListening = this.listenerCount("readable") > 0, de.flowing !== !1 && this.resume()) : R === "readable" && !de.endEmitted && !de.readableListening && (de.readableListening = de.needReadable = !0, de.flowing = !1, de.emittedReadable = !1, y("on readable", de.length, de.reading), de.length ? _(this) : de.reading || e.nextTick(ft, this)), fe;
  }, we.prototype.addListener = we.prototype.on, we.prototype.removeListener = function(R, C) {
    const fe = h.prototype.removeListener.call(this, R, C);
    return R === "readable" && e.nextTick(Ge, this), fe;
  }, we.prototype.off = we.prototype.removeListener, we.prototype.removeAllListeners = function(R) {
    const C = h.prototype.removeAllListeners.apply(this, arguments);
    return (R === "readable" || R === void 0) && e.nextTick(Ge, this), C;
  };
  function Ge(R) {
    const C = R._readableState;
    C.readableListening = R.listenerCount("readable") > 0, C.resumeScheduled && C[K] === !1 ? C.flowing = !0 : R.listenerCount("data") > 0 ? R.resume() : C.readableListening || (C.flowing = null);
  }
  function ft(R) {
    y("readable nexttick read 0"), R.read(0);
  }
  we.prototype.resume = function() {
    const R = this._readableState;
    return R.flowing || (y("resume"), R.flowing = !R.readableListening, ze(this, R)), R[K] = !1, this;
  };
  function ze(R, C) {
    C.resumeScheduled || (C.resumeScheduled = !0, e.nextTick(st, R, C));
  }
  function st(R, C) {
    y("resume", C.reading), C.reading || R.read(0), C.resumeScheduled = !1, R.emit("resume"), nt(R), C.flowing && !C.reading && R.read(0);
  }
  we.prototype.pause = function() {
    return y("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (y("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState[K] = !0, this;
  };
  function nt(R) {
    const C = R._readableState;
    for (y("flow", C.flowing); C.flowing && R.read() !== null; )
      ;
  }
  we.prototype.wrap = function(R) {
    let C = !1;
    R.on("data", (de) => {
      !this.push(de) && R.pause && (C = !0, R.pause());
    }), R.on("end", () => {
      this.push(null);
    }), R.on("error", (de) => {
      te(this, de);
    }), R.on("close", () => {
      this.destroy();
    }), R.on("destroy", () => {
      this.destroy();
    }), this._read = () => {
      C && R.resume && (C = !1, R.resume());
    };
    const fe = o(R);
    for (let de = 1; de < fe.length; de++) {
      const he = fe[de];
      this[he] === void 0 && typeof R[he] == "function" && (this[he] = R[he].bind(R));
    }
    return this;
  }, we.prototype[f] = function() {
    return nr(this);
  }, we.prototype.iterator = function(R) {
    return R !== void 0 && ne(R, "options"), nr(this, R);
  };
  function nr(R, C) {
    typeof R.read != "function" && (R = we.wrap(R, {
      objectMode: !0
    }));
    const fe = rr(R, C);
    return fe.stream = R, fe;
  }
  async function* rr(R, C) {
    let fe = ue;
    function de(De) {
      this === R ? (fe(), fe = ue) : fe = De;
    }
    R.on("readable", de);
    let he;
    const $e = E(
      R,
      {
        writable: !1
      },
      (De) => {
        he = De ? Z(he, De) : null, fe(), fe = ue;
      }
    );
    try {
      for (; ; ) {
        const De = R.destroyed ? null : R.read();
        if (De !== null)
          yield De;
        else {
          if (he)
            throw he;
          if (he === null)
            return;
          await new l(de);
        }
      }
    } catch (De) {
      throw he = Z(he, De), he;
    } finally {
      (he || C?.destroyOnReturn !== !1) && (he === void 0 || R._readableState.autoDestroy) ? F.destroyer(R, null) : (R.off("readable", de), $e());
    }
  }
  s(we.prototype, {
    readable: {
      __proto__: null,
      get() {
        const R = this._readableState;
        return !!R && R.readable !== !1 && !R.destroyed && !R.errorEmitted && !R.endEmitted;
      },
      set(R) {
        this._readableState && (this._readableState.readable = !!R);
      }
    },
    readableDidRead: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return this._readableState.dataEmitted;
      }
    },
    readableAborted: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return !!(this._readableState.readable !== !1 && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
      }
    },
    readableHighWaterMark: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return this._readableState.highWaterMark;
      }
    },
    readableBuffer: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return this._readableState && this._readableState.buffer;
      }
    },
    readableFlowing: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return this._readableState.flowing;
      },
      set: function(R) {
        this._readableState && (this._readableState.flowing = R);
      }
    },
    readableLength: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState.length;
      }
    },
    readableObjectMode: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.objectMode : !1;
      }
    },
    readableEncoding: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.encoding : null;
      }
    },
    errored: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.errored : null;
      }
    },
    closed: {
      __proto__: null,
      get() {
        return this._readableState ? this._readableState.closed : !1;
      }
    },
    destroyed: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.destroyed : !1;
      },
      set(R) {
        this._readableState && (this._readableState.destroyed = R);
      }
    },
    readableEnded: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.endEmitted : !1;
      }
    }
  }), s(Me.prototype, {
    // Legacy getter for `pipesCount`.
    pipesCount: {
      __proto__: null,
      get() {
        return this.pipes.length;
      }
    },
    // Legacy property for `paused`.
    paused: {
      __proto__: null,
      get() {
        return this[K] !== !1;
      },
      set(R) {
        this[K] = !!R;
      }
    }
  }), we._fromList = ir;
  function ir(R, C) {
    if (C.length === 0)
      return null;
    let fe;
    return C.objectMode ? fe = C.buffer.shift() : !R || R >= C.length ? (C.decoder ? fe = C.buffer.join("") : C.buffer.length === 1 ? fe = C.buffer.first() : fe = C.buffer.concat(C.length), C.buffer.clear()) : fe = C.buffer.consume(R, C.decoder), fe;
  }
  function Ut(R) {
    const C = R._readableState;
    y("endReadable", C.endEmitted), C.endEmitted || (C.ended = !0, e.nextTick(mi, C, R));
  }
  function mi(R, C) {
    if (y("endReadableNT", R.endEmitted, R.length), !R.errored && !R.closeEmitted && !R.endEmitted && R.length === 0) {
      if (R.endEmitted = !0, C.emit("end"), C.writable && C.allowHalfOpen === !1)
        e.nextTick(Vt, C);
      else if (R.autoDestroy) {
        const fe = C._writableState;
        (!fe || fe.autoDestroy && // We don't expect the writable to ever 'finish'
        // if writable is explicitly set to false.
        (fe.finished || fe.writable === !1)) && C.destroy();
      }
    }
  }
  function Vt(R) {
    R.writable && !R.writableEnded && !R.destroyed && R.end();
  }
  we.from = function(R, C) {
    return re(we, R, C);
  };
  let $r;
  function ie() {
    return $r === void 0 && ($r = {}), $r;
  }
  return we.fromWeb = function(R, C) {
    return ie().newStreamReadableFromReadableStream(R, C);
  }, we.toWeb = function(R, C) {
    return ie().newReadableStreamFromStreamReadable(R, C);
  }, we.wrap = function(R, C) {
    var fe, de;
    return new we({
      objectMode: (fe = (de = R.readableObjectMode) !== null && de !== void 0 ? de : R.objectMode) !== null && fe !== void 0 ? fe : !0,
      ...C,
      destroy(he, $e) {
        F.destroyer(R, he), $e(he);
      }
    }).wrap(R);
  }, sf;
}
var of, gy;
function cp() {
  if (gy)
    return of;
  gy = 1;
  const e = Xi, {
    ArrayPrototypeSlice: t,
    Error: n,
    FunctionPrototypeSymbolHasInstance: r,
    ObjectDefineProperty: i,
    ObjectDefineProperties: s,
    ObjectSetPrototypeOf: o,
    StringPrototypeToLowerCase: a,
    Symbol: l,
    SymbolHasInstance: c
  } = Pt;
  of = ne, ne.WritableState = U;
  const { EventEmitter: u } = Ji, f = up.Stream, { Buffer: d } = jn, p = Ps, { addAbortSignal: h } = xu, { getHighWaterMark: m, getDefaultHighWaterMark: v } = Du, {
    ERR_INVALID_ARG_TYPE: b,
    ERR_METHOD_NOT_IMPLEMENTED: E,
    ERR_MULTIPLE_CALLBACK: y,
    ERR_STREAM_CANNOT_PIPE: D,
    ERR_STREAM_DESTROYED: F,
    ERR_STREAM_ALREADY_FINISHED: W,
    ERR_STREAM_NULL_VALUES: J,
    ERR_STREAM_WRITE_AFTER_END: Z,
    ERR_UNKNOWN_ENCODING: j
  } = hn.codes, { errorOrDestroy: ee } = p;
  o(ne.prototype, f.prototype), o(ne, f);
  function le() {
  }
  const ce = l("kOnFinished");
  function U(O, I, L) {
    typeof L != "boolean" && (L = I instanceof Fr()), this.objectMode = !!(O && O.objectMode), L && (this.objectMode = this.objectMode || !!(O && O.writableObjectMode)), this.highWaterMark = O ? m(this, O, "writableHighWaterMark", L) : v(!1), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    const H = !!(O && O.decodeStrings === !1);
    this.decodeStrings = !H, this.defaultEncoding = O && O.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = te.bind(void 0, I), this.writecb = null, this.writelen = 0, this.afterWriteTickInfo = null, z(this), this.pendingcb = 0, this.constructed = !0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = !O || O.emitClose !== !1, this.autoDestroy = !O || O.autoDestroy !== !1, this.errored = null, this.closed = !1, this.closeEmitted = !1, this[ce] = [];
  }
  function z(O) {
    O.buffered = [], O.bufferedIndex = 0, O.allBuffers = !0, O.allNoop = !0;
  }
  U.prototype.getBuffer = function() {
    return t(this.buffered, this.bufferedIndex);
  }, i(U.prototype, "bufferedRequestCount", {
    __proto__: null,
    get() {
      return this.buffered.length - this.bufferedIndex;
    }
  });
  function ne(O) {
    const I = this instanceof Fr();
    if (!I && !r(ne, this))
      return new ne(O);
    this._writableState = new U(O, this, I), O && (typeof O.write == "function" && (this._write = O.write), typeof O.writev == "function" && (this._writev = O.writev), typeof O.destroy == "function" && (this._destroy = O.destroy), typeof O.final == "function" && (this._final = O.final), typeof O.construct == "function" && (this._construct = O.construct), O.signal && h(O.signal, this)), f.call(this, O), p.construct(this, () => {
      const L = this._writableState;
      L.writing || T(this, L), Y(this, L);
    });
  }
  i(ne, c, {
    __proto__: null,
    value: function(O) {
      return r(this, O) ? !0 : this !== ne ? !1 : O && O._writableState instanceof U;
    }
  }), ne.prototype.pipe = function() {
    ee(this, new D());
  };
  function K(O, I, L, H) {
    const ae = O._writableState;
    if (typeof L == "function")
      H = L, L = ae.defaultEncoding;
    else {
      if (!L)
        L = ae.defaultEncoding;
      else if (L !== "buffer" && !d.isEncoding(L))
        throw new j(L);
      typeof H != "function" && (H = le);
    }
    if (I === null)
      throw new J();
    if (!ae.objectMode)
      if (typeof I == "string")
        ae.decodeStrings !== !1 && (I = d.from(I, L), L = "buffer");
      else if (I instanceof d)
        L = "buffer";
      else if (f._isUint8Array(I))
        I = f._uint8ArrayToBuffer(I), L = "buffer";
      else
        throw new b("chunk", ["string", "Buffer", "Uint8Array"], I);
    let Ee;
    return ae.ending ? Ee = new Z() : ae.destroyed && (Ee = new F("write")), Ee ? (e.nextTick(H, Ee), ee(O, Ee, !0), Ee) : (ae.pendingcb++, se(O, ae, I, L, H));
  }
  ne.prototype.write = function(O, I, L) {
    return K(this, O, I, L) === !0;
  }, ne.prototype.cork = function() {
    this._writableState.corked++;
  }, ne.prototype.uncork = function() {
    const O = this._writableState;
    O.corked && (O.corked--, O.writing || T(this, O));
  }, ne.prototype.setDefaultEncoding = function(I) {
    if (typeof I == "string" && (I = a(I)), !d.isEncoding(I))
      throw new j(I);
    return this._writableState.defaultEncoding = I, this;
  };
  function se(O, I, L, H, ae) {
    const Ee = I.objectMode ? 1 : L.length;
    I.length += Ee;
    const Oe = I.length < I.highWaterMark;
    return Oe || (I.needDrain = !0), I.writing || I.corked || I.errored || !I.constructed ? (I.buffered.push({
      chunk: L,
      encoding: H,
      callback: ae
    }), I.allBuffers && H !== "buffer" && (I.allBuffers = !1), I.allNoop && ae !== le && (I.allNoop = !1)) : (I.writelen = Ee, I.writecb = ae, I.writing = !0, I.sync = !0, O._write(L, H, I.onwrite), I.sync = !1), Oe && !I.errored && !I.destroyed;
  }
  function re(O, I, L, H, ae, Ee, Oe) {
    I.writelen = H, I.writecb = Oe, I.writing = !0, I.sync = !0, I.destroyed ? I.onwrite(new F("write")) : L ? O._writev(ae, I.onwrite) : O._write(ae, Ee, I.onwrite), I.sync = !1;
  }
  function ue(O, I, L, H) {
    --I.pendingcb, H(L), N(I), ee(O, L);
  }
  function te(O, I) {
    const L = O._writableState, H = L.sync, ae = L.writecb;
    if (typeof ae != "function") {
      ee(O, new y());
      return;
    }
    L.writing = !1, L.writecb = null, L.length -= L.writelen, L.writelen = 0, I ? (I.stack, L.errored || (L.errored = I), O._readableState && !O._readableState.errored && (O._readableState.errored = I), H ? e.nextTick(ue, O, L, I, ae) : ue(O, L, I, ae)) : (L.buffered.length > L.bufferedIndex && T(O, L), H ? L.afterWriteTickInfo !== null && L.afterWriteTickInfo.cb === ae ? L.afterWriteTickInfo.count++ : (L.afterWriteTickInfo = {
      count: 1,
      cb: ae,
      stream: O,
      state: L
    }, e.nextTick(B, L.afterWriteTickInfo)) : M(O, L, 1, ae));
  }
  function B({ stream: O, state: I, count: L, cb: H }) {
    return I.afterWriteTickInfo = null, M(O, I, L, H);
  }
  function M(O, I, L, H) {
    for (!I.ending && !O.destroyed && I.length === 0 && I.needDrain && (I.needDrain = !1, O.emit("drain")); L-- > 0; )
      I.pendingcb--, H();
    I.destroyed && N(I), Y(O, I);
  }
  function N(O) {
    if (O.writing)
      return;
    for (let ae = O.bufferedIndex; ae < O.buffered.length; ++ae) {
      var I;
      const { chunk: Ee, callback: Oe } = O.buffered[ae], Te = O.objectMode ? 1 : Ee.length;
      O.length -= Te, Oe(
        (I = O.errored) !== null && I !== void 0 ? I : new F("write")
      );
    }
    const L = O[ce].splice(0);
    for (let ae = 0; ae < L.length; ae++) {
      var H;
      L[ae](
        (H = O.errored) !== null && H !== void 0 ? H : new F("end")
      );
    }
    z(O);
  }
  function T(O, I) {
    if (I.corked || I.bufferProcessing || I.destroyed || !I.constructed)
      return;
    const { buffered: L, bufferedIndex: H, objectMode: ae } = I, Ee = L.length - H;
    if (!Ee)
      return;
    let Oe = H;
    if (I.bufferProcessing = !0, Ee > 1 && O._writev) {
      I.pendingcb -= Ee - 1;
      const Te = I.allNoop ? le : (we) => {
        for (let Le = Oe; Le < L.length; ++Le)
          L[Le].callback(we);
      }, Me = I.allNoop && Oe === 0 ? L : t(L, Oe);
      Me.allBuffers = I.allBuffers, re(O, I, !0, I.length, Me, "", Te), z(I);
    } else {
      do {
        const { chunk: Te, encoding: Me, callback: we } = L[Oe];
        L[Oe++] = null;
        const Le = ae ? 1 : Te.length;
        re(O, I, !1, Le, Te, Me, we);
      } while (Oe < L.length && !I.writing);
      Oe === L.length ? z(I) : Oe > 256 ? (L.splice(0, Oe), I.bufferedIndex = 0) : I.bufferedIndex = Oe;
    }
    I.bufferProcessing = !1;
  }
  ne.prototype._write = function(O, I, L) {
    if (this._writev)
      this._writev(
        [
          {
            chunk: O,
            encoding: I
          }
        ],
        L
      );
    else
      throw new E("_write()");
  }, ne.prototype._writev = null, ne.prototype.end = function(O, I, L) {
    const H = this._writableState;
    typeof O == "function" ? (L = O, O = null, I = null) : typeof I == "function" && (L = I, I = null);
    let ae;
    if (O != null) {
      const Ee = K(this, O, I);
      Ee instanceof n && (ae = Ee);
    }
    return H.corked && (H.corked = 1, this.uncork()), ae || (!H.errored && !H.ending ? (H.ending = !0, Y(this, H, !0), H.ended = !0) : H.finished ? ae = new W("end") : H.destroyed && (ae = new F("end"))), typeof L == "function" && (ae || H.finished ? e.nextTick(L, ae) : H[ce].push(L)), this;
  };
  function P(O) {
    return O.ending && !O.destroyed && O.constructed && O.length === 0 && !O.errored && O.buffered.length === 0 && !O.finished && !O.writing && !O.errorEmitted && !O.closeEmitted;
  }
  function k(O, I) {
    let L = !1;
    function H(ae) {
      if (L) {
        ee(O, ae ?? y());
        return;
      }
      if (L = !0, I.pendingcb--, ae) {
        const Ee = I[ce].splice(0);
        for (let Oe = 0; Oe < Ee.length; Oe++)
          Ee[Oe](ae);
        ee(O, ae, I.sync);
      } else
        P(I) && (I.prefinished = !0, O.emit("prefinish"), I.pendingcb++, e.nextTick(ve, O, I));
    }
    I.sync = !0, I.pendingcb++;
    try {
      O._final(H);
    } catch (ae) {
      H(ae);
    }
    I.sync = !1;
  }
  function q(O, I) {
    !I.prefinished && !I.finalCalled && (typeof O._final == "function" && !I.destroyed ? (I.finalCalled = !0, k(O, I)) : (I.prefinished = !0, O.emit("prefinish")));
  }
  function Y(O, I, L) {
    P(I) && (q(O, I), I.pendingcb === 0 && (L ? (I.pendingcb++, e.nextTick(
      (H, ae) => {
        P(ae) ? ve(H, ae) : ae.pendingcb--;
      },
      O,
      I
    )) : P(I) && (I.pendingcb++, ve(O, I))));
  }
  function ve(O, I) {
    I.pendingcb--, I.finished = !0;
    const L = I[ce].splice(0);
    for (let H = 0; H < L.length; H++)
      L[H]();
    if (O.emit("finish"), I.autoDestroy) {
      const H = O._readableState;
      (!H || H.autoDestroy && // We don't expect the readable to ever 'end'
      // if readable is explicitly set to false.
      (H.endEmitted || H.readable === !1)) && O.destroy();
    }
  }
  s(ne.prototype, {
    closed: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.closed : !1;
      }
    },
    destroyed: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.destroyed : !1;
      },
      set(O) {
        this._writableState && (this._writableState.destroyed = O);
      }
    },
    writable: {
      __proto__: null,
      get() {
        const O = this._writableState;
        return !!O && O.writable !== !1 && !O.destroyed && !O.errored && !O.ending && !O.ended;
      },
      set(O) {
        this._writableState && (this._writableState.writable = !!O);
      }
    },
    writableFinished: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.finished : !1;
      }
    },
    writableObjectMode: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.objectMode : !1;
      }
    },
    writableBuffer: {
      __proto__: null,
      get() {
        return this._writableState && this._writableState.getBuffer();
      }
    },
    writableEnded: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.ending : !1;
      }
    },
    writableNeedDrain: {
      __proto__: null,
      get() {
        const O = this._writableState;
        return O ? !O.destroyed && !O.ending && O.needDrain : !1;
      }
    },
    writableHighWaterMark: {
      __proto__: null,
      get() {
        return this._writableState && this._writableState.highWaterMark;
      }
    },
    writableCorked: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.corked : 0;
      }
    },
    writableLength: {
      __proto__: null,
      get() {
        return this._writableState && this._writableState.length;
      }
    },
    errored: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._writableState ? this._writableState.errored : null;
      }
    },
    writableAborted: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return !!(this._writableState.writable !== !1 && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
      }
    }
  });
  const oe = p.destroy;
  ne.prototype.destroy = function(O, I) {
    const L = this._writableState;
    return !L.destroyed && (L.bufferedIndex < L.buffered.length || L[ce].length) && e.nextTick(N, L), oe.call(this, O, I), this;
  }, ne.prototype._undestroy = p.undestroy, ne.prototype._destroy = function(O, I) {
    I(O);
  }, ne.prototype[u.captureRejectionSymbol] = function(O) {
    this.destroy(O);
  };
  let S;
  function $() {
    return S === void 0 && (S = {}), S;
  }
  return ne.fromWeb = function(O, I) {
    return $().newStreamWritableFromWritableStream(O, I);
  }, ne.toWeb = function(O) {
    return $().newWritableStreamFromStreamWritable(O);
  }, of;
}
var af, by;
function fR() {
  if (by)
    return af;
  by = 1;
  const e = Xi, t = jn, {
    isReadable: n,
    isWritable: r,
    isIterable: i,
    isNodeStream: s,
    isReadableNodeStream: o,
    isWritableNodeStream: a,
    isDuplexNodeStream: l,
    isReadableStream: c,
    isWritableStream: u
  } = Wr, f = ci, {
    AbortError: d,
    codes: { ERR_INVALID_ARG_TYPE: p, ERR_INVALID_RETURN_VALUE: h }
  } = hn, { destroyer: m } = Ps, v = Fr(), b = Pu(), E = cp(), { createDeferredPromise: y } = on, D = Rv, F = globalThis.Blob || t.Blob, W = typeof F < "u" ? function(U) {
    return U instanceof F;
  } : function(U) {
    return !1;
  }, J = globalThis.AbortController || Qo().AbortController, { FunctionPrototypeCall: Z } = Pt;
  class j extends v {
    constructor(U) {
      super(U), U?.readable === !1 && (this._readableState.readable = !1, this._readableState.ended = !0, this._readableState.endEmitted = !0), U?.writable === !1 && (this._writableState.writable = !1, this._writableState.ending = !0, this._writableState.ended = !0, this._writableState.finished = !0);
    }
  }
  af = function ce(U, z) {
    if (l(U))
      return U;
    if (o(U))
      return le({
        readable: U
      });
    if (a(U))
      return le({
        writable: U
      });
    if (s(U))
      return le({
        writable: !1,
        readable: !1
      });
    if (c(U))
      return le({
        readable: b.fromWeb(U)
      });
    if (u(U))
      return le({
        writable: E.fromWeb(U)
      });
    if (typeof U == "function") {
      const { value: K, write: se, final: re, destroy: ue } = ee(U);
      if (i(K))
        return D(j, K, {
          // TODO (ronag): highWaterMark?
          objectMode: !0,
          write: se,
          final: re,
          destroy: ue
        });
      const te = K?.then;
      if (typeof te == "function") {
        let B;
        const M = Z(
          te,
          K,
          (N) => {
            if (N != null)
              throw new h("nully", "body", N);
          },
          (N) => {
            m(B, N);
          }
        );
        return B = new j({
          // TODO (ronag): highWaterMark?
          objectMode: !0,
          readable: !1,
          write: se,
          final(N) {
            re(async () => {
              try {
                await M, e.nextTick(N, null);
              } catch (T) {
                e.nextTick(N, T);
              }
            });
          },
          destroy: ue
        });
      }
      throw new h("Iterable, AsyncIterable or AsyncFunction", z, K);
    }
    if (W(U))
      return ce(U.arrayBuffer());
    if (i(U))
      return D(j, U, {
        // TODO (ronag): highWaterMark?
        objectMode: !0,
        writable: !1
      });
    if (c(U?.readable) && u(U?.writable))
      return j.fromWeb(U);
    if (typeof U?.writable == "object" || typeof U?.readable == "object") {
      const K = U != null && U.readable ? o(U?.readable) ? U?.readable : ce(U.readable) : void 0, se = U != null && U.writable ? a(U?.writable) ? U?.writable : ce(U.writable) : void 0;
      return le({
        readable: K,
        writable: se
      });
    }
    const ne = U?.then;
    if (typeof ne == "function") {
      let K;
      return Z(
        ne,
        U,
        (se) => {
          se != null && K.push(se), K.push(null);
        },
        (se) => {
          m(K, se);
        }
      ), K = new j({
        objectMode: !0,
        writable: !1,
        read() {
        }
      });
    }
    throw new p(
      z,
      [
        "Blob",
        "ReadableStream",
        "WritableStream",
        "Stream",
        "Iterable",
        "AsyncIterable",
        "Function",
        "{ readable, writable } pair",
        "Promise"
      ],
      U
    );
  };
  function ee(ce) {
    let { promise: U, resolve: z } = y();
    const ne = new J(), K = ne.signal;
    return {
      value: ce(
        async function* () {
          for (; ; ) {
            const re = U;
            U = null;
            const { chunk: ue, done: te, cb: B } = await re;
            if (e.nextTick(B), te)
              return;
            if (K.aborted)
              throw new d(void 0, {
                cause: K.reason
              });
            ({ promise: U, resolve: z } = y()), yield ue;
          }
        }(),
        {
          signal: K
        }
      ),
      write(re, ue, te) {
        const B = z;
        z = null, B({
          chunk: re,
          done: !1,
          cb: te
        });
      },
      final(re) {
        const ue = z;
        z = null, ue({
          done: !0,
          cb: re
        });
      },
      destroy(re, ue) {
        ne.abort(), ue(re);
      }
    };
  }
  function le(ce) {
    const U = ce.readable && typeof ce.readable.read != "function" ? b.wrap(ce.readable) : ce.readable, z = ce.writable;
    let ne = !!n(U), K = !!r(z), se, re, ue, te, B;
    function M(N) {
      const T = te;
      te = null, T ? T(N) : N && B.destroy(N);
    }
    return B = new j({
      // TODO (ronag): highWaterMark?
      readableObjectMode: !!(U != null && U.readableObjectMode),
      writableObjectMode: !!(z != null && z.writableObjectMode),
      readable: ne,
      writable: K
    }), K && (f(z, (N) => {
      K = !1, N && m(U, N), M(N);
    }), B._write = function(N, T, P) {
      z.write(N, T) ? P() : se = P;
    }, B._final = function(N) {
      z.end(), re = N;
    }, z.on("drain", function() {
      if (se) {
        const N = se;
        se = null, N();
      }
    }), z.on("finish", function() {
      if (re) {
        const N = re;
        re = null, N();
      }
    })), ne && (f(U, (N) => {
      ne = !1, N && m(U, N), M(N);
    }), U.on("readable", function() {
      if (ue) {
        const N = ue;
        ue = null, N();
      }
    }), U.on("end", function() {
      B.push(null);
    }), B._read = function() {
      for (; ; ) {
        const N = U.read();
        if (N === null) {
          ue = B._read;
          return;
        }
        if (!B.push(N))
          return;
      }
    }), B._destroy = function(N, T) {
      !N && te !== null && (N = new d()), ue = null, se = null, re = null, te === null ? T(N) : (te = T, m(z, N), m(U, N));
    }, B;
  }
  return af;
}
var lf, vy;
function Fr() {
  if (vy)
    return lf;
  vy = 1;
  const {
    ObjectDefineProperties: e,
    ObjectGetOwnPropertyDescriptor: t,
    ObjectKeys: n,
    ObjectSetPrototypeOf: r
  } = Pt;
  lf = o;
  const i = Pu(), s = cp();
  r(o.prototype, i.prototype), r(o, i);
  {
    const u = n(s.prototype);
    for (let f = 0; f < u.length; f++) {
      const d = u[f];
      o.prototype[d] || (o.prototype[d] = s.prototype[d]);
    }
  }
  function o(u) {
    if (!(this instanceof o))
      return new o(u);
    i.call(this, u), s.call(this, u), u ? (this.allowHalfOpen = u.allowHalfOpen !== !1, u.readable === !1 && (this._readableState.readable = !1, this._readableState.ended = !0, this._readableState.endEmitted = !0), u.writable === !1 && (this._writableState.writable = !1, this._writableState.ending = !0, this._writableState.ended = !0, this._writableState.finished = !0)) : this.allowHalfOpen = !0;
  }
  e(o.prototype, {
    writable: {
      __proto__: null,
      ...t(s.prototype, "writable")
    },
    writableHighWaterMark: {
      __proto__: null,
      ...t(s.prototype, "writableHighWaterMark")
    },
    writableObjectMode: {
      __proto__: null,
      ...t(s.prototype, "writableObjectMode")
    },
    writableBuffer: {
      __proto__: null,
      ...t(s.prototype, "writableBuffer")
    },
    writableLength: {
      __proto__: null,
      ...t(s.prototype, "writableLength")
    },
    writableFinished: {
      __proto__: null,
      ...t(s.prototype, "writableFinished")
    },
    writableCorked: {
      __proto__: null,
      ...t(s.prototype, "writableCorked")
    },
    writableEnded: {
      __proto__: null,
      ...t(s.prototype, "writableEnded")
    },
    writableNeedDrain: {
      __proto__: null,
      ...t(s.prototype, "writableNeedDrain")
    },
    destroyed: {
      __proto__: null,
      get() {
        return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
      },
      set(u) {
        this._readableState && this._writableState && (this._readableState.destroyed = u, this._writableState.destroyed = u);
      }
    }
  });
  let a;
  function l() {
    return a === void 0 && (a = {}), a;
  }
  o.fromWeb = function(u, f) {
    return l().newStreamDuplexFromReadableWritablePair(u, f);
  }, o.toWeb = function(u) {
    return l().newReadableWritablePairFromDuplex(u);
  };
  let c;
  return o.from = function(u) {
    return c || (c = fR()), c(u, "body");
  }, lf;
}
const { ObjectSetPrototypeOf: Av, Symbol: dR } = Pt;
var xv = Ur;
const { ERR_METHOD_NOT_IMPLEMENTED: pR } = hn.codes, fp = Fr(), { getHighWaterMark: hR } = Du;
Av(Ur.prototype, fp.prototype);
Av(Ur, fp);
const Do = dR("kCallback");
function Ur(e) {
  if (!(this instanceof Ur))
    return new Ur(e);
  const t = e ? hR(this, e, "readableHighWaterMark", !0) : null;
  t === 0 && (e = {
    ...e,
    highWaterMark: null,
    readableHighWaterMark: t,
    // TODO (ronag): 0 is not optimal since we have
    // a "bug" where we check needDrain before calling _write and not after.
    // Refs: https://github.com/nodejs/node/pull/32887
    // Refs: https://github.com/nodejs/node/pull/35941
    writableHighWaterMark: e.writableHighWaterMark || 0
  }), fp.call(this, e), this._readableState.sync = !1, this[Do] = null, e && (typeof e.transform == "function" && (this._transform = e.transform), typeof e.flush == "function" && (this._flush = e.flush)), this.on("prefinish", mR);
}
function td(e) {
  typeof this._flush == "function" && !this.destroyed ? this._flush((t, n) => {
    if (t) {
      e ? e(t) : this.destroy(t);
      return;
    }
    n != null && this.push(n), this.push(null), e && e();
  }) : (this.push(null), e && e());
}
function mR() {
  this._final !== td && td.call(this);
}
Ur.prototype._final = td;
Ur.prototype._transform = function(e, t, n) {
  throw new pR("_transform()");
};
Ur.prototype._write = function(e, t, n) {
  const r = this._readableState, i = this._writableState, s = r.length;
  this._transform(e, t, (o, a) => {
    if (o) {
      n(o);
      return;
    }
    a != null && this.push(a), i.ended || // Backwards compat.
    s === r.length || // Backwards compat.
    r.length < r.highWaterMark ? n() : this[Do] = n;
  });
};
Ur.prototype._read = function() {
  if (this[Do]) {
    const e = this[Do];
    this[Do] = null, e();
  }
};
const { ObjectSetPrototypeOf: Dv } = Pt;
var Pv = Es;
const dp = xv;
Dv(Es.prototype, dp.prototype);
Dv(Es, dp);
function Es(e) {
  if (!(this instanceof Es))
    return new Es(e);
  dp.call(this, e);
}
Es.prototype._transform = function(e, t, n) {
  n(null, e);
};
const To = Xi, { ArrayIsArray: yR, Promise: gR, SymbolAsyncIterator: bR, SymbolDispose: vR } = Pt, Ml = ci, { once: _R } = on, wR = Ps, _y = Fr(), {
  aggregateTwoErrors: ER,
  codes: {
    ERR_INVALID_ARG_TYPE: nd,
    ERR_INVALID_RETURN_VALUE: uf,
    ERR_MISSING_ARGS: SR,
    ERR_STREAM_DESTROYED: TR,
    ERR_STREAM_PREMATURE_CLOSE: $R
  },
  AbortError: NR
} = hn, { validateFunction: OR, validateAbortSignal: IR } = ha, {
  isIterable: Di,
  isReadable: cf,
  isReadableNodeStream: yl,
  isNodeStream: wy,
  isTransformStream: us,
  isWebStream: RR,
  isReadableStream: ff,
  isReadableFinished: AR
} = Wr, xR = globalThis.AbortController || Qo().AbortController;
let df, pf, hf;
function Ey(e, t, n) {
  let r = !1;
  e.on("close", () => {
    r = !0;
  });
  const i = Ml(
    e,
    {
      readable: t,
      writable: n
    },
    (s) => {
      r = !s;
    }
  );
  return {
    destroy: (s) => {
      r || (r = !0, wR.destroyer(e, s || new TR("pipe")));
    },
    cleanup: i
  };
}
function DR(e) {
  return OR(e[e.length - 1], "streams[stream.length - 1]"), e.pop();
}
function mf(e) {
  if (Di(e))
    return e;
  if (yl(e))
    return PR(e);
  throw new nd("val", ["Readable", "Iterable", "AsyncIterable"], e);
}
async function* PR(e) {
  pf || (pf = Pu()), yield* pf.prototype[bR].call(e);
}
async function Ba(e, t, n, { end: r }) {
  let i, s = null;
  const o = (c) => {
    if (c && (i = c), s) {
      const u = s;
      s = null, u();
    }
  }, a = () => new gR((c, u) => {
    i ? u(i) : s = () => {
      i ? u(i) : c();
    };
  });
  t.on("drain", o);
  const l = Ml(
    t,
    {
      readable: !1
    },
    o
  );
  try {
    t.writableNeedDrain && await a();
    for await (const c of e)
      t.write(c) || await a();
    r && (t.end(), await a()), n();
  } catch (c) {
    n(i !== c ? ER(i, c) : c);
  } finally {
    l(), t.off("drain", o);
  }
}
async function yf(e, t, n, { end: r }) {
  us(t) && (t = t.writable);
  const i = t.getWriter();
  try {
    for await (const s of e)
      await i.ready, i.write(s).catch(() => {
      });
    await i.ready, r && await i.close(), n();
  } catch (s) {
    try {
      await i.abort(s), n(s);
    } catch (o) {
      n(o);
    }
  }
}
function kR(...e) {
  return kv(e, _R(DR(e)));
}
function kv(e, t, n) {
  if (e.length === 1 && yR(e[0]) && (e = e[0]), e.length < 2)
    throw new SR("streams");
  const r = new xR(), i = r.signal, s = n?.signal, o = [];
  IR(s, "options.signal");
  function a() {
    h(new NR());
  }
  hf = hf || on.addAbortListener;
  let l;
  s && (l = hf(s, a));
  let c, u;
  const f = [];
  let d = 0;
  function p(E) {
    h(E, --d === 0);
  }
  function h(E, y) {
    var D;
    if (E && (!c || c.code === "ERR_STREAM_PREMATURE_CLOSE") && (c = E), !(!c && !y)) {
      for (; f.length; )
        f.shift()(c);
      (D = l) === null || D === void 0 || D[vR](), r.abort(), y && (c || o.forEach((F) => F()), To.nextTick(t, c, u));
    }
  }
  let m;
  for (let E = 0; E < e.length; E++) {
    const y = e[E], D = E < e.length - 1, F = E > 0, W = D || n?.end !== !1, J = E === e.length - 1;
    if (wy(y)) {
      let Z = function(j) {
        j && j.name !== "AbortError" && j.code !== "ERR_STREAM_PREMATURE_CLOSE" && p(j);
      };
      if (W) {
        const { destroy: j, cleanup: ee } = Ey(y, D, F);
        f.push(j), cf(y) && J && o.push(ee);
      }
      y.on("error", Z), cf(y) && J && o.push(() => {
        y.removeListener("error", Z);
      });
    }
    if (E === 0)
      if (typeof y == "function") {
        if (m = y({
          signal: i
        }), !Di(m))
          throw new uf("Iterable, AsyncIterable or Stream", "source", m);
      } else
        Di(y) || yl(y) || us(y) ? m = y : m = _y.from(y);
    else if (typeof y == "function") {
      if (us(m)) {
        var v;
        m = mf((v = m) === null || v === void 0 ? void 0 : v.readable);
      } else
        m = mf(m);
      if (m = y(m, {
        signal: i
      }), D) {
        if (!Di(m, !0))
          throw new uf("AsyncIterable", `transform[${E - 1}]`, m);
      } else {
        var b;
        df || (df = Pv);
        const Z = new df({
          objectMode: !0
        }), j = (b = m) === null || b === void 0 ? void 0 : b.then;
        if (typeof j == "function")
          d++, j.call(
            m,
            (ce) => {
              u = ce, ce != null && Z.write(ce), W && Z.end(), To.nextTick(p);
            },
            (ce) => {
              Z.destroy(ce), To.nextTick(p, ce);
            }
          );
        else if (Di(m, !0))
          d++, Ba(m, Z, p, {
            end: W
          });
        else if (ff(m) || us(m)) {
          const ce = m.readable || m;
          d++, Ba(ce, Z, p, {
            end: W
          });
        } else
          throw new uf("AsyncIterable or Promise", "destination", m);
        m = Z;
        const { destroy: ee, cleanup: le } = Ey(m, !1, !0);
        f.push(ee), J && o.push(le);
      }
    } else if (wy(y)) {
      if (yl(m)) {
        d += 2;
        const Z = LR(m, y, p, {
          end: W
        });
        cf(y) && J && o.push(Z);
      } else if (us(m) || ff(m)) {
        const Z = m.readable || m;
        d++, Ba(Z, y, p, {
          end: W
        });
      } else if (Di(m))
        d++, Ba(m, y, p, {
          end: W
        });
      else
        throw new nd(
          "val",
          ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"],
          m
        );
      m = y;
    } else if (RR(y)) {
      if (yl(m))
        d++, yf(mf(m), y, p, {
          end: W
        });
      else if (ff(m) || Di(m))
        d++, yf(m, y, p, {
          end: W
        });
      else if (us(m))
        d++, yf(m.readable, y, p, {
          end: W
        });
      else
        throw new nd(
          "val",
          ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"],
          m
        );
      m = y;
    } else
      m = _y.from(y);
  }
  return (i != null && i.aborted || s != null && s.aborted) && To.nextTick(a), m;
}
function LR(e, t, n, { end: r }) {
  let i = !1;
  if (t.on("close", () => {
    i || n(new $R());
  }), e.pipe(t, {
    end: !1
  }), r) {
    let s = function() {
      i = !0, t.end();
    };
    AR(e) ? To.nextTick(s) : e.once("end", s);
  } else
    n();
  return Ml(
    e,
    {
      readable: !0,
      writable: !1
    },
    (s) => {
      const o = e._readableState;
      s && s.code === "ERR_STREAM_PREMATURE_CLOSE" && o && o.ended && !o.errored && !o.errorEmitted ? e.once("end", n).once("error", n) : n(s);
    }
  ), Ml(
    t,
    {
      readable: !1,
      writable: !0
    },
    n
  );
}
var pp = {
  pipelineImpl: kv,
  pipeline: kR
};
const { pipeline: jR } = pp, Ga = Fr(), { destroyer: CR } = Ps, {
  isNodeStream: za,
  isReadable: Sy,
  isWritable: Ty,
  isWebStream: gf,
  isTransformStream: $i,
  isWritableStream: $y,
  isReadableStream: Ny
} = Wr, {
  AbortError: MR,
  codes: { ERR_INVALID_ARG_VALUE: Oy, ERR_MISSING_ARGS: FR }
} = hn, UR = ci;
var Lv = function(...t) {
  if (t.length === 0)
    throw new FR("streams");
  if (t.length === 1)
    return Ga.from(t[0]);
  const n = [...t];
  if (typeof t[0] == "function" && (t[0] = Ga.from(t[0])), typeof t[t.length - 1] == "function") {
    const p = t.length - 1;
    t[p] = Ga.from(t[p]);
  }
  for (let p = 0; p < t.length; ++p)
    if (!(!za(t[p]) && !gf(t[p]))) {
      if (p < t.length - 1 && !(Sy(t[p]) || Ny(t[p]) || $i(t[p])))
        throw new Oy(`streams[${p}]`, n[p], "must be readable");
      if (p > 0 && !(Ty(t[p]) || $y(t[p]) || $i(t[p])))
        throw new Oy(`streams[${p}]`, n[p], "must be writable");
    }
  let r, i, s, o, a;
  function l(p) {
    const h = o;
    o = null, h ? h(p) : p ? a.destroy(p) : !d && !f && a.destroy();
  }
  const c = t[0], u = jR(t, l), f = !!(Ty(c) || $y(c) || $i(c)), d = !!(Sy(u) || Ny(u) || $i(u));
  if (a = new Ga({
    // TODO (ronag): highWaterMark?
    writableObjectMode: !!(c != null && c.writableObjectMode),
    readableObjectMode: !!(u != null && u.readableObjectMode),
    writable: f,
    readable: d
  }), f) {
    if (za(c))
      a._write = function(h, m, v) {
        c.write(h, m) ? v() : r = v;
      }, a._final = function(h) {
        c.end(), i = h;
      }, c.on("drain", function() {
        if (r) {
          const h = r;
          r = null, h();
        }
      });
    else if (gf(c)) {
      const m = ($i(c) ? c.writable : c).getWriter();
      a._write = async function(v, b, E) {
        try {
          await m.ready, m.write(v).catch(() => {
          }), E();
        } catch (y) {
          E(y);
        }
      }, a._final = async function(v) {
        try {
          await m.ready, m.close().catch(() => {
          }), i = v;
        } catch (b) {
          v(b);
        }
      };
    }
    const p = $i(u) ? u.readable : u;
    UR(p, () => {
      if (i) {
        const h = i;
        i = null, h();
      }
    });
  }
  if (d) {
    if (za(u))
      u.on("readable", function() {
        if (s) {
          const p = s;
          s = null, p();
        }
      }), u.on("end", function() {
        a.push(null);
      }), a._read = function() {
        for (; ; ) {
          const p = u.read();
          if (p === null) {
            s = a._read;
            return;
          }
          if (!a.push(p))
            return;
        }
      };
    else if (gf(u)) {
      const h = ($i(u) ? u.readable : u).getReader();
      a._read = async function() {
        for (; ; )
          try {
            const { value: m, done: v } = await h.read();
            if (!a.push(m))
              return;
            if (v) {
              a.push(null);
              return;
            }
          } catch {
            return;
          }
      };
    }
  }
  return a._destroy = function(p, h) {
    !p && o !== null && (p = new MR()), s = null, r = null, i = null, o === null ? h(p) : (o = h, za(u) && CR(u, p));
  }, a;
};
const VR = globalThis.AbortController || Qo().AbortController, {
  codes: { ERR_INVALID_ARG_VALUE: BR, ERR_INVALID_ARG_TYPE: ma, ERR_MISSING_ARGS: GR, ERR_OUT_OF_RANGE: zR },
  AbortError: br
} = hn, { validateAbortSignal: es, validateInteger: Iy, validateObject: ts } = ha, qR = Pt.Symbol("kWeak"), HR = Pt.Symbol("kResistStopPropagation"), { finished: WR } = ci, QR = Lv, { addAbortSignalNoValidate: JR } = xu, { isWritable: KR, isNodeStream: YR } = Wr, { deprecate: XR } = on, {
  ArrayPrototypePush: ZR,
  Boolean: eA,
  MathFloor: Ry,
  Number: tA,
  NumberIsNaN: nA,
  Promise: Ay,
  PromiseReject: xy,
  PromiseResolve: rA,
  PromisePrototypeThen: Dy,
  Symbol: jv
} = Pt, Fl = jv("kEmpty"), Py = jv("kEof");
function iA(e, t) {
  if (t != null && ts(t, "options"), t?.signal != null && es(t.signal, "options.signal"), YR(e) && !KR(e))
    throw new BR("stream", e, "must be writable");
  const n = QR(this, e);
  return t != null && t.signal && JR(t.signal, n), n;
}
function ku(e, t) {
  if (typeof e != "function")
    throw new ma("fn", ["Function", "AsyncFunction"], e);
  t != null && ts(t, "options"), t?.signal != null && es(t.signal, "options.signal");
  let n = 1;
  t?.concurrency != null && (n = Ry(t.concurrency));
  let r = n - 1;
  return t?.highWaterMark != null && (r = Ry(t.highWaterMark)), Iy(n, "options.concurrency", 1), Iy(r, "options.highWaterMark", 0), r += n, async function* () {
    const s = on.AbortSignalAny(
      [t?.signal].filter(eA)
    ), o = this, a = [], l = {
      signal: s
    };
    let c, u, f = !1, d = 0;
    function p() {
      f = !0, h();
    }
    function h() {
      d -= 1, m();
    }
    function m() {
      u && !f && d < n && a.length < r && (u(), u = null);
    }
    async function v() {
      try {
        for await (let b of o) {
          if (f)
            return;
          if (s.aborted)
            throw new br();
          try {
            if (b = e(b, l), b === Fl)
              continue;
            b = rA(b);
          } catch (E) {
            b = xy(E);
          }
          d += 1, Dy(b, h, p), a.push(b), c && (c(), c = null), !f && (a.length >= r || d >= n) && await new Ay((E) => {
            u = E;
          });
        }
        a.push(Py);
      } catch (b) {
        const E = xy(b);
        Dy(E, h, p), a.push(E);
      } finally {
        f = !0, c && (c(), c = null);
      }
    }
    v();
    try {
      for (; ; ) {
        for (; a.length > 0; ) {
          const b = await a[0];
          if (b === Py)
            return;
          if (s.aborted)
            throw new br();
          b !== Fl && (yield b), a.shift(), m();
        }
        await new Ay((b) => {
          c = b;
        });
      }
    } finally {
      f = !0, u && (u(), u = null);
    }
  }.call(this);
}
function sA(e = void 0) {
  return e != null && ts(e, "options"), e?.signal != null && es(e.signal, "options.signal"), async function* () {
    let n = 0;
    for await (const i of this) {
      var r;
      if (e != null && (r = e.signal) !== null && r !== void 0 && r.aborted)
        throw new br({
          cause: e.signal.reason
        });
      yield [n++, i];
    }
  }.call(this);
}
async function Cv(e, t = void 0) {
  for await (const n of hp.call(this, e, t))
    return !0;
  return !1;
}
async function oA(e, t = void 0) {
  if (typeof e != "function")
    throw new ma("fn", ["Function", "AsyncFunction"], e);
  return !await Cv.call(
    this,
    async (...n) => !await e(...n),
    t
  );
}
async function aA(e, t) {
  for await (const n of hp.call(this, e, t))
    return n;
}
async function lA(e, t) {
  if (typeof e != "function")
    throw new ma("fn", ["Function", "AsyncFunction"], e);
  async function n(r, i) {
    return await e(r, i), Fl;
  }
  for await (const r of ku.call(this, n, t))
    ;
}
function hp(e, t) {
  if (typeof e != "function")
    throw new ma("fn", ["Function", "AsyncFunction"], e);
  async function n(r, i) {
    return await e(r, i) ? r : Fl;
  }
  return ku.call(this, n, t);
}
class uA extends GR {
  constructor() {
    super("reduce"), this.message = "Reduce of an empty stream requires an initial value";
  }
}
async function cA(e, t, n) {
  var r;
  if (typeof e != "function")
    throw new ma("reducer", ["Function", "AsyncFunction"], e);
  n != null && ts(n, "options"), n?.signal != null && es(n.signal, "options.signal");
  let i = arguments.length > 1;
  if (n != null && (r = n.signal) !== null && r !== void 0 && r.aborted) {
    const c = new br(void 0, {
      cause: n.signal.reason
    });
    throw this.once("error", () => {
    }), await WR(this.destroy(c)), c;
  }
  const s = new VR(), o = s.signal;
  if (n != null && n.signal) {
    const c = {
      once: !0,
      [qR]: this,
      [HR]: !0
    };
    n.signal.addEventListener("abort", () => s.abort(), c);
  }
  let a = !1;
  try {
    for await (const c of this) {
      var l;
      if (a = !0, n != null && (l = n.signal) !== null && l !== void 0 && l.aborted)
        throw new br();
      i ? t = await e(t, c, {
        signal: o
      }) : (t = c, i = !0);
    }
    if (!a && !i)
      throw new uA();
  } finally {
    s.abort();
  }
  return t;
}
async function fA(e) {
  e != null && ts(e, "options"), e?.signal != null && es(e.signal, "options.signal");
  const t = [];
  for await (const r of this) {
    var n;
    if (e != null && (n = e.signal) !== null && n !== void 0 && n.aborted)
      throw new br(void 0, {
        cause: e.signal.reason
      });
    ZR(t, r);
  }
  return t;
}
function dA(e, t) {
  const n = ku.call(this, e, t);
  return async function* () {
    for await (const i of n)
      yield* i;
  }.call(this);
}
function Mv(e) {
  if (e = tA(e), nA(e))
    return 0;
  if (e < 0)
    throw new zR("number", ">= 0", e);
  return e;
}
function pA(e, t = void 0) {
  return t != null && ts(t, "options"), t?.signal != null && es(t.signal, "options.signal"), e = Mv(e), async function* () {
    var r;
    if (t != null && (r = t.signal) !== null && r !== void 0 && r.aborted)
      throw new br();
    for await (const s of this) {
      var i;
      if (t != null && (i = t.signal) !== null && i !== void 0 && i.aborted)
        throw new br();
      e-- <= 0 && (yield s);
    }
  }.call(this);
}
function hA(e, t = void 0) {
  return t != null && ts(t, "options"), t?.signal != null && es(t.signal, "options.signal"), e = Mv(e), async function* () {
    var r;
    if (t != null && (r = t.signal) !== null && r !== void 0 && r.aborted)
      throw new br();
    for await (const s of this) {
      var i;
      if (t != null && (i = t.signal) !== null && i !== void 0 && i.aborted)
        throw new br();
      if (e-- > 0 && (yield s), e <= 0)
        return;
    }
  }.call(this);
}
ip.streamReturningOperators = {
  asIndexedPairs: XR(sA, "readable.asIndexedPairs will be removed in a future version."),
  drop: pA,
  filter: hp,
  flatMap: dA,
  map: ku,
  take: hA,
  compose: iA
};
ip.promiseReturningOperators = {
  every: oA,
  forEach: lA,
  reduce: cA,
  toArray: fA,
  some: Cv,
  find: aA
};
var bf, ky;
function Fv() {
  if (ky)
    return bf;
  ky = 1;
  const { ArrayPrototypePop: e, Promise: t } = Pt, { isIterable: n, isNodeStream: r, isWebStream: i } = Wr, { pipelineImpl: s } = pp, { finished: o } = ci;
  Uv();
  function a(...l) {
    return new t((c, u) => {
      let f, d;
      const p = l[l.length - 1];
      if (p && typeof p == "object" && !r(p) && !n(p) && !i(p)) {
        const h = e(l);
        f = h.signal, d = h.end;
      }
      s(
        l,
        (h, m) => {
          h ? u(h) : c(m);
        },
        {
          signal: f,
          end: d
        }
      );
    });
  }
  return bf = {
    finished: o,
    pipeline: a
  }, bf;
}
var Ly;
function Uv() {
  if (Ly)
    return ef.exports;
  Ly = 1;
  const { Buffer: e } = jn, { ObjectDefineProperty: t, ObjectKeys: n, ReflectApply: r } = Pt, {
    promisify: { custom: i }
  } = on, { streamReturningOperators: s, promiseReturningOperators: o } = ip, {
    codes: { ERR_ILLEGAL_CONSTRUCTOR: a }
  } = hn, l = Lv, { setDefaultHighWaterMark: c, getDefaultHighWaterMark: u } = Du, { pipeline: f } = pp, { destroyer: d } = Ps, p = ci, h = Fv(), m = Wr, v = ef.exports = up.Stream;
  v.isDestroyed = m.isDestroyed, v.isDisturbed = m.isDisturbed, v.isErrored = m.isErrored, v.isReadable = m.isReadable, v.isWritable = m.isWritable, v.Readable = Pu();
  for (const E of n(s)) {
    let D = function(...F) {
      if (new.target)
        throw a();
      return v.Readable.from(r(y, this, F));
    };
    const y = s[E];
    t(D, "name", {
      __proto__: null,
      value: y.name
    }), t(D, "length", {
      __proto__: null,
      value: y.length
    }), t(v.Readable.prototype, E, {
      __proto__: null,
      value: D,
      enumerable: !1,
      configurable: !0,
      writable: !0
    });
  }
  for (const E of n(o)) {
    let D = function(...F) {
      if (new.target)
        throw a();
      return r(y, this, F);
    };
    const y = o[E];
    t(D, "name", {
      __proto__: null,
      value: y.name
    }), t(D, "length", {
      __proto__: null,
      value: y.length
    }), t(v.Readable.prototype, E, {
      __proto__: null,
      value: D,
      enumerable: !1,
      configurable: !0,
      writable: !0
    });
  }
  v.Writable = cp(), v.Duplex = Fr(), v.Transform = xv, v.PassThrough = Pv, v.pipeline = f;
  const { addAbortSignal: b } = xu;
  return v.addAbortSignal = b, v.finished = p, v.destroy = d, v.compose = l, v.setDefaultHighWaterMark = c, v.getDefaultHighWaterMark = u, t(v, "promises", {
    __proto__: null,
    configurable: !0,
    enumerable: !0,
    get() {
      return h;
    }
  }), t(f, i, {
    __proto__: null,
    enumerable: !0,
    get() {
      return h.pipeline;
    }
  }), t(p, i, {
    __proto__: null,
    enumerable: !0,
    get() {
      return h.finished;
    }
  }), v.Stream = v, v._isUint8Array = function(y) {
    return y instanceof Uint8Array;
  }, v._uint8ArrayToBuffer = function(y) {
    return e.from(y.buffer, y.byteOffset, y.byteLength);
  }, ef.exports;
}
(function(e) {
  const t = Uv(), n = Fv(), r = t.Readable.destroy;
  e.exports = t.Readable, e.exports._uint8ArrayToBuffer = t._uint8ArrayToBuffer, e.exports._isUint8Array = t._isUint8Array, e.exports.isDisturbed = t.isDisturbed, e.exports.isErrored = t.isErrored, e.exports.isReadable = t.isReadable, e.exports.Readable = t.Readable, e.exports.Writable = t.Writable, e.exports.Duplex = t.Duplex, e.exports.Transform = t.Transform, e.exports.PassThrough = t.PassThrough, e.exports.addAbortSignal = t.addAbortSignal, e.exports.finished = t.finished, e.exports.destroy = t.destroy, e.exports.destroy = r, e.exports.pipeline = t.pipeline, e.exports.compose = t.compose, Object.defineProperty(t, "promises", {
    configurable: !0,
    enumerable: !0,
    get() {
      return n;
    }
  }), e.exports.Stream = t.Stream, e.exports.default = e.exports;
})(Hb);
var mA = Hb.exports;
const { Readable: yA } = mA;
let gA = class {
  constructor(t) {
    this.emitter = t;
  }
  subscribe(t, n) {
    return new Promise((r, i) => {
      function s(a, l) {
        n.push(a.payload), l();
      }
      const o = () => {
        this.emitter.removeListener(t, s);
      };
      this.emitter.on(t, s, (a) => {
        if (a)
          return i(a);
        r();
      }), n.close || (n.close = []), n.close.push(o);
    });
  }
  publish(t, n) {
    this.emitter.emit(t, n);
  }
}, bA = class {
  constructor({ pubsub: t, fastify: n }) {
    this.fastify = n, this.pubsub = t, this.queue = new yA({
      objectMode: !0,
      read: () => {
      }
    });
  }
  subscribe(t) {
    return typeof t == "string" ? this.pubsub.subscribe(t, this.queue).then(() => this.queue) : Promise.all(t.map((n) => this.pubsub.subscribe(n, this.queue))).then(() => this.queue);
  }
  publish(t) {
    return new Promise((n, r) => {
      this.pubsub.publish(t, (i) => {
        if (i)
          return r(i);
        n();
      });
    }).catch((n) => {
      this.fastify.log.error(n);
    });
  }
  close() {
    Array.isArray(this.queue.close) && this.queue.close.map((t) => t()), this.queue.push(null);
  }
};
function vA(e, t) {
  return async function* (n, r, i, s) {
    const o = await e(n, r, i, s);
    for await (const a of o)
      try {
        await t(a, r, i, s) && (yield a);
      } catch (l) {
        i.app.log.error(l);
        continue;
      }
  };
}
var Vv = {
  PubSub: gA,
  SubscriptionContext: bA,
  withFilter: vA
}, ks = { exports: {} };
const _A = typeof Buffer < "u", jy = /"(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])"\s*:/, Cy = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
function Bv(e, t, n) {
  n == null && t !== null && typeof t == "object" && (n = t, t = void 0), _A && Buffer.isBuffer(e) && (e = e.toString()), e && e.charCodeAt(0) === 65279 && (e = e.slice(1));
  const r = JSON.parse(e, t);
  if (r === null || typeof r != "object")
    return r;
  const i = n && n.protoAction || "error", s = n && n.constructorAction || "error";
  if (i === "ignore" && s === "ignore")
    return r;
  if (i !== "ignore" && s !== "ignore") {
    if (jy.test(e) === !1 && Cy.test(e) === !1)
      return r;
  } else if (i !== "ignore" && s === "ignore") {
    if (jy.test(e) === !1)
      return r;
  } else if (Cy.test(e) === !1)
    return r;
  return Gv(r, { protoAction: i, constructorAction: s, safe: n && n.safe });
}
function Gv(e, { protoAction: t = "error", constructorAction: n = "error", safe: r } = {}) {
  let i = [e];
  for (; i.length; ) {
    const s = i;
    i = [];
    for (const o of s) {
      if (t !== "ignore" && Object.prototype.hasOwnProperty.call(o, "__proto__")) {
        if (r === !0)
          return null;
        if (t === "error")
          throw new SyntaxError("Object contains forbidden prototype property");
        delete o.__proto__;
      }
      if (n !== "ignore" && Object.prototype.hasOwnProperty.call(o, "constructor") && Object.prototype.hasOwnProperty.call(o.constructor, "prototype")) {
        if (r === !0)
          return null;
        if (n === "error")
          throw new SyntaxError("Object contains forbidden prototype property");
        delete o.constructor;
      }
      for (const a in o) {
        const l = o[a];
        l && typeof l == "object" && i.push(l);
      }
    }
  }
  return e;
}
function mp(e, t, n) {
  const r = Error.stackTraceLimit;
  Error.stackTraceLimit = 0;
  try {
    return Bv(e, t, n);
  } finally {
    Error.stackTraceLimit = r;
  }
}
function wA(e, t) {
  const n = Error.stackTraceLimit;
  Error.stackTraceLimit = 0;
  try {
    return Bv(e, t, { safe: !0 });
  } catch {
    return null;
  } finally {
    Error.stackTraceLimit = n;
  }
}
ks.exports = mp;
ks.exports.default = mp;
ks.exports.parse = mp;
ks.exports.safeParse = wA;
ks.exports.scan = Gv;
var zv = ks.exports;
const { hooksRunner: fi, preExecutionHooksRunner: EA, hookRunner: yp, preParsingHookRunner: qv, onResolutionHookRunner: Hv, onEndHookRunner: SA } = rp, { addErrorsToContext: TA } = xs;
async function $A(e) {
  await fi(
    e.context.preParsing,
    qv,
    e
  );
}
async function NA(e) {
  await fi(
    e.context.preValidation,
    yp,
    e
  );
}
async function OA(e) {
  const {
    errors: t,
    modifiedDocument: n,
    modifiedSchema: r,
    modifiedVariables: i
  } = await EA(
    e.context.preExecution,
    e
  );
  return t.length > 0 && TA(e.context, t), typeof n < "u" || typeof r < "u" || typeof i < "u" ? Object.create(null, {
    modifiedDocument: { value: n },
    modifiedSchema: { value: r },
    modifiedVariables: { value: i }
  }) : {};
}
async function IA(e) {
  await fi(
    e.context.onResolution,
    Hv,
    e
  );
}
async function RA(e) {
  await fi(
    e.context.preSubscriptionParsing,
    qv,
    e
  );
}
async function AA(e) {
  await fi(
    e.context.preSubscriptionExecution,
    yp,
    e
  );
}
async function xA(e) {
  await fi(
    e.context.onSubscriptionResolution,
    Hv,
    e
  );
}
async function DA(e) {
  await fi(
    e.context.onSubscriptionEnd,
    SA,
    e
  );
}
async function PA(e) {
  await fi(
    e.context.onExtendSchema,
    yp,
    e
  );
}
var Wv = {
  preParsingHandler: $A,
  preValidationHandler: NA,
  preExecutionHandler: OA,
  onResolutionHandler: IA,
  preSubscriptionParsingHandler: RA,
  preSubscriptionExecutionHandler: AA,
  onSubscriptionResolutionHandler: xA,
  onSubscriptionEndHandler: DA,
  onExtendSchemaHandler: PA
}, ya = {};
const Qv = "graphql-ws", Jv = "graphql-transport-ws";
ya.GRAPHQL_WS = Qv;
ya.GRAPHQL_TRANSPORT_WS = Jv;
ya.getProtocolByName = function(e) {
  switch (!0) {
    case e.indexOf(Jv) !== -1:
      return {
        GQL_CONNECTION_INIT: "connection_init",
        // Client -> Server
        GQL_CONNECTION_ACK: "connection_ack",
        // Server -> Client
        GQL_CONNECTION_ERROR: "connection_error",
        // Server -> Client
        GQL_CONNECTION_KEEP_ALIVE: "ping",
        // Bidirectional
        GQL_CONNECTION_KEEP_ALIVE_ACK: "pong",
        // Bidirectional
        GQL_CONNECTION_TERMINATE: "connection_terminate",
        // Client -> Server
        GQL_START: "subscribe",
        // Client -> Server
        GQL_DATA: "next",
        // Server -> Client
        GQL_ERROR: "error",
        // Server -> Client
        GQL_COMPLETE: "complete",
        // Server -> Client
        GQL_STOP: "complete"
        // Client -> Server
      };
    case e.indexOf(Qv) !== -1:
      return {
        GQL_CONNECTION_INIT: "connection_init",
        // Client -> Server
        GQL_CONNECTION_ACK: "connection_ack",
        // Server -> Client
        GQL_CONNECTION_ERROR: "connection_error",
        // Server -> Client
        GQL_CONNECTION_KEEP_ALIVE: "ka",
        // Server -> Client
        GQL_CONNECTION_TERMINATE: "connection_terminate",
        // Client -> Server
        GQL_START: "start",
        // Client -> Server
        GQL_DATA: "data",
        // Server -> Client
        GQL_ERROR: "error",
        // Server -> Client
        GQL_COMPLETE: "complete",
        // Server -> Client
        GQL_STOP: "stop"
        // Client -> Server
      };
    default:
      return null;
  }
};
const { on: kA } = Ji, { subscribe: LA, parse: jA, print: CA, getOperationAST: MA } = Ln, { SubscriptionContext: FA } = Vv, UA = zv, { MER_ERR_GQL_SUBSCRIPTION_FORBIDDEN: VA, MER_ERR_GQL_SUBSCRIPTION_UNKNOWN_EXTENSION: BA, MER_ERR_GQL_SUBSCRIPTION_INVALID_OPERATION: GA } = xs, { preSubscriptionParsingHandler: zA, onSubscriptionResolutionHandler: qA, preSubscriptionExecutionHandler: HA, onSubscriptionEndHandler: WA } = Wv, { kSubscriptionFactory: My, kLoaders: QA } = Su, { getProtocolByName: JA } = ya;
var KA = class {
  constructor(t, {
    subscriber: n,
    fastify: r,
    entityResolversFactory: i,
    context: s = {},
    onConnect: o,
    onDisconnect: a,
    resolveContext: l,
    keepAlive: c,
    fullWsTransport: u,
    errorFormatter: f
  }) {
    this.fastify = r, this.socket = t, this.entityResolversFactory = i, this.subscriber = n, this.onConnect = o, this.onDisconnect = a, this.subscriptionContexts = /* @__PURE__ */ new Map(), this.subscriptionIters = /* @__PURE__ */ new Map(), this.context = s, this.isReady = !1, this.resolveContext = l, this.keepAlive = c, this.fullWsTransport = u, this.errorFormatter = f, this.headers = {}, this.protocolMessageTypes = JA(t.protocol), this.socket.on("error", this.handleConnectionClose.bind(this)), this.handleConnection().catch(YA);
  }
  async handleConnection() {
    for await (const [t, n] of kA(this.socket, "message"))
      try {
        await this.handleMessage(t, n);
      } catch (r) {
        this.fastify.log.error(r), this.handleConnectionClose();
      }
  }
  async handleMessage(t, n) {
    let r;
    try {
      r = UA.parse(n ? t : t.toString());
    } catch {
      this.sendMessage(this.protocolMessageTypes.GQL_ERROR, null, "Message must be a JSON string");
      return;
    }
    const { id: i, type: s } = r;
    switch (s) {
      case this.protocolMessageTypes.GQL_CONNECTION_INIT:
        await this.handleConnectionInit(r);
        break;
      case this.protocolMessageTypes.GQL_CONNECTION_TERMINATE:
        this.handleConnectionClose();
        break;
      case this.protocolMessageTypes.GQL_START: {
        if (this.isReady)
          this.handleGQLStart(r).catch((o) => {
            this.sendMessage(
              this.protocolMessageTypes.GQL_ERROR,
              i,
              o.message
            );
          });
        else
          return this.sendMessage(
            this.protocolMessageTypes.GQL_CONNECTION_ERROR,
            void 0,
            { message: "Connection has not been established yet." }
          ), this.handleConnectionClose();
        break;
      }
      case this.protocolMessageTypes.GQL_STOP:
        await this.handleGQLStop(r);
        break;
      case this.protocolMessageTypes.GQL_CONNECTION_KEEP_ALIVE:
        this.protocolMessageTypes.GQL_CONNECTION_KEEP_ALIVE_ACK && this.sendMessage(
          this.protocolMessageTypes.GQL_CONNECTION_KEEP_ALIVE_ACK,
          i
        );
        break;
      default:
        if (this.protocolMessageTypes.GQL_CONNECTION_KEEP_ALIVE_ACK && s === this.protocolMessageTypes.GQL_CONNECTION_KEEP_ALIVE_ACK)
          break;
        this.sendMessage(
          this.protocolMessageTypes.GQL_ERROR,
          i,
          "Invalid payload type"
        );
    }
  }
  async handleConnectionInit(t) {
    if (typeof this.resolveContext == "function")
      try {
        this.context = {
          ...this.context,
          ...await this.resolveContext()
        };
      } catch (n) {
        this.fastify.log.error(n), this.socket.close(1011);
        return;
      }
    if (typeof this.onConnect == "function") {
      let n = !1;
      try {
        n = await this.onConnect(t);
      } catch (r) {
        this.fastify.log.error(r);
      }
      if (!n)
        return this.sendMessage(this.protocolMessageTypes.GQL_CONNECTION_ERROR, void 0, { message: "Forbidden" }), this.handleConnectionClose();
      typeof n == "object" && (this.context = {
        ...this.context,
        ...n
      });
    }
    this.context._connectionInit = t.payload, t.payload && (t.payload.headers ? this.headers = t.payload.headers : this.headers = t.payload), this.sendMessage(this.protocolMessageTypes.GQL_CONNECTION_ACK), this.keepAlive && (this.sendKeepAlive(), this.keepAliveTimer = setInterval(() => {
      this.sendKeepAlive();
    }, this.keepAlive)), this.isReady = !0;
  }
  async handleGQLStart(t) {
    const { id: n, payload: r, extensions: i } = t, { query: s, variables: o, operationName: a } = r;
    let l = { ...this.context };
    if (i && i instanceof Array)
      for (const f of i)
        switch (f.type) {
          case "connectionInit": {
            const d = await this.handleConnectionInitExtension(f);
            typeof d == "object" && (l = {
              ...l,
              ...d
            });
            break;
          }
          default:
            throw new BA(f.type);
        }
    const c = typeof s != "string" ? s : jA(s);
    if (!c)
      throw new Error("Must provide document.");
    const u = MA(c, a);
    if (u.operation === "subscription")
      await this._executeSubscription({
        document: c,
        query: s,
        context: l,
        variables: o,
        operationName: a,
        id: n
      });
    else if (this.fullWsTransport === !0 && (u.operation === "query" || u.operation === "mutation"))
      await this._executeQueryOrMutation({
        query: s,
        context: l,
        variables: o,
        operationName: a,
        id: n
      });
    else
      throw new GA(u.operation);
  }
  async _executeSubscription({ document: t, query: n, context: r, variables: i, operationName: s, id: o }) {
    const a = this.fastify.graphql.schema, l = new FA({
      fastify: this.fastify,
      pubsub: this.subscriber
    });
    this.context.preSubscriptionParsing !== null && typeof a < "u" && typeof n == "string" && await zA({ schema: a, source: n, context: r }), this.subscriptionContexts.set(o, l), this.context.preSubscriptionExecution !== null && typeof a < "u" && await HA({ schema: a, document: t, context: r });
    let c;
    this.fastify[My] && (c = this.fastify[My]);
    for (const [f, d] of Object.entries(this.headers))
      r.request.headers[f] === void 0 && (r.request.headers[f] = d);
    const u = await LA({
      schema: a,
      document: t,
      rootValue: {},
      contextValue: {
        ...r,
        get __currentQuery() {
          return CA(t);
        },
        id: o,
        pubsub: l,
        lruGatewayResolvers: this.lruGatewayResolvers,
        reply: {
          request: r.request,
          [QA]: c && c.create(r)
        }
      },
      variableValues: i,
      operationName: s
    });
    if (this.subscriptionIters.set(o, u), u.errors)
      throw this.fastify.log.error(u.errors), u.errors[0];
    for await (const f of u) {
      if (this.context.onSubscriptionResolution !== null)
        try {
          await qA({ execution: f, context: r });
        } catch (h) {
          return this.fastify.log.error(h), this.handleConnectionClose();
        }
      const p = Array.isArray(f.errors) && f.errors.length > 0 ? this.errorFormatter(f, this.context).response : f;
      this.sendMessage(this.protocolMessageTypes.GQL_DATA, o, p);
    }
    this.sendMessage(this.protocolMessageTypes.GQL_COMPLETE, o, null), this.handleGQLComplete(o);
  }
  async _executeQueryOrMutation({ query: t, context: n, variables: r, operationName: i, id: s }) {
    n.entityResolversFactory = this.entityResolversFactory;
    const o = await this.fastify.graphql(
      t,
      n,
      r,
      i
    );
    this.sendMessage(this.protocolMessageTypes.GQL_DATA, s, o), this.sendMessage(this.protocolMessageTypes.GQL_COMPLETE, s, null);
  }
  handleGQLComplete(t) {
    const n = this.subscriptionContexts.get(t);
    n && (n.close && n.close(), this.subscriptionContexts.delete(t));
    const r = this.subscriptionIters.get(t);
    r && (r.return && r.return(), this.subscriptionIters.delete(t));
  }
  async handleGQLStop(t) {
    if (this.context.onSubscriptionEnd)
      try {
        await WA({ context: this.context, id: t.id });
      } catch (n) {
        return this.fastify.log.error(n), this.handleConnectionClose();
      }
    this.handleGQLComplete(t.id);
  }
  handleConnectionClose() {
    Array.from(this.subscriptionContexts.values()).map((t) => t.close()), Array.from(this.subscriptionIters.values()).map((t) => t.return && t.return()), this.socket.close(), this.keepAliveTimer && clearInterval(this.keepAliveTimer), typeof this.onDisconnect == "function" && Promise.resolve().then(() => this.onDisconnect(this.context)).catch((t) => {
      this.fastify.log.error(t);
    });
  }
  sendMessage(t, n, r) {
    try {
      this.socket.send(JSON.stringify({
        type: t,
        id: n,
        payload: r
      }));
    } catch {
      this.handleConnectionClose();
    }
  }
  async handleConnectionInitExtension(t) {
    if (typeof this.onConnect == "function") {
      let n = !1;
      try {
        n = await this.onConnect({
          type: this.protocolMessageTypes.GQL_CONNECTION_INIT,
          payload: t.payload
        });
      } catch (r) {
        this.fastify.log.error(r);
      }
      if (!n)
        throw new VA();
      return n;
    }
    return !0;
  }
  close() {
    this.handleConnectionClose();
  }
  sendKeepAlive() {
    this.sendMessage(this.protocolMessageTypes.GQL_CONNECTION_KEEP_ALIVE);
  }
};
function YA() {
}
const XA = jN, { assignLifeCycleHooksToContext: Fy, Hooks: ZA } = rp, { kHooks: Uy } = Su, ex = KA, { getProtocolByName: tx } = ya;
function nx({ subscriber: e, fastify: t, onConnect: n, onDisconnect: r, entityResolversFactory: i, subscriptionContextFn: s, keepAlive: o, fullWsTransport: a, errorFormatter: l }) {
  return async (c, u) => {
    if (c.protocol === void 0 || tx(c.protocol) === null) {
      u.log.warn("wrong websocket protocol"), c.close(1002);
      return;
    }
    let f = {
      app: t,
      pubsub: e,
      request: u
    };
    f.app.graphql && f.app.graphql[Uy] ? f = Fy(f, f.app.graphql[Uy]) : f = Fy(f, new ZA());
    let d;
    s && (d = () => s(c, u));
    const p = new ex(c, {
      subscriber: e,
      fastify: t,
      onConnect: n,
      onDisconnect: r,
      entityResolversFactory: i,
      context: f,
      resolveContext: d,
      keepAlive: o,
      fullWsTransport: a,
      errorFormatter: l
    });
    c.on("error", () => {
      p.close();
    }), c.on("close", () => {
      p.close();
    });
  };
}
var rx = async function(e, t) {
  const { getOptions: n, subscriber: r, verifyClient: i, onConnect: s, onDisconnect: o, entityResolversFactory: a, subscriptionContextFn: l, keepAlive: c, fullWsTransport: u, errorFormatter: f } = t;
  e.websocketServer === void 0 && await e.register(XA, {
    options: {
      maxPayload: 1048576,
      verifyClient: i
    }
  }), e.route({
    ...n,
    wsHandler: nx({
      subscriber: r,
      fastify: e,
      onConnect: s,
      onDisconnect: o,
      entityResolversFactory: a,
      subscriptionContextFn: l,
      keepAlive: c,
      fullWsTransport: u,
      errorFormatter: f
    })
  });
};
const { join: ix } = at, sx = h1, ox = rx, { kRequestContext: Rt } = Su, ax = zv, {
  defaultErrorFormatter: lx,
  MER_ERR_GQL_PERSISTED_QUERY_NOT_FOUND: Vy,
  MER_ERR_GQL_PERSISTED_QUERY_NOT_SUPPORTED: ux,
  MER_ERR_GQL_VALIDATION: Kv,
  toGraphQLError: By
} = xs, Yv = {
  data: {
    type: ["object", "null"],
    additionalProperties: !0
  },
  errors: {
    type: "array",
    items: {
      type: "object",
      required: ["message"],
      properties: {
        message: { type: "string" },
        locations: {
          type: "array",
          items: {
            type: "object",
            properties: {
              line: { type: "integer" },
              column: { type: "integer" }
            }
          }
        },
        path: {
          type: "array",
          items: { type: "string" }
        },
        extensions: {
          type: "object",
          properties: {
            code: { type: "string" }
          },
          additionalProperties: !0
        }
      }
    }
  },
  extensions: {
    type: "object",
    additionalProperties: !0
  }
}, Xv = {
  query: {
    type: "string"
  },
  persisted: {
    type: "boolean"
  },
  operationName: {
    type: ["string", "null"]
  }
}, cx = {
  querystring: {
    type: "object",
    properties: {
      ...Xv,
      variables: {
        type: "string"
        // Stringified JSON
      },
      extensions: {
        type: "string"
        // Stringified JSON
      }
    }
  },
  response: {
    "2xx": {
      type: "object",
      properties: Yv
    }
  }
}, fx = (e) => {
  let t = {
    type: "object",
    properties: {
      ...Xv,
      variables: {
        type: ["object", "null"]
      },
      extensions: {
        type: "object"
      }
    }
  };
  return e && (t = {
    anyOf: [{
      ...t
    }, {
      type: "array",
      items: {
        ...t
      }
    }]
  }), {
    body: t,
    // JSON schema isn't allowing ['object', 'array'] on response.
    response: e ? {} : {
      "2xx": {
        type: "object",
        properties: Yv
      }
    }
  };
};
function Gy(e) {
  if (e) {
    const t = new Kv();
    throw t.errors = [e], t;
  }
}
function zy(e, t) {
  try {
    return ax.parse(t);
  } catch (n) {
    const r = new Kv();
    throw n.code = r.code, n.statusCode = r.statusCode, n;
  }
}
var dx = async function(e, t) {
  const n = typeof t.errorFormatter == "function" ? t.errorFormatter : lx, r = t.context;
  typeof t.errorHandler == "function" ? e.setErrorHandler(async (U, z, ne) => {
    const K = t.errorHandler;
    return z[Rt] || (r ? (z[Rt] = await r(z, ne), Object.assign(z[Rt], { reply: ne, app: e })) : z[Rt] = { reply: ne, app: e }), K(U, z, ne);
  }) : (t.errorHandler === !0 || t.errorHandler === void 0) && e.setErrorHandler(async (U, z, ne) => {
    z[Rt] || (r ? (z[Rt] = await r(z, ne), Object.assign(z[Rt], { reply: ne, app: e })) : z[Rt] = { reply: ne, app: e });
    const { statusCode: K, response: se } = n(
      { errors: [By(U)] },
      z[Rt]
    );
    return ne.code(K).send(se);
  });
  const { subscriptionContextFn: i } = t;
  e.decorateRequest(Rt);
  const {
    path: s = "/graphql",
    subscriber: o,
    verifyClient: a,
    onConnect: l,
    onDisconnect: c,
    entityResolversFactory: u,
    persistedQueryProvider: f,
    allowBatchedQueries: d,
    keepAlive: p,
    fullWsTransport: h,
    additionalRouteOptions: m
  } = t, {
    isPersistedQuery: v,
    getHash: b,
    getQueryFromHash: E,
    getHashForQuery: y,
    saveQuery: D,
    notFoundError: F,
    notSupportedError: W
  } = f || {}, J = { ...m };
  (J.handler || J.wsHandler) && (J.handler = void 0, J.wsHandler = void 0);
  async function Z(U, z, ne, K, se) {
    return U ? se.graphql(
      U,
      Object.assign(
        K[Rt],
        { pubsub: o, __currentQuery: U }
      ),
      z,
      ne
    ) : new Vy("Unknown query");
  }
  function j(U, z, ne) {
    const { query: K, operationName: se, variables: re } = U;
    return Z(K, re, se, z, ne);
  }
  async function ee(U, z, ne) {
    let { query: K } = U;
    const { operationName: se, variables: re } = U, ue = v(U);
    if (ue) {
      const B = b && b(U);
      if (B) {
        if (K = await E(B), !K)
          throw new Vy(F);
      } else
        throw new ux(W);
    }
    const te = await Z(K, re, se, z, ne);
    if (!ue && K) {
      const B = y && y(K);
      if (B)
        try {
          await D(B, K);
        } catch (M) {
          z.log.warn({ err: M, hash: B, query: K }, "Failed to persist query");
        }
    }
    return te;
  }
  const le = f ? ee : j, ce = {
    url: s,
    method: "GET",
    schema: cx,
    attachValidation: !0,
    ...J,
    handler: async function(U, z) {
      r ? (U[Rt] = await r(U, z), Object.assign(U[Rt], { reply: z, app: e })) : U[Rt] = { reply: z, app: e }, Gy(U.validationError);
      const { variables: ne, extensions: K } = U.query;
      return le({
        ...U.query,
        // Parse variables and extensions from stringified JSON
        variables: ne && zy(U, ne),
        extensions: K && zy(U, K)
      }, U, z);
    }
  };
  o ? e.register(ox, {
    getOptions: ce,
    subscriber: o,
    verifyClient: a,
    onConnect: l,
    onDisconnect: c,
    entityResolversFactory: u,
    subscriptionContextFn: i,
    keepAlive: p,
    fullWsTransport: h,
    errorFormatter: n
  }) : e.route(ce), e.addContentTypeParser("application/graphql", { parseAs: "string" }, function(U, z, ne) {
    ne(null, { query: z });
  }), e.post(s, {
    schema: fx(d),
    attachValidation: !0,
    ...J
  }, async function(U, z) {
    if (r ? (U[Rt] = await r(U, z), Object.assign(U[Rt], { reply: z, app: e })) : U[Rt] = { reply: z, app: e }, Gy(U.validationError), d && Array.isArray(U.body)) {
      const ne = U.body.length;
      return Object.assign(U[Rt], { operationsCount: ne }), Promise.all(U.body.map(async (K, se) => {
        const re = ne > 1 ? {
          ...U,
          [Rt]: Object.create(U[Rt])
        } : U;
        Object.assign(re[Rt], { operationId: se });
        try {
          return await le(K, re, z);
        } catch (ue) {
          const { response: te } = n({ errors: [By(ue)] }, U[Rt]);
          return te;
        }
      }));
    } else
      return le(U.body, U, z);
  }), t.ide && (e.register(sx, {
    root: ix(__dirname, "../static"),
    wildcard: !1,
    serve: !1
  }), (t.ide === !0 || t.ide === "graphiql" || typeof t.ide == "object" && t.ide !== null && t.ide.enabled !== !1) && (e.get("/graphiql", (U, z) => {
    z.sendFile("graphiql.html");
  }), e.get("/graphiql/main.js", (U, z) => {
    z.sendFile("main.js");
  }), e.get("/graphiql/sw.js", (U, z) => {
    z.sendFile("sw.js");
  }), e.get("/graphiql/config.js", (U, z) => {
    const ne = [
      `window.GRAPHQL_ENDPOINT = '${e.prefix}${s}'`
    ], K = [];
    (t.ide.plugins || []).forEach((re) => {
      re.name ? (ne.push(`window.GRAPIHQL_PLUGIN_${re.name.toUpperCase()} = ${JSON.stringify(re)}`), K.push(re.name)) : e.log.warn("Graphiql plugin without a name defined");
    }), ne.push(`window.GRAPHIQL_PLUGIN_LIST = ${JSON.stringify(K)}`), z.header("Content-Type", "application/javascript").send(ne.join(`;
`));
  })));
}, Zv = {}, vf = {}, Ls = { exports: {} }, ga = function e(t, n) {
  if (t === n)
    return !0;
  if (t && n && typeof t == "object" && typeof n == "object") {
    if (t.constructor !== n.constructor)
      return !1;
    var r, i, s;
    if (Array.isArray(t)) {
      if (r = t.length, r != n.length)
        return !1;
      for (i = r; i-- !== 0; )
        if (!e(t[i], n[i]))
          return !1;
      return !0;
    }
    if (t.constructor === RegExp)
      return t.source === n.source && t.flags === n.flags;
    if (t.valueOf !== Object.prototype.valueOf)
      return t.valueOf() === n.valueOf();
    if (t.toString !== Object.prototype.toString)
      return t.toString() === n.toString();
    if (s = Object.keys(t), r = s.length, r !== Object.keys(n).length)
      return !1;
    for (i = r; i-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(n, s[i]))
        return !1;
    for (i = r; i-- !== 0; ) {
      var o = s[i];
      if (!e(t[o], n[o]))
        return !1;
    }
    return !0;
  }
  return t !== t && n !== n;
};
const qy = ga, px = Symbol.for("json-schema-ref");
let hx = class {
  #e;
  #t;
  #s;
  #n;
  #o;
  constructor(t = {}) {
    this.#e = {}, this.#t = {}, this.#s = t.insertRefSymbol ?? !1, this.#n = t.allowEqualDuplicates ?? !0, this.#o = t.cloneSchemaWithoutRefs ?? !1;
  }
  addSchema(t, n) {
    t.$id !== void 0 && t.$id.charAt(0) !== "#" ? n = t.$id : this.#l(t, n), this.#u(t, n);
  }
  getSchema(t, n = "#") {
    const r = this.#e[t];
    if (r === void 0)
      throw new Error(
        `Cannot resolve ref "${t}${n}". Schema with id "${t}" is not found.`
      );
    return r.anchors[n] !== void 0 ? r.anchors[n] : Hy(r.schema, n);
  }
  hasSchema(t) {
    return this.#e[t] !== void 0;
  }
  getSchemaRefs(t) {
    const n = this.#e[t];
    if (n === void 0)
      throw new Error(`Schema with id "${t}" is not found.`);
    return n.refs;
  }
  getSchemaDependencies(t, n = {}) {
    const r = this.#e[t];
    for (const i of r.refs) {
      const s = i.schemaId;
      n[s] === void 0 && (n[s] = this.getSchema(s), this.getSchemaDependencies(s, n));
    }
    return n;
  }
  derefSchema(t) {
    if (this.#t[t] !== void 0)
      return;
    const n = this.#e[t];
    if (n === void 0)
      throw new Error(`Schema with id "${t}" is not found.`);
    !this.#o && n.refs.length === 0 && (this.#t[t] = {
      schema: n.schema,
      anchors: n.anchors
    });
    const r = [];
    this.#c(n.schema, t, r);
    const i = this.getSchemaDependencies(t);
    for (const s in i) {
      const o = i[s];
      this.#c(o, s, r);
    }
    for (const s of r) {
      const {
        refSchemaId: o,
        refJsonPointer: a
      } = this.#g(s.ref, s.sourceSchemaId), l = this.getDerefSchema(o, a);
      if (l === null)
        throw new Error(
          `Cannot resolve ref "${s.ref}". Ref "${a}" is not found in schema "${o}".`
        );
      s.targetSchema = l, s.targetSchemaId = o;
    }
    for (const s of r)
      this.#a(s, r);
  }
  getDerefSchema(t, n = "#") {
    let r = this.#t[t];
    return r === void 0 && (this.derefSchema(t), r = this.#t[t]), r.anchors[n] !== void 0 ? r.anchors[n] : Hy(r.schema, n);
  }
  #g(t, n) {
    const r = t.indexOf("#");
    return r === -1 ? { refSchemaId: t, refJsonPointer: "#" } : r === 0 ? { refSchemaId: n, refJsonPointer: t } : {
      refSchemaId: t.slice(0, r),
      refJsonPointer: t.slice(r)
    };
  }
  #u(t, n) {
    const r = t.$id;
    r !== void 0 && typeof r == "string" && (r.charAt(0) === "#" ? this.#r(t, n, r) : (this.#l(t, r), n = r));
    const i = t.$ref;
    if (i !== void 0 && typeof i == "string") {
      const { refSchemaId: s, refJsonPointer: o } = this.#g(i, n);
      this.#e[n].refs.push({
        schemaId: s,
        jsonPointer: o
      });
    }
    for (const s in t)
      typeof t[s] == "object" && t[s] !== null && this.#u(t[s], n);
  }
  #c(t, n, r = []) {
    const i = Array.isArray(t) ? [...t] : { ...t }, s = i.$id;
    s !== void 0 && typeof s == "string" && (s.charAt(0) === "#" ? this.#h(i, n, s) : (this.#p(i, s), n = s)), i.$ref !== void 0 && r.push({
      ref: i.$ref,
      sourceSchemaId: n,
      sourceSchema: i
    });
    for (const o in i) {
      const a = i[o];
      typeof a == "object" && a !== null && (i[o] = this.#c(a, n, r));
    }
    return i;
  }
  #a(t, n) {
    const { sourceSchema: r, targetSchema: i } = t;
    if (r.$ref) {
      if (this.#s && (r[px] = r.$ref), delete r.$ref, i.$ref) {
        const s = n.find((o) => o.sourceSchema === i);
        this.#a(s, n);
      }
      for (const s in i)
        if (s !== "$id") {
          if (r[s] !== void 0) {
            if (qy(r[s], i[s]))
              continue;
            throw new Error(
              `Cannot resolve ref "${t.ref}". Property "${s}" is already exist in schema "${t.sourceSchemaId}".`
            );
          }
          r[s] = i[s];
        }
      t.isResolved = !0;
    }
  }
  #l(t, n) {
    const r = this.#e[n];
    if (r !== void 0) {
      if (this.#n && qy(t, r.schema))
        return;
      throw new Error(`There is already another schema with id "${n}".`);
    }
    this.#e[n] = { schema: t, anchors: {}, refs: [] };
  }
  #r(t, n, r) {
    const { anchors: i } = this.#e[n];
    if (i[r] !== void 0)
      throw new Error(`There is already another anchor "${r}" in a schema "${n}".`);
    i[r] = t;
  }
  #p(t, n) {
    this.#t[n] === void 0 && (this.#t[n] = { schema: t, anchors: {} });
  }
  #h(t, n, r) {
    const { anchors: i } = this.#t[n];
    i[r] = t;
  }
};
function Hy(e, t) {
  const n = t.split("/");
  let r = e;
  for (const i of n)
    if (!(i === "" || i === "#")) {
      if (typeof r != "object" || r === null)
        return null;
      r = r[i];
    }
  return r ?? null;
}
var mx = { RefResolver: hx };
const yx = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]/;
var e_ = class t_ {
  constructor(t) {
    switch (t && t.rounding) {
      case "floor":
        this.parseInteger = Math.floor;
        break;
      case "ceil":
        this.parseInteger = Math.ceil;
        break;
      case "round":
        this.parseInteger = Math.round;
        break;
      case "trunc":
      default:
        this.parseInteger = Math.trunc;
        break;
    }
    this._options = t;
  }
  asInteger(t) {
    if (Number.isInteger(t))
      return "" + t;
    if (typeof t == "bigint")
      return t.toString();
    const n = this.parseInteger(t);
    if (n === 1 / 0 || n === -1 / 0 || n !== n)
      throw new Error(`The value "${t}" cannot be converted to an integer.`);
    return "" + n;
  }
  asNumber(t) {
    const n = Number(t);
    if (n !== n)
      throw new Error(`The value "${t}" cannot be converted to a number.`);
    return n === 1 / 0 || n === -1 / 0 ? "null" : "" + n;
  }
  asBoolean(t) {
    return t && "true" || "false";
  }
  asDateTime(t) {
    if (t === null)
      return '""';
    if (t instanceof Date)
      return '"' + t.toISOString() + '"';
    if (typeof t == "string")
      return '"' + t + '"';
    throw new Error(`The value "${t}" cannot be converted to a date-time.`);
  }
  asDate(t) {
    if (t === null)
      return '""';
    if (t instanceof Date)
      return '"' + new Date(t.getTime() - t.getTimezoneOffset() * 6e4).toISOString().slice(0, 10) + '"';
    if (typeof t == "string")
      return '"' + t + '"';
    throw new Error(`The value "${t}" cannot be converted to a date.`);
  }
  asTime(t) {
    if (t === null)
      return '""';
    if (t instanceof Date)
      return '"' + new Date(t.getTime() - t.getTimezoneOffset() * 6e4).toISOString().slice(11, 19) + '"';
    if (typeof t == "string")
      return '"' + t + '"';
    throw new Error(`The value "${t}" cannot be converted to a time.`);
  }
  asString(t) {
    const n = t.length;
    if (n < 42) {
      let i = "", s = -1, o = 255;
      for (var r = 0; r < n; r++)
        if (o = t.charCodeAt(r), o === 34 || // '"'
        o === 92)
          s === -1 && (s = 0), i += t.slice(s, r) + "\\", s = r;
        else if (o < 32 || o >= 55296 && o <= 57343)
          return JSON.stringify(t);
      return s === -1 && '"' + t + '"' || '"' + i + t.slice(s) + '"';
    } else
      return n < 5e3 && yx.test(t) === !1 ? '"' + t + '"' : JSON.stringify(t);
  }
  asUnsafeString(t) {
    return '"' + t + '"';
  }
  getState() {
    return this._options;
  }
  static restoreFromState(t) {
    return new t_(t);
  }
}, rd = { exports: {} }, n_ = {}, Kn = {}, Ss = {}, ba = {}, Xe = {}, Jo = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.regexpCode = e.getEsmExportName = e.getProperty = e.safeStringify = e.stringify = e.strConcat = e.addCodeArg = e.str = e._ = e.nil = e._Code = e.Name = e.IDENTIFIER = e._CodeOrName = void 0;
  class t {
  }
  e._CodeOrName = t, e.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
  class n extends t {
    constructor(E) {
      if (super(), !e.IDENTIFIER.test(E))
        throw new Error("CodeGen: name must be a valid identifier");
      this.str = E;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      return !1;
    }
    get names() {
      return { [this.str]: 1 };
    }
  }
  e.Name = n;
  class r extends t {
    constructor(E) {
      super(), this._items = typeof E == "string" ? [E] : E;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      if (this._items.length > 1)
        return !1;
      const E = this._items[0];
      return E === "" || E === '""';
    }
    get str() {
      var E;
      return (E = this._str) !== null && E !== void 0 ? E : this._str = this._items.reduce((y, D) => `${y}${D}`, "");
    }
    get names() {
      var E;
      return (E = this._names) !== null && E !== void 0 ? E : this._names = this._items.reduce((y, D) => (D instanceof n && (y[D.str] = (y[D.str] || 0) + 1), y), {});
    }
  }
  e._Code = r, e.nil = new r("");
  function i(b, ...E) {
    const y = [b[0]];
    let D = 0;
    for (; D < E.length; )
      a(y, E[D]), y.push(b[++D]);
    return new r(y);
  }
  e._ = i;
  const s = new r("+");
  function o(b, ...E) {
    const y = [p(b[0])];
    let D = 0;
    for (; D < E.length; )
      y.push(s), a(y, E[D]), y.push(s, p(b[++D]));
    return l(y), new r(y);
  }
  e.str = o;
  function a(b, E) {
    E instanceof r ? b.push(...E._items) : E instanceof n ? b.push(E) : b.push(f(E));
  }
  e.addCodeArg = a;
  function l(b) {
    let E = 1;
    for (; E < b.length - 1; ) {
      if (b[E] === s) {
        const y = c(b[E - 1], b[E + 1]);
        if (y !== void 0) {
          b.splice(E - 1, 3, y);
          continue;
        }
        b[E++] = "+";
      }
      E++;
    }
  }
  function c(b, E) {
    if (E === '""')
      return b;
    if (b === '""')
      return E;
    if (typeof b == "string")
      return E instanceof n || b[b.length - 1] !== '"' ? void 0 : typeof E != "string" ? `${b.slice(0, -1)}${E}"` : E[0] === '"' ? b.slice(0, -1) + E.slice(1) : void 0;
    if (typeof E == "string" && E[0] === '"' && !(b instanceof n))
      return `"${b}${E.slice(1)}`;
  }
  function u(b, E) {
    return E.emptyStr() ? b : b.emptyStr() ? E : o`${b}${E}`;
  }
  e.strConcat = u;
  function f(b) {
    return typeof b == "number" || typeof b == "boolean" || b === null ? b : p(Array.isArray(b) ? b.join(",") : b);
  }
  function d(b) {
    return new r(p(b));
  }
  e.stringify = d;
  function p(b) {
    return JSON.stringify(b).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
  }
  e.safeStringify = p;
  function h(b) {
    return typeof b == "string" && e.IDENTIFIER.test(b) ? new r(`.${b}`) : i`[${b}]`;
  }
  e.getProperty = h;
  function m(b) {
    if (typeof b == "string" && e.IDENTIFIER.test(b))
      return new r(`${b}`);
    throw new Error(`CodeGen: invalid export name: ${b}, use explicit $id name mapping`);
  }
  e.getEsmExportName = m;
  function v(b) {
    return new r(b.toString());
  }
  e.regexpCode = v;
})(Jo);
var id = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.ValueScope = e.ValueScopeName = e.Scope = e.varKinds = e.UsedValueState = void 0;
  const t = Jo;
  class n extends Error {
    constructor(c) {
      super(`CodeGen: "code" for ${c} not defined`), this.value = c.value;
    }
  }
  var r;
  (function(l) {
    l[l.Started = 0] = "Started", l[l.Completed = 1] = "Completed";
  })(r || (e.UsedValueState = r = {})), e.varKinds = {
    const: new t.Name("const"),
    let: new t.Name("let"),
    var: new t.Name("var")
  };
  class i {
    constructor({ prefixes: c, parent: u } = {}) {
      this._names = {}, this._prefixes = c, this._parent = u;
    }
    toName(c) {
      return c instanceof t.Name ? c : this.name(c);
    }
    name(c) {
      return new t.Name(this._newName(c));
    }
    _newName(c) {
      const u = this._names[c] || this._nameGroup(c);
      return `${c}${u.index++}`;
    }
    _nameGroup(c) {
      var u, f;
      if (!((f = (u = this._parent) === null || u === void 0 ? void 0 : u._prefixes) === null || f === void 0) && f.has(c) || this._prefixes && !this._prefixes.has(c))
        throw new Error(`CodeGen: prefix "${c}" is not allowed in this scope`);
      return this._names[c] = { prefix: c, index: 0 };
    }
  }
  e.Scope = i;
  class s extends t.Name {
    constructor(c, u) {
      super(u), this.prefix = c;
    }
    setValue(c, { property: u, itemIndex: f }) {
      this.value = c, this.scopePath = (0, t._)`.${new t.Name(u)}[${f}]`;
    }
  }
  e.ValueScopeName = s;
  const o = (0, t._)`\n`;
  class a extends i {
    constructor(c) {
      super(c), this._values = {}, this._scope = c.scope, this.opts = { ...c, _n: c.lines ? o : t.nil };
    }
    get() {
      return this._scope;
    }
    name(c) {
      return new s(c, this._newName(c));
    }
    value(c, u) {
      var f;
      if (u.ref === void 0)
        throw new Error("CodeGen: ref must be passed in value");
      const d = this.toName(c), { prefix: p } = d, h = (f = u.key) !== null && f !== void 0 ? f : u.ref;
      let m = this._values[p];
      if (m) {
        const E = m.get(h);
        if (E)
          return E;
      } else
        m = this._values[p] = /* @__PURE__ */ new Map();
      m.set(h, d);
      const v = this._scope[p] || (this._scope[p] = []), b = v.length;
      return v[b] = u.ref, d.setValue(u, { property: p, itemIndex: b }), d;
    }
    getValue(c, u) {
      const f = this._values[c];
      if (f)
        return f.get(u);
    }
    scopeRefs(c, u = this._values) {
      return this._reduceValues(u, (f) => {
        if (f.scopePath === void 0)
          throw new Error(`CodeGen: name "${f}" has no value`);
        return (0, t._)`${c}${f.scopePath}`;
      });
    }
    scopeCode(c = this._values, u, f) {
      return this._reduceValues(c, (d) => {
        if (d.value === void 0)
          throw new Error(`CodeGen: name "${d}" has no value`);
        return d.value.code;
      }, u, f);
    }
    _reduceValues(c, u, f = {}, d) {
      let p = t.nil;
      for (const h in c) {
        const m = c[h];
        if (!m)
          continue;
        const v = f[h] = f[h] || /* @__PURE__ */ new Map();
        m.forEach((b) => {
          if (v.has(b))
            return;
          v.set(b, r.Started);
          let E = u(b);
          if (E) {
            const y = this.opts.es5 ? e.varKinds.var : e.varKinds.const;
            p = (0, t._)`${p}${y} ${b} = ${E};${this.opts._n}`;
          } else if (E = d?.(b))
            p = (0, t._)`${p}${E}${this.opts._n}`;
          else
            throw new n(b);
          v.set(b, r.Completed);
        });
      }
      return p;
    }
  }
  e.ValueScope = a;
})(id);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.or = e.and = e.not = e.CodeGen = e.operators = e.varKinds = e.ValueScopeName = e.ValueScope = e.Scope = e.Name = e.regexpCode = e.stringify = e.getProperty = e.nil = e.strConcat = e.str = e._ = void 0;
  const t = Jo, n = id;
  var r = Jo;
  Object.defineProperty(e, "_", { enumerable: !0, get: function() {
    return r._;
  } }), Object.defineProperty(e, "str", { enumerable: !0, get: function() {
    return r.str;
  } }), Object.defineProperty(e, "strConcat", { enumerable: !0, get: function() {
    return r.strConcat;
  } }), Object.defineProperty(e, "nil", { enumerable: !0, get: function() {
    return r.nil;
  } }), Object.defineProperty(e, "getProperty", { enumerable: !0, get: function() {
    return r.getProperty;
  } }), Object.defineProperty(e, "stringify", { enumerable: !0, get: function() {
    return r.stringify;
  } }), Object.defineProperty(e, "regexpCode", { enumerable: !0, get: function() {
    return r.regexpCode;
  } }), Object.defineProperty(e, "Name", { enumerable: !0, get: function() {
    return r.Name;
  } });
  var i = id;
  Object.defineProperty(e, "Scope", { enumerable: !0, get: function() {
    return i.Scope;
  } }), Object.defineProperty(e, "ValueScope", { enumerable: !0, get: function() {
    return i.ValueScope;
  } }), Object.defineProperty(e, "ValueScopeName", { enumerable: !0, get: function() {
    return i.ValueScopeName;
  } }), Object.defineProperty(e, "varKinds", { enumerable: !0, get: function() {
    return i.varKinds;
  } }), e.operators = {
    GT: new t._Code(">"),
    GTE: new t._Code(">="),
    LT: new t._Code("<"),
    LTE: new t._Code("<="),
    EQ: new t._Code("==="),
    NEQ: new t._Code("!=="),
    NOT: new t._Code("!"),
    OR: new t._Code("||"),
    AND: new t._Code("&&"),
    ADD: new t._Code("+")
  };
  class s {
    optimizeNodes() {
      return this;
    }
    optimizeNames(T, P) {
      return this;
    }
  }
  class o extends s {
    constructor(T, P, k) {
      super(), this.varKind = T, this.name = P, this.rhs = k;
    }
    render({ es5: T, _n: P }) {
      const k = T ? n.varKinds.var : this.varKind, q = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
      return `${k} ${this.name}${q};` + P;
    }
    optimizeNames(T, P) {
      if (T[this.name.str])
        return this.rhs && (this.rhs = z(this.rhs, T, P)), this;
    }
    get names() {
      return this.rhs instanceof t._CodeOrName ? this.rhs.names : {};
    }
  }
  class a extends s {
    constructor(T, P, k) {
      super(), this.lhs = T, this.rhs = P, this.sideEffects = k;
    }
    render({ _n: T }) {
      return `${this.lhs} = ${this.rhs};` + T;
    }
    optimizeNames(T, P) {
      if (!(this.lhs instanceof t.Name && !T[this.lhs.str] && !this.sideEffects))
        return this.rhs = z(this.rhs, T, P), this;
    }
    get names() {
      const T = this.lhs instanceof t.Name ? {} : { ...this.lhs.names };
      return U(T, this.rhs);
    }
  }
  class l extends a {
    constructor(T, P, k, q) {
      super(T, k, q), this.op = P;
    }
    render({ _n: T }) {
      return `${this.lhs} ${this.op}= ${this.rhs};` + T;
    }
  }
  class c extends s {
    constructor(T) {
      super(), this.label = T, this.names = {};
    }
    render({ _n: T }) {
      return `${this.label}:` + T;
    }
  }
  class u extends s {
    constructor(T) {
      super(), this.label = T, this.names = {};
    }
    render({ _n: T }) {
      return `break${this.label ? ` ${this.label}` : ""};` + T;
    }
  }
  class f extends s {
    constructor(T) {
      super(), this.error = T;
    }
    render({ _n: T }) {
      return `throw ${this.error};` + T;
    }
    get names() {
      return this.error.names;
    }
  }
  class d extends s {
    constructor(T) {
      super(), this.code = T;
    }
    render({ _n: T }) {
      return `${this.code};` + T;
    }
    optimizeNodes() {
      return `${this.code}` ? this : void 0;
    }
    optimizeNames(T, P) {
      return this.code = z(this.code, T, P), this;
    }
    get names() {
      return this.code instanceof t._CodeOrName ? this.code.names : {};
    }
  }
  class p extends s {
    constructor(T = []) {
      super(), this.nodes = T;
    }
    render(T) {
      return this.nodes.reduce((P, k) => P + k.render(T), "");
    }
    optimizeNodes() {
      const { nodes: T } = this;
      let P = T.length;
      for (; P--; ) {
        const k = T[P].optimizeNodes();
        Array.isArray(k) ? T.splice(P, 1, ...k) : k ? T[P] = k : T.splice(P, 1);
      }
      return T.length > 0 ? this : void 0;
    }
    optimizeNames(T, P) {
      const { nodes: k } = this;
      let q = k.length;
      for (; q--; ) {
        const Y = k[q];
        Y.optimizeNames(T, P) || (ne(T, Y.names), k.splice(q, 1));
      }
      return k.length > 0 ? this : void 0;
    }
    get names() {
      return this.nodes.reduce((T, P) => ce(T, P.names), {});
    }
  }
  class h extends p {
    render(T) {
      return "{" + T._n + super.render(T) + "}" + T._n;
    }
  }
  class m extends p {
  }
  class v extends h {
  }
  v.kind = "else";
  class b extends h {
    constructor(T, P) {
      super(P), this.condition = T;
    }
    render(T) {
      let P = `if(${this.condition})` + super.render(T);
      return this.else && (P += "else " + this.else.render(T)), P;
    }
    optimizeNodes() {
      super.optimizeNodes();
      const T = this.condition;
      if (T === !0)
        return this.nodes;
      let P = this.else;
      if (P) {
        const k = P.optimizeNodes();
        P = this.else = Array.isArray(k) ? new v(k) : k;
      }
      if (P)
        return T === !1 ? P instanceof b ? P : P.nodes : this.nodes.length ? this : new b(K(T), P instanceof b ? [P] : P.nodes);
      if (!(T === !1 || !this.nodes.length))
        return this;
    }
    optimizeNames(T, P) {
      var k;
      if (this.else = (k = this.else) === null || k === void 0 ? void 0 : k.optimizeNames(T, P), !!(super.optimizeNames(T, P) || this.else))
        return this.condition = z(this.condition, T, P), this;
    }
    get names() {
      const T = super.names;
      return U(T, this.condition), this.else && ce(T, this.else.names), T;
    }
  }
  b.kind = "if";
  class E extends h {
  }
  E.kind = "for";
  class y extends E {
    constructor(T) {
      super(), this.iteration = T;
    }
    render(T) {
      return `for(${this.iteration})` + super.render(T);
    }
    optimizeNames(T, P) {
      if (super.optimizeNames(T, P))
        return this.iteration = z(this.iteration, T, P), this;
    }
    get names() {
      return ce(super.names, this.iteration.names);
    }
  }
  class D extends E {
    constructor(T, P, k, q) {
      super(), this.varKind = T, this.name = P, this.from = k, this.to = q;
    }
    render(T) {
      const P = T.es5 ? n.varKinds.var : this.varKind, { name: k, from: q, to: Y } = this;
      return `for(${P} ${k}=${q}; ${k}<${Y}; ${k}++)` + super.render(T);
    }
    get names() {
      const T = U(super.names, this.from);
      return U(T, this.to);
    }
  }
  class F extends E {
    constructor(T, P, k, q) {
      super(), this.loop = T, this.varKind = P, this.name = k, this.iterable = q;
    }
    render(T) {
      return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(T);
    }
    optimizeNames(T, P) {
      if (super.optimizeNames(T, P))
        return this.iterable = z(this.iterable, T, P), this;
    }
    get names() {
      return ce(super.names, this.iterable.names);
    }
  }
  class W extends h {
    constructor(T, P, k) {
      super(), this.name = T, this.args = P, this.async = k;
    }
    render(T) {
      return `${this.async ? "async " : ""}function ${this.name}(${this.args})` + super.render(T);
    }
  }
  W.kind = "func";
  class J extends p {
    render(T) {
      return "return " + super.render(T);
    }
  }
  J.kind = "return";
  class Z extends h {
    render(T) {
      let P = "try" + super.render(T);
      return this.catch && (P += this.catch.render(T)), this.finally && (P += this.finally.render(T)), P;
    }
    optimizeNodes() {
      var T, P;
      return super.optimizeNodes(), (T = this.catch) === null || T === void 0 || T.optimizeNodes(), (P = this.finally) === null || P === void 0 || P.optimizeNodes(), this;
    }
    optimizeNames(T, P) {
      var k, q;
      return super.optimizeNames(T, P), (k = this.catch) === null || k === void 0 || k.optimizeNames(T, P), (q = this.finally) === null || q === void 0 || q.optimizeNames(T, P), this;
    }
    get names() {
      const T = super.names;
      return this.catch && ce(T, this.catch.names), this.finally && ce(T, this.finally.names), T;
    }
  }
  class j extends h {
    constructor(T) {
      super(), this.error = T;
    }
    render(T) {
      return `catch(${this.error})` + super.render(T);
    }
  }
  j.kind = "catch";
  class ee extends h {
    render(T) {
      return "finally" + super.render(T);
    }
  }
  ee.kind = "finally";
  class le {
    constructor(T, P = {}) {
      this._values = {}, this._blockStarts = [], this._constants = {}, this.opts = { ...P, _n: P.lines ? `
` : "" }, this._extScope = T, this._scope = new n.Scope({ parent: T }), this._nodes = [new m()];
    }
    toString() {
      return this._root.render(this.opts);
    }
    // returns unique name in the internal scope
    name(T) {
      return this._scope.name(T);
    }
    // reserves unique name in the external scope
    scopeName(T) {
      return this._extScope.name(T);
    }
    // reserves unique name in the external scope and assigns value to it
    scopeValue(T, P) {
      const k = this._extScope.value(T, P);
      return (this._values[k.prefix] || (this._values[k.prefix] = /* @__PURE__ */ new Set())).add(k), k;
    }
    getScopeValue(T, P) {
      return this._extScope.getValue(T, P);
    }
    // return code that assigns values in the external scope to the names that are used internally
    // (same names that were returned by gen.scopeName or gen.scopeValue)
    scopeRefs(T) {
      return this._extScope.scopeRefs(T, this._values);
    }
    scopeCode() {
      return this._extScope.scopeCode(this._values);
    }
    _def(T, P, k, q) {
      const Y = this._scope.toName(P);
      return k !== void 0 && q && (this._constants[Y.str] = k), this._leafNode(new o(T, Y, k)), Y;
    }
    // `const` declaration (`var` in es5 mode)
    const(T, P, k) {
      return this._def(n.varKinds.const, T, P, k);
    }
    // `let` declaration with optional assignment (`var` in es5 mode)
    let(T, P, k) {
      return this._def(n.varKinds.let, T, P, k);
    }
    // `var` declaration with optional assignment
    var(T, P, k) {
      return this._def(n.varKinds.var, T, P, k);
    }
    // assignment code
    assign(T, P, k) {
      return this._leafNode(new a(T, P, k));
    }
    // `+=` code
    add(T, P) {
      return this._leafNode(new l(T, e.operators.ADD, P));
    }
    // appends passed SafeExpr to code or executes Block
    code(T) {
      return typeof T == "function" ? T() : T !== t.nil && this._leafNode(new d(T)), this;
    }
    // returns code for object literal for the passed argument list of key-value pairs
    object(...T) {
      const P = ["{"];
      for (const [k, q] of T)
        P.length > 1 && P.push(","), P.push(k), (k !== q || this.opts.es5) && (P.push(":"), (0, t.addCodeArg)(P, q));
      return P.push("}"), new t._Code(P);
    }
    // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
    if(T, P, k) {
      if (this._blockNode(new b(T)), P && k)
        this.code(P).else().code(k).endIf();
      else if (P)
        this.code(P).endIf();
      else if (k)
        throw new Error('CodeGen: "else" body without "then" body');
      return this;
    }
    // `else if` clause - invalid without `if` or after `else` clauses
    elseIf(T) {
      return this._elseNode(new b(T));
    }
    // `else` clause - only valid after `if` or `else if` clauses
    else() {
      return this._elseNode(new v());
    }
    // end `if` statement (needed if gen.if was used only with condition)
    endIf() {
      return this._endBlockNode(b, v);
    }
    _for(T, P) {
      return this._blockNode(T), P && this.code(P).endFor(), this;
    }
    // a generic `for` clause (or statement if `forBody` is passed)
    for(T, P) {
      return this._for(new y(T), P);
    }
    // `for` statement for a range of values
    forRange(T, P, k, q, Y = this.opts.es5 ? n.varKinds.var : n.varKinds.let) {
      const ve = this._scope.toName(T);
      return this._for(new D(Y, ve, P, k), () => q(ve));
    }
    // `for-of` statement (in es5 mode replace with a normal for loop)
    forOf(T, P, k, q = n.varKinds.const) {
      const Y = this._scope.toName(T);
      if (this.opts.es5) {
        const ve = P instanceof t.Name ? P : this.var("_arr", P);
        return this.forRange("_i", 0, (0, t._)`${ve}.length`, (oe) => {
          this.var(Y, (0, t._)`${ve}[${oe}]`), k(Y);
        });
      }
      return this._for(new F("of", q, Y, P), () => k(Y));
    }
    // `for-in` statement.
    // With option `ownProperties` replaced with a `for-of` loop for object keys
    forIn(T, P, k, q = this.opts.es5 ? n.varKinds.var : n.varKinds.const) {
      if (this.opts.ownProperties)
        return this.forOf(T, (0, t._)`Object.keys(${P})`, k);
      const Y = this._scope.toName(T);
      return this._for(new F("in", q, Y, P), () => k(Y));
    }
    // end `for` loop
    endFor() {
      return this._endBlockNode(E);
    }
    // `label` statement
    label(T) {
      return this._leafNode(new c(T));
    }
    // `break` statement
    break(T) {
      return this._leafNode(new u(T));
    }
    // `return` statement
    return(T) {
      const P = new J();
      if (this._blockNode(P), this.code(T), P.nodes.length !== 1)
        throw new Error('CodeGen: "return" should have one node');
      return this._endBlockNode(J);
    }
    // `try` statement
    try(T, P, k) {
      if (!P && !k)
        throw new Error('CodeGen: "try" without "catch" and "finally"');
      const q = new Z();
      if (this._blockNode(q), this.code(T), P) {
        const Y = this.name("e");
        this._currNode = q.catch = new j(Y), P(Y);
      }
      return k && (this._currNode = q.finally = new ee(), this.code(k)), this._endBlockNode(j, ee);
    }
    // `throw` statement
    throw(T) {
      return this._leafNode(new f(T));
    }
    // start self-balancing block
    block(T, P) {
      return this._blockStarts.push(this._nodes.length), T && this.code(T).endBlock(P), this;
    }
    // end the current self-balancing block
    endBlock(T) {
      const P = this._blockStarts.pop();
      if (P === void 0)
        throw new Error("CodeGen: not in self-balancing block");
      const k = this._nodes.length - P;
      if (k < 0 || T !== void 0 && k !== T)
        throw new Error(`CodeGen: wrong number of nodes: ${k} vs ${T} expected`);
      return this._nodes.length = P, this;
    }
    // `function` heading (or definition if funcBody is passed)
    func(T, P = t.nil, k, q) {
      return this._blockNode(new W(T, P, k)), q && this.code(q).endFunc(), this;
    }
    // end function definition
    endFunc() {
      return this._endBlockNode(W);
    }
    optimize(T = 1) {
      for (; T-- > 0; )
        this._root.optimizeNodes(), this._root.optimizeNames(this._root.names, this._constants);
    }
    _leafNode(T) {
      return this._currNode.nodes.push(T), this;
    }
    _blockNode(T) {
      this._currNode.nodes.push(T), this._nodes.push(T);
    }
    _endBlockNode(T, P) {
      const k = this._currNode;
      if (k instanceof T || P && k instanceof P)
        return this._nodes.pop(), this;
      throw new Error(`CodeGen: not in block "${P ? `${T.kind}/${P.kind}` : T.kind}"`);
    }
    _elseNode(T) {
      const P = this._currNode;
      if (!(P instanceof b))
        throw new Error('CodeGen: "else" without "if"');
      return this._currNode = P.else = T, this;
    }
    get _root() {
      return this._nodes[0];
    }
    get _currNode() {
      const T = this._nodes;
      return T[T.length - 1];
    }
    set _currNode(T) {
      const P = this._nodes;
      P[P.length - 1] = T;
    }
  }
  e.CodeGen = le;
  function ce(N, T) {
    for (const P in T)
      N[P] = (N[P] || 0) + (T[P] || 0);
    return N;
  }
  function U(N, T) {
    return T instanceof t._CodeOrName ? ce(N, T.names) : N;
  }
  function z(N, T, P) {
    if (N instanceof t.Name)
      return k(N);
    if (!q(N))
      return N;
    return new t._Code(N._items.reduce((Y, ve) => (ve instanceof t.Name && (ve = k(ve)), ve instanceof t._Code ? Y.push(...ve._items) : Y.push(ve), Y), []));
    function k(Y) {
      const ve = P[Y.str];
      return ve === void 0 || T[Y.str] !== 1 ? Y : (delete T[Y.str], ve);
    }
    function q(Y) {
      return Y instanceof t._Code && Y._items.some((ve) => ve instanceof t.Name && T[ve.str] === 1 && P[ve.str] !== void 0);
    }
  }
  function ne(N, T) {
    for (const P in T)
      N[P] = (N[P] || 0) - (T[P] || 0);
  }
  function K(N) {
    return typeof N == "boolean" || typeof N == "number" || N === null ? !N : (0, t._)`!${M(N)}`;
  }
  e.not = K;
  const se = B(e.operators.AND);
  function re(...N) {
    return N.reduce(se);
  }
  e.and = re;
  const ue = B(e.operators.OR);
  function te(...N) {
    return N.reduce(ue);
  }
  e.or = te;
  function B(N) {
    return (T, P) => T === t.nil ? P : P === t.nil ? T : (0, t._)`${M(T)} ${N} ${M(P)}`;
  }
  function M(N) {
    return N instanceof t.Name ? N : (0, t._)`(${N})`;
  }
})(Xe);
var xe = {};
Object.defineProperty(xe, "__esModule", { value: !0 });
xe.checkStrictMode = xe.getErrorPath = xe.Type = xe.useFunc = xe.setEvaluated = xe.evaluatedPropsToName = xe.mergeEvaluated = xe.eachItem = xe.unescapeJsonPointer = xe.escapeJsonPointer = xe.escapeFragment = xe.unescapeFragment = xe.schemaRefOrVal = xe.schemaHasRulesButRef = xe.schemaHasRules = xe.checkUnknownRules = xe.alwaysValidSchema = xe.toHash = void 0;
const gt = Xe, gx = Jo;
function bx(e) {
  const t = {};
  for (const n of e)
    t[n] = !0;
  return t;
}
xe.toHash = bx;
function vx(e, t) {
  return typeof t == "boolean" ? t : Object.keys(t).length === 0 ? !0 : (r_(e, t), !i_(t, e.self.RULES.all));
}
xe.alwaysValidSchema = vx;
function r_(e, t = e.schema) {
  const { opts: n, self: r } = e;
  if (!n.strictSchema || typeof t == "boolean")
    return;
  const i = r.RULES.keywords;
  for (const s in t)
    i[s] || a_(e, `unknown keyword: "${s}"`);
}
xe.checkUnknownRules = r_;
function i_(e, t) {
  if (typeof e == "boolean")
    return !e;
  for (const n in e)
    if (t[n])
      return !0;
  return !1;
}
xe.schemaHasRules = i_;
function _x(e, t) {
  if (typeof e == "boolean")
    return !e;
  for (const n in e)
    if (n !== "$ref" && t.all[n])
      return !0;
  return !1;
}
xe.schemaHasRulesButRef = _x;
function wx({ topSchemaRef: e, schemaPath: t }, n, r, i) {
  if (!i) {
    if (typeof n == "number" || typeof n == "boolean")
      return n;
    if (typeof n == "string")
      return (0, gt._)`${n}`;
  }
  return (0, gt._)`${e}${t}${(0, gt.getProperty)(r)}`;
}
xe.schemaRefOrVal = wx;
function Ex(e) {
  return s_(decodeURIComponent(e));
}
xe.unescapeFragment = Ex;
function Sx(e) {
  return encodeURIComponent(gp(e));
}
xe.escapeFragment = Sx;
function gp(e) {
  return typeof e == "number" ? `${e}` : e.replace(/~/g, "~0").replace(/\//g, "~1");
}
xe.escapeJsonPointer = gp;
function s_(e) {
  return e.replace(/~1/g, "/").replace(/~0/g, "~");
}
xe.unescapeJsonPointer = s_;
function Tx(e, t) {
  if (Array.isArray(e))
    for (const n of e)
      t(n);
  else
    t(e);
}
xe.eachItem = Tx;
function Wy({ mergeNames: e, mergeToName: t, mergeValues: n, resultToName: r }) {
  return (i, s, o, a) => {
    const l = o === void 0 ? s : o instanceof gt.Name ? (s instanceof gt.Name ? e(i, s, o) : t(i, s, o), o) : s instanceof gt.Name ? (t(i, o, s), s) : n(s, o);
    return a === gt.Name && !(l instanceof gt.Name) ? r(i, l) : l;
  };
}
xe.mergeEvaluated = {
  props: Wy({
    mergeNames: (e, t, n) => e.if((0, gt._)`${n} !== true && ${t} !== undefined`, () => {
      e.if((0, gt._)`${t} === true`, () => e.assign(n, !0), () => e.assign(n, (0, gt._)`${n} || {}`).code((0, gt._)`Object.assign(${n}, ${t})`));
    }),
    mergeToName: (e, t, n) => e.if((0, gt._)`${n} !== true`, () => {
      t === !0 ? e.assign(n, !0) : (e.assign(n, (0, gt._)`${n} || {}`), bp(e, n, t));
    }),
    mergeValues: (e, t) => e === !0 ? !0 : { ...e, ...t },
    resultToName: o_
  }),
  items: Wy({
    mergeNames: (e, t, n) => e.if((0, gt._)`${n} !== true && ${t} !== undefined`, () => e.assign(n, (0, gt._)`${t} === true ? true : ${n} > ${t} ? ${n} : ${t}`)),
    mergeToName: (e, t, n) => e.if((0, gt._)`${n} !== true`, () => e.assign(n, t === !0 ? !0 : (0, gt._)`${n} > ${t} ? ${n} : ${t}`)),
    mergeValues: (e, t) => e === !0 ? !0 : Math.max(e, t),
    resultToName: (e, t) => e.var("items", t)
  })
};
function o_(e, t) {
  if (t === !0)
    return e.var("props", !0);
  const n = e.var("props", (0, gt._)`{}`);
  return t !== void 0 && bp(e, n, t), n;
}
xe.evaluatedPropsToName = o_;
function bp(e, t, n) {
  Object.keys(n).forEach((r) => e.assign((0, gt._)`${t}${(0, gt.getProperty)(r)}`, !0));
}
xe.setEvaluated = bp;
const Qy = {};
function $x(e, t) {
  return e.scopeValue("func", {
    ref: t,
    code: Qy[t.code] || (Qy[t.code] = new gx._Code(t.code))
  });
}
xe.useFunc = $x;
var sd;
(function(e) {
  e[e.Num = 0] = "Num", e[e.Str = 1] = "Str";
})(sd || (xe.Type = sd = {}));
function Nx(e, t, n) {
  if (e instanceof gt.Name) {
    const r = t === sd.Num;
    return n ? r ? (0, gt._)`"[" + ${e} + "]"` : (0, gt._)`"['" + ${e} + "']"` : r ? (0, gt._)`"/" + ${e}` : (0, gt._)`"/" + ${e}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
  }
  return n ? (0, gt.getProperty)(e).toString() : "/" + gp(e);
}
xe.getErrorPath = Nx;
function a_(e, t, n = e.opts.strictSchema) {
  if (n) {
    if (t = `strict mode: ${t}`, n === !0)
      throw new Error(t);
    e.self.logger.warn(t);
  }
}
xe.checkStrictMode = a_;
var Tr = {};
Object.defineProperty(Tr, "__esModule", { value: !0 });
const Zt = Xe, Ox = {
  // validation function arguments
  data: new Zt.Name("data"),
  // data passed to validation function
  // args passed from referencing schema
  valCxt: new Zt.Name("valCxt"),
  // validation/data context - should not be used directly, it is destructured to the names below
  instancePath: new Zt.Name("instancePath"),
  parentData: new Zt.Name("parentData"),
  parentDataProperty: new Zt.Name("parentDataProperty"),
  rootData: new Zt.Name("rootData"),
  // root data - same as the data passed to the first/top validation function
  dynamicAnchors: new Zt.Name("dynamicAnchors"),
  // used to support recursiveRef and dynamicRef
  // function scoped variables
  vErrors: new Zt.Name("vErrors"),
  // null or array of validation errors
  errors: new Zt.Name("errors"),
  // counter of validation errors
  this: new Zt.Name("this"),
  // "globals"
  self: new Zt.Name("self"),
  scope: new Zt.Name("scope"),
  // JTD serialize/parse name for JSON string and position
  json: new Zt.Name("json"),
  jsonPos: new Zt.Name("jsonPos"),
  jsonLen: new Zt.Name("jsonLen"),
  jsonPart: new Zt.Name("jsonPart")
};
Tr.default = Ox;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.extendErrors = e.resetErrorsCount = e.reportExtraError = e.reportError = e.keyword$DataError = e.keywordError = void 0;
  const t = Xe, n = xe, r = Tr;
  e.keywordError = {
    message: ({ keyword: v }) => (0, t.str)`must pass "${v}" keyword validation`
  }, e.keyword$DataError = {
    message: ({ keyword: v, schemaType: b }) => b ? (0, t.str)`"${v}" keyword must be ${b} ($data)` : (0, t.str)`"${v}" keyword is invalid ($data)`
  };
  function i(v, b = e.keywordError, E, y) {
    const { it: D } = v, { gen: F, compositeRule: W, allErrors: J } = D, Z = f(v, b, E);
    y ?? (W || J) ? l(F, Z) : c(D, (0, t._)`[${Z}]`);
  }
  e.reportError = i;
  function s(v, b = e.keywordError, E) {
    const { it: y } = v, { gen: D, compositeRule: F, allErrors: W } = y, J = f(v, b, E);
    l(D, J), F || W || c(y, r.default.vErrors);
  }
  e.reportExtraError = s;
  function o(v, b) {
    v.assign(r.default.errors, b), v.if((0, t._)`${r.default.vErrors} !== null`, () => v.if(b, () => v.assign((0, t._)`${r.default.vErrors}.length`, b), () => v.assign(r.default.vErrors, null)));
  }
  e.resetErrorsCount = o;
  function a({ gen: v, keyword: b, schemaValue: E, data: y, errsCount: D, it: F }) {
    if (D === void 0)
      throw new Error("ajv implementation error");
    const W = v.name("err");
    v.forRange("i", D, r.default.errors, (J) => {
      v.const(W, (0, t._)`${r.default.vErrors}[${J}]`), v.if((0, t._)`${W}.instancePath === undefined`, () => v.assign((0, t._)`${W}.instancePath`, (0, t.strConcat)(r.default.instancePath, F.errorPath))), v.assign((0, t._)`${W}.schemaPath`, (0, t.str)`${F.errSchemaPath}/${b}`), F.opts.verbose && (v.assign((0, t._)`${W}.schema`, E), v.assign((0, t._)`${W}.data`, y));
    });
  }
  e.extendErrors = a;
  function l(v, b) {
    const E = v.const("err", b);
    v.if((0, t._)`${r.default.vErrors} === null`, () => v.assign(r.default.vErrors, (0, t._)`[${E}]`), (0, t._)`${r.default.vErrors}.push(${E})`), v.code((0, t._)`${r.default.errors}++`);
  }
  function c(v, b) {
    const { gen: E, validateName: y, schemaEnv: D } = v;
    D.$async ? E.throw((0, t._)`new ${v.ValidationError}(${b})`) : (E.assign((0, t._)`${y}.errors`, b), E.return(!1));
  }
  const u = {
    keyword: new t.Name("keyword"),
    schemaPath: new t.Name("schemaPath"),
    // also used in JTD errors
    params: new t.Name("params"),
    propertyName: new t.Name("propertyName"),
    message: new t.Name("message"),
    schema: new t.Name("schema"),
    parentSchema: new t.Name("parentSchema")
  };
  function f(v, b, E) {
    const { createErrors: y } = v.it;
    return y === !1 ? (0, t._)`{}` : d(v, b, E);
  }
  function d(v, b, E = {}) {
    const { gen: y, it: D } = v, F = [
      p(D, E),
      h(v, E)
    ];
    return m(v, b, F), y.object(...F);
  }
  function p({ errorPath: v }, { instancePath: b }) {
    const E = b ? (0, t.str)`${v}${(0, n.getErrorPath)(b, n.Type.Str)}` : v;
    return [r.default.instancePath, (0, t.strConcat)(r.default.instancePath, E)];
  }
  function h({ keyword: v, it: { errSchemaPath: b } }, { schemaPath: E, parentSchema: y }) {
    let D = y ? b : (0, t.str)`${b}/${v}`;
    return E && (D = (0, t.str)`${D}${(0, n.getErrorPath)(E, n.Type.Str)}`), [u.schemaPath, D];
  }
  function m(v, { params: b, message: E }, y) {
    const { keyword: D, data: F, schemaValue: W, it: J } = v, { opts: Z, propertyName: j, topSchemaRef: ee, schemaPath: le } = J;
    y.push([u.keyword, D], [u.params, typeof b == "function" ? b(v) : b || (0, t._)`{}`]), Z.messages && y.push([u.message, typeof E == "function" ? E(v) : E]), Z.verbose && y.push([u.schema, W], [u.parentSchema, (0, t._)`${ee}${le}`], [r.default.data, F]), j && y.push([u.propertyName, j]);
  }
})(ba);
Object.defineProperty(Ss, "__esModule", { value: !0 });
Ss.boolOrEmptySchema = Ss.topBoolOrEmptySchema = void 0;
const Ix = ba, Rx = Xe, Ax = Tr, xx = {
  message: "boolean schema is false"
};
function Dx(e) {
  const { gen: t, schema: n, validateName: r } = e;
  n === !1 ? l_(e, !1) : typeof n == "object" && n.$async === !0 ? t.return(Ax.default.data) : (t.assign((0, Rx._)`${r}.errors`, null), t.return(!0));
}
Ss.topBoolOrEmptySchema = Dx;
function Px(e, t) {
  const { gen: n, schema: r } = e;
  r === !1 ? (n.var(t, !1), l_(e)) : n.var(t, !0);
}
Ss.boolOrEmptySchema = Px;
function l_(e, t) {
  const { gen: n, data: r } = e, i = {
    gen: n,
    keyword: "false schema",
    data: r,
    schema: !1,
    schemaCode: !1,
    schemaValue: !1,
    params: {},
    it: e
  };
  (0, Ix.reportError)(i, xx, void 0, t);
}
var Bt = {}, Ui = {};
Object.defineProperty(Ui, "__esModule", { value: !0 });
Ui.getRules = Ui.isJSONType = void 0;
const kx = ["string", "number", "integer", "boolean", "null", "object", "array"], Lx = new Set(kx);
function jx(e) {
  return typeof e == "string" && Lx.has(e);
}
Ui.isJSONType = jx;
function Cx() {
  const e = {
    number: { type: "number", rules: [] },
    string: { type: "string", rules: [] },
    array: { type: "array", rules: [] },
    object: { type: "object", rules: [] }
  };
  return {
    types: { ...e, integer: !0, boolean: !0, null: !0 },
    rules: [{ rules: [] }, e.number, e.string, e.array, e.object],
    post: { rules: [] },
    all: {},
    keywords: {}
  };
}
Ui.getRules = Cx;
var kr = {};
Object.defineProperty(kr, "__esModule", { value: !0 });
kr.shouldUseRule = kr.shouldUseGroup = kr.schemaHasRulesForType = void 0;
function Mx({ schema: e, self: t }, n) {
  const r = t.RULES.types[n];
  return r && r !== !0 && u_(e, r);
}
kr.schemaHasRulesForType = Mx;
function u_(e, t) {
  return t.rules.some((n) => c_(e, n));
}
kr.shouldUseGroup = u_;
function c_(e, t) {
  var n;
  return e[t.keyword] !== void 0 || ((n = t.definition.implements) === null || n === void 0 ? void 0 : n.some((r) => e[r] !== void 0));
}
kr.shouldUseRule = c_;
Object.defineProperty(Bt, "__esModule", { value: !0 });
Bt.reportTypeError = Bt.checkDataTypes = Bt.checkDataType = Bt.coerceAndCheckDataType = Bt.getJSONTypes = Bt.getSchemaTypes = Bt.DataType = void 0;
const Fx = Ui, Ux = kr, Vx = ba, Ke = Xe, f_ = xe;
var ys;
(function(e) {
  e[e.Correct = 0] = "Correct", e[e.Wrong = 1] = "Wrong";
})(ys || (Bt.DataType = ys = {}));
function Bx(e) {
  const t = d_(e.type);
  if (t.includes("null")) {
    if (e.nullable === !1)
      throw new Error("type: null contradicts nullable: false");
  } else {
    if (!t.length && e.nullable !== void 0)
      throw new Error('"nullable" cannot be used without "type"');
    e.nullable === !0 && t.push("null");
  }
  return t;
}
Bt.getSchemaTypes = Bx;
function d_(e) {
  const t = Array.isArray(e) ? e : e ? [e] : [];
  if (t.every(Fx.isJSONType))
    return t;
  throw new Error("type must be JSONType or JSONType[]: " + t.join(","));
}
Bt.getJSONTypes = d_;
function Gx(e, t) {
  const { gen: n, data: r, opts: i } = e, s = zx(t, i.coerceTypes), o = t.length > 0 && !(s.length === 0 && t.length === 1 && (0, Ux.schemaHasRulesForType)(e, t[0]));
  if (o) {
    const a = vp(t, r, i.strictNumbers, ys.Wrong);
    n.if(a, () => {
      s.length ? qx(e, t, s) : _p(e);
    });
  }
  return o;
}
Bt.coerceAndCheckDataType = Gx;
const p_ = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
function zx(e, t) {
  return t ? e.filter((n) => p_.has(n) || t === "array" && n === "array") : [];
}
function qx(e, t, n) {
  const { gen: r, data: i, opts: s } = e, o = r.let("dataType", (0, Ke._)`typeof ${i}`), a = r.let("coerced", (0, Ke._)`undefined`);
  s.coerceTypes === "array" && r.if((0, Ke._)`${o} == 'object' && Array.isArray(${i}) && ${i}.length == 1`, () => r.assign(i, (0, Ke._)`${i}[0]`).assign(o, (0, Ke._)`typeof ${i}`).if(vp(t, i, s.strictNumbers), () => r.assign(a, i))), r.if((0, Ke._)`${a} !== undefined`);
  for (const c of n)
    (p_.has(c) || c === "array" && s.coerceTypes === "array") && l(c);
  r.else(), _p(e), r.endIf(), r.if((0, Ke._)`${a} !== undefined`, () => {
    r.assign(i, a), Hx(e, a);
  });
  function l(c) {
    switch (c) {
      case "string":
        r.elseIf((0, Ke._)`${o} == "number" || ${o} == "boolean"`).assign(a, (0, Ke._)`"" + ${i}`).elseIf((0, Ke._)`${i} === null`).assign(a, (0, Ke._)`""`);
        return;
      case "number":
        r.elseIf((0, Ke._)`${o} == "boolean" || ${i} === null
              || (${o} == "string" && ${i} && ${i} == +${i})`).assign(a, (0, Ke._)`+${i}`);
        return;
      case "integer":
        r.elseIf((0, Ke._)`${o} === "boolean" || ${i} === null
              || (${o} === "string" && ${i} && ${i} == +${i} && !(${i} % 1))`).assign(a, (0, Ke._)`+${i}`);
        return;
      case "boolean":
        r.elseIf((0, Ke._)`${i} === "false" || ${i} === 0 || ${i} === null`).assign(a, !1).elseIf((0, Ke._)`${i} === "true" || ${i} === 1`).assign(a, !0);
        return;
      case "null":
        r.elseIf((0, Ke._)`${i} === "" || ${i} === 0 || ${i} === false`), r.assign(a, null);
        return;
      case "array":
        r.elseIf((0, Ke._)`${o} === "string" || ${o} === "number"
              || ${o} === "boolean" || ${i} === null`).assign(a, (0, Ke._)`[${i}]`);
    }
  }
}
function Hx({ gen: e, parentData: t, parentDataProperty: n }, r) {
  e.if((0, Ke._)`${t} !== undefined`, () => e.assign((0, Ke._)`${t}[${n}]`, r));
}
function od(e, t, n, r = ys.Correct) {
  const i = r === ys.Correct ? Ke.operators.EQ : Ke.operators.NEQ;
  let s;
  switch (e) {
    case "null":
      return (0, Ke._)`${t} ${i} null`;
    case "array":
      s = (0, Ke._)`Array.isArray(${t})`;
      break;
    case "object":
      s = (0, Ke._)`${t} && typeof ${t} == "object" && !Array.isArray(${t})`;
      break;
    case "integer":
      s = o((0, Ke._)`!(${t} % 1) && !isNaN(${t})`);
      break;
    case "number":
      s = o();
      break;
    default:
      return (0, Ke._)`typeof ${t} ${i} ${e}`;
  }
  return r === ys.Correct ? s : (0, Ke.not)(s);
  function o(a = Ke.nil) {
    return (0, Ke.and)((0, Ke._)`typeof ${t} == "number"`, a, n ? (0, Ke._)`isFinite(${t})` : Ke.nil);
  }
}
Bt.checkDataType = od;
function vp(e, t, n, r) {
  if (e.length === 1)
    return od(e[0], t, n, r);
  let i;
  const s = (0, f_.toHash)(e);
  if (s.array && s.object) {
    const o = (0, Ke._)`typeof ${t} != "object"`;
    i = s.null ? o : (0, Ke._)`!${t} || ${o}`, delete s.null, delete s.array, delete s.object;
  } else
    i = Ke.nil;
  s.number && delete s.integer;
  for (const o in s)
    i = (0, Ke.and)(i, od(o, t, n, r));
  return i;
}
Bt.checkDataTypes = vp;
const Wx = {
  message: ({ schema: e }) => `must be ${e}`,
  params: ({ schema: e, schemaValue: t }) => typeof e == "string" ? (0, Ke._)`{type: ${e}}` : (0, Ke._)`{type: ${t}}`
};
function _p(e) {
  const t = Qx(e);
  (0, Vx.reportError)(t, Wx);
}
Bt.reportTypeError = _p;
function Qx(e) {
  const { gen: t, data: n, schema: r } = e, i = (0, f_.schemaRefOrVal)(e, r, "type");
  return {
    gen: t,
    keyword: "type",
    data: n,
    schema: r.type,
    schemaCode: i,
    schemaValue: i,
    parentSchema: r,
    params: {},
    it: e
  };
}
var Lu = {};
Object.defineProperty(Lu, "__esModule", { value: !0 });
Lu.assignDefaults = void 0;
const as = Xe, Jx = xe;
function Kx(e, t) {
  const { properties: n, items: r } = e.schema;
  if (t === "object" && n)
    for (const i in n)
      Jy(e, i, n[i].default);
  else
    t === "array" && Array.isArray(r) && r.forEach((i, s) => Jy(e, s, i.default));
}
Lu.assignDefaults = Kx;
function Jy(e, t, n) {
  const { gen: r, compositeRule: i, data: s, opts: o } = e;
  if (n === void 0)
    return;
  const a = (0, as._)`${s}${(0, as.getProperty)(t)}`;
  if (i) {
    (0, Jx.checkStrictMode)(e, `default is ignored for: ${a}`);
    return;
  }
  let l = (0, as._)`${a} === undefined`;
  o.useDefaults === "empty" && (l = (0, as._)`${l} || ${a} === null || ${a} === ""`), r.if(l, (0, as._)`${a} = ${(0, as.stringify)(n)}`);
}
var fr = {}, tt = {};
Object.defineProperty(tt, "__esModule", { value: !0 });
tt.validateUnion = tt.validateArray = tt.usePattern = tt.callValidateCode = tt.schemaProperties = tt.allSchemaProperties = tt.noPropertyInData = tt.propertyInData = tt.isOwnProperty = tt.hasPropFunc = tt.reportMissingProp = tt.checkMissingProp = tt.checkReportMissingProp = void 0;
const wt = Xe, wp = xe, Kr = Tr, Yx = xe;
function Xx(e, t) {
  const { gen: n, data: r, it: i } = e;
  n.if(Sp(n, r, t, i.opts.ownProperties), () => {
    e.setParams({ missingProperty: (0, wt._)`${t}` }, !0), e.error();
  });
}
tt.checkReportMissingProp = Xx;
function Zx({ gen: e, data: t, it: { opts: n } }, r, i) {
  return (0, wt.or)(...r.map((s) => (0, wt.and)(Sp(e, t, s, n.ownProperties), (0, wt._)`${i} = ${s}`)));
}
tt.checkMissingProp = Zx;
function eD(e, t) {
  e.setParams({ missingProperty: t }, !0), e.error();
}
tt.reportMissingProp = eD;
function h_(e) {
  return e.scopeValue("func", {
    // eslint-disable-next-line @typescript-eslint/unbound-method
    ref: Object.prototype.hasOwnProperty,
    code: (0, wt._)`Object.prototype.hasOwnProperty`
  });
}
tt.hasPropFunc = h_;
function Ep(e, t, n) {
  return (0, wt._)`${h_(e)}.call(${t}, ${n})`;
}
tt.isOwnProperty = Ep;
function tD(e, t, n, r) {
  const i = (0, wt._)`${t}${(0, wt.getProperty)(n)} !== undefined`;
  return r ? (0, wt._)`${i} && ${Ep(e, t, n)}` : i;
}
tt.propertyInData = tD;
function Sp(e, t, n, r) {
  const i = (0, wt._)`${t}${(0, wt.getProperty)(n)} === undefined`;
  return r ? (0, wt.or)(i, (0, wt.not)(Ep(e, t, n))) : i;
}
tt.noPropertyInData = Sp;
function m_(e) {
  return e ? Object.keys(e).filter((t) => t !== "__proto__") : [];
}
tt.allSchemaProperties = m_;
function nD(e, t) {
  return m_(t).filter((n) => !(0, wp.alwaysValidSchema)(e, t[n]));
}
tt.schemaProperties = nD;
function rD({ schemaCode: e, data: t, it: { gen: n, topSchemaRef: r, schemaPath: i, errorPath: s }, it: o }, a, l, c) {
  const u = c ? (0, wt._)`${e}, ${t}, ${r}${i}` : t, f = [
    [Kr.default.instancePath, (0, wt.strConcat)(Kr.default.instancePath, s)],
    [Kr.default.parentData, o.parentData],
    [Kr.default.parentDataProperty, o.parentDataProperty],
    [Kr.default.rootData, Kr.default.rootData]
  ];
  o.opts.dynamicRef && f.push([Kr.default.dynamicAnchors, Kr.default.dynamicAnchors]);
  const d = (0, wt._)`${u}, ${n.object(...f)}`;
  return l !== wt.nil ? (0, wt._)`${a}.call(${l}, ${d})` : (0, wt._)`${a}(${d})`;
}
tt.callValidateCode = rD;
const iD = (0, wt._)`new RegExp`;
function sD({ gen: e, it: { opts: t } }, n) {
  const r = t.unicodeRegExp ? "u" : "", { regExp: i } = t.code, s = i(n, r);
  return e.scopeValue("pattern", {
    key: s.toString(),
    ref: s,
    code: (0, wt._)`${i.code === "new RegExp" ? iD : (0, Yx.useFunc)(e, i)}(${n}, ${r})`
  });
}
tt.usePattern = sD;
function oD(e) {
  const { gen: t, data: n, keyword: r, it: i } = e, s = t.name("valid");
  if (i.allErrors) {
    const a = t.let("valid", !0);
    return o(() => t.assign(a, !1)), a;
  }
  return t.var(s, !0), o(() => t.break()), s;
  function o(a) {
    const l = t.const("len", (0, wt._)`${n}.length`);
    t.forRange("i", 0, l, (c) => {
      e.subschema({
        keyword: r,
        dataProp: c,
        dataPropType: wp.Type.Num
      }, s), t.if((0, wt.not)(s), a);
    });
  }
}
tt.validateArray = oD;
function aD(e) {
  const { gen: t, schema: n, keyword: r, it: i } = e;
  if (!Array.isArray(n))
    throw new Error("ajv implementation error");
  if (n.some((l) => (0, wp.alwaysValidSchema)(i, l)) && !i.opts.unevaluated)
    return;
  const o = t.let("valid", !1), a = t.name("_valid");
  t.block(() => n.forEach((l, c) => {
    const u = e.subschema({
      keyword: r,
      schemaProp: c,
      compositeRule: !0
    }, a);
    t.assign(o, (0, wt._)`${o} || ${a}`), e.mergeValidEvaluated(u, a) || t.if((0, wt.not)(o));
  })), e.result(o, () => e.reset(), () => e.error(!0));
}
tt.validateUnion = aD;
Object.defineProperty(fr, "__esModule", { value: !0 });
fr.validateKeywordUsage = fr.validSchemaType = fr.funcKeywordCode = fr.macroKeywordCode = void 0;
const sn = Xe, Pi = Tr, lD = tt, uD = ba;
function cD(e, t) {
  const { gen: n, keyword: r, schema: i, parentSchema: s, it: o } = e, a = t.macro.call(o.self, i, s, o), l = y_(n, r, a);
  o.opts.validateSchema !== !1 && o.self.validateSchema(a, !0);
  const c = n.name("valid");
  e.subschema({
    schema: a,
    schemaPath: sn.nil,
    errSchemaPath: `${o.errSchemaPath}/${r}`,
    topSchemaRef: l,
    compositeRule: !0
  }, c), e.pass(c, () => e.error(!0));
}
fr.macroKeywordCode = cD;
function fD(e, t) {
  var n;
  const { gen: r, keyword: i, schema: s, parentSchema: o, $data: a, it: l } = e;
  pD(l, t);
  const c = !a && t.compile ? t.compile.call(l.self, s, o, l) : t.validate, u = y_(r, i, c), f = r.let("valid");
  e.block$data(f, d), e.ok((n = t.valid) !== null && n !== void 0 ? n : f);
  function d() {
    if (t.errors === !1)
      m(), t.modifying && Ky(e), v(() => e.error());
    else {
      const b = t.async ? p() : h();
      t.modifying && Ky(e), v(() => dD(e, b));
    }
  }
  function p() {
    const b = r.let("ruleErrs", null);
    return r.try(() => m((0, sn._)`await `), (E) => r.assign(f, !1).if((0, sn._)`${E} instanceof ${l.ValidationError}`, () => r.assign(b, (0, sn._)`${E}.errors`), () => r.throw(E))), b;
  }
  function h() {
    const b = (0, sn._)`${u}.errors`;
    return r.assign(b, null), m(sn.nil), b;
  }
  function m(b = t.async ? (0, sn._)`await ` : sn.nil) {
    const E = l.opts.passContext ? Pi.default.this : Pi.default.self, y = !("compile" in t && !a || t.schema === !1);
    r.assign(f, (0, sn._)`${b}${(0, lD.callValidateCode)(e, u, E, y)}`, t.modifying);
  }
  function v(b) {
    var E;
    r.if((0, sn.not)((E = t.valid) !== null && E !== void 0 ? E : f), b);
  }
}
fr.funcKeywordCode = fD;
function Ky(e) {
  const { gen: t, data: n, it: r } = e;
  t.if(r.parentData, () => t.assign(n, (0, sn._)`${r.parentData}[${r.parentDataProperty}]`));
}
function dD(e, t) {
  const { gen: n } = e;
  n.if((0, sn._)`Array.isArray(${t})`, () => {
    n.assign(Pi.default.vErrors, (0, sn._)`${Pi.default.vErrors} === null ? ${t} : ${Pi.default.vErrors}.concat(${t})`).assign(Pi.default.errors, (0, sn._)`${Pi.default.vErrors}.length`), (0, uD.extendErrors)(e);
  }, () => e.error());
}
function pD({ schemaEnv: e }, t) {
  if (t.async && !e.$async)
    throw new Error("async keyword in sync schema");
}
function y_(e, t, n) {
  if (n === void 0)
    throw new Error(`keyword "${t}" failed to compile`);
  return e.scopeValue("keyword", typeof n == "function" ? { ref: n } : { ref: n, code: (0, sn.stringify)(n) });
}
function hD(e, t, n = !1) {
  return !t.length || t.some((r) => r === "array" ? Array.isArray(e) : r === "object" ? e && typeof e == "object" && !Array.isArray(e) : typeof e == r || n && typeof e > "u");
}
fr.validSchemaType = hD;
function mD({ schema: e, opts: t, self: n, errSchemaPath: r }, i, s) {
  if (Array.isArray(i.keyword) ? !i.keyword.includes(s) : i.keyword !== s)
    throw new Error("ajv implementation error");
  const o = i.dependencies;
  if (o?.some((a) => !Object.prototype.hasOwnProperty.call(e, a)))
    throw new Error(`parent schema must have dependencies of ${s}: ${o.join(",")}`);
  if (i.validateSchema && !i.validateSchema(e[s])) {
    const l = `keyword "${s}" value is invalid at path "${r}": ` + n.errorsText(i.validateSchema.errors);
    if (t.validateSchema === "log")
      n.logger.error(l);
    else
      throw new Error(l);
  }
}
fr.validateKeywordUsage = mD;
var si = {};
Object.defineProperty(si, "__esModule", { value: !0 });
si.extendSubschemaMode = si.extendSubschemaData = si.getSubschema = void 0;
const ur = Xe, g_ = xe;
function yD(e, { keyword: t, schemaProp: n, schema: r, schemaPath: i, errSchemaPath: s, topSchemaRef: o }) {
  if (t !== void 0 && r !== void 0)
    throw new Error('both "keyword" and "schema" passed, only one allowed');
  if (t !== void 0) {
    const a = e.schema[t];
    return n === void 0 ? {
      schema: a,
      schemaPath: (0, ur._)`${e.schemaPath}${(0, ur.getProperty)(t)}`,
      errSchemaPath: `${e.errSchemaPath}/${t}`
    } : {
      schema: a[n],
      schemaPath: (0, ur._)`${e.schemaPath}${(0, ur.getProperty)(t)}${(0, ur.getProperty)(n)}`,
      errSchemaPath: `${e.errSchemaPath}/${t}/${(0, g_.escapeFragment)(n)}`
    };
  }
  if (r !== void 0) {
    if (i === void 0 || s === void 0 || o === void 0)
      throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
    return {
      schema: r,
      schemaPath: i,
      topSchemaRef: o,
      errSchemaPath: s
    };
  }
  throw new Error('either "keyword" or "schema" must be passed');
}
si.getSubschema = yD;
function gD(e, t, { dataProp: n, dataPropType: r, data: i, dataTypes: s, propertyName: o }) {
  if (i !== void 0 && n !== void 0)
    throw new Error('both "data" and "dataProp" passed, only one allowed');
  const { gen: a } = t;
  if (n !== void 0) {
    const { errorPath: c, dataPathArr: u, opts: f } = t, d = a.let("data", (0, ur._)`${t.data}${(0, ur.getProperty)(n)}`, !0);
    l(d), e.errorPath = (0, ur.str)`${c}${(0, g_.getErrorPath)(n, r, f.jsPropertySyntax)}`, e.parentDataProperty = (0, ur._)`${n}`, e.dataPathArr = [...u, e.parentDataProperty];
  }
  if (i !== void 0) {
    const c = i instanceof ur.Name ? i : a.let("data", i, !0);
    l(c), o !== void 0 && (e.propertyName = o);
  }
  s && (e.dataTypes = s);
  function l(c) {
    e.data = c, e.dataLevel = t.dataLevel + 1, e.dataTypes = [], t.definedProperties = /* @__PURE__ */ new Set(), e.parentData = t.data, e.dataNames = [...t.dataNames, c];
  }
}
si.extendSubschemaData = gD;
function bD(e, { jtdDiscriminator: t, jtdMetadata: n, compositeRule: r, createErrors: i, allErrors: s }) {
  r !== void 0 && (e.compositeRule = r), i !== void 0 && (e.createErrors = i), s !== void 0 && (e.allErrors = s), e.jtdDiscriminator = t, e.jtdMetadata = n;
}
si.extendSubschemaMode = bD;
var Jt = {}, b_ = { exports: {} }, ti = b_.exports = function(e, t, n) {
  typeof t == "function" && (n = t, t = {}), n = t.cb || n;
  var r = typeof n == "function" ? n : n.pre || function() {
  }, i = n.post || function() {
  };
  gl(t, r, i, e, "", e);
};
ti.keywords = {
  additionalItems: !0,
  items: !0,
  contains: !0,
  additionalProperties: !0,
  propertyNames: !0,
  not: !0,
  if: !0,
  then: !0,
  else: !0
};
ti.arrayKeywords = {
  items: !0,
  allOf: !0,
  anyOf: !0,
  oneOf: !0
};
ti.propsKeywords = {
  $defs: !0,
  definitions: !0,
  properties: !0,
  patternProperties: !0,
  dependencies: !0
};
ti.skipKeywords = {
  default: !0,
  enum: !0,
  const: !0,
  required: !0,
  maximum: !0,
  minimum: !0,
  exclusiveMaximum: !0,
  exclusiveMinimum: !0,
  multipleOf: !0,
  maxLength: !0,
  minLength: !0,
  pattern: !0,
  format: !0,
  maxItems: !0,
  minItems: !0,
  uniqueItems: !0,
  maxProperties: !0,
  minProperties: !0
};
function gl(e, t, n, r, i, s, o, a, l, c) {
  if (r && typeof r == "object" && !Array.isArray(r)) {
    t(r, i, s, o, a, l, c);
    for (var u in r) {
      var f = r[u];
      if (Array.isArray(f)) {
        if (u in ti.arrayKeywords)
          for (var d = 0; d < f.length; d++)
            gl(e, t, n, f[d], i + "/" + u + "/" + d, s, i, u, r, d);
      } else if (u in ti.propsKeywords) {
        if (f && typeof f == "object")
          for (var p in f)
            gl(e, t, n, f[p], i + "/" + u + "/" + vD(p), s, i, u, r, p);
      } else
        (u in ti.keywords || e.allKeys && !(u in ti.skipKeywords)) && gl(e, t, n, f, i + "/" + u, s, i, u, r);
    }
    n(r, i, s, o, a, l, c);
  }
}
function vD(e) {
  return e.replace(/~/g, "~0").replace(/\//g, "~1");
}
var _D = b_.exports;
Object.defineProperty(Jt, "__esModule", { value: !0 });
Jt.getSchemaRefs = Jt.resolveUrl = Jt.normalizeId = Jt._getFullPath = Jt.getFullPath = Jt.inlineRef = void 0;
const wD = xe, ED = ga, SD = _D, TD = /* @__PURE__ */ new Set([
  "type",
  "format",
  "pattern",
  "maxLength",
  "minLength",
  "maxProperties",
  "minProperties",
  "maxItems",
  "minItems",
  "maximum",
  "minimum",
  "uniqueItems",
  "multipleOf",
  "required",
  "enum",
  "const"
]);
function $D(e, t = !0) {
  return typeof e == "boolean" ? !0 : t === !0 ? !ad(e) : t ? v_(e) <= t : !1;
}
Jt.inlineRef = $D;
const ND = /* @__PURE__ */ new Set([
  "$ref",
  "$recursiveRef",
  "$recursiveAnchor",
  "$dynamicRef",
  "$dynamicAnchor"
]);
function ad(e) {
  for (const t in e) {
    if (ND.has(t))
      return !0;
    const n = e[t];
    if (Array.isArray(n) && n.some(ad) || typeof n == "object" && ad(n))
      return !0;
  }
  return !1;
}
function v_(e) {
  let t = 0;
  for (const n in e) {
    if (n === "$ref")
      return 1 / 0;
    if (t++, !TD.has(n) && (typeof e[n] == "object" && (0, wD.eachItem)(e[n], (r) => t += v_(r)), t === 1 / 0))
      return 1 / 0;
  }
  return t;
}
function __(e, t = "", n) {
  n !== !1 && (t = gs(t));
  const r = e.parse(t);
  return w_(e, r);
}
Jt.getFullPath = __;
function w_(e, t) {
  return e.serialize(t).split("#")[0] + "#";
}
Jt._getFullPath = w_;
const OD = /#\/?$/;
function gs(e) {
  return e ? e.replace(OD, "") : "";
}
Jt.normalizeId = gs;
function ID(e, t, n) {
  return n = gs(n), e.resolve(t, n);
}
Jt.resolveUrl = ID;
const RD = /^[a-z_][-a-z0-9._]*$/i;
function AD(e, t) {
  if (typeof e == "boolean")
    return {};
  const { schemaId: n, uriResolver: r } = this.opts, i = gs(e[n] || t), s = { "": i }, o = __(r, i, !1), a = {}, l = /* @__PURE__ */ new Set();
  return SD(e, { allKeys: !0 }, (f, d, p, h) => {
    if (h === void 0)
      return;
    const m = o + d;
    let v = s[h];
    typeof f[n] == "string" && (v = b.call(this, f[n])), E.call(this, f.$anchor), E.call(this, f.$dynamicAnchor), s[d] = v;
    function b(y) {
      const D = this.opts.uriResolver.resolve;
      if (y = gs(v ? D(v, y) : y), l.has(y))
        throw u(y);
      l.add(y);
      let F = this.refs[y];
      return typeof F == "string" && (F = this.refs[F]), typeof F == "object" ? c(f, F.schema, y) : y !== gs(m) && (y[0] === "#" ? (c(f, a[y], y), a[y] = f) : this.refs[y] = m), y;
    }
    function E(y) {
      if (typeof y == "string") {
        if (!RD.test(y))
          throw new Error(`invalid anchor "${y}"`);
        b.call(this, `#${y}`);
      }
    }
  }), a;
  function c(f, d, p) {
    if (d !== void 0 && !ED(f, d))
      throw u(p);
  }
  function u(f) {
    return new Error(`reference "${f}" resolves to more than one schema`);
  }
}
Jt.getSchemaRefs = AD;
Object.defineProperty(Kn, "__esModule", { value: !0 });
Kn.getData = Kn.KeywordCxt = Kn.validateFunctionCode = void 0;
const E_ = Ss, Yy = Bt, Tp = kr, Ul = Bt, xD = Lu, Po = fr, _f = si, je = Xe, He = Tr, DD = Jt, Lr = xe, po = ba;
function PD(e) {
  if ($_(e) && (N_(e), T_(e))) {
    jD(e);
    return;
  }
  S_(e, () => (0, E_.topBoolOrEmptySchema)(e));
}
Kn.validateFunctionCode = PD;
function S_({ gen: e, validateName: t, schema: n, schemaEnv: r, opts: i }, s) {
  i.code.es5 ? e.func(t, (0, je._)`${He.default.data}, ${He.default.valCxt}`, r.$async, () => {
    e.code((0, je._)`"use strict"; ${Xy(n, i)}`), LD(e, i), e.code(s);
  }) : e.func(t, (0, je._)`${He.default.data}, ${kD(i)}`, r.$async, () => e.code(Xy(n, i)).code(s));
}
function kD(e) {
  return (0, je._)`{${He.default.instancePath}="", ${He.default.parentData}, ${He.default.parentDataProperty}, ${He.default.rootData}=${He.default.data}${e.dynamicRef ? (0, je._)`, ${He.default.dynamicAnchors}={}` : je.nil}}={}`;
}
function LD(e, t) {
  e.if(He.default.valCxt, () => {
    e.var(He.default.instancePath, (0, je._)`${He.default.valCxt}.${He.default.instancePath}`), e.var(He.default.parentData, (0, je._)`${He.default.valCxt}.${He.default.parentData}`), e.var(He.default.parentDataProperty, (0, je._)`${He.default.valCxt}.${He.default.parentDataProperty}`), e.var(He.default.rootData, (0, je._)`${He.default.valCxt}.${He.default.rootData}`), t.dynamicRef && e.var(He.default.dynamicAnchors, (0, je._)`${He.default.valCxt}.${He.default.dynamicAnchors}`);
  }, () => {
    e.var(He.default.instancePath, (0, je._)`""`), e.var(He.default.parentData, (0, je._)`undefined`), e.var(He.default.parentDataProperty, (0, je._)`undefined`), e.var(He.default.rootData, He.default.data), t.dynamicRef && e.var(He.default.dynamicAnchors, (0, je._)`{}`);
  });
}
function jD(e) {
  const { schema: t, opts: n, gen: r } = e;
  S_(e, () => {
    n.$comment && t.$comment && I_(e), VD(e), r.let(He.default.vErrors, null), r.let(He.default.errors, 0), n.unevaluated && CD(e), O_(e), zD(e);
  });
}
function CD(e) {
  const { gen: t, validateName: n } = e;
  e.evaluated = t.const("evaluated", (0, je._)`${n}.evaluated`), t.if((0, je._)`${e.evaluated}.dynamicProps`, () => t.assign((0, je._)`${e.evaluated}.props`, (0, je._)`undefined`)), t.if((0, je._)`${e.evaluated}.dynamicItems`, () => t.assign((0, je._)`${e.evaluated}.items`, (0, je._)`undefined`));
}
function Xy(e, t) {
  const n = typeof e == "object" && e[t.schemaId];
  return n && (t.code.source || t.code.process) ? (0, je._)`/*# sourceURL=${n} */` : je.nil;
}
function MD(e, t) {
  if ($_(e) && (N_(e), T_(e))) {
    FD(e, t);
    return;
  }
  (0, E_.boolOrEmptySchema)(e, t);
}
function T_({ schema: e, self: t }) {
  if (typeof e == "boolean")
    return !e;
  for (const n in e)
    if (t.RULES.all[n])
      return !0;
  return !1;
}
function $_(e) {
  return typeof e.schema != "boolean";
}
function FD(e, t) {
  const { schema: n, gen: r, opts: i } = e;
  i.$comment && n.$comment && I_(e), BD(e), GD(e);
  const s = r.const("_errs", He.default.errors);
  O_(e, s), r.var(t, (0, je._)`${s} === ${He.default.errors}`);
}
function N_(e) {
  (0, Lr.checkUnknownRules)(e), UD(e);
}
function O_(e, t) {
  if (e.opts.jtd)
    return Zy(e, [], !1, t);
  const n = (0, Yy.getSchemaTypes)(e.schema), r = (0, Yy.coerceAndCheckDataType)(e, n);
  Zy(e, n, !r, t);
}
function UD(e) {
  const { schema: t, errSchemaPath: n, opts: r, self: i } = e;
  t.$ref && r.ignoreKeywordsWithRef && (0, Lr.schemaHasRulesButRef)(t, i.RULES) && i.logger.warn(`$ref: keywords ignored in schema at path "${n}"`);
}
function VD(e) {
  const { schema: t, opts: n } = e;
  t.default !== void 0 && n.useDefaults && n.strictSchema && (0, Lr.checkStrictMode)(e, "default is ignored in the schema root");
}
function BD(e) {
  const t = e.schema[e.opts.schemaId];
  t && (e.baseId = (0, DD.resolveUrl)(e.opts.uriResolver, e.baseId, t));
}
function GD(e) {
  if (e.schema.$async && !e.schemaEnv.$async)
    throw new Error("async schema in sync schema");
}
function I_({ gen: e, schemaEnv: t, schema: n, errSchemaPath: r, opts: i }) {
  const s = n.$comment;
  if (i.$comment === !0)
    e.code((0, je._)`${He.default.self}.logger.log(${s})`);
  else if (typeof i.$comment == "function") {
    const o = (0, je.str)`${r}/$comment`, a = e.scopeValue("root", { ref: t.root });
    e.code((0, je._)`${He.default.self}.opts.$comment(${s}, ${o}, ${a}.schema)`);
  }
}
function zD(e) {
  const { gen: t, schemaEnv: n, validateName: r, ValidationError: i, opts: s } = e;
  n.$async ? t.if((0, je._)`${He.default.errors} === 0`, () => t.return(He.default.data), () => t.throw((0, je._)`new ${i}(${He.default.vErrors})`)) : (t.assign((0, je._)`${r}.errors`, He.default.vErrors), s.unevaluated && qD(e), t.return((0, je._)`${He.default.errors} === 0`));
}
function qD({ gen: e, evaluated: t, props: n, items: r }) {
  n instanceof je.Name && e.assign((0, je._)`${t}.props`, n), r instanceof je.Name && e.assign((0, je._)`${t}.items`, r);
}
function Zy(e, t, n, r) {
  const { gen: i, schema: s, data: o, allErrors: a, opts: l, self: c } = e, { RULES: u } = c;
  if (s.$ref && (l.ignoreKeywordsWithRef || !(0, Lr.schemaHasRulesButRef)(s, u))) {
    i.block(() => x_(e, "$ref", u.all.$ref.definition));
    return;
  }
  l.jtd || HD(e, t), i.block(() => {
    for (const d of u.rules)
      f(d);
    f(u.post);
  });
  function f(d) {
    (0, Tp.shouldUseGroup)(s, d) && (d.type ? (i.if((0, Ul.checkDataType)(d.type, o, l.strictNumbers)), eg(e, d), t.length === 1 && t[0] === d.type && n && (i.else(), (0, Ul.reportTypeError)(e)), i.endIf()) : eg(e, d), a || i.if((0, je._)`${He.default.errors} === ${r || 0}`));
  }
}
function eg(e, t) {
  const { gen: n, schema: r, opts: { useDefaults: i } } = e;
  i && (0, xD.assignDefaults)(e, t.type), n.block(() => {
    for (const s of t.rules)
      (0, Tp.shouldUseRule)(r, s) && x_(e, s.keyword, s.definition, t.type);
  });
}
function HD(e, t) {
  e.schemaEnv.meta || !e.opts.strictTypes || (WD(e, t), e.opts.allowUnionTypes || QD(e, t), JD(e, e.dataTypes));
}
function WD(e, t) {
  if (t.length) {
    if (!e.dataTypes.length) {
      e.dataTypes = t;
      return;
    }
    t.forEach((n) => {
      R_(e.dataTypes, n) || $p(e, `type "${n}" not allowed by context "${e.dataTypes.join(",")}"`);
    }), YD(e, t);
  }
}
function QD(e, t) {
  t.length > 1 && !(t.length === 2 && t.includes("null")) && $p(e, "use allowUnionTypes to allow union type keyword");
}
function JD(e, t) {
  const n = e.self.RULES.all;
  for (const r in n) {
    const i = n[r];
    if (typeof i == "object" && (0, Tp.shouldUseRule)(e.schema, i)) {
      const { type: s } = i.definition;
      s.length && !s.some((o) => KD(t, o)) && $p(e, `missing type "${s.join(",")}" for keyword "${r}"`);
    }
  }
}
function KD(e, t) {
  return e.includes(t) || t === "number" && e.includes("integer");
}
function R_(e, t) {
  return e.includes(t) || t === "integer" && e.includes("number");
}
function YD(e, t) {
  const n = [];
  for (const r of e.dataTypes)
    R_(t, r) ? n.push(r) : t.includes("integer") && r === "number" && n.push("integer");
  e.dataTypes = n;
}
function $p(e, t) {
  const n = e.schemaEnv.baseId + e.errSchemaPath;
  t += ` at "${n}" (strictTypes)`, (0, Lr.checkStrictMode)(e, t, e.opts.strictTypes);
}
class A_ {
  constructor(t, n, r) {
    if ((0, Po.validateKeywordUsage)(t, n, r), this.gen = t.gen, this.allErrors = t.allErrors, this.keyword = r, this.data = t.data, this.schema = t.schema[r], this.$data = n.$data && t.opts.$data && this.schema && this.schema.$data, this.schemaValue = (0, Lr.schemaRefOrVal)(t, this.schema, r, this.$data), this.schemaType = n.schemaType, this.parentSchema = t.schema, this.params = {}, this.it = t, this.def = n, this.$data)
      this.schemaCode = t.gen.const("vSchema", D_(this.$data, t));
    else if (this.schemaCode = this.schemaValue, !(0, Po.validSchemaType)(this.schema, n.schemaType, n.allowUndefined))
      throw new Error(`${r} value must be ${JSON.stringify(n.schemaType)}`);
    ("code" in n ? n.trackErrors : n.errors !== !1) && (this.errsCount = t.gen.const("_errs", He.default.errors));
  }
  result(t, n, r) {
    this.failResult((0, je.not)(t), n, r);
  }
  failResult(t, n, r) {
    this.gen.if(t), r ? r() : this.error(), n ? (this.gen.else(), n(), this.allErrors && this.gen.endIf()) : this.allErrors ? this.gen.endIf() : this.gen.else();
  }
  pass(t, n) {
    this.failResult((0, je.not)(t), void 0, n);
  }
  fail(t) {
    if (t === void 0) {
      this.error(), this.allErrors || this.gen.if(!1);
      return;
    }
    this.gen.if(t), this.error(), this.allErrors ? this.gen.endIf() : this.gen.else();
  }
  fail$data(t) {
    if (!this.$data)
      return this.fail(t);
    const { schemaCode: n } = this;
    this.fail((0, je._)`${n} !== undefined && (${(0, je.or)(this.invalid$data(), t)})`);
  }
  error(t, n, r) {
    if (n) {
      this.setParams(n), this._error(t, r), this.setParams({});
      return;
    }
    this._error(t, r);
  }
  _error(t, n) {
    (t ? po.reportExtraError : po.reportError)(this, this.def.error, n);
  }
  $dataError() {
    (0, po.reportError)(this, this.def.$dataError || po.keyword$DataError);
  }
  reset() {
    if (this.errsCount === void 0)
      throw new Error('add "trackErrors" to keyword definition');
    (0, po.resetErrorsCount)(this.gen, this.errsCount);
  }
  ok(t) {
    this.allErrors || this.gen.if(t);
  }
  setParams(t, n) {
    n ? Object.assign(this.params, t) : this.params = t;
  }
  block$data(t, n, r = je.nil) {
    this.gen.block(() => {
      this.check$data(t, r), n();
    });
  }
  check$data(t = je.nil, n = je.nil) {
    if (!this.$data)
      return;
    const { gen: r, schemaCode: i, schemaType: s, def: o } = this;
    r.if((0, je.or)((0, je._)`${i} === undefined`, n)), t !== je.nil && r.assign(t, !0), (s.length || o.validateSchema) && (r.elseIf(this.invalid$data()), this.$dataError(), t !== je.nil && r.assign(t, !1)), r.else();
  }
  invalid$data() {
    const { gen: t, schemaCode: n, schemaType: r, def: i, it: s } = this;
    return (0, je.or)(o(), a());
    function o() {
      if (r.length) {
        if (!(n instanceof je.Name))
          throw new Error("ajv implementation error");
        const l = Array.isArray(r) ? r : [r];
        return (0, je._)`${(0, Ul.checkDataTypes)(l, n, s.opts.strictNumbers, Ul.DataType.Wrong)}`;
      }
      return je.nil;
    }
    function a() {
      if (i.validateSchema) {
        const l = t.scopeValue("validate$data", { ref: i.validateSchema });
        return (0, je._)`!${l}(${n})`;
      }
      return je.nil;
    }
  }
  subschema(t, n) {
    const r = (0, _f.getSubschema)(this.it, t);
    (0, _f.extendSubschemaData)(r, this.it, t), (0, _f.extendSubschemaMode)(r, t);
    const i = { ...this.it, ...r, items: void 0, props: void 0 };
    return MD(i, n), i;
  }
  mergeEvaluated(t, n) {
    const { it: r, gen: i } = this;
    r.opts.unevaluated && (r.props !== !0 && t.props !== void 0 && (r.props = Lr.mergeEvaluated.props(i, t.props, r.props, n)), r.items !== !0 && t.items !== void 0 && (r.items = Lr.mergeEvaluated.items(i, t.items, r.items, n)));
  }
  mergeValidEvaluated(t, n) {
    const { it: r, gen: i } = this;
    if (r.opts.unevaluated && (r.props !== !0 || r.items !== !0))
      return i.if(n, () => this.mergeEvaluated(t, je.Name)), !0;
  }
}
Kn.KeywordCxt = A_;
function x_(e, t, n, r) {
  const i = new A_(e, n, t);
  "code" in n ? n.code(i, r) : i.$data && n.validate ? (0, Po.funcKeywordCode)(i, n) : "macro" in n ? (0, Po.macroKeywordCode)(i, n) : (n.compile || n.validate) && (0, Po.funcKeywordCode)(i, n);
}
const XD = /^\/(?:[^~]|~0|~1)*$/, ZD = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
function D_(e, { dataLevel: t, dataNames: n, dataPathArr: r }) {
  let i, s;
  if (e === "")
    return He.default.rootData;
  if (e[0] === "/") {
    if (!XD.test(e))
      throw new Error(`Invalid JSON-pointer: ${e}`);
    i = e, s = He.default.rootData;
  } else {
    const c = ZD.exec(e);
    if (!c)
      throw new Error(`Invalid JSON-pointer: ${e}`);
    const u = +c[1];
    if (i = c[2], i === "#") {
      if (u >= t)
        throw new Error(l("property/index", u));
      return r[t - u];
    }
    if (u > t)
      throw new Error(l("data", u));
    if (s = n[t - u], !i)
      return s;
  }
  let o = s;
  const a = i.split("/");
  for (const c of a)
    c && (s = (0, je._)`${s}${(0, je.getProperty)((0, Lr.unescapeJsonPointer)(c))}`, o = (0, je._)`${o} && ${s}`);
  return o;
  function l(c, u) {
    return `Cannot access ${c} ${u} levels up, current level is ${t}`;
  }
}
Kn.getData = D_;
var va = {};
Object.defineProperty(va, "__esModule", { value: !0 });
class eP extends Error {
  constructor(t) {
    super("validation failed"), this.errors = t, this.ajv = this.validation = !0;
  }
}
va.default = eP;
var js = {};
Object.defineProperty(js, "__esModule", { value: !0 });
const wf = Jt;
class tP extends Error {
  constructor(t, n, r, i) {
    super(i || `can't resolve reference ${r} from id ${n}`), this.missingRef = (0, wf.resolveUrl)(t, n, r), this.missingSchema = (0, wf.normalizeId)((0, wf.getFullPath)(t, this.missingRef));
  }
}
js.default = tP;
var cn = {};
Object.defineProperty(cn, "__esModule", { value: !0 });
cn.resolveSchema = cn.getCompilingSchema = cn.resolveRef = cn.compileSchema = cn.SchemaEnv = void 0;
const Bn = Xe, nP = va, Ni = Tr, Qn = Jt, tg = xe, rP = Kn;
class ju {
  constructor(t) {
    var n;
    this.refs = {}, this.dynamicAnchors = {};
    let r;
    typeof t.schema == "object" && (r = t.schema), this.schema = t.schema, this.schemaId = t.schemaId, this.root = t.root || this, this.baseId = (n = t.baseId) !== null && n !== void 0 ? n : (0, Qn.normalizeId)(r?.[t.schemaId || "$id"]), this.schemaPath = t.schemaPath, this.localRefs = t.localRefs, this.meta = t.meta, this.$async = r?.$async, this.refs = {};
  }
}
cn.SchemaEnv = ju;
function Np(e) {
  const t = P_.call(this, e);
  if (t)
    return t;
  const n = (0, Qn.getFullPath)(this.opts.uriResolver, e.root.baseId), { es5: r, lines: i } = this.opts.code, { ownProperties: s } = this.opts, o = new Bn.CodeGen(this.scope, { es5: r, lines: i, ownProperties: s });
  let a;
  e.$async && (a = o.scopeValue("Error", {
    ref: nP.default,
    code: (0, Bn._)`require("ajv/dist/runtime/validation_error").default`
  }));
  const l = o.scopeName("validate");
  e.validateName = l;
  const c = {
    gen: o,
    allErrors: this.opts.allErrors,
    data: Ni.default.data,
    parentData: Ni.default.parentData,
    parentDataProperty: Ni.default.parentDataProperty,
    dataNames: [Ni.default.data],
    dataPathArr: [Bn.nil],
    // TODO can its length be used as dataLevel if nil is removed?
    dataLevel: 0,
    dataTypes: [],
    definedProperties: /* @__PURE__ */ new Set(),
    topSchemaRef: o.scopeValue("schema", this.opts.code.source === !0 ? { ref: e.schema, code: (0, Bn.stringify)(e.schema) } : { ref: e.schema }),
    validateName: l,
    ValidationError: a,
    schema: e.schema,
    schemaEnv: e,
    rootId: n,
    baseId: e.baseId || n,
    schemaPath: Bn.nil,
    errSchemaPath: e.schemaPath || (this.opts.jtd ? "" : "#"),
    errorPath: (0, Bn._)`""`,
    opts: this.opts,
    self: this
  };
  let u;
  try {
    this._compilations.add(e), (0, rP.validateFunctionCode)(c), o.optimize(this.opts.code.optimize);
    const f = o.toString();
    u = `${o.scopeRefs(Ni.default.scope)}return ${f}`, this.opts.code.process && (u = this.opts.code.process(u, e));
    const p = new Function(`${Ni.default.self}`, `${Ni.default.scope}`, u)(this, this.scope.get());
    if (this.scope.value(l, { ref: p }), p.errors = null, p.schema = e.schema, p.schemaEnv = e, e.$async && (p.$async = !0), this.opts.code.source === !0 && (p.source = { validateName: l, validateCode: f, scopeValues: o._values }), this.opts.unevaluated) {
      const { props: h, items: m } = c;
      p.evaluated = {
        props: h instanceof Bn.Name ? void 0 : h,
        items: m instanceof Bn.Name ? void 0 : m,
        dynamicProps: h instanceof Bn.Name,
        dynamicItems: m instanceof Bn.Name
      }, p.source && (p.source.evaluated = (0, Bn.stringify)(p.evaluated));
    }
    return e.validate = p, e;
  } catch (f) {
    throw delete e.validate, delete e.validateName, u && this.logger.error("Error compiling schema, function code:", u), f;
  } finally {
    this._compilations.delete(e);
  }
}
cn.compileSchema = Np;
function iP(e, t, n) {
  var r;
  n = (0, Qn.resolveUrl)(this.opts.uriResolver, t, n);
  const i = e.refs[n];
  if (i)
    return i;
  let s = aP.call(this, e, n);
  if (s === void 0) {
    const o = (r = e.localRefs) === null || r === void 0 ? void 0 : r[n], { schemaId: a } = this.opts;
    o && (s = new ju({ schema: o, schemaId: a, root: e, baseId: t }));
  }
  if (s !== void 0)
    return e.refs[n] = sP.call(this, s);
}
cn.resolveRef = iP;
function sP(e) {
  return (0, Qn.inlineRef)(e.schema, this.opts.inlineRefs) ? e.schema : e.validate ? e : Np.call(this, e);
}
function P_(e) {
  for (const t of this._compilations)
    if (oP(t, e))
      return t;
}
cn.getCompilingSchema = P_;
function oP(e, t) {
  return e.schema === t.schema && e.root === t.root && e.baseId === t.baseId;
}
function aP(e, t) {
  let n;
  for (; typeof (n = this.refs[t]) == "string"; )
    t = n;
  return n || this.schemas[t] || Cu.call(this, e, t);
}
function Cu(e, t) {
  const n = this.opts.uriResolver.parse(t), r = (0, Qn._getFullPath)(this.opts.uriResolver, n);
  let i = (0, Qn.getFullPath)(this.opts.uriResolver, e.baseId, void 0);
  if (Object.keys(e.schema).length > 0 && r === i)
    return Ef.call(this, n, e);
  const s = (0, Qn.normalizeId)(r), o = this.refs[s] || this.schemas[s];
  if (typeof o == "string") {
    const a = Cu.call(this, e, o);
    return typeof a?.schema != "object" ? void 0 : Ef.call(this, n, a);
  }
  if (typeof o?.schema == "object") {
    if (o.validate || Np.call(this, o), s === (0, Qn.normalizeId)(t)) {
      const { schema: a } = o, { schemaId: l } = this.opts, c = a[l];
      return c && (i = (0, Qn.resolveUrl)(this.opts.uriResolver, i, c)), new ju({ schema: a, schemaId: l, root: e, baseId: i });
    }
    return Ef.call(this, n, o);
  }
}
cn.resolveSchema = Cu;
const lP = /* @__PURE__ */ new Set([
  "properties",
  "patternProperties",
  "enum",
  "dependencies",
  "definitions"
]);
function Ef(e, { baseId: t, schema: n, root: r }) {
  var i;
  if (((i = e.fragment) === null || i === void 0 ? void 0 : i[0]) !== "/")
    return;
  for (const a of e.fragment.slice(1).split("/")) {
    if (typeof n == "boolean")
      return;
    const l = n[(0, tg.unescapeFragment)(a)];
    if (l === void 0)
      return;
    n = l;
    const c = typeof n == "object" && n[this.opts.schemaId];
    !lP.has(a) && c && (t = (0, Qn.resolveUrl)(this.opts.uriResolver, t, c));
  }
  let s;
  if (typeof n != "boolean" && n.$ref && !(0, tg.schemaHasRulesButRef)(n, this.RULES)) {
    const a = (0, Qn.resolveUrl)(this.opts.uriResolver, t, n.$ref);
    s = Cu.call(this, r, a);
  }
  const { schemaId: o } = this.opts;
  if (s = s || new ju({ schema: n, schemaId: o, root: r, baseId: t }), s.schema !== s.root.schema)
    return s;
}
const uP = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#", cP = "Meta-schema for $data reference (JSON AnySchema extension proposal)", fP = "object", dP = [
  "$data"
], pP = {
  $data: {
    type: "string",
    anyOf: [
      {
        format: "relative-json-pointer"
      },
      {
        format: "json-pointer"
      }
    ]
  }
}, hP = !1, mP = {
  $id: uP,
  description: cP,
  type: fP,
  required: dP,
  properties: pP,
  additionalProperties: hP
};
var Op = {}, Mu = { exports: {} };
const yP = {
  0: 0,
  1: 1,
  2: 2,
  3: 3,
  4: 4,
  5: 5,
  6: 6,
  7: 7,
  8: 8,
  9: 9,
  a: 10,
  A: 10,
  b: 11,
  B: 11,
  c: 12,
  C: 12,
  d: 13,
  D: 13,
  e: 14,
  E: 14,
  f: 15,
  F: 15
};
var gP = {
  HEX: yP
};
const { HEX: bP } = gP;
function k_(e) {
  if (j_(e, ".") < 3)
    return { host: e, isIPV4: !1 };
  const t = e.match(/^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/u) || [], [n] = t;
  return n ? { host: _P(n, "."), isIPV4: !0 } : { host: e, isIPV4: !1 };
}
function ld(e, t = !1) {
  let n = "", r = !0;
  for (const i of e) {
    if (bP[i] === void 0)
      return;
    i !== "0" && r === !0 && (r = !1), r || (n += i);
  }
  return t && n.length === 0 && (n = "0"), n;
}
function vP(e) {
  let t = 0;
  const n = { error: !1, address: "", zone: "" }, r = [], i = [];
  let s = !1, o = !1, a = !1;
  function l() {
    if (i.length) {
      if (s === !1) {
        const c = ld(i);
        if (c !== void 0)
          r.push(c);
        else
          return n.error = !0, !1;
      }
      i.length = 0;
    }
    return !0;
  }
  for (let c = 0; c < e.length; c++) {
    const u = e[c];
    if (!(u === "[" || u === "]"))
      if (u === ":") {
        if (o === !0 && (a = !0), !l())
          break;
        if (t++, r.push(":"), t > 7) {
          n.error = !0;
          break;
        }
        c - 1 >= 0 && e[c - 1] === ":" && (o = !0);
        continue;
      } else if (u === "%") {
        if (!l())
          break;
        s = !0;
      } else {
        i.push(u);
        continue;
      }
  }
  return i.length && (s ? n.zone = i.join("") : a ? r.push(i.join("")) : r.push(ld(i))), n.address = r.join(""), n;
}
function L_(e, t = {}) {
  if (j_(e, ":") < 2)
    return { host: e, isIPV6: !1 };
  const n = vP(e);
  if (n.error)
    return { host: e, isIPV6: !1 };
  {
    let r = n.address, i = n.address;
    return n.zone && (r += "%" + n.zone, i += "%25" + n.zone), { host: r, escapedHost: i, isIPV6: !0 };
  }
}
function _P(e, t) {
  let n = "", r = !0;
  const i = e.length;
  for (let s = 0; s < i; s++) {
    const o = e[s];
    o === "0" && r ? (s + 1 <= i && e[s + 1] === t || s + 1 === i) && (n += o, r = !1) : (o === t ? r = !0 : r = !1, n += o);
  }
  return n;
}
function j_(e, t) {
  let n = 0;
  for (let r = 0; r < e.length; r++)
    e[r] === t && n++;
  return n;
}
const ng = /^\.\.?\//u, rg = /^\/\.(?:\/|$)/u, ig = /^\/\.\.(?:\/|$)/u, wP = /^\/?(?:.|\n)*?(?=\/|$)/u;
function EP(e) {
  const t = [];
  for (; e.length; )
    if (e.match(ng))
      e = e.replace(ng, "");
    else if (e.match(rg))
      e = e.replace(rg, "/");
    else if (e.match(ig))
      e = e.replace(ig, "/"), t.pop();
    else if (e === "." || e === "..")
      e = "";
    else {
      const n = e.match(wP);
      if (n) {
        const r = n[0];
        e = e.slice(r.length), t.push(r);
      } else
        throw new Error("Unexpected dot segment condition");
    }
  return t.join("");
}
function SP(e, t) {
  const n = t !== !0 ? escape : unescape;
  return e.scheme !== void 0 && (e.scheme = n(e.scheme)), e.userinfo !== void 0 && (e.userinfo = n(e.userinfo)), e.host !== void 0 && (e.host = n(e.host)), e.path !== void 0 && (e.path = n(e.path)), e.query !== void 0 && (e.query = n(e.query)), e.fragment !== void 0 && (e.fragment = n(e.fragment)), e;
}
function TP(e, t) {
  const n = [];
  if (e.userinfo !== void 0 && (n.push(e.userinfo), n.push("@")), e.host !== void 0) {
    let r = unescape(e.host);
    const i = k_(r);
    if (i.isIPV4)
      r = i.host;
    else {
      const s = L_(i.host, { isIPV4: !1 });
      s.isIPV6 === !0 ? r = `[${s.escapedHost}]` : r = e.host;
    }
    n.push(r);
  }
  return (typeof e.port == "number" || typeof e.port == "string") && (n.push(":"), n.push(String(e.port))), n.length ? n.join("") : void 0;
}
var $P = {
  recomposeAuthority: TP,
  normalizeComponentEncoding: SP,
  removeDotSegments: EP,
  normalizeIPv4: k_,
  normalizeIPv6: L_,
  stringArrayToHexStripped: ld
};
const NP = /^[\da-f]{8}\b-[\da-f]{4}\b-[\da-f]{4}\b-[\da-f]{4}\b-[\da-f]{12}$/iu, OP = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
function C_(e) {
  return typeof e.secure == "boolean" ? e.secure : String(e.scheme).toLowerCase() === "wss";
}
function M_(e) {
  return e.host || (e.error = e.error || "HTTP URIs must have a host."), e;
}
function F_(e) {
  const t = String(e.scheme).toLowerCase() === "https";
  return (e.port === (t ? 443 : 80) || e.port === "") && (e.port = void 0), e.path || (e.path = "/"), e;
}
function IP(e) {
  return e.secure = C_(e), e.resourceName = (e.path || "/") + (e.query ? "?" + e.query : ""), e.path = void 0, e.query = void 0, e;
}
function RP(e) {
  if ((e.port === (C_(e) ? 443 : 80) || e.port === "") && (e.port = void 0), typeof e.secure == "boolean" && (e.scheme = e.secure ? "wss" : "ws", e.secure = void 0), e.resourceName) {
    const [t, n] = e.resourceName.split("?");
    e.path = t && t !== "/" ? t : void 0, e.query = n, e.resourceName = void 0;
  }
  return e.fragment = void 0, e;
}
function AP(e, t) {
  if (!e.path)
    return e.error = "URN can not be parsed", e;
  const n = e.path.match(OP);
  if (n) {
    const r = t.scheme || e.scheme || "urn";
    e.nid = n[1].toLowerCase(), e.nss = n[2];
    const i = `${r}:${t.nid || e.nid}`, s = Ip[i];
    e.path = void 0, s && (e = s.parse(e, t));
  } else
    e.error = e.error || "URN can not be parsed.";
  return e;
}
function xP(e, t) {
  const n = t.scheme || e.scheme || "urn", r = e.nid.toLowerCase(), i = `${n}:${t.nid || r}`, s = Ip[i];
  s && (e = s.serialize(e, t));
  const o = e, a = e.nss;
  return o.path = `${r || t.nid}:${a}`, t.skipEscape = !0, o;
}
function DP(e, t) {
  const n = e;
  return n.uuid = n.nss, n.nss = void 0, !t.tolerant && (!n.uuid || !NP.test(n.uuid)) && (n.error = n.error || "UUID is not valid."), n;
}
function PP(e) {
  const t = e;
  return t.nss = (e.uuid || "").toLowerCase(), t;
}
const U_ = {
  scheme: "http",
  domainHost: !0,
  parse: M_,
  serialize: F_
}, kP = {
  scheme: "https",
  domainHost: U_.domainHost,
  parse: M_,
  serialize: F_
}, bl = {
  scheme: "ws",
  domainHost: !0,
  parse: IP,
  serialize: RP
}, LP = {
  scheme: "wss",
  domainHost: bl.domainHost,
  parse: bl.parse,
  serialize: bl.serialize
}, jP = {
  scheme: "urn",
  parse: AP,
  serialize: xP,
  skipNormalize: !0
}, CP = {
  scheme: "urn:uuid",
  parse: DP,
  serialize: PP,
  skipNormalize: !0
}, Ip = {
  http: U_,
  https: kP,
  ws: bl,
  wss: LP,
  urn: jP,
  "urn:uuid": CP
};
var MP = Ip;
const { normalizeIPv6: FP, normalizeIPv4: UP, removeDotSegments: $o, recomposeAuthority: VP, normalizeComponentEncoding: qa } = $P, Rp = MP;
function BP(e, t) {
  return typeof e == "string" ? e = dr(Vr(e, t), t) : typeof e == "object" && (e = Vr(dr(e, t), t)), e;
}
function GP(e, t, n) {
  const r = Object.assign({ scheme: "null" }, n), i = V_(Vr(e, r), Vr(t, r), r, !0);
  return dr(i, { ...r, skipEscape: !0 });
}
function V_(e, t, n, r) {
  const i = {};
  return r || (e = Vr(dr(e, n), n), t = Vr(dr(t, n), n)), n = n || {}, !n.tolerant && t.scheme ? (i.scheme = t.scheme, i.userinfo = t.userinfo, i.host = t.host, i.port = t.port, i.path = $o(t.path || ""), i.query = t.query) : (t.userinfo !== void 0 || t.host !== void 0 || t.port !== void 0 ? (i.userinfo = t.userinfo, i.host = t.host, i.port = t.port, i.path = $o(t.path || ""), i.query = t.query) : (t.path ? (t.path.charAt(0) === "/" ? i.path = $o(t.path) : ((e.userinfo !== void 0 || e.host !== void 0 || e.port !== void 0) && !e.path ? i.path = "/" + t.path : e.path ? i.path = e.path.slice(0, e.path.lastIndexOf("/") + 1) + t.path : i.path = t.path, i.path = $o(i.path)), i.query = t.query) : (i.path = e.path, t.query !== void 0 ? i.query = t.query : i.query = e.query), i.userinfo = e.userinfo, i.host = e.host, i.port = e.port), i.scheme = e.scheme), i.fragment = t.fragment, i;
}
function zP(e, t, n) {
  return typeof e == "string" ? (e = unescape(e), e = dr(qa(Vr(e, n), !0), { ...n, skipEscape: !0 })) : typeof e == "object" && (e = dr(qa(e, !0), { ...n, skipEscape: !0 })), typeof t == "string" ? (t = unescape(t), t = dr(qa(Vr(t, n), !0), { ...n, skipEscape: !0 })) : typeof t == "object" && (t = dr(qa(t, !0), { ...n, skipEscape: !0 })), e.toLowerCase() === t.toLowerCase();
}
function dr(e, t) {
  const n = {
    host: e.host,
    scheme: e.scheme,
    userinfo: e.userinfo,
    port: e.port,
    path: e.path,
    query: e.query,
    nid: e.nid,
    nss: e.nss,
    uuid: e.uuid,
    fragment: e.fragment,
    reference: e.reference,
    resourceName: e.resourceName,
    secure: e.secure,
    error: ""
  }, r = Object.assign({}, t), i = [], s = Rp[(r.scheme || n.scheme || "").toLowerCase()];
  s && s.serialize && s.serialize(n, r), n.path !== void 0 && (r.skipEscape ? n.path = unescape(n.path) : (n.path = escape(n.path), n.scheme !== void 0 && (n.path = n.path.split("%3A").join(":")))), r.reference !== "suffix" && n.scheme && (i.push(n.scheme), i.push(":"));
  const o = VP(n, r);
  if (o !== void 0 && (r.reference !== "suffix" && i.push("//"), i.push(o), n.path && n.path.charAt(0) !== "/" && i.push("/")), n.path !== void 0) {
    let a = n.path;
    !r.absolutePath && (!s || !s.absolutePath) && (a = $o(a)), o === void 0 && (a = a.replace(/^\/\//u, "/%2F")), i.push(a);
  }
  return n.query !== void 0 && (i.push("?"), i.push(n.query)), n.fragment !== void 0 && (i.push("#"), i.push(n.fragment)), i.join("");
}
const qP = Array.from({ length: 127 }, (e, t) => /[^!"$&'()*+,\-.;=_`a-z{}~]/u.test(String.fromCharCode(t)));
function HP(e) {
  let t = 0;
  for (let n = 0, r = e.length; n < r; ++n)
    if (t = e.charCodeAt(n), t > 126 || qP[t])
      return !0;
  return !1;
}
const WP = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
function Vr(e, t) {
  const n = Object.assign({}, t), r = {
    scheme: void 0,
    userinfo: void 0,
    host: "",
    port: void 0,
    path: "",
    query: void 0,
    fragment: void 0
  }, i = e.indexOf("%") !== -1;
  let s = !1;
  n.reference === "suffix" && (e = (n.scheme ? n.scheme + ":" : "") + "//" + e);
  const o = e.match(WP);
  if (o) {
    if (r.scheme = o[1], r.userinfo = o[3], r.host = o[4], r.port = parseInt(o[5], 10), r.path = o[6] || "", r.query = o[7], r.fragment = o[8], isNaN(r.port) && (r.port = o[5]), r.host) {
      const l = UP(r.host);
      if (l.isIPV4 === !1) {
        const c = FP(l.host, { isIPV4: !1 });
        r.host = c.host.toLowerCase(), s = c.isIPV6;
      } else
        r.host = l.host, s = !0;
    }
    r.scheme === void 0 && r.userinfo === void 0 && r.host === void 0 && r.port === void 0 && !r.path && r.query === void 0 ? r.reference = "same-document" : r.scheme === void 0 ? r.reference = "relative" : r.fragment === void 0 ? r.reference = "absolute" : r.reference = "uri", n.reference && n.reference !== "suffix" && n.reference !== r.reference && (r.error = r.error || "URI is not a " + n.reference + " reference.");
    const a = Rp[(n.scheme || r.scheme || "").toLowerCase()];
    if (!n.unicodeSupport && (!a || !a.unicodeSupport) && r.host && (n.domainHost || a && a.domainHost) && s === !1 && HP(r.host))
      try {
        r.host = URL.domainToASCII(r.host.toLowerCase());
      } catch (l) {
        r.error = r.error || "Host's domain name can not be converted to ASCII: " + l;
      }
    (!a || a && !a.skipNormalize) && (i && r.scheme !== void 0 && (r.scheme = unescape(r.scheme)), i && r.userinfo !== void 0 && (r.userinfo = unescape(r.userinfo)), i && r.host !== void 0 && (r.host = unescape(r.host)), r.path !== void 0 && r.path.length && (r.path = escape(unescape(r.path))), r.fragment !== void 0 && r.fragment.length && (r.fragment = encodeURI(decodeURIComponent(r.fragment)))), a && a.parse && a.parse(r, n);
  } else
    r.error = r.error || "URI can not be parsed.";
  return r;
}
const Ap = {
  SCHEMES: Rp,
  normalize: BP,
  resolve: GP,
  resolveComponents: V_,
  equal: zP,
  serialize: dr,
  parse: Vr
};
Mu.exports = Ap;
Mu.exports.default = Ap;
Mu.exports.fastUri = Ap;
var QP = Mu.exports;
Object.defineProperty(Op, "__esModule", { value: !0 });
const B_ = QP;
B_.code = 'require("ajv/dist/runtime/uri").default';
Op.default = B_;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CodeGen = e.Name = e.nil = e.stringify = e.str = e._ = e.KeywordCxt = void 0;
  var t = Kn;
  Object.defineProperty(e, "KeywordCxt", { enumerable: !0, get: function() {
    return t.KeywordCxt;
  } });
  var n = Xe;
  Object.defineProperty(e, "_", { enumerable: !0, get: function() {
    return n._;
  } }), Object.defineProperty(e, "str", { enumerable: !0, get: function() {
    return n.str;
  } }), Object.defineProperty(e, "stringify", { enumerable: !0, get: function() {
    return n.stringify;
  } }), Object.defineProperty(e, "nil", { enumerable: !0, get: function() {
    return n.nil;
  } }), Object.defineProperty(e, "Name", { enumerable: !0, get: function() {
    return n.Name;
  } }), Object.defineProperty(e, "CodeGen", { enumerable: !0, get: function() {
    return n.CodeGen;
  } });
  const r = va, i = js, s = Ui, o = cn, a = Xe, l = Jt, c = Bt, u = xe, f = mP, d = Op, p = (te, B) => new RegExp(te, B);
  p.code = "new RegExp";
  const h = ["removeAdditional", "useDefaults", "coerceTypes"], m = /* @__PURE__ */ new Set([
    "validate",
    "serialize",
    "parse",
    "wrapper",
    "root",
    "schema",
    "keyword",
    "pattern",
    "formats",
    "validate$data",
    "func",
    "obj",
    "Error"
  ]), v = {
    errorDataPath: "",
    format: "`validateFormats: false` can be used instead.",
    nullable: '"nullable" keyword is supported by default.',
    jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
    extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
    missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
    processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
    sourceCode: "Use option `code: {source: true}`",
    strictDefaults: "It is default now, see option `strict`.",
    strictKeywords: "It is default now, see option `strict`.",
    uniqueItems: '"uniqueItems" keyword is always validated.',
    unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
    cache: "Map is used as cache, schema object as key.",
    serialize: "Map is used as cache, schema object as key.",
    ajvErrors: "It is default now."
  }, b = {
    ignoreKeywordsWithRef: "",
    jsPropertySyntax: "",
    unicode: '"minLength"/"maxLength" account for unicode characters by default.'
  }, E = 200;
  function y(te) {
    var B, M, N, T, P, k, q, Y, ve, oe, S, $, O, I, L, H, ae, Ee, Oe, Te, Me, we, Le, ut, Je;
    const bt = te.strict, x = (B = te.code) === null || B === void 0 ? void 0 : B.optimize, g = x === !0 || x === void 0 ? 1 : x || 0, _ = (N = (M = te.code) === null || M === void 0 ? void 0 : M.regExp) !== null && N !== void 0 ? N : p, V = (T = te.uriResolver) !== null && T !== void 0 ? T : d.default;
    return {
      strictSchema: (k = (P = te.strictSchema) !== null && P !== void 0 ? P : bt) !== null && k !== void 0 ? k : !0,
      strictNumbers: (Y = (q = te.strictNumbers) !== null && q !== void 0 ? q : bt) !== null && Y !== void 0 ? Y : !0,
      strictTypes: (oe = (ve = te.strictTypes) !== null && ve !== void 0 ? ve : bt) !== null && oe !== void 0 ? oe : "log",
      strictTuples: ($ = (S = te.strictTuples) !== null && S !== void 0 ? S : bt) !== null && $ !== void 0 ? $ : "log",
      strictRequired: (I = (O = te.strictRequired) !== null && O !== void 0 ? O : bt) !== null && I !== void 0 ? I : !1,
      code: te.code ? { ...te.code, optimize: g, regExp: _ } : { optimize: g, regExp: _ },
      loopRequired: (L = te.loopRequired) !== null && L !== void 0 ? L : E,
      loopEnum: (H = te.loopEnum) !== null && H !== void 0 ? H : E,
      meta: (ae = te.meta) !== null && ae !== void 0 ? ae : !0,
      messages: (Ee = te.messages) !== null && Ee !== void 0 ? Ee : !0,
      inlineRefs: (Oe = te.inlineRefs) !== null && Oe !== void 0 ? Oe : !0,
      schemaId: (Te = te.schemaId) !== null && Te !== void 0 ? Te : "$id",
      addUsedSchema: (Me = te.addUsedSchema) !== null && Me !== void 0 ? Me : !0,
      validateSchema: (we = te.validateSchema) !== null && we !== void 0 ? we : !0,
      validateFormats: (Le = te.validateFormats) !== null && Le !== void 0 ? Le : !0,
      unicodeRegExp: (ut = te.unicodeRegExp) !== null && ut !== void 0 ? ut : !0,
      int32range: (Je = te.int32range) !== null && Je !== void 0 ? Je : !0,
      uriResolver: V
    };
  }
  class D {
    constructor(B = {}) {
      this.schemas = {}, this.refs = {}, this.formats = {}, this._compilations = /* @__PURE__ */ new Set(), this._loading = {}, this._cache = /* @__PURE__ */ new Map(), B = this.opts = { ...B, ...y(B) };
      const { es5: M, lines: N } = this.opts.code;
      this.scope = new a.ValueScope({ scope: {}, prefixes: m, es5: M, lines: N }), this.logger = ce(B.logger);
      const T = B.validateFormats;
      B.validateFormats = !1, this.RULES = (0, s.getRules)(), F.call(this, v, B, "NOT SUPPORTED"), F.call(this, b, B, "DEPRECATED", "warn"), this._metaOpts = ee.call(this), B.formats && Z.call(this), this._addVocabularies(), this._addDefaultMetaSchema(), B.keywords && j.call(this, B.keywords), typeof B.meta == "object" && this.addMetaSchema(B.meta), J.call(this), B.validateFormats = T;
    }
    _addVocabularies() {
      this.addKeyword("$async");
    }
    _addDefaultMetaSchema() {
      const { $data: B, meta: M, schemaId: N } = this.opts;
      let T = f;
      N === "id" && (T = { ...f }, T.id = T.$id, delete T.$id), M && B && this.addMetaSchema(T, T[N], !1);
    }
    defaultMeta() {
      const { meta: B, schemaId: M } = this.opts;
      return this.opts.defaultMeta = typeof B == "object" ? B[M] || B : void 0;
    }
    validate(B, M) {
      let N;
      if (typeof B == "string") {
        if (N = this.getSchema(B), !N)
          throw new Error(`no schema with key or ref "${B}"`);
      } else
        N = this.compile(B);
      const T = N(M);
      return "$async" in N || (this.errors = N.errors), T;
    }
    compile(B, M) {
      const N = this._addSchema(B, M);
      return N.validate || this._compileSchemaEnv(N);
    }
    compileAsync(B, M) {
      if (typeof this.opts.loadSchema != "function")
        throw new Error("options.loadSchema should be a function");
      const { loadSchema: N } = this.opts;
      return T.call(this, B, M);
      async function T(oe, S) {
        await P.call(this, oe.$schema);
        const $ = this._addSchema(oe, S);
        return $.validate || k.call(this, $);
      }
      async function P(oe) {
        oe && !this.getSchema(oe) && await T.call(this, { $ref: oe }, !0);
      }
      async function k(oe) {
        try {
          return this._compileSchemaEnv(oe);
        } catch (S) {
          if (!(S instanceof i.default))
            throw S;
          return q.call(this, S), await Y.call(this, S.missingSchema), k.call(this, oe);
        }
      }
      function q({ missingSchema: oe, missingRef: S }) {
        if (this.refs[oe])
          throw new Error(`AnySchema ${oe} is loaded but ${S} cannot be resolved`);
      }
      async function Y(oe) {
        const S = await ve.call(this, oe);
        this.refs[oe] || await P.call(this, S.$schema), this.refs[oe] || this.addSchema(S, oe, M);
      }
      async function ve(oe) {
        const S = this._loading[oe];
        if (S)
          return S;
        try {
          return await (this._loading[oe] = N(oe));
        } finally {
          delete this._loading[oe];
        }
      }
    }
    // Adds schema to the instance
    addSchema(B, M, N, T = this.opts.validateSchema) {
      if (Array.isArray(B)) {
        for (const k of B)
          this.addSchema(k, void 0, N, T);
        return this;
      }
      let P;
      if (typeof B == "object") {
        const { schemaId: k } = this.opts;
        if (P = B[k], P !== void 0 && typeof P != "string")
          throw new Error(`schema ${k} must be string`);
      }
      return M = (0, l.normalizeId)(M || P), this._checkUnique(M), this.schemas[M] = this._addSchema(B, N, M, T, !0), this;
    }
    // Add schema that will be used to validate other schemas
    // options in META_IGNORE_OPTIONS are alway set to false
    addMetaSchema(B, M, N = this.opts.validateSchema) {
      return this.addSchema(B, M, !0, N), this;
    }
    //  Validate schema against its meta-schema
    validateSchema(B, M) {
      if (typeof B == "boolean")
        return !0;
      let N;
      if (N = B.$schema, N !== void 0 && typeof N != "string")
        throw new Error("$schema must be a string");
      if (N = N || this.opts.defaultMeta || this.defaultMeta(), !N)
        return this.logger.warn("meta-schema not available"), this.errors = null, !0;
      const T = this.validate(N, B);
      if (!T && M) {
        const P = "schema is invalid: " + this.errorsText();
        if (this.opts.validateSchema === "log")
          this.logger.error(P);
        else
          throw new Error(P);
      }
      return T;
    }
    // Get compiled schema by `key` or `ref`.
    // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
    getSchema(B) {
      let M;
      for (; typeof (M = W.call(this, B)) == "string"; )
        B = M;
      if (M === void 0) {
        const { schemaId: N } = this.opts, T = new o.SchemaEnv({ schema: {}, schemaId: N });
        if (M = o.resolveSchema.call(this, T, B), !M)
          return;
        this.refs[B] = M;
      }
      return M.validate || this._compileSchemaEnv(M);
    }
    // Remove cached schema(s).
    // If no parameter is passed all schemas but meta-schemas are removed.
    // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
    // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
    removeSchema(B) {
      if (B instanceof RegExp)
        return this._removeAllSchemas(this.schemas, B), this._removeAllSchemas(this.refs, B), this;
      switch (typeof B) {
        case "undefined":
          return this._removeAllSchemas(this.schemas), this._removeAllSchemas(this.refs), this._cache.clear(), this;
        case "string": {
          const M = W.call(this, B);
          return typeof M == "object" && this._cache.delete(M.schema), delete this.schemas[B], delete this.refs[B], this;
        }
        case "object": {
          const M = B;
          this._cache.delete(M);
          let N = B[this.opts.schemaId];
          return N && (N = (0, l.normalizeId)(N), delete this.schemas[N], delete this.refs[N]), this;
        }
        default:
          throw new Error("ajv.removeSchema: invalid parameter");
      }
    }
    // add "vocabulary" - a collection of keywords
    addVocabulary(B) {
      for (const M of B)
        this.addKeyword(M);
      return this;
    }
    addKeyword(B, M) {
      let N;
      if (typeof B == "string")
        N = B, typeof M == "object" && (this.logger.warn("these parameters are deprecated, see docs for addKeyword"), M.keyword = N);
      else if (typeof B == "object" && M === void 0) {
        if (M = B, N = M.keyword, Array.isArray(N) && !N.length)
          throw new Error("addKeywords: keyword must be string or non-empty array");
      } else
        throw new Error("invalid addKeywords parameters");
      if (z.call(this, N, M), !M)
        return (0, u.eachItem)(N, (P) => ne.call(this, P)), this;
      se.call(this, M);
      const T = {
        ...M,
        type: (0, c.getJSONTypes)(M.type),
        schemaType: (0, c.getJSONTypes)(M.schemaType)
      };
      return (0, u.eachItem)(N, T.type.length === 0 ? (P) => ne.call(this, P, T) : (P) => T.type.forEach((k) => ne.call(this, P, T, k))), this;
    }
    getKeyword(B) {
      const M = this.RULES.all[B];
      return typeof M == "object" ? M.definition : !!M;
    }
    // Remove keyword
    removeKeyword(B) {
      const { RULES: M } = this;
      delete M.keywords[B], delete M.all[B];
      for (const N of M.rules) {
        const T = N.rules.findIndex((P) => P.keyword === B);
        T >= 0 && N.rules.splice(T, 1);
      }
      return this;
    }
    // Add format
    addFormat(B, M) {
      return typeof M == "string" && (M = new RegExp(M)), this.formats[B] = M, this;
    }
    errorsText(B = this.errors, { separator: M = ", ", dataVar: N = "data" } = {}) {
      return !B || B.length === 0 ? "No errors" : B.map((T) => `${N}${T.instancePath} ${T.message}`).reduce((T, P) => T + M + P);
    }
    $dataMetaSchema(B, M) {
      const N = this.RULES.all;
      B = JSON.parse(JSON.stringify(B));
      for (const T of M) {
        const P = T.split("/").slice(1);
        let k = B;
        for (const q of P)
          k = k[q];
        for (const q in N) {
          const Y = N[q];
          if (typeof Y != "object")
            continue;
          const { $data: ve } = Y.definition, oe = k[q];
          ve && oe && (k[q] = ue(oe));
        }
      }
      return B;
    }
    _removeAllSchemas(B, M) {
      for (const N in B) {
        const T = B[N];
        (!M || M.test(N)) && (typeof T == "string" ? delete B[N] : T && !T.meta && (this._cache.delete(T.schema), delete B[N]));
      }
    }
    _addSchema(B, M, N, T = this.opts.validateSchema, P = this.opts.addUsedSchema) {
      let k;
      const { schemaId: q } = this.opts;
      if (typeof B == "object")
        k = B[q];
      else {
        if (this.opts.jtd)
          throw new Error("schema must be object");
        if (typeof B != "boolean")
          throw new Error("schema must be object or boolean");
      }
      let Y = this._cache.get(B);
      if (Y !== void 0)
        return Y;
      N = (0, l.normalizeId)(k || N);
      const ve = l.getSchemaRefs.call(this, B, N);
      return Y = new o.SchemaEnv({ schema: B, schemaId: q, meta: M, baseId: N, localRefs: ve }), this._cache.set(Y.schema, Y), P && !N.startsWith("#") && (N && this._checkUnique(N), this.refs[N] = Y), T && this.validateSchema(B, !0), Y;
    }
    _checkUnique(B) {
      if (this.schemas[B] || this.refs[B])
        throw new Error(`schema with key or id "${B}" already exists`);
    }
    _compileSchemaEnv(B) {
      if (B.meta ? this._compileMetaSchema(B) : o.compileSchema.call(this, B), !B.validate)
        throw new Error("ajv implementation error");
      return B.validate;
    }
    _compileMetaSchema(B) {
      const M = this.opts;
      this.opts = this._metaOpts;
      try {
        o.compileSchema.call(this, B);
      } finally {
        this.opts = M;
      }
    }
  }
  D.ValidationError = r.default, D.MissingRefError = i.default, e.default = D;
  function F(te, B, M, N = "error") {
    for (const T in te) {
      const P = T;
      P in B && this.logger[N](`${M}: option ${T}. ${te[P]}`);
    }
  }
  function W(te) {
    return te = (0, l.normalizeId)(te), this.schemas[te] || this.refs[te];
  }
  function J() {
    const te = this.opts.schemas;
    if (te)
      if (Array.isArray(te))
        this.addSchema(te);
      else
        for (const B in te)
          this.addSchema(te[B], B);
  }
  function Z() {
    for (const te in this.opts.formats) {
      const B = this.opts.formats[te];
      B && this.addFormat(te, B);
    }
  }
  function j(te) {
    if (Array.isArray(te)) {
      this.addVocabulary(te);
      return;
    }
    this.logger.warn("keywords option as map is deprecated, pass array");
    for (const B in te) {
      const M = te[B];
      M.keyword || (M.keyword = B), this.addKeyword(M);
    }
  }
  function ee() {
    const te = { ...this.opts };
    for (const B of h)
      delete te[B];
    return te;
  }
  const le = { log() {
  }, warn() {
  }, error() {
  } };
  function ce(te) {
    if (te === !1)
      return le;
    if (te === void 0)
      return console;
    if (te.log && te.warn && te.error)
      return te;
    throw new Error("logger must implement log, warn and error methods");
  }
  const U = /^[a-z_$][a-z0-9_$:-]*$/i;
  function z(te, B) {
    const { RULES: M } = this;
    if ((0, u.eachItem)(te, (N) => {
      if (M.keywords[N])
        throw new Error(`Keyword ${N} is already defined`);
      if (!U.test(N))
        throw new Error(`Keyword ${N} has invalid name`);
    }), !!B && B.$data && !("code" in B || "validate" in B))
      throw new Error('$data keyword must have "code" or "validate" function');
  }
  function ne(te, B, M) {
    var N;
    const T = B?.post;
    if (M && T)
      throw new Error('keyword with "post" flag cannot have "type"');
    const { RULES: P } = this;
    let k = T ? P.post : P.rules.find(({ type: Y }) => Y === M);
    if (k || (k = { type: M, rules: [] }, P.rules.push(k)), P.keywords[te] = !0, !B)
      return;
    const q = {
      keyword: te,
      definition: {
        ...B,
        type: (0, c.getJSONTypes)(B.type),
        schemaType: (0, c.getJSONTypes)(B.schemaType)
      }
    };
    B.before ? K.call(this, k, q, B.before) : k.rules.push(q), P.all[te] = q, (N = B.implements) === null || N === void 0 || N.forEach((Y) => this.addKeyword(Y));
  }
  function K(te, B, M) {
    const N = te.rules.findIndex((T) => T.keyword === M);
    N >= 0 ? te.rules.splice(N, 0, B) : (te.rules.push(B), this.logger.warn(`rule ${M} is not defined`));
  }
  function se(te) {
    let { metaSchema: B } = te;
    B !== void 0 && (te.$data && this.opts.$data && (B = ue(B)), te.validateSchema = this.compile(B, !0));
  }
  const re = {
    $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
  };
  function ue(te) {
    return { anyOf: [te, re] };
  }
})(n_);
var xp = {}, Dp = {}, Pp = {};
Object.defineProperty(Pp, "__esModule", { value: !0 });
const JP = {
  keyword: "id",
  code() {
    throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
  }
};
Pp.default = JP;
var Vi = {};
Object.defineProperty(Vi, "__esModule", { value: !0 });
Vi.callRef = Vi.getValidate = void 0;
const KP = js, sg = tt, ln = Xe, ls = Tr, og = cn, Ha = xe, YP = {
  keyword: "$ref",
  schemaType: "string",
  code(e) {
    const { gen: t, schema: n, it: r } = e, { baseId: i, schemaEnv: s, validateName: o, opts: a, self: l } = r, { root: c } = s;
    if ((n === "#" || n === "#/") && i === c.baseId)
      return f();
    const u = og.resolveRef.call(l, c, i, n);
    if (u === void 0)
      throw new KP.default(r.opts.uriResolver, i, n);
    if (u instanceof og.SchemaEnv)
      return d(u);
    return p(u);
    function f() {
      if (s === c)
        return vl(e, o, s, s.$async);
      const h = t.scopeValue("root", { ref: c });
      return vl(e, (0, ln._)`${h}.validate`, c, c.$async);
    }
    function d(h) {
      const m = G_(e, h);
      vl(e, m, h, h.$async);
    }
    function p(h) {
      const m = t.scopeValue("schema", a.code.source === !0 ? { ref: h, code: (0, ln.stringify)(h) } : { ref: h }), v = t.name("valid"), b = e.subschema({
        schema: h,
        dataTypes: [],
        schemaPath: ln.nil,
        topSchemaRef: m,
        errSchemaPath: n
      }, v);
      e.mergeEvaluated(b), e.ok(v);
    }
  }
};
function G_(e, t) {
  const { gen: n } = e;
  return t.validate ? n.scopeValue("validate", { ref: t.validate }) : (0, ln._)`${n.scopeValue("wrapper", { ref: t })}.validate`;
}
Vi.getValidate = G_;
function vl(e, t, n, r) {
  const { gen: i, it: s } = e, { allErrors: o, schemaEnv: a, opts: l } = s, c = l.passContext ? ls.default.this : ln.nil;
  r ? u() : f();
  function u() {
    if (!a.$async)
      throw new Error("async schema referenced by sync schema");
    const h = i.let("valid");
    i.try(() => {
      i.code((0, ln._)`await ${(0, sg.callValidateCode)(e, t, c)}`), p(t), o || i.assign(h, !0);
    }, (m) => {
      i.if((0, ln._)`!(${m} instanceof ${s.ValidationError})`, () => i.throw(m)), d(m), o || i.assign(h, !1);
    }), e.ok(h);
  }
  function f() {
    e.result((0, sg.callValidateCode)(e, t, c), () => p(t), () => d(t));
  }
  function d(h) {
    const m = (0, ln._)`${h}.errors`;
    i.assign(ls.default.vErrors, (0, ln._)`${ls.default.vErrors} === null ? ${m} : ${ls.default.vErrors}.concat(${m})`), i.assign(ls.default.errors, (0, ln._)`${ls.default.vErrors}.length`);
  }
  function p(h) {
    var m;
    if (!s.opts.unevaluated)
      return;
    const v = (m = n?.validate) === null || m === void 0 ? void 0 : m.evaluated;
    if (s.props !== !0)
      if (v && !v.dynamicProps)
        v.props !== void 0 && (s.props = Ha.mergeEvaluated.props(i, v.props, s.props));
      else {
        const b = i.var("props", (0, ln._)`${h}.evaluated.props`);
        s.props = Ha.mergeEvaluated.props(i, b, s.props, ln.Name);
      }
    if (s.items !== !0)
      if (v && !v.dynamicItems)
        v.items !== void 0 && (s.items = Ha.mergeEvaluated.items(i, v.items, s.items));
      else {
        const b = i.var("items", (0, ln._)`${h}.evaluated.items`);
        s.items = Ha.mergeEvaluated.items(i, b, s.items, ln.Name);
      }
  }
}
Vi.callRef = vl;
Vi.default = YP;
Object.defineProperty(Dp, "__esModule", { value: !0 });
const XP = Pp, ZP = Vi, ek = [
  "$schema",
  "$id",
  "$defs",
  "$vocabulary",
  { keyword: "$comment" },
  "definitions",
  XP.default,
  ZP.default
];
Dp.default = ek;
var kp = {}, Lp = {};
Object.defineProperty(Lp, "__esModule", { value: !0 });
const Vl = Xe, Yr = Vl.operators, Bl = {
  maximum: { okStr: "<=", ok: Yr.LTE, fail: Yr.GT },
  minimum: { okStr: ">=", ok: Yr.GTE, fail: Yr.LT },
  exclusiveMaximum: { okStr: "<", ok: Yr.LT, fail: Yr.GTE },
  exclusiveMinimum: { okStr: ">", ok: Yr.GT, fail: Yr.LTE }
}, tk = {
  message: ({ keyword: e, schemaCode: t }) => (0, Vl.str)`must be ${Bl[e].okStr} ${t}`,
  params: ({ keyword: e, schemaCode: t }) => (0, Vl._)`{comparison: ${Bl[e].okStr}, limit: ${t}}`
}, nk = {
  keyword: Object.keys(Bl),
  type: "number",
  schemaType: "number",
  $data: !0,
  error: tk,
  code(e) {
    const { keyword: t, data: n, schemaCode: r } = e;
    e.fail$data((0, Vl._)`${n} ${Bl[t].fail} ${r} || isNaN(${n})`);
  }
};
Lp.default = nk;
var jp = {};
Object.defineProperty(jp, "__esModule", { value: !0 });
const ko = Xe, rk = {
  message: ({ schemaCode: e }) => (0, ko.str)`must be multiple of ${e}`,
  params: ({ schemaCode: e }) => (0, ko._)`{multipleOf: ${e}}`
}, ik = {
  keyword: "multipleOf",
  type: "number",
  schemaType: "number",
  $data: !0,
  error: rk,
  code(e) {
    const { gen: t, data: n, schemaCode: r, it: i } = e, s = i.opts.multipleOfPrecision, o = t.let("res"), a = s ? (0, ko._)`Math.abs(Math.round(${o}) - ${o}) > 1e-${s}` : (0, ko._)`${o} !== parseInt(${o})`;
    e.fail$data((0, ko._)`(${r} === 0 || (${o} = ${n}/${r}, ${a}))`);
  }
};
jp.default = ik;
var Cp = {}, Mp = {};
Object.defineProperty(Mp, "__esModule", { value: !0 });
function z_(e) {
  const t = e.length;
  let n = 0, r = 0, i;
  for (; r < t; )
    n++, i = e.charCodeAt(r++), i >= 55296 && i <= 56319 && r < t && (i = e.charCodeAt(r), (i & 64512) === 56320 && r++);
  return n;
}
Mp.default = z_;
z_.code = 'require("ajv/dist/runtime/ucs2length").default';
Object.defineProperty(Cp, "__esModule", { value: !0 });
const ki = Xe, sk = xe, ok = Mp, ak = {
  message({ keyword: e, schemaCode: t }) {
    const n = e === "maxLength" ? "more" : "fewer";
    return (0, ki.str)`must NOT have ${n} than ${t} characters`;
  },
  params: ({ schemaCode: e }) => (0, ki._)`{limit: ${e}}`
}, lk = {
  keyword: ["maxLength", "minLength"],
  type: "string",
  schemaType: "number",
  $data: !0,
  error: ak,
  code(e) {
    const { keyword: t, data: n, schemaCode: r, it: i } = e, s = t === "maxLength" ? ki.operators.GT : ki.operators.LT, o = i.opts.unicode === !1 ? (0, ki._)`${n}.length` : (0, ki._)`${(0, sk.useFunc)(e.gen, ok.default)}(${n})`;
    e.fail$data((0, ki._)`${o} ${s} ${r}`);
  }
};
Cp.default = lk;
var Fp = {};
Object.defineProperty(Fp, "__esModule", { value: !0 });
const uk = tt, Gl = Xe, ck = {
  message: ({ schemaCode: e }) => (0, Gl.str)`must match pattern "${e}"`,
  params: ({ schemaCode: e }) => (0, Gl._)`{pattern: ${e}}`
}, fk = {
  keyword: "pattern",
  type: "string",
  schemaType: "string",
  $data: !0,
  error: ck,
  code(e) {
    const { data: t, $data: n, schema: r, schemaCode: i, it: s } = e, o = s.opts.unicodeRegExp ? "u" : "", a = n ? (0, Gl._)`(new RegExp(${i}, ${o}))` : (0, uk.usePattern)(e, r);
    e.fail$data((0, Gl._)`!${a}.test(${t})`);
  }
};
Fp.default = fk;
var Up = {};
Object.defineProperty(Up, "__esModule", { value: !0 });
const Lo = Xe, dk = {
  message({ keyword: e, schemaCode: t }) {
    const n = e === "maxProperties" ? "more" : "fewer";
    return (0, Lo.str)`must NOT have ${n} than ${t} properties`;
  },
  params: ({ schemaCode: e }) => (0, Lo._)`{limit: ${e}}`
}, pk = {
  keyword: ["maxProperties", "minProperties"],
  type: "object",
  schemaType: "number",
  $data: !0,
  error: dk,
  code(e) {
    const { keyword: t, data: n, schemaCode: r } = e, i = t === "maxProperties" ? Lo.operators.GT : Lo.operators.LT;
    e.fail$data((0, Lo._)`Object.keys(${n}).length ${i} ${r}`);
  }
};
Up.default = pk;
var Vp = {};
Object.defineProperty(Vp, "__esModule", { value: !0 });
const ho = tt, jo = Xe, hk = xe, mk = {
  message: ({ params: { missingProperty: e } }) => (0, jo.str)`must have required property '${e}'`,
  params: ({ params: { missingProperty: e } }) => (0, jo._)`{missingProperty: ${e}}`
}, yk = {
  keyword: "required",
  type: "object",
  schemaType: "array",
  $data: !0,
  error: mk,
  code(e) {
    const { gen: t, schema: n, schemaCode: r, data: i, $data: s, it: o } = e, { opts: a } = o;
    if (!s && n.length === 0)
      return;
    const l = n.length >= a.loopRequired;
    if (o.allErrors ? c() : u(), a.strictRequired) {
      const p = e.parentSchema.properties, { definedProperties: h } = e.it;
      for (const m of n)
        if (p?.[m] === void 0 && !h.has(m)) {
          const v = o.schemaEnv.baseId + o.errSchemaPath, b = `required property "${m}" is not defined at "${v}" (strictRequired)`;
          (0, hk.checkStrictMode)(o, b, o.opts.strictRequired);
        }
    }
    function c() {
      if (l || s)
        e.block$data(jo.nil, f);
      else
        for (const p of n)
          (0, ho.checkReportMissingProp)(e, p);
    }
    function u() {
      const p = t.let("missing");
      if (l || s) {
        const h = t.let("valid", !0);
        e.block$data(h, () => d(p, h)), e.ok(h);
      } else
        t.if((0, ho.checkMissingProp)(e, n, p)), (0, ho.reportMissingProp)(e, p), t.else();
    }
    function f() {
      t.forOf("prop", r, (p) => {
        e.setParams({ missingProperty: p }), t.if((0, ho.noPropertyInData)(t, i, p, a.ownProperties), () => e.error());
      });
    }
    function d(p, h) {
      e.setParams({ missingProperty: p }), t.forOf(p, r, () => {
        t.assign(h, (0, ho.propertyInData)(t, i, p, a.ownProperties)), t.if((0, jo.not)(h), () => {
          e.error(), t.break();
        });
      }, jo.nil);
    }
  }
};
Vp.default = yk;
var Bp = {};
Object.defineProperty(Bp, "__esModule", { value: !0 });
const Co = Xe, gk = {
  message({ keyword: e, schemaCode: t }) {
    const n = e === "maxItems" ? "more" : "fewer";
    return (0, Co.str)`must NOT have ${n} than ${t} items`;
  },
  params: ({ schemaCode: e }) => (0, Co._)`{limit: ${e}}`
}, bk = {
  keyword: ["maxItems", "minItems"],
  type: "array",
  schemaType: "number",
  $data: !0,
  error: gk,
  code(e) {
    const { keyword: t, data: n, schemaCode: r } = e, i = t === "maxItems" ? Co.operators.GT : Co.operators.LT;
    e.fail$data((0, Co._)`${n}.length ${i} ${r}`);
  }
};
Bp.default = bk;
var Gp = {}, Cs = {};
Object.defineProperty(Cs, "__esModule", { value: !0 });
const q_ = ga;
q_.code = 'require("ajv/dist/runtime/equal").default';
Cs.default = q_;
Object.defineProperty(Gp, "__esModule", { value: !0 });
const Sf = Bt, Qt = Xe, vk = xe, _k = Cs, wk = {
  message: ({ params: { i: e, j: t } }) => (0, Qt.str)`must NOT have duplicate items (items ## ${t} and ${e} are identical)`,
  params: ({ params: { i: e, j: t } }) => (0, Qt._)`{i: ${e}, j: ${t}}`
}, Ek = {
  keyword: "uniqueItems",
  type: "array",
  schemaType: "boolean",
  $data: !0,
  error: wk,
  code(e) {
    const { gen: t, data: n, $data: r, schema: i, parentSchema: s, schemaCode: o, it: a } = e;
    if (!r && !i)
      return;
    const l = t.let("valid"), c = s.items ? (0, Sf.getSchemaTypes)(s.items) : [];
    e.block$data(l, u, (0, Qt._)`${o} === false`), e.ok(l);
    function u() {
      const h = t.let("i", (0, Qt._)`${n}.length`), m = t.let("j");
      e.setParams({ i: h, j: m }), t.assign(l, !0), t.if((0, Qt._)`${h} > 1`, () => (f() ? d : p)(h, m));
    }
    function f() {
      return c.length > 0 && !c.some((h) => h === "object" || h === "array");
    }
    function d(h, m) {
      const v = t.name("item"), b = (0, Sf.checkDataTypes)(c, v, a.opts.strictNumbers, Sf.DataType.Wrong), E = t.const("indices", (0, Qt._)`{}`);
      t.for((0, Qt._)`;${h}--;`, () => {
        t.let(v, (0, Qt._)`${n}[${h}]`), t.if(b, (0, Qt._)`continue`), c.length > 1 && t.if((0, Qt._)`typeof ${v} == "string"`, (0, Qt._)`${v} += "_"`), t.if((0, Qt._)`typeof ${E}[${v}] == "number"`, () => {
          t.assign(m, (0, Qt._)`${E}[${v}]`), e.error(), t.assign(l, !1).break();
        }).code((0, Qt._)`${E}[${v}] = ${h}`);
      });
    }
    function p(h, m) {
      const v = (0, vk.useFunc)(t, _k.default), b = t.name("outer");
      t.label(b).for((0, Qt._)`;${h}--;`, () => t.for((0, Qt._)`${m} = ${h}; ${m}--;`, () => t.if((0, Qt._)`${v}(${n}[${h}], ${n}[${m}])`, () => {
        e.error(), t.assign(l, !1).break(b);
      })));
    }
  }
};
Gp.default = Ek;
var zp = {};
Object.defineProperty(zp, "__esModule", { value: !0 });
const ud = Xe, Sk = xe, Tk = Cs, $k = {
  message: "must be equal to constant",
  params: ({ schemaCode: e }) => (0, ud._)`{allowedValue: ${e}}`
}, Nk = {
  keyword: "const",
  $data: !0,
  error: $k,
  code(e) {
    const { gen: t, data: n, $data: r, schemaCode: i, schema: s } = e;
    r || s && typeof s == "object" ? e.fail$data((0, ud._)`!${(0, Sk.useFunc)(t, Tk.default)}(${n}, ${i})`) : e.fail((0, ud._)`${s} !== ${n}`);
  }
};
zp.default = Nk;
var qp = {};
Object.defineProperty(qp, "__esModule", { value: !0 });
const No = Xe, Ok = xe, Ik = Cs, Rk = {
  message: "must be equal to one of the allowed values",
  params: ({ schemaCode: e }) => (0, No._)`{allowedValues: ${e}}`
}, Ak = {
  keyword: "enum",
  schemaType: "array",
  $data: !0,
  error: Rk,
  code(e) {
    const { gen: t, data: n, $data: r, schema: i, schemaCode: s, it: o } = e;
    if (!r && i.length === 0)
      throw new Error("enum must have non-empty array");
    const a = i.length >= o.opts.loopEnum;
    let l;
    const c = () => l ?? (l = (0, Ok.useFunc)(t, Ik.default));
    let u;
    if (a || r)
      u = t.let("valid"), e.block$data(u, f);
    else {
      if (!Array.isArray(i))
        throw new Error("ajv implementation error");
      const p = t.const("vSchema", s);
      u = (0, No.or)(...i.map((h, m) => d(p, m)));
    }
    e.pass(u);
    function f() {
      t.assign(u, !1), t.forOf("v", s, (p) => t.if((0, No._)`${c()}(${n}, ${p})`, () => t.assign(u, !0).break()));
    }
    function d(p, h) {
      const m = i[h];
      return typeof m == "object" && m !== null ? (0, No._)`${c()}(${n}, ${p}[${h}])` : (0, No._)`${n} === ${m}`;
    }
  }
};
qp.default = Ak;
Object.defineProperty(kp, "__esModule", { value: !0 });
const xk = Lp, Dk = jp, Pk = Cp, kk = Fp, Lk = Up, jk = Vp, Ck = Bp, Mk = Gp, Fk = zp, Uk = qp, Vk = [
  // number
  xk.default,
  Dk.default,
  // string
  Pk.default,
  kk.default,
  // object
  Lk.default,
  jk.default,
  // array
  Ck.default,
  Mk.default,
  // any
  { keyword: "type", schemaType: ["string", "array"] },
  { keyword: "nullable", schemaType: "boolean" },
  Fk.default,
  Uk.default
];
kp.default = Vk;
var Hp = {}, Ms = {};
Object.defineProperty(Ms, "__esModule", { value: !0 });
Ms.validateAdditionalItems = void 0;
const Li = Xe, cd = xe, Bk = {
  message: ({ params: { len: e } }) => (0, Li.str)`must NOT have more than ${e} items`,
  params: ({ params: { len: e } }) => (0, Li._)`{limit: ${e}}`
}, Gk = {
  keyword: "additionalItems",
  type: "array",
  schemaType: ["boolean", "object"],
  before: "uniqueItems",
  error: Bk,
  code(e) {
    const { parentSchema: t, it: n } = e, { items: r } = t;
    if (!Array.isArray(r)) {
      (0, cd.checkStrictMode)(n, '"additionalItems" is ignored when "items" is not an array of schemas');
      return;
    }
    H_(e, r);
  }
};
function H_(e, t) {
  const { gen: n, schema: r, data: i, keyword: s, it: o } = e;
  o.items = !0;
  const a = n.const("len", (0, Li._)`${i}.length`);
  if (r === !1)
    e.setParams({ len: t.length }), e.pass((0, Li._)`${a} <= ${t.length}`);
  else if (typeof r == "object" && !(0, cd.alwaysValidSchema)(o, r)) {
    const c = n.var("valid", (0, Li._)`${a} <= ${t.length}`);
    n.if((0, Li.not)(c), () => l(c)), e.ok(c);
  }
  function l(c) {
    n.forRange("i", t.length, a, (u) => {
      e.subschema({ keyword: s, dataProp: u, dataPropType: cd.Type.Num }, c), o.allErrors || n.if((0, Li.not)(c), () => n.break());
    });
  }
}
Ms.validateAdditionalItems = H_;
Ms.default = Gk;
var Wp = {}, Fs = {};
Object.defineProperty(Fs, "__esModule", { value: !0 });
Fs.validateTuple = void 0;
const ag = Xe, _l = xe, zk = tt, qk = {
  keyword: "items",
  type: "array",
  schemaType: ["object", "array", "boolean"],
  before: "uniqueItems",
  code(e) {
    const { schema: t, it: n } = e;
    if (Array.isArray(t))
      return W_(e, "additionalItems", t);
    n.items = !0, !(0, _l.alwaysValidSchema)(n, t) && e.ok((0, zk.validateArray)(e));
  }
};
function W_(e, t, n = e.schema) {
  const { gen: r, parentSchema: i, data: s, keyword: o, it: a } = e;
  u(i), a.opts.unevaluated && n.length && a.items !== !0 && (a.items = _l.mergeEvaluated.items(r, n.length, a.items));
  const l = r.name("valid"), c = r.const("len", (0, ag._)`${s}.length`);
  n.forEach((f, d) => {
    (0, _l.alwaysValidSchema)(a, f) || (r.if((0, ag._)`${c} > ${d}`, () => e.subschema({
      keyword: o,
      schemaProp: d,
      dataProp: d
    }, l)), e.ok(l));
  });
  function u(f) {
    const { opts: d, errSchemaPath: p } = a, h = n.length, m = h === f.minItems && (h === f.maxItems || f[t] === !1);
    if (d.strictTuples && !m) {
      const v = `"${o}" is ${h}-tuple, but minItems or maxItems/${t} are not specified or different at path "${p}"`;
      (0, _l.checkStrictMode)(a, v, d.strictTuples);
    }
  }
}
Fs.validateTuple = W_;
Fs.default = qk;
Object.defineProperty(Wp, "__esModule", { value: !0 });
const Hk = Fs, Wk = {
  keyword: "prefixItems",
  type: "array",
  schemaType: ["array"],
  before: "uniqueItems",
  code: (e) => (0, Hk.validateTuple)(e, "items")
};
Wp.default = Wk;
var Qp = {};
Object.defineProperty(Qp, "__esModule", { value: !0 });
const lg = Xe, Qk = xe, Jk = tt, Kk = Ms, Yk = {
  message: ({ params: { len: e } }) => (0, lg.str)`must NOT have more than ${e} items`,
  params: ({ params: { len: e } }) => (0, lg._)`{limit: ${e}}`
}, Xk = {
  keyword: "items",
  type: "array",
  schemaType: ["object", "boolean"],
  before: "uniqueItems",
  error: Yk,
  code(e) {
    const { schema: t, parentSchema: n, it: r } = e, { prefixItems: i } = n;
    r.items = !0, !(0, Qk.alwaysValidSchema)(r, t) && (i ? (0, Kk.validateAdditionalItems)(e, i) : e.ok((0, Jk.validateArray)(e)));
  }
};
Qp.default = Xk;
var Jp = {};
Object.defineProperty(Jp, "__esModule", { value: !0 });
const Nn = Xe, Wa = xe, Zk = {
  message: ({ params: { min: e, max: t } }) => t === void 0 ? (0, Nn.str)`must contain at least ${e} valid item(s)` : (0, Nn.str)`must contain at least ${e} and no more than ${t} valid item(s)`,
  params: ({ params: { min: e, max: t } }) => t === void 0 ? (0, Nn._)`{minContains: ${e}}` : (0, Nn._)`{minContains: ${e}, maxContains: ${t}}`
}, eL = {
  keyword: "contains",
  type: "array",
  schemaType: ["object", "boolean"],
  before: "uniqueItems",
  trackErrors: !0,
  error: Zk,
  code(e) {
    const { gen: t, schema: n, parentSchema: r, data: i, it: s } = e;
    let o, a;
    const { minContains: l, maxContains: c } = r;
    s.opts.next ? (o = l === void 0 ? 1 : l, a = c) : o = 1;
    const u = t.const("len", (0, Nn._)`${i}.length`);
    if (e.setParams({ min: o, max: a }), a === void 0 && o === 0) {
      (0, Wa.checkStrictMode)(s, '"minContains" == 0 without "maxContains": "contains" keyword ignored');
      return;
    }
    if (a !== void 0 && o > a) {
      (0, Wa.checkStrictMode)(s, '"minContains" > "maxContains" is always invalid'), e.fail();
      return;
    }
    if ((0, Wa.alwaysValidSchema)(s, n)) {
      let m = (0, Nn._)`${u} >= ${o}`;
      a !== void 0 && (m = (0, Nn._)`${m} && ${u} <= ${a}`), e.pass(m);
      return;
    }
    s.items = !0;
    const f = t.name("valid");
    a === void 0 && o === 1 ? p(f, () => t.if(f, () => t.break())) : o === 0 ? (t.let(f, !0), a !== void 0 && t.if((0, Nn._)`${i}.length > 0`, d)) : (t.let(f, !1), d()), e.result(f, () => e.reset());
    function d() {
      const m = t.name("_valid"), v = t.let("count", 0);
      p(m, () => t.if(m, () => h(v)));
    }
    function p(m, v) {
      t.forRange("i", 0, u, (b) => {
        e.subschema({
          keyword: "contains",
          dataProp: b,
          dataPropType: Wa.Type.Num,
          compositeRule: !0
        }, m), v();
      });
    }
    function h(m) {
      t.code((0, Nn._)`${m}++`), a === void 0 ? t.if((0, Nn._)`${m} >= ${o}`, () => t.assign(f, !0).break()) : (t.if((0, Nn._)`${m} > ${a}`, () => t.assign(f, !1).break()), o === 1 ? t.assign(f, !0) : t.if((0, Nn._)`${m} >= ${o}`, () => t.assign(f, !0)));
    }
  }
};
Jp.default = eL;
var Q_ = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.validateSchemaDeps = e.validatePropertyDeps = e.error = void 0;
  const t = Xe, n = xe, r = tt;
  e.error = {
    message: ({ params: { property: l, depsCount: c, deps: u } }) => {
      const f = c === 1 ? "property" : "properties";
      return (0, t.str)`must have ${f} ${u} when property ${l} is present`;
    },
    params: ({ params: { property: l, depsCount: c, deps: u, missingProperty: f } }) => (0, t._)`{property: ${l},
    missingProperty: ${f},
    depsCount: ${c},
    deps: ${u}}`
    // TODO change to reference
  };
  const i = {
    keyword: "dependencies",
    type: "object",
    schemaType: "object",
    error: e.error,
    code(l) {
      const [c, u] = s(l);
      o(l, c), a(l, u);
    }
  };
  function s({ schema: l }) {
    const c = {}, u = {};
    for (const f in l) {
      if (f === "__proto__")
        continue;
      const d = Array.isArray(l[f]) ? c : u;
      d[f] = l[f];
    }
    return [c, u];
  }
  function o(l, c = l.schema) {
    const { gen: u, data: f, it: d } = l;
    if (Object.keys(c).length === 0)
      return;
    const p = u.let("missing");
    for (const h in c) {
      const m = c[h];
      if (m.length === 0)
        continue;
      const v = (0, r.propertyInData)(u, f, h, d.opts.ownProperties);
      l.setParams({
        property: h,
        depsCount: m.length,
        deps: m.join(", ")
      }), d.allErrors ? u.if(v, () => {
        for (const b of m)
          (0, r.checkReportMissingProp)(l, b);
      }) : (u.if((0, t._)`${v} && (${(0, r.checkMissingProp)(l, m, p)})`), (0, r.reportMissingProp)(l, p), u.else());
    }
  }
  e.validatePropertyDeps = o;
  function a(l, c = l.schema) {
    const { gen: u, data: f, keyword: d, it: p } = l, h = u.name("valid");
    for (const m in c)
      (0, n.alwaysValidSchema)(p, c[m]) || (u.if(
        (0, r.propertyInData)(u, f, m, p.opts.ownProperties),
        () => {
          const v = l.subschema({ keyword: d, schemaProp: m }, h);
          l.mergeValidEvaluated(v, h);
        },
        () => u.var(h, !0)
        // TODO var
      ), l.ok(h));
  }
  e.validateSchemaDeps = a, e.default = i;
})(Q_);
var Kp = {};
Object.defineProperty(Kp, "__esModule", { value: !0 });
const J_ = Xe, tL = xe, nL = {
  message: "property name must be valid",
  params: ({ params: e }) => (0, J_._)`{propertyName: ${e.propertyName}}`
}, rL = {
  keyword: "propertyNames",
  type: "object",
  schemaType: ["object", "boolean"],
  error: nL,
  code(e) {
    const { gen: t, schema: n, data: r, it: i } = e;
    if ((0, tL.alwaysValidSchema)(i, n))
      return;
    const s = t.name("valid");
    t.forIn("key", r, (o) => {
      e.setParams({ propertyName: o }), e.subschema({
        keyword: "propertyNames",
        data: o,
        dataTypes: ["string"],
        propertyName: o,
        compositeRule: !0
      }, s), t.if((0, J_.not)(s), () => {
        e.error(!0), i.allErrors || t.break();
      });
    }), e.ok(s);
  }
};
Kp.default = rL;
var Fu = {};
Object.defineProperty(Fu, "__esModule", { value: !0 });
const Qa = tt, Hn = Xe, iL = Tr, Ja = xe, sL = {
  message: "must NOT have additional properties",
  params: ({ params: e }) => (0, Hn._)`{additionalProperty: ${e.additionalProperty}}`
}, oL = {
  keyword: "additionalProperties",
  type: ["object"],
  schemaType: ["boolean", "object"],
  allowUndefined: !0,
  trackErrors: !0,
  error: sL,
  code(e) {
    const { gen: t, schema: n, parentSchema: r, data: i, errsCount: s, it: o } = e;
    if (!s)
      throw new Error("ajv implementation error");
    const { allErrors: a, opts: l } = o;
    if (o.props = !0, l.removeAdditional !== "all" && (0, Ja.alwaysValidSchema)(o, n))
      return;
    const c = (0, Qa.allSchemaProperties)(r.properties), u = (0, Qa.allSchemaProperties)(r.patternProperties);
    f(), e.ok((0, Hn._)`${s} === ${iL.default.errors}`);
    function f() {
      t.forIn("key", i, (v) => {
        !c.length && !u.length ? h(v) : t.if(d(v), () => h(v));
      });
    }
    function d(v) {
      let b;
      if (c.length > 8) {
        const E = (0, Ja.schemaRefOrVal)(o, r.properties, "properties");
        b = (0, Qa.isOwnProperty)(t, E, v);
      } else
        c.length ? b = (0, Hn.or)(...c.map((E) => (0, Hn._)`${v} === ${E}`)) : b = Hn.nil;
      return u.length && (b = (0, Hn.or)(b, ...u.map((E) => (0, Hn._)`${(0, Qa.usePattern)(e, E)}.test(${v})`))), (0, Hn.not)(b);
    }
    function p(v) {
      t.code((0, Hn._)`delete ${i}[${v}]`);
    }
    function h(v) {
      if (l.removeAdditional === "all" || l.removeAdditional && n === !1) {
        p(v);
        return;
      }
      if (n === !1) {
        e.setParams({ additionalProperty: v }), e.error(), a || t.break();
        return;
      }
      if (typeof n == "object" && !(0, Ja.alwaysValidSchema)(o, n)) {
        const b = t.name("valid");
        l.removeAdditional === "failing" ? (m(v, b, !1), t.if((0, Hn.not)(b), () => {
          e.reset(), p(v);
        })) : (m(v, b), a || t.if((0, Hn.not)(b), () => t.break()));
      }
    }
    function m(v, b, E) {
      const y = {
        keyword: "additionalProperties",
        dataProp: v,
        dataPropType: Ja.Type.Str
      };
      E === !1 && Object.assign(y, {
        compositeRule: !0,
        createErrors: !1,
        allErrors: !1
      }), e.subschema(y, b);
    }
  }
};
Fu.default = oL;
var Yp = {};
Object.defineProperty(Yp, "__esModule", { value: !0 });
const aL = Kn, ug = tt, Tf = xe, cg = Fu, lL = {
  keyword: "properties",
  type: "object",
  schemaType: "object",
  code(e) {
    const { gen: t, schema: n, parentSchema: r, data: i, it: s } = e;
    s.opts.removeAdditional === "all" && r.additionalProperties === void 0 && cg.default.code(new aL.KeywordCxt(s, cg.default, "additionalProperties"));
    const o = (0, ug.allSchemaProperties)(n);
    for (const f of o)
      s.definedProperties.add(f);
    s.opts.unevaluated && o.length && s.props !== !0 && (s.props = Tf.mergeEvaluated.props(t, (0, Tf.toHash)(o), s.props));
    const a = o.filter((f) => !(0, Tf.alwaysValidSchema)(s, n[f]));
    if (a.length === 0)
      return;
    const l = t.name("valid");
    for (const f of a)
      c(f) ? u(f) : (t.if((0, ug.propertyInData)(t, i, f, s.opts.ownProperties)), u(f), s.allErrors || t.else().var(l, !0), t.endIf()), e.it.definedProperties.add(f), e.ok(l);
    function c(f) {
      return s.opts.useDefaults && !s.compositeRule && n[f].default !== void 0;
    }
    function u(f) {
      e.subschema({
        keyword: "properties",
        schemaProp: f,
        dataProp: f
      }, l);
    }
  }
};
Yp.default = lL;
var Xp = {};
Object.defineProperty(Xp, "__esModule", { value: !0 });
const fg = tt, Ka = Xe, dg = xe, pg = xe, uL = {
  keyword: "patternProperties",
  type: "object",
  schemaType: "object",
  code(e) {
    const { gen: t, schema: n, data: r, parentSchema: i, it: s } = e, { opts: o } = s, a = (0, fg.allSchemaProperties)(n), l = a.filter((m) => (0, dg.alwaysValidSchema)(s, n[m]));
    if (a.length === 0 || l.length === a.length && (!s.opts.unevaluated || s.props === !0))
      return;
    const c = o.strictSchema && !o.allowMatchingProperties && i.properties, u = t.name("valid");
    s.props !== !0 && !(s.props instanceof Ka.Name) && (s.props = (0, pg.evaluatedPropsToName)(t, s.props));
    const { props: f } = s;
    d();
    function d() {
      for (const m of a)
        c && p(m), s.allErrors ? h(m) : (t.var(u, !0), h(m), t.if(u));
    }
    function p(m) {
      for (const v in c)
        new RegExp(m).test(v) && (0, dg.checkStrictMode)(s, `property ${v} matches pattern ${m} (use allowMatchingProperties)`);
    }
    function h(m) {
      t.forIn("key", r, (v) => {
        t.if((0, Ka._)`${(0, fg.usePattern)(e, m)}.test(${v})`, () => {
          const b = l.includes(m);
          b || e.subschema({
            keyword: "patternProperties",
            schemaProp: m,
            dataProp: v,
            dataPropType: pg.Type.Str
          }, u), s.opts.unevaluated && f !== !0 ? t.assign((0, Ka._)`${f}[${v}]`, !0) : !b && !s.allErrors && t.if((0, Ka.not)(u), () => t.break());
        });
      });
    }
  }
};
Xp.default = uL;
var Zp = {};
Object.defineProperty(Zp, "__esModule", { value: !0 });
const cL = xe, fL = {
  keyword: "not",
  schemaType: ["object", "boolean"],
  trackErrors: !0,
  code(e) {
    const { gen: t, schema: n, it: r } = e;
    if ((0, cL.alwaysValidSchema)(r, n)) {
      e.fail();
      return;
    }
    const i = t.name("valid");
    e.subschema({
      keyword: "not",
      compositeRule: !0,
      createErrors: !1,
      allErrors: !1
    }, i), e.failResult(i, () => e.reset(), () => e.error());
  },
  error: { message: "must NOT be valid" }
};
Zp.default = fL;
var eh = {};
Object.defineProperty(eh, "__esModule", { value: !0 });
const dL = tt, pL = {
  keyword: "anyOf",
  schemaType: "array",
  trackErrors: !0,
  code: dL.validateUnion,
  error: { message: "must match a schema in anyOf" }
};
eh.default = pL;
var th = {};
Object.defineProperty(th, "__esModule", { value: !0 });
const wl = Xe, hL = xe, mL = {
  message: "must match exactly one schema in oneOf",
  params: ({ params: e }) => (0, wl._)`{passingSchemas: ${e.passing}}`
}, yL = {
  keyword: "oneOf",
  schemaType: "array",
  trackErrors: !0,
  error: mL,
  code(e) {
    const { gen: t, schema: n, parentSchema: r, it: i } = e;
    if (!Array.isArray(n))
      throw new Error("ajv implementation error");
    if (i.opts.discriminator && r.discriminator)
      return;
    const s = n, o = t.let("valid", !1), a = t.let("passing", null), l = t.name("_valid");
    e.setParams({ passing: a }), t.block(c), e.result(o, () => e.reset(), () => e.error(!0));
    function c() {
      s.forEach((u, f) => {
        let d;
        (0, hL.alwaysValidSchema)(i, u) ? t.var(l, !0) : d = e.subschema({
          keyword: "oneOf",
          schemaProp: f,
          compositeRule: !0
        }, l), f > 0 && t.if((0, wl._)`${l} && ${o}`).assign(o, !1).assign(a, (0, wl._)`[${a}, ${f}]`).else(), t.if(l, () => {
          t.assign(o, !0), t.assign(a, f), d && e.mergeEvaluated(d, wl.Name);
        });
      });
    }
  }
};
th.default = yL;
var nh = {};
Object.defineProperty(nh, "__esModule", { value: !0 });
const gL = xe, bL = {
  keyword: "allOf",
  schemaType: "array",
  code(e) {
    const { gen: t, schema: n, it: r } = e;
    if (!Array.isArray(n))
      throw new Error("ajv implementation error");
    const i = t.name("valid");
    n.forEach((s, o) => {
      if ((0, gL.alwaysValidSchema)(r, s))
        return;
      const a = e.subschema({ keyword: "allOf", schemaProp: o }, i);
      e.ok(i), e.mergeEvaluated(a);
    });
  }
};
nh.default = bL;
var rh = {};
Object.defineProperty(rh, "__esModule", { value: !0 });
const zl = Xe, K_ = xe, vL = {
  message: ({ params: e }) => (0, zl.str)`must match "${e.ifClause}" schema`,
  params: ({ params: e }) => (0, zl._)`{failingKeyword: ${e.ifClause}}`
}, _L = {
  keyword: "if",
  schemaType: ["object", "boolean"],
  trackErrors: !0,
  error: vL,
  code(e) {
    const { gen: t, parentSchema: n, it: r } = e;
    n.then === void 0 && n.else === void 0 && (0, K_.checkStrictMode)(r, '"if" without "then" and "else" is ignored');
    const i = hg(r, "then"), s = hg(r, "else");
    if (!i && !s)
      return;
    const o = t.let("valid", !0), a = t.name("_valid");
    if (l(), e.reset(), i && s) {
      const u = t.let("ifClause");
      e.setParams({ ifClause: u }), t.if(a, c("then", u), c("else", u));
    } else
      i ? t.if(a, c("then")) : t.if((0, zl.not)(a), c("else"));
    e.pass(o, () => e.error(!0));
    function l() {
      const u = e.subschema({
        keyword: "if",
        compositeRule: !0,
        createErrors: !1,
        allErrors: !1
      }, a);
      e.mergeEvaluated(u);
    }
    function c(u, f) {
      return () => {
        const d = e.subschema({ keyword: u }, a);
        t.assign(o, a), e.mergeValidEvaluated(d, o), f ? t.assign(f, (0, zl._)`${u}`) : e.setParams({ ifClause: u });
      };
    }
  }
};
function hg(e, t) {
  const n = e.schema[t];
  return n !== void 0 && !(0, K_.alwaysValidSchema)(e, n);
}
rh.default = _L;
var ih = {};
Object.defineProperty(ih, "__esModule", { value: !0 });
const wL = xe, EL = {
  keyword: ["then", "else"],
  schemaType: ["object", "boolean"],
  code({ keyword: e, parentSchema: t, it: n }) {
    t.if === void 0 && (0, wL.checkStrictMode)(n, `"${e}" without "if" is ignored`);
  }
};
ih.default = EL;
Object.defineProperty(Hp, "__esModule", { value: !0 });
const SL = Ms, TL = Wp, $L = Fs, NL = Qp, OL = Jp, IL = Q_, RL = Kp, AL = Fu, xL = Yp, DL = Xp, PL = Zp, kL = eh, LL = th, jL = nh, CL = rh, ML = ih;
function FL(e = !1) {
  const t = [
    // any
    PL.default,
    kL.default,
    LL.default,
    jL.default,
    CL.default,
    ML.default,
    // object
    RL.default,
    AL.default,
    IL.default,
    xL.default,
    DL.default
  ];
  return e ? t.push(TL.default, NL.default) : t.push(SL.default, $L.default), t.push(OL.default), t;
}
Hp.default = FL;
var sh = {}, oh = {};
Object.defineProperty(oh, "__esModule", { value: !0 });
const Lt = Xe, UL = {
  message: ({ schemaCode: e }) => (0, Lt.str)`must match format "${e}"`,
  params: ({ schemaCode: e }) => (0, Lt._)`{format: ${e}}`
}, VL = {
  keyword: "format",
  type: ["number", "string"],
  schemaType: "string",
  $data: !0,
  error: UL,
  code(e, t) {
    const { gen: n, data: r, $data: i, schema: s, schemaCode: o, it: a } = e, { opts: l, errSchemaPath: c, schemaEnv: u, self: f } = a;
    if (!l.validateFormats)
      return;
    i ? d() : p();
    function d() {
      const h = n.scopeValue("formats", {
        ref: f.formats,
        code: l.code.formats
      }), m = n.const("fDef", (0, Lt._)`${h}[${o}]`), v = n.let("fType"), b = n.let("format");
      n.if((0, Lt._)`typeof ${m} == "object" && !(${m} instanceof RegExp)`, () => n.assign(v, (0, Lt._)`${m}.type || "string"`).assign(b, (0, Lt._)`${m}.validate`), () => n.assign(v, (0, Lt._)`"string"`).assign(b, m)), e.fail$data((0, Lt.or)(E(), y()));
      function E() {
        return l.strictSchema === !1 ? Lt.nil : (0, Lt._)`${o} && !${b}`;
      }
      function y() {
        const D = u.$async ? (0, Lt._)`(${m}.async ? await ${b}(${r}) : ${b}(${r}))` : (0, Lt._)`${b}(${r})`, F = (0, Lt._)`(typeof ${b} == "function" ? ${D} : ${b}.test(${r}))`;
        return (0, Lt._)`${b} && ${b} !== true && ${v} === ${t} && !${F}`;
      }
    }
    function p() {
      const h = f.formats[s];
      if (!h) {
        E();
        return;
      }
      if (h === !0)
        return;
      const [m, v, b] = y(h);
      m === t && e.pass(D());
      function E() {
        if (l.strictSchema === !1) {
          f.logger.warn(F());
          return;
        }
        throw new Error(F());
        function F() {
          return `unknown format "${s}" ignored in schema at path "${c}"`;
        }
      }
      function y(F) {
        const W = F instanceof RegExp ? (0, Lt.regexpCode)(F) : l.code.formats ? (0, Lt._)`${l.code.formats}${(0, Lt.getProperty)(s)}` : void 0, J = n.scopeValue("formats", { key: s, ref: F, code: W });
        return typeof F == "object" && !(F instanceof RegExp) ? [F.type || "string", F.validate, (0, Lt._)`${J}.validate`] : ["string", F, J];
      }
      function D() {
        if (typeof h == "object" && !(h instanceof RegExp) && h.async) {
          if (!u.$async)
            throw new Error("async format in sync schema");
          return (0, Lt._)`await ${b}(${r})`;
        }
        return typeof v == "function" ? (0, Lt._)`${b}(${r})` : (0, Lt._)`${b}.test(${r})`;
      }
    }
  }
};
oh.default = VL;
Object.defineProperty(sh, "__esModule", { value: !0 });
const BL = oh, GL = [BL.default];
sh.default = GL;
var Ts = {};
Object.defineProperty(Ts, "__esModule", { value: !0 });
Ts.contentVocabulary = Ts.metadataVocabulary = void 0;
Ts.metadataVocabulary = [
  "title",
  "description",
  "default",
  "deprecated",
  "readOnly",
  "writeOnly",
  "examples"
];
Ts.contentVocabulary = [
  "contentMediaType",
  "contentEncoding",
  "contentSchema"
];
Object.defineProperty(xp, "__esModule", { value: !0 });
const zL = Dp, qL = kp, HL = Hp, WL = sh, mg = Ts, QL = [
  zL.default,
  qL.default,
  (0, HL.default)(),
  WL.default,
  mg.metadataVocabulary,
  mg.contentVocabulary
];
xp.default = QL;
var ah = {}, Uu = {};
Object.defineProperty(Uu, "__esModule", { value: !0 });
Uu.DiscrError = void 0;
var yg;
(function(e) {
  e.Tag = "tag", e.Mapping = "mapping";
})(yg || (Uu.DiscrError = yg = {}));
Object.defineProperty(ah, "__esModule", { value: !0 });
const cs = Xe, fd = Uu, gg = cn, JL = js, KL = xe, YL = {
  message: ({ params: { discrError: e, tagName: t } }) => e === fd.DiscrError.Tag ? `tag "${t}" must be string` : `value of tag "${t}" must be in oneOf`,
  params: ({ params: { discrError: e, tag: t, tagName: n } }) => (0, cs._)`{error: ${e}, tag: ${n}, tagValue: ${t}}`
}, XL = {
  keyword: "discriminator",
  type: "object",
  schemaType: "object",
  error: YL,
  code(e) {
    const { gen: t, data: n, schema: r, parentSchema: i, it: s } = e, { oneOf: o } = i;
    if (!s.opts.discriminator)
      throw new Error("discriminator: requires discriminator option");
    const a = r.propertyName;
    if (typeof a != "string")
      throw new Error("discriminator: requires propertyName");
    if (r.mapping)
      throw new Error("discriminator: mapping is not supported");
    if (!o)
      throw new Error("discriminator: requires oneOf keyword");
    const l = t.let("valid", !1), c = t.const("tag", (0, cs._)`${n}${(0, cs.getProperty)(a)}`);
    t.if((0, cs._)`typeof ${c} == "string"`, () => u(), () => e.error(!1, { discrError: fd.DiscrError.Tag, tag: c, tagName: a })), e.ok(l);
    function u() {
      const p = d();
      t.if(!1);
      for (const h in p)
        t.elseIf((0, cs._)`${c} === ${h}`), t.assign(l, f(p[h]));
      t.else(), e.error(!1, { discrError: fd.DiscrError.Mapping, tag: c, tagName: a }), t.endIf();
    }
    function f(p) {
      const h = t.name("valid"), m = e.subschema({ keyword: "oneOf", schemaProp: p }, h);
      return e.mergeEvaluated(m, cs.Name), h;
    }
    function d() {
      var p;
      const h = {}, m = b(i);
      let v = !0;
      for (let D = 0; D < o.length; D++) {
        let F = o[D];
        if (F?.$ref && !(0, KL.schemaHasRulesButRef)(F, s.self.RULES)) {
          const J = F.$ref;
          if (F = gg.resolveRef.call(s.self, s.schemaEnv.root, s.baseId, J), F instanceof gg.SchemaEnv && (F = F.schema), F === void 0)
            throw new JL.default(s.opts.uriResolver, s.baseId, J);
        }
        const W = (p = F?.properties) === null || p === void 0 ? void 0 : p[a];
        if (typeof W != "object")
          throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${a}"`);
        v = v && (m || b(F)), E(W, D);
      }
      if (!v)
        throw new Error(`discriminator: "${a}" must be required`);
      return h;
      function b({ required: D }) {
        return Array.isArray(D) && D.includes(a);
      }
      function E(D, F) {
        if (D.const)
          y(D.const, F);
        else if (D.enum)
          for (const W of D.enum)
            y(W, F);
        else
          throw new Error(`discriminator: "properties/${a}" must have "const" or "enum"`);
      }
      function y(D, F) {
        if (typeof D != "string" || D in h)
          throw new Error(`discriminator: "${a}" values must be unique strings`);
        h[D] = F;
      }
    }
  }
};
ah.default = XL;
const ZL = "http://json-schema.org/draft-07/schema#", ej = "http://json-schema.org/draft-07/schema#", tj = "Core schema meta-schema", nj = {
  schemaArray: {
    type: "array",
    minItems: 1,
    items: {
      $ref: "#"
    }
  },
  nonNegativeInteger: {
    type: "integer",
    minimum: 0
  },
  nonNegativeIntegerDefault0: {
    allOf: [
      {
        $ref: "#/definitions/nonNegativeInteger"
      },
      {
        default: 0
      }
    ]
  },
  simpleTypes: {
    enum: [
      "array",
      "boolean",
      "integer",
      "null",
      "number",
      "object",
      "string"
    ]
  },
  stringArray: {
    type: "array",
    items: {
      type: "string"
    },
    uniqueItems: !0,
    default: []
  }
}, rj = [
  "object",
  "boolean"
], ij = {
  $id: {
    type: "string",
    format: "uri-reference"
  },
  $schema: {
    type: "string",
    format: "uri"
  },
  $ref: {
    type: "string",
    format: "uri-reference"
  },
  $comment: {
    type: "string"
  },
  title: {
    type: "string"
  },
  description: {
    type: "string"
  },
  default: !0,
  readOnly: {
    type: "boolean",
    default: !1
  },
  examples: {
    type: "array",
    items: !0
  },
  multipleOf: {
    type: "number",
    exclusiveMinimum: 0
  },
  maximum: {
    type: "number"
  },
  exclusiveMaximum: {
    type: "number"
  },
  minimum: {
    type: "number"
  },
  exclusiveMinimum: {
    type: "number"
  },
  maxLength: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minLength: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  pattern: {
    type: "string",
    format: "regex"
  },
  additionalItems: {
    $ref: "#"
  },
  items: {
    anyOf: [
      {
        $ref: "#"
      },
      {
        $ref: "#/definitions/schemaArray"
      }
    ],
    default: !0
  },
  maxItems: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minItems: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  uniqueItems: {
    type: "boolean",
    default: !1
  },
  contains: {
    $ref: "#"
  },
  maxProperties: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minProperties: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  required: {
    $ref: "#/definitions/stringArray"
  },
  additionalProperties: {
    $ref: "#"
  },
  definitions: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    default: {}
  },
  properties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    default: {}
  },
  patternProperties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    propertyNames: {
      format: "regex"
    },
    default: {}
  },
  dependencies: {
    type: "object",
    additionalProperties: {
      anyOf: [
        {
          $ref: "#"
        },
        {
          $ref: "#/definitions/stringArray"
        }
      ]
    }
  },
  propertyNames: {
    $ref: "#"
  },
  const: !0,
  enum: {
    type: "array",
    items: !0,
    minItems: 1,
    uniqueItems: !0
  },
  type: {
    anyOf: [
      {
        $ref: "#/definitions/simpleTypes"
      },
      {
        type: "array",
        items: {
          $ref: "#/definitions/simpleTypes"
        },
        minItems: 1,
        uniqueItems: !0
      }
    ]
  },
  format: {
    type: "string"
  },
  contentMediaType: {
    type: "string"
  },
  contentEncoding: {
    type: "string"
  },
  if: {
    $ref: "#"
  },
  then: {
    $ref: "#"
  },
  else: {
    $ref: "#"
  },
  allOf: {
    $ref: "#/definitions/schemaArray"
  },
  anyOf: {
    $ref: "#/definitions/schemaArray"
  },
  oneOf: {
    $ref: "#/definitions/schemaArray"
  },
  not: {
    $ref: "#"
  }
}, sj = {
  $schema: ZL,
  $id: ej,
  title: tj,
  definitions: nj,
  type: rj,
  properties: ij,
  default: !0
};
(function(e, t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.MissingRefError = t.ValidationError = t.CodeGen = t.Name = t.nil = t.stringify = t.str = t._ = t.KeywordCxt = t.Ajv = void 0;
  const n = n_, r = xp, i = ah, s = sj, o = ["/properties"], a = "http://json-schema.org/draft-07/schema";
  class l extends n.default {
    _addVocabularies() {
      super._addVocabularies(), r.default.forEach((h) => this.addVocabulary(h)), this.opts.discriminator && this.addKeyword(i.default);
    }
    _addDefaultMetaSchema() {
      if (super._addDefaultMetaSchema(), !this.opts.meta)
        return;
      const h = this.opts.$data ? this.$dataMetaSchema(s, o) : s;
      this.addMetaSchema(h, a, !1), this.refs["http://json-schema.org/schema"] = a;
    }
    defaultMeta() {
      return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(a) ? a : void 0);
    }
  }
  t.Ajv = l, e.exports = t = l, e.exports.Ajv = l, Object.defineProperty(t, "__esModule", { value: !0 }), t.default = l;
  var c = Kn;
  Object.defineProperty(t, "KeywordCxt", { enumerable: !0, get: function() {
    return c.KeywordCxt;
  } });
  var u = Xe;
  Object.defineProperty(t, "_", { enumerable: !0, get: function() {
    return u._;
  } }), Object.defineProperty(t, "str", { enumerable: !0, get: function() {
    return u.str;
  } }), Object.defineProperty(t, "stringify", { enumerable: !0, get: function() {
    return u.stringify;
  } }), Object.defineProperty(t, "nil", { enumerable: !0, get: function() {
    return u.nil;
  } }), Object.defineProperty(t, "Name", { enumerable: !0, get: function() {
    return u.Name;
  } }), Object.defineProperty(t, "CodeGen", { enumerable: !0, get: function() {
    return u.CodeGen;
  } });
  var f = va;
  Object.defineProperty(t, "ValidationError", { enumerable: !0, get: function() {
    return f.default;
  } });
  var d = js;
  Object.defineProperty(t, "MissingRefError", { enumerable: !0, get: function() {
    return d.default;
  } });
})(rd, rd.exports);
var Y_ = rd.exports, Vu = { exports: {} };
const oj = {
  0: 0,
  1: 1,
  2: 2,
  3: 3,
  4: 4,
  5: 5,
  6: 6,
  7: 7,
  8: 8,
  9: 9,
  a: 10,
  A: 10,
  b: 11,
  B: 11,
  c: 12,
  C: 12,
  d: 13,
  D: 13,
  e: 14,
  E: 14,
  f: 15,
  F: 15
};
var aj = {
  HEX: oj
};
const { HEX: lj } = aj;
function X_(e) {
  if (ew(e, ".") < 3)
    return { host: e, isIPV4: !1 };
  const t = e.match(/^(\b[01]?\d{1,2}|\b2[0-4]\d|\b25[0-5])(\.([01]?\d{1,2}|2[0-4]\d|25[0-5])){3}$/u) || [], [n] = t;
  return n ? { host: cj(n, "."), isIPV4: !0 } : { host: e, isIPV4: !1 };
}
function dd(e) {
  let t = "", n = !0;
  for (const r of e) {
    if (r !== "0" && n === !0 && (n = !1), lj[r] === void 0)
      return;
    n || (t += r);
  }
  return t;
}
function uj(e) {
  let t = 0;
  const n = { error: !1, address: "", zone: "" }, r = [], i = [];
  let s = !1, o = !1, a = !1;
  function l() {
    if (i.length) {
      if (s === !1) {
        const c = dd(i.join(""));
        if (c !== void 0)
          r.push(c);
        else
          return n.error = !0, !1;
      }
      i.length = 0;
    }
    return !0;
  }
  for (let c = 0; c < e.length; c++) {
    const u = e[c];
    if (!(u === "[" || u === "]"))
      if (u === ":") {
        if (o === !0 && (a = !0), !l())
          break;
        if (t++, r.push(":"), t > 7) {
          n.error = !0;
          break;
        }
        c - 1 >= 0 && e[c - 1] === ":" && (o = !0);
        continue;
      } else if (u === "%") {
        if (!l())
          break;
        s = !0;
      } else {
        i.push(u);
        continue;
      }
  }
  return i.length && (s ? n.zone = i.join("") : a ? r.push(i.join("")) : r.push(dd(i.join("")))), n.address = r.join(""), n;
}
function Z_(e, t = {}) {
  if (ew(e, ":") < 2)
    return { host: e, isIPV6: !1 };
  const n = uj(e);
  if (n.error)
    return { host: e, isIPV6: !1 };
  {
    let r = n.address, i = n.address;
    return n.zone && (r += "%" + n.zone, i += "%25" + n.zone), { host: r, escapedHost: i, isIPV6: !0 };
  }
}
function cj(e, t) {
  let n = "", r = !0;
  const i = e.length;
  for (let s = 0; s < i; s++) {
    const o = e[s];
    o === "0" && r ? (s + 1 <= i && e[s + 1] === t || s + 1 === i) && (n += o, r = !1) : (o === t ? r = !0 : r = !1, n += o);
  }
  return n;
}
function ew(e, t) {
  let n = 0;
  for (let r = 0; r < e.length; r++)
    e[r] === t && n++;
  return n;
}
const bg = /^\.\.?\//u, vg = /^\/\.(?:\/|$)/u, _g = /^\/\.\.(?:\/|$)/u, fj = /^\/?(?:.|\n)*?(?=\/|$)/u;
function dj(e) {
  const t = [];
  for (; e.length; )
    if (e.match(bg))
      e = e.replace(bg, "");
    else if (e.match(vg))
      e = e.replace(vg, "/");
    else if (e.match(_g))
      e = e.replace(_g, "/"), t.pop();
    else if (e === "." || e === "..")
      e = "";
    else {
      const n = e.match(fj);
      if (n) {
        const r = n[0];
        e = e.slice(r.length), t.push(r);
      } else
        throw new Error("Unexpected dot segment condition");
    }
  return t.join("");
}
function pj(e, t) {
  const n = t !== !0 ? escape : unescape;
  return e.scheme !== void 0 && (e.scheme = n(e.scheme)), e.userinfo !== void 0 && (e.userinfo = n(e.userinfo)), e.host !== void 0 && (e.host = n(e.host)), e.path !== void 0 && (e.path = n(e.path)), e.query !== void 0 && (e.query = n(e.query)), e.fragment !== void 0 && (e.fragment = n(e.fragment)), e;
}
function hj(e, t) {
  const n = [];
  if (e.userinfo !== void 0 && (n.push(e.userinfo), n.push("@")), e.host !== void 0) {
    let r = unescape(e.host);
    const i = X_(r);
    if (i.isIPV4)
      r = i.host;
    else {
      const s = Z_(i.host, { isIPV4: !1 });
      s.isIPV6 === !0 ? r = `[${s.escapedHost}]` : r = e.host;
    }
    n.push(r);
  }
  return (typeof e.port == "number" || typeof e.port == "string") && (n.push(":"), n.push(String(e.port))), n.length ? n.join("") : void 0;
}
var mj = {
  recomposeAuthority: hj,
  normalizeComponentEncoding: pj,
  removeDotSegments: dj,
  normalizeIPv4: X_,
  normalizeIPv6: Z_,
  stringToHexStripped: dd
};
const yj = /^[\da-f]{8}\b-[\da-f]{4}\b-[\da-f]{4}\b-[\da-f]{4}\b-[\da-f]{12}$/iu, gj = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
function tw(e) {
  return typeof e.secure == "boolean" ? e.secure : String(e.scheme).toLowerCase() === "wss";
}
function nw(e) {
  return e.host || (e.error = e.error || "HTTP URIs must have a host."), e;
}
function rw(e) {
  const t = String(e.scheme).toLowerCase() === "https";
  return (e.port === (t ? 443 : 80) || e.port === "") && (e.port = void 0), e.path || (e.path = "/"), e;
}
function bj(e) {
  return e.secure = tw(e), e.resourceName = (e.path || "/") + (e.query ? "?" + e.query : ""), e.path = void 0, e.query = void 0, e;
}
function vj(e) {
  if ((e.port === (tw(e) ? 443 : 80) || e.port === "") && (e.port = void 0), typeof e.secure == "boolean" && (e.scheme = e.secure ? "wss" : "ws", e.secure = void 0), e.resourceName) {
    const [t, n] = e.resourceName.split("?");
    e.path = t && t !== "/" ? t : void 0, e.query = n, e.resourceName = void 0;
  }
  return e.fragment = void 0, e;
}
function _j(e, t) {
  if (!e.path)
    return e.error = "URN can not be parsed", e;
  const n = e.path.match(gj);
  if (n) {
    const r = t.scheme || e.scheme || "urn";
    e.nid = n[1].toLowerCase(), e.nss = n[2];
    const i = `${r}:${t.nid || e.nid}`, s = lh[i];
    e.path = void 0, s && (e = s.parse(e, t));
  } else
    e.error = e.error || "URN can not be parsed.";
  return e;
}
function wj(e, t) {
  const n = t.scheme || e.scheme || "urn", r = e.nid.toLowerCase(), i = `${n}:${t.nid || r}`, s = lh[i];
  s && (e = s.serialize(e, t));
  const o = e, a = e.nss;
  return o.path = `${r || t.nid}:${a}`, t.skipEscape = !0, o;
}
function Ej(e, t) {
  const n = e;
  return n.uuid = n.nss, n.nss = void 0, !t.tolerant && (!n.uuid || !yj.test(n.uuid)) && (n.error = n.error || "UUID is not valid."), n;
}
function Sj(e) {
  const t = e;
  return t.nss = (e.uuid || "").toLowerCase(), t;
}
const iw = {
  scheme: "http",
  domainHost: !0,
  parse: nw,
  serialize: rw
}, Tj = {
  scheme: "https",
  domainHost: iw.domainHost,
  parse: nw,
  serialize: rw
}, El = {
  scheme: "ws",
  domainHost: !0,
  parse: bj,
  serialize: vj
}, $j = {
  scheme: "wss",
  domainHost: El.domainHost,
  parse: El.parse,
  serialize: El.serialize
}, Nj = {
  scheme: "urn",
  parse: _j,
  serialize: wj,
  skipNormalize: !0
}, Oj = {
  scheme: "urn:uuid",
  parse: Ej,
  serialize: Sj,
  skipNormalize: !0
}, lh = {
  http: iw,
  https: Tj,
  ws: El,
  wss: $j,
  urn: Nj,
  "urn:uuid": Oj
};
var Ij = lh;
const { normalizeIPv6: Rj, normalizeIPv4: Aj, removeDotSegments: Oo, recomposeAuthority: xj, normalizeComponentEncoding: Ya } = mj, sw = Ij;
function Dj(e, t) {
  return typeof e == "string" ? e = pr(Br(e, t), t) : typeof e == "object" && (e = Br(pr(e, t), t)), e;
}
function Pj(e, t, n) {
  const r = Object.assign({ scheme: "null" }, n), i = ow(Br(e, r), Br(t, r), r, !0);
  return pr(i, { ...r, skipEscape: !0 });
}
function ow(e, t, n, r) {
  const i = {};
  return r || (e = Br(pr(e, n), n), t = Br(pr(t, n), n)), n = n || {}, !n.tolerant && t.scheme ? (i.scheme = t.scheme, i.userinfo = t.userinfo, i.host = t.host, i.port = t.port, i.path = Oo(t.path || ""), i.query = t.query) : (t.userinfo !== void 0 || t.host !== void 0 || t.port !== void 0 ? (i.userinfo = t.userinfo, i.host = t.host, i.port = t.port, i.path = Oo(t.path || ""), i.query = t.query) : (t.path ? (t.path.charAt(0) === "/" ? i.path = Oo(t.path) : ((e.userinfo !== void 0 || e.host !== void 0 || e.port !== void 0) && !e.path ? i.path = "/" + t.path : e.path ? i.path = e.path.slice(0, e.path.lastIndexOf("/") + 1) + t.path : i.path = t.path, i.path = Oo(i.path)), i.query = t.query) : (i.path = e.path, t.query !== void 0 ? i.query = t.query : i.query = e.query), i.userinfo = e.userinfo, i.host = e.host, i.port = e.port), i.scheme = e.scheme), i.fragment = t.fragment, i;
}
function kj(e, t, n) {
  return typeof e == "string" ? (e = unescape(e), e = pr(Ya(Br(e, n), !0), { ...n, skipEscape: !0 })) : typeof e == "object" && (e = pr(Ya(e, !0), { ...n, skipEscape: !0 })), typeof t == "string" ? (t = unescape(t), t = pr(Ya(Br(t, n), !0), { ...n, skipEscape: !0 })) : typeof t == "object" && (t = pr(Ya(t, !0), { ...n, skipEscape: !0 })), e.toLowerCase() === t.toLowerCase();
}
function pr(e, t) {
  const n = {
    host: e.host,
    scheme: e.scheme,
    userinfo: e.userinfo,
    port: e.port,
    path: e.path,
    query: e.query,
    nid: e.nid,
    nss: e.nss,
    uuid: e.uuid,
    fragment: e.fragment,
    reference: e.reference,
    resourceName: e.resourceName,
    secure: e.secure,
    error: ""
  }, r = Object.assign({}, t), i = [], s = sw[(r.scheme || n.scheme || "").toLowerCase()];
  s && s.serialize && s.serialize(n, r), n.path !== void 0 && (r.skipEscape ? n.path = unescape(n.path) : (n.path = escape(n.path), n.scheme !== void 0 && (n.path = n.path.split("%3A").join(":")))), r.reference !== "suffix" && n.scheme && (i.push(n.scheme), i.push(":"));
  const o = xj(n, r);
  if (o !== void 0 && (r.reference !== "suffix" && i.push("//"), i.push(o), n.path && n.path.charAt(0) !== "/" && i.push("/")), n.path !== void 0) {
    let a = n.path;
    !r.absolutePath && (!s || !s.absolutePath) && (a = Oo(a)), o === void 0 && (a = a.replace(/^\/\//u, "/%2F")), i.push(a);
  }
  return n.query !== void 0 && (i.push("?"), i.push(n.query)), n.fragment !== void 0 && (i.push("#"), i.push(n.fragment)), i.join("");
}
const Lj = Array.from({ length: 127 }, (e, t) => /[^!"$&'()*+,\-.;=_`a-z{}~]/u.test(String.fromCharCode(t)));
function jj(e) {
  let t = 0;
  for (let n = 0, r = e.length; n < r; ++n)
    if (t = e.charCodeAt(n), t > 126 || Lj[t])
      return !0;
  return !1;
}
const Cj = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
function Br(e, t) {
  const n = Object.assign({}, t), r = {
    scheme: void 0,
    userinfo: void 0,
    host: "",
    port: void 0,
    path: "",
    query: void 0,
    fragment: void 0
  }, i = e.indexOf("%") !== -1;
  n.reference === "suffix" && (e = (n.scheme ? n.scheme + ":" : "") + "//" + e);
  const s = e.match(Cj);
  if (s) {
    if (r.scheme = s[1], r.userinfo = s[3], r.host = s[4], r.port = parseInt(s[5], 10), r.path = s[6] || "", r.query = s[7], r.fragment = s[8], isNaN(r.port) && (r.port = s[5]), r.host) {
      const a = Aj(r.host);
      a.isIPV4 === !1 ? r.host = Rj(a.host, { isIPV4: !1 }).host.toLowerCase() : r.host = a.host;
    }
    r.scheme === void 0 && r.userinfo === void 0 && r.host === void 0 && r.port === void 0 && !r.path && r.query === void 0 ? r.reference = "same-document" : r.scheme === void 0 ? r.reference = "relative" : r.fragment === void 0 ? r.reference = "absolute" : r.reference = "uri", n.reference && n.reference !== "suffix" && n.reference !== r.reference && (r.error = r.error || "URI is not a " + n.reference + " reference.");
    const o = sw[(n.scheme || r.scheme || "").toLowerCase()];
    if (!n.unicodeSupport && (!o || !o.unicodeSupport) && r.host && (n.domainHost || o && o.domainHost) && jj(r.host))
      try {
        r.host = URL.domainToASCII(r.host.toLowerCase());
      } catch (a) {
        r.error = r.error || "Host's domain name can not be converted to ASCII: " + a;
      }
    (!o || o && !o.skipNormalize) && (i && r.scheme !== void 0 && (r.scheme = unescape(r.scheme)), i && r.userinfo !== void 0 && (r.userinfo = unescape(r.userinfo)), i && r.host !== void 0 && (r.host = unescape(r.host)), r.path !== void 0 && r.path.length && (r.path = escape(unescape(r.path))), r.fragment !== void 0 && r.fragment.length && (r.fragment = encodeURI(decodeURI(r.fragment)))), o && o.parse && o.parse(r, n);
  } else
    r.error = r.error || "URI can not be parsed.";
  return r;
}
const uh = {
  normalize: Dj,
  resolve: Pj,
  resolveComponents: ow,
  equal: kj,
  serialize: pr,
  parse: Br
};
Vu.exports = uh;
Vu.exports.default = uh;
Vu.exports.fastUri = uh;
var Mj = Vu.exports, pd = { exports: {} }, Bu = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.formatNames = e.fastFormats = e.fullFormats = void 0;
  function t(le, ce) {
    return { validate: le, compare: ce };
  }
  e.fullFormats = {
    // date: http://tools.ietf.org/html/rfc3339#section-5.6
    date: t(s, o),
    // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
    time: t(l(!0), c),
    "date-time": t(d(!0), p),
    "iso-time": t(l(), u),
    "iso-date-time": t(d(), h),
    // duration: https://tools.ietf.org/html/rfc3339#appendix-A
    duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
    uri: b,
    "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
    // uri-template: https://tools.ietf.org/html/rfc6570
    "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
    // For the source: https://gist.github.com/dperini/729294
    // For test cases: https://mathiasbynens.be/demo/url-regex
    url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
    email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
    hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
    // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
    ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/,
    ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
    regex: ee,
    // uuid: http://tools.ietf.org/html/rfc4122
    uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
    // JSON-pointer: https://tools.ietf.org/html/rfc6901
    // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
    "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
    "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
    // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
    "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
    // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types
    // byte: https://github.com/miguelmota/is-base64
    byte: y,
    // signed 32 bit integer
    int32: { type: "number", validate: W },
    // signed 64 bit integer
    int64: { type: "number", validate: J },
    // C-type float
    float: { type: "number", validate: Z },
    // C-type double
    double: { type: "number", validate: Z },
    // hint to the UI to hide input strings
    password: !0,
    // unchecked string payload
    binary: !0
  }, e.fastFormats = {
    ...e.fullFormats,
    date: t(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, o),
    time: t(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, c),
    "date-time": t(/^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, p),
    "iso-time": t(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, u),
    "iso-date-time": t(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, h),
    // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
    uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
    "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
    // email (sources from jsen validator):
    // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
    // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')
    email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
  }, e.formatNames = Object.keys(e.fullFormats);
  function n(le) {
    return le % 4 === 0 && (le % 100 !== 0 || le % 400 === 0);
  }
  const r = /^(\d\d\d\d)-(\d\d)-(\d\d)$/, i = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  function s(le) {
    const ce = r.exec(le);
    if (!ce)
      return !1;
    const U = +ce[1], z = +ce[2], ne = +ce[3];
    return z >= 1 && z <= 12 && ne >= 1 && ne <= (z === 2 && n(U) ? 29 : i[z]);
  }
  function o(le, ce) {
    if (le && ce)
      return le > ce ? 1 : le < ce ? -1 : 0;
  }
  const a = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
  function l(le) {
    return function(U) {
      const z = a.exec(U);
      if (!z)
        return !1;
      const ne = +z[1], K = +z[2], se = +z[3], re = z[4], ue = z[5] === "-" ? -1 : 1, te = +(z[6] || 0), B = +(z[7] || 0);
      if (te > 23 || B > 59 || le && !re)
        return !1;
      if (ne <= 23 && K <= 59 && se < 60)
        return !0;
      const M = K - B * ue, N = ne - te * ue - (M < 0 ? 1 : 0);
      return (N === 23 || N === -1) && (M === 59 || M === -1) && se < 61;
    };
  }
  function c(le, ce) {
    if (!(le && ce))
      return;
    const U = (/* @__PURE__ */ new Date("2020-01-01T" + le)).valueOf(), z = (/* @__PURE__ */ new Date("2020-01-01T" + ce)).valueOf();
    if (U && z)
      return U - z;
  }
  function u(le, ce) {
    if (!(le && ce))
      return;
    const U = a.exec(le), z = a.exec(ce);
    if (U && z)
      return le = U[1] + U[2] + U[3], ce = z[1] + z[2] + z[3], le > ce ? 1 : le < ce ? -1 : 0;
  }
  const f = /t|\s/i;
  function d(le) {
    const ce = l(le);
    return function(z) {
      const ne = z.split(f);
      return ne.length === 2 && s(ne[0]) && ce(ne[1]);
    };
  }
  function p(le, ce) {
    if (!(le && ce))
      return;
    const U = new Date(le).valueOf(), z = new Date(ce).valueOf();
    if (U && z)
      return U - z;
  }
  function h(le, ce) {
    if (!(le && ce))
      return;
    const [U, z] = le.split(f), [ne, K] = ce.split(f), se = o(U, ne);
    if (se !== void 0)
      return se || c(z, K);
  }
  const m = /\/|:/, v = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
  function b(le) {
    return m.test(le) && v.test(le);
  }
  const E = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
  function y(le) {
    return E.lastIndex = 0, E.test(le);
  }
  const D = -(2 ** 31), F = 2 ** 31 - 1;
  function W(le) {
    return Number.isInteger(le) && le <= F && le >= D;
  }
  function J(le) {
    return Number.isInteger(le);
  }
  function Z() {
    return !0;
  }
  const j = /[^\\]\\Z/;
  function ee(le) {
    if (j.test(le))
      return !1;
    try {
      return new RegExp(le), !0;
    } catch {
      return !1;
    }
  }
})(Bu);
var aw = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.formatLimitDefinition = void 0;
  const t = Y_, n = Xe, r = n.operators, i = {
    formatMaximum: { okStr: "<=", ok: r.LTE, fail: r.GT },
    formatMinimum: { okStr: ">=", ok: r.GTE, fail: r.LT },
    formatExclusiveMaximum: { okStr: "<", ok: r.LT, fail: r.GTE },
    formatExclusiveMinimum: { okStr: ">", ok: r.GT, fail: r.LTE }
  }, s = {
    message: ({ keyword: a, schemaCode: l }) => (0, n.str)`should be ${i[a].okStr} ${l}`,
    params: ({ keyword: a, schemaCode: l }) => (0, n._)`{comparison: ${i[a].okStr}, limit: ${l}}`
  };
  e.formatLimitDefinition = {
    keyword: Object.keys(i),
    type: "string",
    schemaType: "string",
    $data: !0,
    error: s,
    code(a) {
      const { gen: l, data: c, schemaCode: u, keyword: f, it: d } = a, { opts: p, self: h } = d;
      if (!p.validateFormats)
        return;
      const m = new t.KeywordCxt(d, h.RULES.all.format.definition, "format");
      m.$data ? v() : b();
      function v() {
        const y = l.scopeValue("formats", {
          ref: h.formats,
          code: p.code.formats
        }), D = l.const("fmt", (0, n._)`${y}[${m.schemaCode}]`);
        a.fail$data((0, n.or)((0, n._)`typeof ${D} != "object"`, (0, n._)`${D} instanceof RegExp`, (0, n._)`typeof ${D}.compare != "function"`, E(D)));
      }
      function b() {
        const y = m.schema, D = h.formats[y];
        if (!D || D === !0)
          return;
        if (typeof D != "object" || D instanceof RegExp || typeof D.compare != "function")
          throw new Error(`"${f}": format "${y}" does not define "compare" function`);
        const F = l.scopeValue("formats", {
          key: y,
          ref: D,
          code: p.code.formats ? (0, n._)`${p.code.formats}${(0, n.getProperty)(y)}` : void 0
        });
        a.fail$data(E(F));
      }
      function E(y) {
        return (0, n._)`${y}.compare(${c}, ${u}) ${i[f].fail} 0`;
      }
    },
    dependencies: ["format"]
  };
  const o = (a) => (a.addKeyword(e.formatLimitDefinition), a);
  e.default = o;
})(aw);
(function(e, t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  const n = Bu, r = aw, i = Xe, s = new i.Name("fullFormats"), o = new i.Name("fastFormats"), a = (c, u = { keywords: !0 }) => {
    if (Array.isArray(u))
      return l(c, u, n.fullFormats, s), c;
    const [f, d] = u.mode === "fast" ? [n.fastFormats, o] : [n.fullFormats, s], p = u.formats || n.formatNames;
    return l(c, p, f, d), u.keywords && (0, r.default)(c), c;
  };
  a.get = (c, u = "full") => {
    const d = (u === "fast" ? n.fastFormats : n.fullFormats)[c];
    if (!d)
      throw new Error(`Unknown format "${c}"`);
    return d;
  };
  function l(c, u, f, d) {
    var p, h;
    (p = (h = c.opts.code).formats) !== null && p !== void 0 || (h.formats = (0, i._)`require("ajv-formats/dist/formats").${d}`);
    for (const m of u)
      c.addFormat(m, f[m]);
  }
  e.exports = t = a, Object.defineProperty(t, "__esModule", { value: !0 }), t.default = a;
})(pd, pd.exports);
var Fj = pd.exports, Uj = Vj;
function bs(e) {
  return e instanceof Buffer ? Buffer.from(e) : new e.constructor(e.buffer.slice(), e.byteOffset, e.length);
}
function Vj(e) {
  if (e = e || {}, e.circles)
    return Bj(e);
  const t = /* @__PURE__ */ new Map();
  if (t.set(Date, (o) => new Date(o)), t.set(Map, (o, a) => new Map(r(Array.from(o), a))), t.set(Set, (o, a) => new Set(r(Array.from(o), a))), e.constructorHandlers)
    for (const o of e.constructorHandlers)
      t.set(o[0], o[1]);
  let n = null;
  return e.proto ? s : i;
  function r(o, a) {
    const l = Object.keys(o), c = new Array(l.length);
    for (let u = 0; u < l.length; u++) {
      const f = l[u], d = o[f];
      typeof d != "object" || d === null ? c[f] = d : d.constructor !== Object && (n = t.get(d.constructor)) ? c[f] = n(d, a) : ArrayBuffer.isView(d) ? c[f] = bs(d) : c[f] = a(d);
    }
    return c;
  }
  function i(o) {
    if (typeof o != "object" || o === null)
      return o;
    if (Array.isArray(o))
      return r(o, i);
    if (o.constructor !== Object && (n = t.get(o.constructor)))
      return n(o, i);
    const a = {};
    for (const l in o) {
      if (Object.hasOwnProperty.call(o, l) === !1)
        continue;
      const c = o[l];
      typeof c != "object" || c === null ? a[l] = c : c.constructor !== Object && (n = t.get(c.constructor)) ? a[l] = n(c, i) : ArrayBuffer.isView(c) ? a[l] = bs(c) : a[l] = i(c);
    }
    return a;
  }
  function s(o) {
    if (typeof o != "object" || o === null)
      return o;
    if (Array.isArray(o))
      return r(o, s);
    if (o.constructor !== Object && (n = t.get(o.constructor)))
      return n(o, s);
    const a = {};
    for (const l in o) {
      const c = o[l];
      typeof c != "object" || c === null ? a[l] = c : c.constructor !== Object && (n = t.get(c.constructor)) ? a[l] = n(c, s) : ArrayBuffer.isView(c) ? a[l] = bs(c) : a[l] = s(c);
    }
    return a;
  }
}
function Bj(e) {
  const t = [], n = [], r = /* @__PURE__ */ new Map();
  if (r.set(Date, (l) => new Date(l)), r.set(Map, (l, c) => new Map(s(Array.from(l), c))), r.set(Set, (l, c) => new Set(s(Array.from(l), c))), e.constructorHandlers)
    for (const l of e.constructorHandlers)
      r.set(l[0], l[1]);
  let i = null;
  return e.proto ? a : o;
  function s(l, c) {
    const u = Object.keys(l), f = new Array(u.length);
    for (let d = 0; d < u.length; d++) {
      const p = u[d], h = l[p];
      if (typeof h != "object" || h === null)
        f[p] = h;
      else if (h.constructor !== Object && (i = r.get(h.constructor)))
        f[p] = i(h, c);
      else if (ArrayBuffer.isView(h))
        f[p] = bs(h);
      else {
        const m = t.indexOf(h);
        m !== -1 ? f[p] = n[m] : f[p] = c(h);
      }
    }
    return f;
  }
  function o(l) {
    if (typeof l != "object" || l === null)
      return l;
    if (Array.isArray(l))
      return s(l, o);
    if (l.constructor !== Object && (i = r.get(l.constructor)))
      return i(l, o);
    const c = {};
    t.push(l), n.push(c);
    for (const u in l) {
      if (Object.hasOwnProperty.call(l, u) === !1)
        continue;
      const f = l[u];
      if (typeof f != "object" || f === null)
        c[u] = f;
      else if (f.constructor !== Object && (i = r.get(f.constructor)))
        c[u] = i(f, o);
      else if (ArrayBuffer.isView(f))
        c[u] = bs(f);
      else {
        const d = t.indexOf(f);
        d !== -1 ? c[u] = n[d] : c[u] = o(f);
      }
    }
    return t.pop(), n.pop(), c;
  }
  function a(l) {
    if (typeof l != "object" || l === null)
      return l;
    if (Array.isArray(l))
      return s(l, a);
    if (l.constructor !== Object && (i = r.get(l.constructor)))
      return i(l, a);
    const c = {};
    t.push(l), n.push(c);
    for (const u in l) {
      const f = l[u];
      if (typeof f != "object" || f === null)
        c[u] = f;
      else if (f.constructor !== Object && (i = r.get(f.constructor)))
        c[u] = i(f, a);
      else if (ArrayBuffer.isView(f))
        c[u] = bs(f);
      else {
        const d = t.indexOf(f);
        d !== -1 ? c[u] = n[d] : c[u] = a(f);
      }
    }
    return t.pop(), n.pop(), c;
  }
}
const Gj = Y_, zj = Mj, qj = Fj, Hj = Uj({ proto: !0 });
let Wj = class lw {
  constructor(t) {
    this.ajv = new Gj({
      ...t,
      strictSchema: !1,
      validateSchema: !1,
      allowUnionTypes: !0,
      uriResolver: zj
    }), qj(this.ajv), this.ajv.addKeyword({
      keyword: "fjs_type",
      type: "object",
      errors: !1,
      validate: (n, r) => r instanceof Date
    }), this._ajvSchemas = {}, this._ajvOptions = t || {};
  }
  addSchema(t, n) {
    let r = t.$id || n;
    if (t.$id !== void 0 && t.$id[0] === "#" && (r = n + t.$id), this.ajv.refs[r] === void 0 && this.ajv.schemas[r] === void 0) {
      const i = Hj(t);
      this.convertSchemaToAjvFormat(i), this.ajv.addSchema(i, r), this._ajvSchemas[r] = t;
    }
  }
  validate(t, n) {
    return this.ajv.validate(t, n);
  }
  // Ajv does not support js date format. In order to properly validate objects containing a date,
  // it needs to replace all occurrences of the string date format with a custom keyword fjs_type.
  // (see https://github.com/fastify/fast-json-stringify/pull/441)
  convertSchemaToAjvFormat(t) {
    if (t !== null) {
      t.type === "string" ? (t.fjs_type = "string", t.type = ["string", "object"]) : Array.isArray(t.type) && t.type.includes("string") && !t.type.includes("object") && (t.fjs_type = "string", t.type.push("object"));
      for (const n in t)
        typeof t[n] == "object" && this.convertSchemaToAjvFormat(t[n]);
    }
  }
  getState() {
    return {
      ajvOptions: this._ajvOptions,
      ajvSchemas: this._ajvSchemas
    };
  }
  static restoreFromState(t) {
    const n = new lw(t.ajvOptions);
    for (const [r, i] of Object.entries(t.ajvSchemas))
      n.ajv.addSchema(i, r);
    return n;
  }
};
var uw = Wj;
let Qj = class cw {
  constructor(t, n, r = "#") {
    this.schema = t, this.schemaId = n, this.jsonPointer = r;
  }
  getPropertyLocation(t) {
    return new cw(
      this.schema[t],
      this.schemaId,
      this.jsonPointer + "/" + t
    );
  }
  getSchemaRef() {
    return this.schemaId + this.jsonPointer;
  }
};
var Jj = Qj, ch = { exports: {} };
ch.exports = Se;
ch.exports.default = Se;
const Kj = { $schema: "http://json-schema.org/draft-07/schema#", $id: "http://json-schema.org/draft-07/schema#", title: "Core schema meta-schema", definitions: { schemaArray: { type: "array", minItems: 1, items: { $ref: "#" } }, nonNegativeInteger: { type: "integer", minimum: 0 }, nonNegativeIntegerDefault0: { allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }] }, simpleTypes: { enum: ["array", "boolean", "integer", "null", "number", "object", "string"] }, stringArray: { type: "array", items: { type: "string" }, uniqueItems: !0, default: [] } }, type: ["object", "boolean"], properties: { $id: { type: "string", format: "uri-reference" }, $schema: { type: "string", format: "uri" }, $ref: { type: "string", format: "uri-reference" }, $comment: { type: "string" }, title: { type: "string" }, description: { type: "string" }, default: !0, readOnly: { type: "boolean", default: !1 }, examples: { type: "array", items: !0 }, multipleOf: { type: "number", exclusiveMinimum: 0 }, maximum: { type: "number" }, exclusiveMaximum: { type: "number" }, minimum: { type: "number" }, exclusiveMinimum: { type: "number" }, maxLength: { $ref: "#/definitions/nonNegativeInteger" }, minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, pattern: { type: "string", format: "regex" }, additionalItems: { $ref: "#" }, items: { anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }], default: !0 }, maxItems: { $ref: "#/definitions/nonNegativeInteger" }, minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, uniqueItems: { type: "boolean", default: !1 }, contains: { $ref: "#" }, maxProperties: { $ref: "#/definitions/nonNegativeInteger" }, minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, required: { $ref: "#/definitions/stringArray" }, additionalProperties: { $ref: "#" }, definitions: { type: "object", additionalProperties: { $ref: "#" }, default: {} }, properties: { type: "object", additionalProperties: { $ref: "#" }, default: {} }, patternProperties: { type: "object", additionalProperties: { $ref: "#" }, propertyNames: { format: "regex" }, default: {} }, dependencies: { type: "object", additionalProperties: { anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }] } }, propertyNames: { $ref: "#" }, const: !0, enum: { type: "array", items: !0, minItems: 1, uniqueItems: !0 }, type: { anyOf: [{ $ref: "#/definitions/simpleTypes" }, { type: "array", items: { $ref: "#/definitions/simpleTypes" }, minItems: 1, uniqueItems: !0 }] }, format: { type: "string" }, contentMediaType: { type: "string" }, contentEncoding: { type: "string" }, if: { $ref: "#" }, then: { $ref: "#" }, else: { $ref: "#" }, allOf: { $ref: "#/definitions/schemaArray" }, anyOf: { $ref: "#/definitions/schemaArray" }, oneOf: { $ref: "#/definitions/schemaArray" }, not: { $ref: "#" } }, default: !0 }, wg = { enum: ["array", "boolean", "integer", "null", "number", "object", "string"] }, Eg = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i, Yj = Bu.fullFormats.uri, Sg = Bu.fullFormats.regex;
function $n(e, { instancePath: t = "", parentData: n, parentDataProperty: r, rootData: i = e } = {}) {
  let s = null, o = 0;
  return typeof e == "number" && !(e % 1) && !isNaN(e) && isFinite(e) ? typeof e == "number" && isFinite(e) && (e < 0 || isNaN(e)) ? ($n.errors = [{ instancePath: t, schemaPath: "#/definitions/nonNegativeInteger/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" }], !1) : ($n.errors = s, o === 0) : ($n.errors = [{ instancePath: t, schemaPath: "#/definitions/nonNegativeInteger/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }], !1);
}
const $f = { validate: Se };
function rn(e, { instancePath: t = "", parentData: n, parentDataProperty: r, rootData: i = e } = {}) {
  let s = null, o = 0;
  if (o === 0)
    if (Array.isArray(e)) {
      if (e.length < 1)
        return rn.errors = [{ instancePath: t, schemaPath: "#/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items" }], !1;
      {
        var a = !0;
        const l = e.length;
        for (let c = 0; c < l; c++) {
          const u = o;
          $f.validate(e[c], { instancePath: t + "/" + c, parentData: e, parentDataProperty: c, rootData: i }) || (s = s === null ? $f.validate.errors : s.concat($f.validate.errors), o = s.length);
          var a = u === o;
          if (!a)
            break;
        }
      }
    } else
      return rn.errors = [{ instancePath: t, schemaPath: "#/type", keyword: "type", params: { type: "array" }, message: "must be array" }], !1;
  return rn.errors = s, o === 0;
}
const Tg = Cs.default;
function Se(e, { instancePath: t = "", parentData: n, parentDataProperty: r, rootData: i = e } = {}) {
  let s = null, o = 0;
  if (!(e && typeof e == "object" && !Array.isArray(e)) && typeof e != "boolean")
    return Se.errors = [{ instancePath: t, schemaPath: "#/type", keyword: "type", params: { type: Kj.type }, message: "must be object,boolean" }], !1;
  if (o === 0 && e && typeof e == "object" && !Array.isArray(e)) {
    if (e.$id !== void 0) {
      let y = e.$id;
      const D = o;
      if (o === D && o === D)
        if (typeof y == "string") {
          if (!Eg.test(y))
            return Se.errors = [{ instancePath: t + "/$id", schemaPath: "#/properties/%24id/format", keyword: "format", params: { format: "uri-reference" }, message: 'must match format "uri-reference"' }], !1;
        } else
          return Se.errors = [{ instancePath: t + "/$id", schemaPath: "#/properties/%24id/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
      var a = D === o;
    } else
      var a = !0;
    if (a) {
      if (e.$schema !== void 0) {
        let y = e.$schema;
        const D = o;
        if (o === D && o === D)
          if (typeof y == "string") {
            if (!Yj(y))
              return Se.errors = [{ instancePath: t + "/$schema", schemaPath: "#/properties/%24schema/format", keyword: "format", params: { format: "uri" }, message: 'must match format "uri"' }], !1;
          } else
            return Se.errors = [{ instancePath: t + "/$schema", schemaPath: "#/properties/%24schema/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
        var a = D === o;
      } else
        var a = !0;
      if (a) {
        if (e.$ref !== void 0) {
          let y = e.$ref;
          const D = o;
          if (o === D && o === D)
            if (typeof y == "string") {
              if (!Eg.test(y))
                return Se.errors = [{ instancePath: t + "/$ref", schemaPath: "#/properties/%24ref/format", keyword: "format", params: { format: "uri-reference" }, message: 'must match format "uri-reference"' }], !1;
            } else
              return Se.errors = [{ instancePath: t + "/$ref", schemaPath: "#/properties/%24ref/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
          var a = D === o;
        } else
          var a = !0;
        if (a) {
          if (e.$comment !== void 0) {
            const y = o;
            if (typeof e.$comment != "string")
              return Se.errors = [{ instancePath: t + "/$comment", schemaPath: "#/properties/%24comment/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
            var a = y === o;
          } else
            var a = !0;
          if (a) {
            if (e.title !== void 0) {
              const y = o;
              if (typeof e.title != "string")
                return Se.errors = [{ instancePath: t + "/title", schemaPath: "#/properties/title/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
              var a = y === o;
            } else
              var a = !0;
            if (a) {
              if (e.description !== void 0) {
                const y = o;
                if (typeof e.description != "string")
                  return Se.errors = [{ instancePath: t + "/description", schemaPath: "#/properties/description/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
                var a = y === o;
              } else
                var a = !0;
              if (a) {
                if (e.readOnly !== void 0) {
                  const y = o;
                  if (typeof e.readOnly != "boolean")
                    return Se.errors = [{ instancePath: t + "/readOnly", schemaPath: "#/properties/readOnly/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                  var a = y === o;
                } else
                  var a = !0;
                if (a) {
                  if (e.examples !== void 0) {
                    const y = o;
                    if (o === y && !Array.isArray(e.examples))
                      return Se.errors = [{ instancePath: t + "/examples", schemaPath: "#/properties/examples/type", keyword: "type", params: { type: "array" }, message: "must be array" }], !1;
                    var a = y === o;
                  } else
                    var a = !0;
                  if (a) {
                    if (e.multipleOf !== void 0) {
                      let y = e.multipleOf;
                      const D = o;
                      if (o === D)
                        if (typeof y == "number" && isFinite(y)) {
                          if (y <= 0 || isNaN(y))
                            return Se.errors = [{ instancePath: t + "/multipleOf", schemaPath: "#/properties/multipleOf/exclusiveMinimum", keyword: "exclusiveMinimum", params: { comparison: ">", limit: 0 }, message: "must be > 0" }], !1;
                        } else
                          return Se.errors = [{ instancePath: t + "/multipleOf", schemaPath: "#/properties/multipleOf/type", keyword: "type", params: { type: "number" }, message: "must be number" }], !1;
                      var a = D === o;
                    } else
                      var a = !0;
                    if (a) {
                      if (e.maximum !== void 0) {
                        let y = e.maximum;
                        const D = o;
                        if (!(typeof y == "number" && isFinite(y)))
                          return Se.errors = [{ instancePath: t + "/maximum", schemaPath: "#/properties/maximum/type", keyword: "type", params: { type: "number" }, message: "must be number" }], !1;
                        var a = D === o;
                      } else
                        var a = !0;
                      if (a) {
                        if (e.exclusiveMaximum !== void 0) {
                          let y = e.exclusiveMaximum;
                          const D = o;
                          if (!(typeof y == "number" && isFinite(y)))
                            return Se.errors = [{ instancePath: t + "/exclusiveMaximum", schemaPath: "#/properties/exclusiveMaximum/type", keyword: "type", params: { type: "number" }, message: "must be number" }], !1;
                          var a = D === o;
                        } else
                          var a = !0;
                        if (a) {
                          if (e.minimum !== void 0) {
                            let y = e.minimum;
                            const D = o;
                            if (!(typeof y == "number" && isFinite(y)))
                              return Se.errors = [{ instancePath: t + "/minimum", schemaPath: "#/properties/minimum/type", keyword: "type", params: { type: "number" }, message: "must be number" }], !1;
                            var a = D === o;
                          } else
                            var a = !0;
                          if (a) {
                            if (e.exclusiveMinimum !== void 0) {
                              let y = e.exclusiveMinimum;
                              const D = o;
                              if (!(typeof y == "number" && isFinite(y)))
                                return Se.errors = [{ instancePath: t + "/exclusiveMinimum", schemaPath: "#/properties/exclusiveMinimum/type", keyword: "type", params: { type: "number" }, message: "must be number" }], !1;
                              var a = D === o;
                            } else
                              var a = !0;
                            if (a) {
                              if (e.maxLength !== void 0) {
                                let y = e.maxLength;
                                const D = o, F = o;
                                if (!(typeof y == "number" && !(y % 1) && !isNaN(y) && isFinite(y)))
                                  return Se.errors = [{ instancePath: t + "/maxLength", schemaPath: "#/definitions/nonNegativeInteger/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }], !1;
                                if (o === F && typeof y == "number" && isFinite(y) && (y < 0 || isNaN(y)))
                                  return Se.errors = [{ instancePath: t + "/maxLength", schemaPath: "#/definitions/nonNegativeInteger/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" }], !1;
                                var a = D === o;
                              } else
                                var a = !0;
                              if (a) {
                                if (e.minLength !== void 0) {
                                  const y = o;
                                  $n(e.minLength, { instancePath: t + "/minLength", parentData: e, parentDataProperty: "minLength", rootData: i }) || (s = s === null ? $n.errors : s.concat($n.errors), o = s.length);
                                  var a = y === o;
                                } else
                                  var a = !0;
                                if (a) {
                                  if (e.pattern !== void 0) {
                                    let y = e.pattern;
                                    const D = o;
                                    if (o === D && o === D)
                                      if (typeof y == "string") {
                                        if (!Sg(y))
                                          return Se.errors = [{ instancePath: t + "/pattern", schemaPath: "#/properties/pattern/format", keyword: "format", params: { format: "regex" }, message: 'must match format "regex"' }], !1;
                                      } else
                                        return Se.errors = [{ instancePath: t + "/pattern", schemaPath: "#/properties/pattern/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
                                    var a = D === o;
                                  } else
                                    var a = !0;
                                  if (a) {
                                    if (e.additionalItems !== void 0) {
                                      const y = o;
                                      Se(e.additionalItems, { instancePath: t + "/additionalItems", parentData: e, parentDataProperty: "additionalItems", rootData: i }) || (s = s === null ? Se.errors : s.concat(Se.errors), o = s.length);
                                      var a = y === o;
                                    } else
                                      var a = !0;
                                    if (a) {
                                      if (e.items !== void 0) {
                                        let y = e.items;
                                        const D = o, F = o;
                                        let W = !1;
                                        const J = o;
                                        Se(y, { instancePath: t + "/items", parentData: e, parentDataProperty: "items", rootData: i }) || (s = s === null ? Se.errors : s.concat(Se.errors), o = s.length);
                                        var l = J === o;
                                        if (W = W || l, !W) {
                                          const j = o;
                                          rn(y, { instancePath: t + "/items", parentData: e, parentDataProperty: "items", rootData: i }) || (s = s === null ? rn.errors : s.concat(rn.errors), o = s.length);
                                          var l = j === o;
                                          W = W || l;
                                        }
                                        if (W)
                                          o = F, s !== null && (F ? s.length = F : s = null);
                                        else {
                                          const j = { instancePath: t + "/items", schemaPath: "#/properties/items/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                          return s === null ? s = [j] : s.push(j), o++, Se.errors = s, !1;
                                        }
                                        var a = D === o;
                                      } else
                                        var a = !0;
                                      if (a) {
                                        if (e.maxItems !== void 0) {
                                          let y = e.maxItems;
                                          const D = o, F = o;
                                          if (!(typeof y == "number" && !(y % 1) && !isNaN(y) && isFinite(y)))
                                            return Se.errors = [{ instancePath: t + "/maxItems", schemaPath: "#/definitions/nonNegativeInteger/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }], !1;
                                          if (o === F && typeof y == "number" && isFinite(y) && (y < 0 || isNaN(y)))
                                            return Se.errors = [{ instancePath: t + "/maxItems", schemaPath: "#/definitions/nonNegativeInteger/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" }], !1;
                                          var a = D === o;
                                        } else
                                          var a = !0;
                                        if (a) {
                                          if (e.minItems !== void 0) {
                                            const y = o;
                                            $n(e.minItems, { instancePath: t + "/minItems", parentData: e, parentDataProperty: "minItems", rootData: i }) || (s = s === null ? $n.errors : s.concat($n.errors), o = s.length);
                                            var a = y === o;
                                          } else
                                            var a = !0;
                                          if (a) {
                                            if (e.uniqueItems !== void 0) {
                                              const y = o;
                                              if (typeof e.uniqueItems != "boolean")
                                                return Se.errors = [{ instancePath: t + "/uniqueItems", schemaPath: "#/properties/uniqueItems/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                                              var a = y === o;
                                            } else
                                              var a = !0;
                                            if (a) {
                                              if (e.contains !== void 0) {
                                                const y = o;
                                                Se(e.contains, { instancePath: t + "/contains", parentData: e, parentDataProperty: "contains", rootData: i }) || (s = s === null ? Se.errors : s.concat(Se.errors), o = s.length);
                                                var a = y === o;
                                              } else
                                                var a = !0;
                                              if (a) {
                                                if (e.maxProperties !== void 0) {
                                                  let y = e.maxProperties;
                                                  const D = o, F = o;
                                                  if (!(typeof y == "number" && !(y % 1) && !isNaN(y) && isFinite(y)))
                                                    return Se.errors = [{ instancePath: t + "/maxProperties", schemaPath: "#/definitions/nonNegativeInteger/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }], !1;
                                                  if (o === F && typeof y == "number" && isFinite(y) && (y < 0 || isNaN(y)))
                                                    return Se.errors = [{ instancePath: t + "/maxProperties", schemaPath: "#/definitions/nonNegativeInteger/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" }], !1;
                                                  var a = D === o;
                                                } else
                                                  var a = !0;
                                                if (a) {
                                                  if (e.minProperties !== void 0) {
                                                    const y = o;
                                                    $n(e.minProperties, { instancePath: t + "/minProperties", parentData: e, parentDataProperty: "minProperties", rootData: i }) || (s = s === null ? $n.errors : s.concat($n.errors), o = s.length);
                                                    var a = y === o;
                                                  } else
                                                    var a = !0;
                                                  if (a) {
                                                    if (e.required !== void 0) {
                                                      let y = e.required;
                                                      const D = o;
                                                      if (o === o)
                                                        if (Array.isArray(y)) {
                                                          var c = !0;
                                                          const J = y.length;
                                                          for (let Z = 0; Z < J; Z++) {
                                                            const j = o;
                                                            if (typeof y[Z] != "string")
                                                              return Se.errors = [{ instancePath: t + "/required/" + Z, schemaPath: "#/definitions/stringArray/items/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
                                                            var c = j === o;
                                                            if (!c)
                                                              break;
                                                          }
                                                          if (c) {
                                                            let Z = y.length, j;
                                                            if (Z > 1) {
                                                              const ee = {};
                                                              for (; Z--; ) {
                                                                let le = y[Z];
                                                                if (typeof le == "string") {
                                                                  if (typeof ee[le] == "number")
                                                                    return j = ee[le], Se.errors = [{ instancePath: t + "/required", schemaPath: "#/definitions/stringArray/uniqueItems", keyword: "uniqueItems", params: { i: Z, j }, message: "must NOT have duplicate items (items ## " + j + " and " + Z + " are identical)" }], !1;
                                                                  ee[le] = Z;
                                                                }
                                                              }
                                                            }
                                                          }
                                                        } else
                                                          return Se.errors = [{ instancePath: t + "/required", schemaPath: "#/definitions/stringArray/type", keyword: "type", params: { type: "array" }, message: "must be array" }], !1;
                                                      var a = D === o;
                                                    } else
                                                      var a = !0;
                                                    if (a) {
                                                      if (e.additionalProperties !== void 0) {
                                                        const y = o;
                                                        Se(e.additionalProperties, { instancePath: t + "/additionalProperties", parentData: e, parentDataProperty: "additionalProperties", rootData: i }) || (s = s === null ? Se.errors : s.concat(Se.errors), o = s.length);
                                                        var a = y === o;
                                                      } else
                                                        var a = !0;
                                                      if (a) {
                                                        if (e.definitions !== void 0) {
                                                          let y = e.definitions;
                                                          const D = o;
                                                          if (o === D)
                                                            if (y && typeof y == "object" && !Array.isArray(y))
                                                              for (const W in y) {
                                                                const J = o;
                                                                Se(y[W], { instancePath: t + "/definitions/" + W.replace(/~/g, "~0").replace(/\//g, "~1"), parentData: y, parentDataProperty: W, rootData: i }) || (s = s === null ? Se.errors : s.concat(Se.errors), o = s.length);
                                                                var u = J === o;
                                                                if (!u)
                                                                  break;
                                                              }
                                                            else
                                                              return Se.errors = [{ instancePath: t + "/definitions", schemaPath: "#/properties/definitions/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
                                                          var a = D === o;
                                                        } else
                                                          var a = !0;
                                                        if (a) {
                                                          if (e.properties !== void 0) {
                                                            let y = e.properties;
                                                            const D = o;
                                                            if (o === D)
                                                              if (y && typeof y == "object" && !Array.isArray(y))
                                                                for (const W in y) {
                                                                  const J = o;
                                                                  Se(y[W], { instancePath: t + "/properties/" + W.replace(/~/g, "~0").replace(/\//g, "~1"), parentData: y, parentDataProperty: W, rootData: i }) || (s = s === null ? Se.errors : s.concat(Se.errors), o = s.length);
                                                                  var f = J === o;
                                                                  if (!f)
                                                                    break;
                                                                }
                                                              else
                                                                return Se.errors = [{ instancePath: t + "/properties", schemaPath: "#/properties/properties/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
                                                            var a = D === o;
                                                          } else
                                                            var a = !0;
                                                          if (a) {
                                                            if (e.patternProperties !== void 0) {
                                                              let y = e.patternProperties;
                                                              const D = o;
                                                              if (o === D)
                                                                if (y && typeof y == "object" && !Array.isArray(y)) {
                                                                  for (const W in y) {
                                                                    const J = o;
                                                                    if (o === J && typeof W == "string" && !Sg(W)) {
                                                                      const Z = { instancePath: t + "/patternProperties", schemaPath: "#/properties/patternProperties/propertyNames/format", keyword: "format", params: { format: "regex" }, message: 'must match format "regex"', propertyName: W };
                                                                      s === null ? s = [Z] : s.push(Z), o++;
                                                                    }
                                                                    var d = J === o;
                                                                    if (!d) {
                                                                      const Z = { instancePath: t + "/patternProperties", schemaPath: "#/properties/patternProperties/propertyNames", keyword: "propertyNames", params: { propertyName: W }, message: "property name must be valid" };
                                                                      return s === null ? s = [Z] : s.push(Z), o++, Se.errors = s, !1;
                                                                    }
                                                                  }
                                                                  if (d)
                                                                    for (const W in y) {
                                                                      const J = o;
                                                                      Se(y[W], { instancePath: t + "/patternProperties/" + W.replace(/~/g, "~0").replace(/\//g, "~1"), parentData: y, parentDataProperty: W, rootData: i }) || (s = s === null ? Se.errors : s.concat(Se.errors), o = s.length);
                                                                      var p = J === o;
                                                                      if (!p)
                                                                        break;
                                                                    }
                                                                } else
                                                                  return Se.errors = [{ instancePath: t + "/patternProperties", schemaPath: "#/properties/patternProperties/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
                                                              var a = D === o;
                                                            } else
                                                              var a = !0;
                                                            if (a) {
                                                              if (e.dependencies !== void 0) {
                                                                let y = e.dependencies;
                                                                const D = o;
                                                                if (o === D)
                                                                  if (y && typeof y == "object" && !Array.isArray(y))
                                                                    for (const W in y) {
                                                                      let J = y[W];
                                                                      const Z = o, j = o;
                                                                      let ee = !1;
                                                                      const le = o;
                                                                      Se(J, { instancePath: t + "/dependencies/" + W.replace(/~/g, "~0").replace(/\//g, "~1"), parentData: y, parentDataProperty: W, rootData: i }) || (s = s === null ? Se.errors : s.concat(Se.errors), o = s.length);
                                                                      var h = le === o;
                                                                      if (ee = ee || h, !ee) {
                                                                        const ce = o;
                                                                        if (o === o)
                                                                          if (Array.isArray(J)) {
                                                                            var m = !0;
                                                                            const ne = J.length;
                                                                            for (let K = 0; K < ne; K++) {
                                                                              const se = o;
                                                                              if (typeof J[K] != "string") {
                                                                                const ue = { instancePath: t + "/dependencies/" + W.replace(/~/g, "~0").replace(/\//g, "~1") + "/" + K, schemaPath: "#/definitions/stringArray/items/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                                                                                s === null ? s = [ue] : s.push(ue), o++;
                                                                              }
                                                                              var m = se === o;
                                                                              if (!m)
                                                                                break;
                                                                            }
                                                                            if (m) {
                                                                              let K = J.length, se;
                                                                              if (K > 1) {
                                                                                const re = {};
                                                                                for (; K--; ) {
                                                                                  let ue = J[K];
                                                                                  if (typeof ue == "string") {
                                                                                    if (typeof re[ue] == "number") {
                                                                                      se = re[ue];
                                                                                      const te = { instancePath: t + "/dependencies/" + W.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/definitions/stringArray/uniqueItems", keyword: "uniqueItems", params: { i: K, j: se }, message: "must NOT have duplicate items (items ## " + se + " and " + K + " are identical)" };
                                                                                      s === null ? s = [te] : s.push(te), o++;
                                                                                      break;
                                                                                    }
                                                                                    re[ue] = K;
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          } else {
                                                                            const ne = { instancePath: t + "/dependencies/" + W.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/definitions/stringArray/type", keyword: "type", params: { type: "array" }, message: "must be array" };
                                                                            s === null ? s = [ne] : s.push(ne), o++;
                                                                          }
                                                                        var h = ce === o;
                                                                        ee = ee || h;
                                                                      }
                                                                      if (ee)
                                                                        o = j, s !== null && (j ? s.length = j : s = null);
                                                                      else {
                                                                        const ce = { instancePath: t + "/dependencies/" + W.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/properties/dependencies/additionalProperties/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                                                        return s === null ? s = [ce] : s.push(ce), o++, Se.errors = s, !1;
                                                                      }
                                                                      var v = Z === o;
                                                                      if (!v)
                                                                        break;
                                                                    }
                                                                  else
                                                                    return Se.errors = [{ instancePath: t + "/dependencies", schemaPath: "#/properties/dependencies/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
                                                                var a = D === o;
                                                              } else
                                                                var a = !0;
                                                              if (a) {
                                                                if (e.propertyNames !== void 0) {
                                                                  const y = o;
                                                                  Se(e.propertyNames, { instancePath: t + "/propertyNames", parentData: e, parentDataProperty: "propertyNames", rootData: i }) || (s = s === null ? Se.errors : s.concat(Se.errors), o = s.length);
                                                                  var a = y === o;
                                                                } else
                                                                  var a = !0;
                                                                if (a) {
                                                                  if (e.enum !== void 0) {
                                                                    let y = e.enum;
                                                                    const D = o;
                                                                    if (o === D)
                                                                      if (Array.isArray(y)) {
                                                                        if (y.length < 1)
                                                                          return Se.errors = [{ instancePath: t + "/enum", schemaPath: "#/properties/enum/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items" }], !1;
                                                                        {
                                                                          let W = y.length, J;
                                                                          if (W > 1) {
                                                                            for (; W--; )
                                                                              for (J = W; J--; )
                                                                                if (Tg(y[W], y[J]))
                                                                                  return Se.errors = [{ instancePath: t + "/enum", schemaPath: "#/properties/enum/uniqueItems", keyword: "uniqueItems", params: { i: W, j: J }, message: "must NOT have duplicate items (items ## " + J + " and " + W + " are identical)" }], !1;
                                                                          }
                                                                        }
                                                                      } else
                                                                        return Se.errors = [{ instancePath: t + "/enum", schemaPath: "#/properties/enum/type", keyword: "type", params: { type: "array" }, message: "must be array" }], !1;
                                                                    var a = D === o;
                                                                  } else
                                                                    var a = !0;
                                                                  if (a) {
                                                                    if (e.type !== void 0) {
                                                                      let y = e.type;
                                                                      const D = o, F = o;
                                                                      let W = !1;
                                                                      const J = o;
                                                                      if (!(y === "array" || y === "boolean" || y === "integer" || y === "null" || y === "number" || y === "object" || y === "string")) {
                                                                        const j = { instancePath: t + "/type", schemaPath: "#/definitions/simpleTypes/enum", keyword: "enum", params: { allowedValues: wg.enum }, message: "must be equal to one of the allowed values" };
                                                                        s === null ? s = [j] : s.push(j), o++;
                                                                      }
                                                                      var b = J === o;
                                                                      if (W = W || b, !W) {
                                                                        const j = o;
                                                                        if (o === j)
                                                                          if (Array.isArray(y))
                                                                            if (y.length < 1) {
                                                                              const le = { instancePath: t + "/type", schemaPath: "#/properties/type/anyOf/1/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items" };
                                                                              s === null ? s = [le] : s.push(le), o++;
                                                                            } else {
                                                                              var E = !0;
                                                                              const le = y.length;
                                                                              for (let ce = 0; ce < le; ce++) {
                                                                                let U = y[ce];
                                                                                const z = o;
                                                                                if (!(U === "array" || U === "boolean" || U === "integer" || U === "null" || U === "number" || U === "object" || U === "string")) {
                                                                                  const K = { instancePath: t + "/type/" + ce, schemaPath: "#/definitions/simpleTypes/enum", keyword: "enum", params: { allowedValues: wg.enum }, message: "must be equal to one of the allowed values" };
                                                                                  s === null ? s = [K] : s.push(K), o++;
                                                                                }
                                                                                var E = z === o;
                                                                                if (!E)
                                                                                  break;
                                                                              }
                                                                              if (E) {
                                                                                let ce = y.length, U;
                                                                                if (ce > 1) {
                                                                                  e:
                                                                                    for (; ce--; )
                                                                                      for (U = ce; U--; )
                                                                                        if (Tg(y[ce], y[U])) {
                                                                                          const z = { instancePath: t + "/type", schemaPath: "#/properties/type/anyOf/1/uniqueItems", keyword: "uniqueItems", params: { i: ce, j: U }, message: "must NOT have duplicate items (items ## " + U + " and " + ce + " are identical)" };
                                                                                          s === null ? s = [z] : s.push(z), o++;
                                                                                          break e;
                                                                                        }
                                                                                }
                                                                              }
                                                                            }
                                                                          else {
                                                                            const le = { instancePath: t + "/type", schemaPath: "#/properties/type/anyOf/1/type", keyword: "type", params: { type: "array" }, message: "must be array" };
                                                                            s === null ? s = [le] : s.push(le), o++;
                                                                          }
                                                                        var b = j === o;
                                                                        W = W || b;
                                                                      }
                                                                      if (W)
                                                                        o = F, s !== null && (F ? s.length = F : s = null);
                                                                      else {
                                                                        const j = { instancePath: t + "/type", schemaPath: "#/properties/type/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                                                        return s === null ? s = [j] : s.push(j), o++, Se.errors = s, !1;
                                                                      }
                                                                      var a = D === o;
                                                                    } else
                                                                      var a = !0;
                                                                    if (a) {
                                                                      if (e.format !== void 0) {
                                                                        const y = o;
                                                                        if (typeof e.format != "string")
                                                                          return Se.errors = [{ instancePath: t + "/format", schemaPath: "#/properties/format/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
                                                                        var a = y === o;
                                                                      } else
                                                                        var a = !0;
                                                                      if (a) {
                                                                        if (e.contentMediaType !== void 0) {
                                                                          const y = o;
                                                                          if (typeof e.contentMediaType != "string")
                                                                            return Se.errors = [{ instancePath: t + "/contentMediaType", schemaPath: "#/properties/contentMediaType/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
                                                                          var a = y === o;
                                                                        } else
                                                                          var a = !0;
                                                                        if (a) {
                                                                          if (e.contentEncoding !== void 0) {
                                                                            const y = o;
                                                                            if (typeof e.contentEncoding != "string")
                                                                              return Se.errors = [{ instancePath: t + "/contentEncoding", schemaPath: "#/properties/contentEncoding/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
                                                                            var a = y === o;
                                                                          } else
                                                                            var a = !0;
                                                                          if (a) {
                                                                            if (e.if !== void 0) {
                                                                              const y = o;
                                                                              Se(e.if, { instancePath: t + "/if", parentData: e, parentDataProperty: "if", rootData: i }) || (s = s === null ? Se.errors : s.concat(Se.errors), o = s.length);
                                                                              var a = y === o;
                                                                            } else
                                                                              var a = !0;
                                                                            if (a) {
                                                                              if (e.then !== void 0) {
                                                                                const y = o;
                                                                                Se(e.then, { instancePath: t + "/then", parentData: e, parentDataProperty: "then", rootData: i }) || (s = s === null ? Se.errors : s.concat(Se.errors), o = s.length);
                                                                                var a = y === o;
                                                                              } else
                                                                                var a = !0;
                                                                              if (a) {
                                                                                if (e.else !== void 0) {
                                                                                  const y = o;
                                                                                  Se(e.else, { instancePath: t + "/else", parentData: e, parentDataProperty: "else", rootData: i }) || (s = s === null ? Se.errors : s.concat(Se.errors), o = s.length);
                                                                                  var a = y === o;
                                                                                } else
                                                                                  var a = !0;
                                                                                if (a) {
                                                                                  if (e.allOf !== void 0) {
                                                                                    const y = o;
                                                                                    rn(e.allOf, { instancePath: t + "/allOf", parentData: e, parentDataProperty: "allOf", rootData: i }) || (s = s === null ? rn.errors : s.concat(rn.errors), o = s.length);
                                                                                    var a = y === o;
                                                                                  } else
                                                                                    var a = !0;
                                                                                  if (a) {
                                                                                    if (e.anyOf !== void 0) {
                                                                                      const y = o;
                                                                                      rn(e.anyOf, { instancePath: t + "/anyOf", parentData: e, parentDataProperty: "anyOf", rootData: i }) || (s = s === null ? rn.errors : s.concat(rn.errors), o = s.length);
                                                                                      var a = y === o;
                                                                                    } else
                                                                                      var a = !0;
                                                                                    if (a) {
                                                                                      if (e.oneOf !== void 0) {
                                                                                        const y = o;
                                                                                        rn(e.oneOf, { instancePath: t + "/oneOf", parentData: e, parentDataProperty: "oneOf", rootData: i }) || (s = s === null ? rn.errors : s.concat(rn.errors), o = s.length);
                                                                                        var a = y === o;
                                                                                      } else
                                                                                        var a = !0;
                                                                                      if (a)
                                                                                        if (e.not !== void 0) {
                                                                                          const y = o;
                                                                                          Se(e.not, { instancePath: t + "/not", parentData: e, parentDataProperty: "not", rootData: i }) || (s = s === null ? Se.errors : s.concat(Se.errors), o = s.length);
                                                                                          var a = y === o;
                                                                                        } else
                                                                                          var a = !0;
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return Se.errors = s, o === 0;
}
var Xj = ch.exports;
let Zj = class extends Error {
  constructor(t, n) {
    super(), this.name = "JsonSchemaMergeError", this.code = "JSON_SCHEMA_MERGE_ERROR", this.message = `Failed to merge "${t}" keyword schemas.`, this.schemas = n;
  }
};
class eC extends Error {
  constructor(t, n) {
    super(), this.name = "JsonSchemaMergeError", this.code = "JSON_SCHEMA_MERGE_ERROR", this.message = `Resolver for "${t}" keyword not found.`, this.schemas = n;
  }
}
class tC extends Error {
  constructor(t) {
    super(), this.name = "JsonSchemaMergeError", this.code = "JSON_SCHEMA_MERGE_ERROR", this.message = `Invalid "onConflict" option: "${t}".`;
  }
}
var fw = {
  MergeError: Zj,
  ResolverNotFoundError: eC,
  InvalidOnConflictOptionError: tC
};
const nC = ga, { MergeError: fh } = fw;
function dw(e) {
  let t = e[0];
  for (let n = 1; n < e.length; n++)
    t = t.filter(
      (r) => e[n].includes(r)
    );
  return t;
}
function rC(e, t, n) {
  const r = dw(t);
  if (r.length === 0)
    throw new fh(e, t);
  n[e] = r;
}
function iC(e, t, n) {
  for (let i = 0; i < t.length; i++)
    Array.isArray(t[i]) || (t[i] = [t[i]]);
  const r = dw(t);
  if (r.length === 0)
    throw new fh(e, t);
  r.length === 1 ? n[e] = r[0] : n[e] = r;
}
function sC(e, t, n) {
  const r = [];
  for (const i of t)
    for (const s of i)
      r.includes(s) || r.push(s);
  n[e] = r;
}
function oC(e, t, n) {
  n[e] = Math.min(...t);
}
function aC(e, t, n) {
  n[e] = Math.max(...t);
}
function lC(e, t, n) {
  const r = (a, l) => l ? r(l, a % l) : a, i = (a, l) => a * l / r(a, l);
  let s = 1;
  for (const a of t)
    for (; a * s % 1 !== 0; )
      s *= 10;
  let o = t[0] * s;
  for (const a of t)
    o = i(o, a * s);
  n[e] = o / s;
}
function uC(e, t, n) {
  const r = t[0];
  for (let i = 1; i < t.length; i++)
    if (!nC(t[i], r))
      throw new fh(e, t);
  n[e] = r;
}
function cC() {
}
function fC(e, t, n) {
  for (const r of t)
    if (r === !1) {
      n[e] = !1;
      return;
    }
  n[e] = !0;
}
function dC(e, t, n) {
  for (const r of t)
    if (r === !0) {
      n[e] = !0;
      return;
    }
  n[e] = !1;
}
var pC = {
  arraysIntersection: rC,
  hybridArraysIntersection: iC,
  arraysUnion: sC,
  minNumber: oC,
  maxNumber: aC,
  commonMultiple: lC,
  allEqual: uC,
  booleanAnd: fC,
  booleanOr: dC,
  skip: cC
};
const hC = ga, Nt = pC, ql = fw, pw = {
  $id: Nt.skip,
  type: Nt.hybridArraysIntersection,
  enum: Nt.arraysIntersection,
  minLength: Nt.maxNumber,
  maxLength: Nt.minNumber,
  minimum: Nt.maxNumber,
  maximum: Nt.minNumber,
  multipleOf: Nt.commonMultiple,
  exclusiveMinimum: Nt.maxNumber,
  exclusiveMaximum: Nt.minNumber,
  minItems: Nt.maxNumber,
  maxItems: Nt.minNumber,
  maxProperties: Nt.minNumber,
  minProperties: Nt.maxNumber,
  const: Nt.allEqual,
  default: Nt.allEqual,
  format: Nt.allEqual,
  required: Nt.arraysUnion,
  properties: _C,
  patternProperties: Za,
  additionalProperties: Xa,
  items: gC,
  additionalItems: bC,
  definitions: Za,
  $defs: Za,
  nullable: Nt.booleanAnd,
  oneOf: $g,
  anyOf: $g,
  allOf: Nt.arraysUnion,
  not: Xa,
  if: wC,
  then: Nt.skip,
  else: Nt.skip,
  dependencies: Ng,
  dependentRequired: Ng,
  dependentSchemas: Za,
  propertyNames: Xa,
  uniqueItems: Nt.booleanOr,
  contains: Xa
};
function Xa(e, t, n, r, i) {
  n[e] = Zn(t, i);
}
function mC(e) {
  let t = [[]];
  for (const n of e) {
    const r = [];
    for (const i of t)
      for (const s of n)
        r.push([...i, s]);
    t = r;
  }
  return t;
}
function $g(e, t, n, r, i) {
  if (t.length === 1) {
    n[e] = t[0];
    return;
  }
  const s = mC(t), o = [];
  for (const a of s)
    try {
      const l = Zn(a, i);
      l !== void 0 && o.push(l);
    } catch (l) {
      if (l instanceof ql.MergeError)
        continue;
      throw l;
    }
  n[e] = o;
}
function yC(e, t) {
  const { items: n, additionalItems: r } = e;
  return Array.isArray(n) ? t < n.length ? n[t] : r : n !== void 0 ? n : r;
}
function gC(e, t, n, r, i) {
  let s = 0;
  for (const a of t)
    Array.isArray(a) && (s = Math.max(s, a.length));
  if (s === 0) {
    n[e] = Zn(t, i);
    return;
  }
  const o = [];
  for (let a = 0; a < s; a++) {
    const l = [];
    for (const c of r) {
      const u = yC(c, a);
      u !== void 0 && l.push(u);
    }
    o[a] = Zn(l, i);
  }
  n[e] = o;
}
function bC(e, t, n, r, i) {
  let s = !1;
  for (const a of r)
    if (Array.isArray(a.items)) {
      s = !0;
      break;
    }
  if (!s) {
    n[e] = Zn(t, i);
    return;
  }
  const o = [];
  for (const a of r) {
    let l = a.additionalItems;
    l === void 0 && !Array.isArray(a.items) && (l = a.items), l !== void 0 && o.push(l);
  }
  n[e] = Zn(o, i);
}
function vC(e, t) {
  const { properties: n, patternProperties: r, additionalProperties: i } = e;
  if (n?.[t] !== void 0)
    return n[t];
  for (const s of Object.keys(r ?? {}))
    if (new RegExp(s).test(t))
      return r[s];
  return i;
}
function _C(e, t, n, r, i) {
  const s = {};
  for (const a of r) {
    const l = a.properties ?? {};
    for (const c of Object.keys(l)) {
      if (s[c] !== void 0)
        continue;
      const u = l[c];
      s[c] = [u];
      for (const f of r) {
        if (a === f)
          continue;
        const d = vC(f, c);
        d !== void 0 && s[c].push(d);
      }
    }
  }
  const o = {};
  for (const a of Object.keys(s)) {
    const l = s[a];
    o[a] = Zn(l, i);
  }
  n[e] = o;
}
function Za(e, t, n, r, i) {
  const s = {};
  for (const a of t)
    for (const l of Object.keys(a))
      s[l] === void 0 && (s[l] = []), s[l].push(a[l]);
  const o = {};
  for (const a of Object.keys(s)) {
    const l = s[a], c = Zn(l, i);
    o[a] = c;
  }
  n[e] = o;
}
function wC(e, t, n, r, i) {
  for (let s = 0; s < r.length; s++) {
    const o = {
      if: r[s].if,
      then: r[s].then,
      else: r[s].else
    };
    if (o.if !== void 0) {
      if (n.if === void 0) {
        n.if = o.if, o.then !== void 0 && (n.then = o.then), o.else !== void 0 && (n.else = o.else);
        continue;
      }
      n.then !== void 0 && (n.then = Zn([n.then, o], i)), n.else !== void 0 && (n.else = Zn([n.else, o], i));
    }
  }
}
function Ng(e, t, n) {
  const r = {};
  for (const i of t)
    for (const s of Object.keys(i)) {
      r[s] === void 0 && (r[s] = []);
      const o = r[s];
      for (const a of i[s])
        o.includes(a) || o.push(a);
    }
  n[e] = r;
}
function Zn(e, t) {
  if (e.length === 0)
    return {};
  if (e.length === 1)
    return e[0];
  const n = {}, r = {};
  let i = !0;
  for (const s of e) {
    if (s === !1)
      return !1;
    if (s !== !0) {
      i = !1;
      for (const o of Object.keys(s))
        r[o] === void 0 && (r[o] = []), r[o].push(s[o]);
    }
  }
  if (i)
    return !0;
  for (const s of Object.keys(r)) {
    const o = r[s];
    (t.resolvers[s] ?? t.defaultResolver)(s, o, n, e, t);
  }
  return n;
}
function hw(e, t, n, r, i) {
  const s = i.onConflict ?? "throw";
  if (t.length === 1 || s === "first") {
    n[e] = t[0];
    return;
  }
  let o = !0;
  for (let a = 1; a < t.length; a++)
    if (!hC(t[a], t[0])) {
      o = !1;
      break;
    }
  if (o) {
    n[e] = t[0];
    return;
  }
  if (s === "throw")
    throw new ql.ResolverNotFoundError(e, t);
  if (s !== "skip")
    throw new ql.InvalidOnConflictOptionError(s);
}
function EC(e, t = {}) {
  return t.defaultResolver === void 0 && (t.defaultResolver = hw), t.resolvers = { ...pw, ...t.resolvers }, Zn(e, t);
}
var SC = { mergeSchemas: EC, keywordsResolvers: pw, defaultResolver: hw, ...ql };
const { mergeSchemas: TC } = SC;
function $C(e) {
  return TC(e, { onConflict: "skip" });
}
var NC = $C, el = { exports: {} }, Og;
function OC() {
  if (Og)
    return el.exports;
  Og = 1;
  function e(t, n, r, i) {
    let s = "";
    n.validatorSchemasIds.size > 0 ? (s += `const Validator = require('fast-json-stringify/lib/validator')
`, s += `const validatorState = ${JSON.stringify(i.getState())}
`, s += `const validator = Validator.restoreFromState(validatorState)
`) : s += `const validator = null
`;
    const { schema: o, ...a } = r.getState();
    return `
  'use strict'

  const Serializer = require('fast-json-stringify/lib/serializer')
  const serializerState = ${JSON.stringify(a)}
  const serializer = Serializer.restoreFromState(serializerState)

  ${s}

  module.exports = ${t.toString()}(validator, serializer)`;
  }
  return el.exports = e, el.exports.dependencies = {
    Serializer: e_,
    Validator: uw
  }, el.exports;
}
const { RefResolver: IC } = mx, RC = e_, AC = uw, ns = Jj, Ig = Xj, xC = NC, DC = /'/g;
let Sl = 2e4, mw = "default";
const PC = [
  "floor",
  "ceil",
  "round",
  "trunc"
], yw = [
  "default",
  "json-stringify"
];
let Ko = 0;
function hd(e, t) {
  if (!Ig(e)) {
    t ? t = `"${t}" ` : t = "";
    const n = Ig.errors[0], r = new Error(`${t}schema is invalid: data${n.instancePath} ${n.message}`);
    throw r.errors = hd.errors, r;
  }
}
function _a(e, t) {
  const n = t.schema.$ref;
  let r = n.indexOf("#");
  r === -1 && (r = n.length);
  const i = n.slice(0, r) || t.schemaId, s = n.slice(r) || "#", o = e.refResolver.getSchema(i, s);
  if (o === null)
    throw new Error(`Cannot find reference "${n}"`);
  const a = new ns(o, i, s);
  return o.$ref !== void 0 ? _a(e, a) : a;
}
function Hl(e, t) {
  const n = e.refResolver.getSchema(t, "#");
  return new ns(n, t, "#");
}
function Rg(e, t) {
  return e.$id && e.$id.charAt(0) !== "#" ? e.$id : t;
}
function dh(e, t) {
  hd(e), t = t || {};
  const n = {
    functions: [],
    functionsCounter: 0,
    functionsNamesBySchema: /* @__PURE__ */ new Map(),
    options: t,
    refResolver: new IC(),
    rootSchemaId: e.$id || `__fjs_root_${Ko++}`,
    validatorSchemasIds: /* @__PURE__ */ new Set(),
    mergedSchemasIds: /* @__PURE__ */ new Map()
  }, r = Rg(e, n.rootSchemaId);
  if (n.refResolver.hasSchema(r) || n.refResolver.addSchema(e, n.rootSchemaId), t.schema)
    for (const u in t.schema) {
      const f = t.schema[u], d = Rg(f, u);
      n.refResolver.hasSchema(d) || (hd(f, u), n.refResolver.addSchema(f, u));
    }
  if (t.rounding && !PC.includes(t.rounding))
    throw new Error(`Unsupported integer rounding method ${t.rounding}`);
  if (t.largeArrayMechanism)
    if (yw.includes(t.largeArrayMechanism))
      mw = t.largeArrayMechanism;
    else
      throw new Error(`Unsupported large array mechanism ${t.largeArrayMechanism}`);
  if (t.largeArraySize)
    if (typeof t.largeArraySize == "string" && Number.isFinite(Number.parseInt(t.largeArraySize, 10)))
      Sl = Number.parseInt(t.largeArraySize, 10);
    else if (typeof t.largeArraySize == "number" && Number.isInteger(t.largeArraySize))
      Sl = t.largeArraySize;
    else if (typeof t.largeArraySize == "bigint")
      Sl = Number(t.largeArraySize);
    else
      throw new Error(`Unsupported large array size. Expected integer-like, got ${typeof t.largeArraySize} with value ${t.largeArraySize}`);
  const i = new ns(e, n.rootSchemaId), s = gn(n, i, "input");
  let o = `
    const JSON_STR_BEGIN_OBJECT = '{'
    const JSON_STR_END_OBJECT = '}'
    const JSON_STR_BEGIN_ARRAY = '['
    const JSON_STR_END_ARRAY = ']'
    const JSON_STR_COMMA = ','
    const JSON_STR_COLONS = ':'
    const JSON_STR_QUOTE = '"'
    const JSON_STR_EMPTY_OBJECT = JSON_STR_BEGIN_OBJECT + JSON_STR_END_OBJECT
    const JSON_STR_EMPTY_ARRAY = JSON_STR_BEGIN_ARRAY + JSON_STR_END_ARRAY
    const JSON_STR_EMPTY_STRING = JSON_STR_QUOTE + JSON_STR_QUOTE
    const JSON_STR_NULL = 'null'
  `;
  s === "json += anonymous0(input)" ? o += `
    ${n.functions.join(`
`)}
    const main = anonymous0
    return main
    ` : o += `
    function main (input) {
      let json = ''
      ${s}
      return json
    }
    ${n.functions.join(`
`)}
    return main
    `;
  const a = new RC(t), l = new AC(t.ajv);
  for (const u of n.validatorSchemasIds) {
    const f = n.refResolver.getSchema(u);
    l.addSchema(f, u);
    const d = n.refResolver.getSchemaDependencies(u);
    for (const [p, h] of Object.entries(d))
      l.addSchema(h, p);
  }
  if (t.debugMode && (t.mode = "debug"), t.mode === "debug")
    return {
      validator: l,
      serializer: a,
      code: `validator
serializer
${o}`,
      ajv: l.ajv
    };
  const c = new Function("validator", "serializer", o);
  return t.mode === "standalone" ? OC()(c, n, a, l) : c(l, a);
}
const kC = [
  "properties",
  "required",
  "additionalProperties",
  "patternProperties",
  "maxProperties",
  "minProperties",
  "dependencies"
], LC = [
  "items",
  "additionalItems",
  "maxItems",
  "minItems",
  "uniqueItems",
  "contains"
], jC = [
  "maxLength",
  "minLength",
  "pattern"
], CC = [
  "multipleOf",
  "maximum",
  "exclusiveMaximum",
  "minimum",
  "exclusiveMinimum"
];
function MC(e) {
  for (var t of kC)
    if (t in e)
      return "object";
  for (var t of LC)
    if (t in e)
      return "array";
  for (var t of jC)
    if (t in e)
      return "string";
  for (var t of CC)
    if (t in e)
      return "number";
  return e.type;
}
function FC(e, t, n) {
  const r = t.schema, i = Object.keys(r.properties || {});
  let s = `
    const propertiesKeys = ${JSON.stringify(i)}
    for (const [key, value] of Object.entries(obj)) {
      if (
        propertiesKeys.includes(key) ||
        value === undefined ||
        typeof value === 'function' ||
        typeof value === 'symbol'
      ) continue
  `;
  const o = t.getPropertyLocation("patternProperties"), a = o.schema;
  if (a !== void 0)
    for (const u in a) {
      const f = o.getPropertyLocation(u);
      s += `
        if (/${u.replace(/\\*\//g, "\\/")}/.test(key)) {
          ${n}
          json += serializer.asString(key) + JSON_STR_COLONS
          ${gn(e, f, "value")}
          continue
        }
      `;
    }
  const c = t.getPropertyLocation("additionalProperties").schema;
  if (c !== void 0)
    if (c === !0)
      s += `
        ${n}
        json += serializer.asString(key) + JSON_STR_COLONS + JSON.stringify(value)
      `;
    else {
      const u = t.getPropertyLocation("additionalProperties");
      s += `
        ${n}
        json += serializer.asString(key) + JSON_STR_COLONS
        ${gn(e, u, "value")}
      `;
    }
  return s += `
    }
  `, s;
}
function UC(e, t) {
  const n = t.schema, r = t.getPropertyLocation("properties"), i = n.required || [], s = Object.keys(n.properties || {}).sort(
    (c, u) => {
      const f = i.includes(c), d = i.includes(u);
      return f === d ? 0 : f ? -1 : 1;
    }
  ), o = i.includes(s[0]);
  let a = `let value
`;
  for (const c of i)
    if (!s.includes(c)) {
      const u = JSON.stringify(c);
      a += `if (obj[${u}] === undefined) throw new Error('${u.replace(/'/g, "\\'")} is required!')
`;
    }
  a += `let json = JSON_STR_BEGIN_OBJECT
`;
  let l = "";
  o || (a += `let addComma = false
`, l = "!addComma && (addComma = true) || (json += JSON_STR_COMMA)");
  for (const c of s) {
    let u = r.getPropertyLocation(c);
    u.schema.$ref && (u = _a(e, u));
    const f = JSON.stringify(c), d = u.schema.default, p = i.includes(c);
    a += `
      value = obj[${f}]
      if (value !== undefined) {
        ${l}
        json += ${JSON.stringify(f + ":")}
        ${gn(e, u, "value")}
      }`, d !== void 0 ? a += ` else {
        ${l}
        json += ${JSON.stringify(f + ":" + JSON.stringify(d))}
      }
      ` : p ? a += ` else {
        throw new Error('${f.replace(/'/g, "\\'")} is required!')
      }
      ` : a += `
`, o && (l = "json += ','");
  }
  return (n.patternProperties || n.additionalProperties) && (a += FC(e, t, l)), a += `
    return json + JSON_STR_END_OBJECT
  `, a;
}
function Wl(e, t, n) {
  for (let o = 0; o < n.length; o++) {
    const a = n[o];
    a.schema.$ref && (n[o] = _a(e, a));
  }
  const r = [];
  for (const o of n) {
    const a = gw(e, o.schema, o.schemaId);
    delete a.$id, r.push(a);
  }
  const i = xC(r), s = new ns(i, t);
  return e.refResolver.addSchema(i, t), s;
}
function gw(e, t, n) {
  const r = Array.isArray(t) ? [] : {};
  t.$id !== void 0 && t.$id.charAt(0) !== "#" && (n = t.$id);
  const i = e.mergedSchemasIds.get(t);
  i && e.mergedSchemasIds.set(r, i);
  for (const s in t) {
    let o = t[s];
    s === "$ref" && typeof o == "string" && o.charAt(0) === "#" && (o = n + o), typeof o == "object" && o !== null && (o = gw(e, o, n)), r[s] = o;
  }
  return r;
}
function VC(e) {
  return `(${e} && typeof ${e}.toJSON === 'function')
    ? ${e}.toJSON()
    : ${e}
  `;
}
function BC(e, t) {
  const n = t.schema;
  if (e.functionsNamesBySchema.has(n))
    return e.functionsNamesBySchema.get(n);
  const r = vw(e);
  e.functionsNamesBySchema.set(n, r);
  let i = t.getSchemaRef();
  i.startsWith(e.rootSchemaId) && (i = i.replace(e.rootSchemaId, ""));
  let s = `
  `;
  const o = n.nullable === !0;
  return s += `
    // ${i}
    function ${r} (input) {
      const obj = ${VC("input")}
      ${o ? "" : "if (obj === null) return JSON_STR_EMPTY_OBJECT"}

      ${UC(e, t)}
    }
  `, e.functions.push(s), r;
}
function GC(e, t) {
  const n = t.schema;
  let r = t.getPropertyLocation("items");
  r.schema = r.schema || {}, r.schema.$ref && (r = _a(e, r));
  const i = r.schema;
  if (e.functionsNamesBySchema.has(n))
    return e.functionsNamesBySchema.get(n);
  const s = vw(e);
  e.functionsNamesBySchema.set(n, s);
  let o = t.getSchemaRef();
  o.startsWith(e.rootSchemaId) && (o = o.replace(e.rootSchemaId, ""));
  let a = `
    function ${s} (obj) {
      // ${o}
  `;
  const l = n.nullable === !0;
  if (a += `
    ${l ? "" : "if (obj === null) return JSON_STR_EMPTY_ARRAY"}
    if (!Array.isArray(obj)) {
      throw new TypeError(\`The value of '${o}' does not match schema definition.\`)
    }
    const arrayLength = obj.length
  `, !n.additionalItems && Array.isArray(i) && (a += `
      if (arrayLength > ${i.length}) {
        throw new Error(\`Item at ${i.length} does not match schema definition.\`)
      }
    `), mw === "json-stringify" && (a += `if (arrayLength >= ${Sl}) return JSON.stringify(obj)
`), a += `
    const arrayEnd = arrayLength - 1
    let value
    let json = ''
  `, Array.isArray(i)) {
    for (let c = 0; c < i.length; c++) {
      const u = i[c];
      a += `value = obj[${c}]`;
      const f = gn(e, r.getPropertyLocation(c), "value");
      a += `
        if (${c} < arrayLength) {
          if (${bw(u.type)}) {
            ${f}
            if (${c} < arrayEnd) {
              json += JSON_STR_COMMA
            }
          } else {
            throw new Error(\`Item at ${c} does not match schema definition.\`)
          }
        }
        `;
    }
    n.additionalItems && (a += `
        for (let i = ${i.length}; i < arrayLength; i++) {
          json += JSON.stringify(obj[i])
          if (i < arrayEnd) {
            json += JSON_STR_COMMA
          }
        }`);
  } else {
    const c = gn(e, r, "obj[i]");
    a += `
      for (let i = 0; i < arrayLength; i++) {
        ${c}
        if (i < arrayEnd) {
          json += JSON_STR_COMMA
        }
      }`;
  }
  return a += `
    return JSON_STR_BEGIN_ARRAY + json + JSON_STR_END_ARRAY
  }`, e.functions.push(a), s;
}
function bw(e, t) {
  let n;
  switch (e) {
    case "null":
      n = "value === null";
      break;
    case "string":
      n = `typeof value === 'string' ||
      value === null ||
      value instanceof Date ||
      value instanceof RegExp ||
      (
        typeof value === "object" &&
        typeof value.toString === "function" &&
        value.toString !== Object.prototype.toString
      )`;
      break;
    case "integer":
      n = "Number.isInteger(value)";
      break;
    case "number":
      n = "Number.isFinite(value)";
      break;
    case "boolean":
      n = "typeof value === 'boolean'";
      break;
    case "object":
      n = "value && typeof value === 'object' && value.constructor === Object";
      break;
    case "array":
      n = "Array.isArray(value)";
      break;
    default:
      Array.isArray(e) && (n = `(${e.map((i) => bw(i)).join(" || ")})`);
  }
  return n;
}
function vw(e) {
  return "anonymous" + e.functionsCounter++;
}
function zC(e, t, n) {
  const i = t.schema.type.sort((a) => a === "null" ? -1 : 1);
  let s = "";
  i.forEach((a, l) => {
    t.schema = { ...t.schema, type: a };
    const c = _w(e, t, n), u = l === 0 ? "if" : "else if";
    switch (a) {
      case "null":
        s += `
          ${u} (${n} === null)
            ${c}
          `;
        break;
      case "string": {
        s += `
          ${u}(
            typeof ${n} === "string" ||
            ${n} === null ||
            ${n} instanceof Date ||
            ${n} instanceof RegExp ||
            (
              typeof ${n} === "object" &&
              typeof ${n}.toString === "function" &&
              ${n}.toString !== Object.prototype.toString
            )
          )
            ${c}
        `;
        break;
      }
      case "array": {
        s += `
          ${u}(Array.isArray(${n}))
            ${c}
        `;
        break;
      }
      case "integer": {
        s += `
          ${u}(Number.isInteger(${n}) || ${n} === null)
            ${c}
        `;
        break;
      }
      default: {
        s += `
          ${u}(typeof ${n} === "${a}" || ${n} === null)
            ${c}
        `;
        break;
      }
    }
  });
  let o = t.getSchemaRef();
  return o.startsWith(e.rootSchemaId) && (o = o.replace(e.rootSchemaId, "")), s += `
    else throw new TypeError(\`The value of '${o}' does not match schema definition.\`)
  `, s;
}
function _w(e, t, n) {
  const r = t.schema;
  switch (r.type) {
    case "null":
      return "json += JSON_STR_NULL";
    case "string":
      return r.format === "date-time" ? `json += serializer.asDateTime(${n})` : r.format === "date" ? `json += serializer.asDate(${n})` : r.format === "time" ? `json += serializer.asTime(${n})` : r.format === "unsafe" ? `json += serializer.asUnsafeString(${n})` : `
        if (typeof ${n} !== 'string') {
          if (${n} === null) {
            json += JSON_STR_EMPTY_STRING
          } else if (${n} instanceof Date) {
            json += JSON_STR_QUOTE + ${n}.toISOString() + JSON_STR_QUOTE
          } else if (${n} instanceof RegExp) {
            json += serializer.asString(${n}.source)
          } else {
            json += serializer.asString(${n}.toString())
          }
        } else {
          json += serializer.asString(${n})
        }
        `;
    case "integer":
      return `json += serializer.asInteger(${n})`;
    case "number":
      return `json += serializer.asNumber(${n})`;
    case "boolean":
      return `json += serializer.asBoolean(${n})`;
    case "object":
      return `json += ${BC(e, t)}(${n})`;
    case "array":
      return `json += ${GC(e, t)}(${n})`;
    case void 0:
      return `json += JSON.stringify(${n})`;
    default:
      throw new Error(`${r.type} unsupported`);
  }
}
function qC(e, t) {
  const n = e.schema, r = n.type, i = Array.isArray(r) && r.includes("null");
  let s = "";
  return i && (s += `
      if (${t} === null) {
        json += JSON_STR_NULL
      } else {
    `), s += `json += '${JSON.stringify(n.const).replace(DC, "\\'")}'`, i && (s += `
      }
    `), s;
}
function HC(e, t, n) {
  const r = t.schema;
  let i = e.mergedSchemasIds.get(r);
  if (i) {
    const u = Hl(e, i);
    return gn(e, u, n);
  }
  i = `__fjs_merged_${Ko++}`, e.mergedSchemasIds.set(r, i);
  const { allOf: s, ...o } = t.schema, a = [
    new ns(
      o,
      t.schemaId,
      t.jsonPointer
    )
  ], l = t.getPropertyLocation("allOf");
  for (let u = 0; u < s.length; u++)
    a.push(l.getPropertyLocation(u));
  const c = Wl(e, i, a);
  return gn(e, c, n);
}
function WC(e, t, n) {
  e.validatorSchemasIds.add(t.schemaId);
  const i = t.schema.anyOf ? "anyOf" : "oneOf", { [i]: s, ...o } = t.schema, a = new ns(
    o,
    t.schemaId,
    t.jsonPointer
  ), l = t.getPropertyLocation(i);
  let c = "";
  for (let f = 0; f < s.length; f++) {
    const d = l.getPropertyLocation(f), p = d.schema;
    let h = e.mergedSchemasIds.get(p), m = null;
    h ? m = Hl(e, h) : (h = `__fjs_merged_${Ko++}`, e.mergedSchemasIds.set(p, h), m = Wl(e, h, [
      a,
      d
    ]));
    const v = gn(e, m, n), b = d.getSchemaRef();
    c += `
      ${f === 0 ? "if" : "else if"}(validator.validate("${b}", ${n}))
        ${v}
    `;
  }
  let u = t.getSchemaRef();
  return u.startsWith(e.rootSchemaId) && (u = u.replace(e.rootSchemaId, "")), c += `
    else throw new TypeError(\`The value of '${u}' does not match schema definition.\`)
  `, c;
}
function QC(e, t, n) {
  e.validatorSchemasIds.add(t.schemaId);
  const {
    if: r,
    then: i,
    else: s,
    ...o
  } = t.schema, a = new ns(
    o,
    t.schemaId,
    t.jsonPointer
  ), c = t.getPropertyLocation("if").getSchemaRef(), u = t.getPropertyLocation("then");
  let f = e.mergedSchemasIds.get(i), d = null;
  if (f ? d = Hl(e, f) : (f = `__fjs_merged_${Ko++}`, e.mergedSchemasIds.set(i, f), d = Wl(e, f, [
    a,
    u
  ])), !s)
    return `
      if (validator.validate("${c}", ${n})) {
        ${gn(e, d, n)}
      } else {
        ${gn(e, a, n)}
      }
    `;
  const p = t.getPropertyLocation("else");
  let h = e.mergedSchemasIds.get(s), m = null;
  return h ? m = Hl(e, h) : (h = `__fjs_merged_${Ko++}`, e.mergedSchemasIds.set(s, h), m = Wl(e, h, [
    a,
    p
  ])), `
    if (validator.validate("${c}", ${n})) {
      ${gn(e, d, n)}
    } else {
      ${gn(e, m, n)}
    }
  `;
}
function gn(e, t, n) {
  let r = t.schema;
  if (typeof r == "boolean")
    return `json += JSON.stringify(${n})`;
  if (r.$ref && (t = _a(e, t), r = t.schema), r.allOf)
    return HC(e, t, n);
  if (r.anyOf || r.oneOf)
    return WC(e, t, n);
  if (r.if && r.then)
    return QC(e, t, n);
  if (r.type === void 0) {
    const a = MC(r);
    a && (r.type = a);
  }
  let i = "";
  const s = r.type, o = r.nullable === !0;
  return o && (i += `
      if (${n} === null) {
        json += JSON_STR_NULL
      } else {
    `), r.const !== void 0 ? i += qC(t, n) : Array.isArray(s) ? i += zC(e, t, n) : i += _w(e, t, n), o && (i += `
      }
    `), i;
}
Ls.exports = dh;
Ls.exports.default = dh;
Ls.exports.build = dh;
Ls.exports.validLargeArrayMechanisms = yw;
Ls.exports.restore = function({ code: e, validator: t, serializer: n }) {
  return Function.apply(null, ["validator", "serializer", e]).apply(null, [t, n]);
};
var JC = Ls.exports;
function KC(e) {
  return /^[$A-Z\_a-z\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc][$A-Z\_a-z\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc0-9\u0300-\u036f\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08e4-\u08fe\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d02\u0d03\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19b0-\u19c0\u19c8\u19c9\u19d0-\u19d9\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf2-\u1cf4\u1dc0-\u1de6\u1dfc-\u1dff\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua880\ua881\ua8b4-\ua8c4\ua8d0-\ua8d9\ua8e0-\ua8f1\ua900-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f]*$/.test(e);
}
var YC = KC, Ag = at, ww = YC, xg = /[\{\[]/, Dg = /[\}\]]/, Pg = [
  "do",
  "if",
  "in",
  "for",
  "let",
  "new",
  "try",
  "var",
  "case",
  "else",
  "enum",
  "eval",
  "null",
  "this",
  "true",
  "void",
  "with",
  "await",
  "break",
  "catch",
  "class",
  "const",
  "false",
  "super",
  "throw",
  "while",
  "yield",
  "delete",
  "export",
  "import",
  "public",
  "return",
  "static",
  "switch",
  "typeof",
  "default",
  "extends",
  "finally",
  "package",
  "private",
  "continue",
  "debugger",
  "function",
  "arguments",
  "interface",
  "protected",
  "implements",
  "instanceof",
  "NaN",
  "undefined"
], Ew = {};
for (var Nf = 0; Nf < Pg.length; Nf++)
  Ew[Pg[Nf]] = !0;
var XC = function(e) {
  return ww(e) && !Ew.hasOwnProperty(e);
}, Sw = {
  s: function(e) {
    return "" + e;
  },
  d: function(e) {
    return "" + Number(e);
  },
  o: function(e) {
    return JSON.stringify(e);
  }
}, Tw = function() {
  var e = [], t = 0, n = {}, r = function(o) {
    for (var a = ""; a.length < t * 2; )
      a += "  ";
    e.push(a + o);
  }, i = function(o) {
    if (Dg.test(o.trim()[0]) && xg.test(o[o.length - 1])) {
      t--, r(o), t++;
      return;
    }
    if (xg.test(o[o.length - 1])) {
      r(o), t++;
      return;
    }
    if (Dg.test(o.trim()[0])) {
      t--, r(o);
      return;
    }
    r(o);
  }, s = function(o) {
    if (!o)
      return s;
    if (arguments.length === 1 && o.indexOf(`
`) > -1)
      for (var a = o.trim().split(`
`), l = 0; l < a.length; l++)
        i(a[l].trim());
    else
      i(Ag.format.apply(Ag, arguments));
    return s;
  };
  return s.scope = {}, s.formats = Sw, s.sym = function(o) {
    return (!o || !XC(o)) && (o = "tmp"), n[o] || (n[o] = 0), o + (n[o]++ || "");
  }, s.property = function(o, a) {
    return arguments.length === 1 && (a = o, o = ""), a = a + "", ww(a) ? o ? o + "." + a : a : o ? o + "[" + JSON.stringify(a) + "]" : JSON.stringify(a);
  }, s.toString = function() {
    return e.join(`
`);
  }, s.toFunction = function(o) {
    o || (o = {});
    var a = "return (" + s.toString() + ")";
    Object.keys(s.scope).forEach(function(u) {
      o[u] || (o[u] = s.scope[u]);
    });
    var l = Object.keys(o).map(function(u) {
      return u;
    }), c = l.map(function(u) {
      return o[u];
    });
    return Function.apply(null, l.concat(a)).apply(null, c);
  }, arguments.length && s.apply(null, arguments), s;
};
Tw.formats = Sw;
var Gu = Tw;
function $s(e, t, n) {
  return {
    prev: e,
    key: t,
    typename: n
  };
}
function un(e) {
  const t = [];
  let n = e;
  for (; n; )
    t.push(n.key), n = n.prev;
  return t.reverse();
}
const ZC = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  addPath: $s,
  pathToArray: un
}, Symbol.toStringTag, { value: "Module" })), eM = /* @__PURE__ */ Hi(ZC);
var Of = {};
function it(e, t) {
  if (!!!e)
    throw new Error(t);
}
const tM = 10, $w = 2;
function _e(e) {
  return zu(e, []);
}
function zu(e, t) {
  switch (typeof e) {
    case "string":
      return JSON.stringify(e);
    case "function":
      return e.name ? `[function ${e.name}]` : "[function]";
    case "object":
      return nM(e, t);
    default:
      return String(e);
  }
}
function nM(e, t) {
  if (e === null)
    return "null";
  if (t.includes(e))
    return "[Circular]";
  const n = [...t, e];
  if (rM(e)) {
    const r = e.toJSON();
    if (r !== e)
      return typeof r == "string" ? r : zu(r, n);
  } else if (Array.isArray(e))
    return sM(e, n);
  return iM(e, n);
}
function rM(e) {
  return typeof e.toJSON == "function";
}
function iM(e, t) {
  const n = Object.entries(e);
  return n.length === 0 ? "{}" : t.length > $w ? "[" + oM(e) + "]" : "{ " + n.map(
    ([i, s]) => i + ": " + zu(s, t)
  ).join(", ") + " }";
}
function sM(e, t) {
  if (e.length === 0)
    return "[]";
  if (t.length > $w)
    return "[Array]";
  const n = Math.min(tM, e.length), r = e.length - n, i = [];
  for (let s = 0; s < n; ++s)
    i.push(zu(e[s], t));
  return r === 1 ? i.push("... 1 more item") : r > 1 && i.push(`... ${r} more items`), "[" + i.join(", ") + "]";
}
function oM(e) {
  const t = Object.prototype.toString.call(e).replace(/^\[object /, "").replace(/]$/, "");
  if (t === "Object" && typeof e.constructor == "function") {
    const n = e.constructor.name;
    if (typeof n == "string" && n !== "")
      return n;
  }
  return t;
}
const aM = globalThis.process && // eslint-disable-next-line no-undef
process.env.NODE_ENV === "production", tr = (
  /* c8 ignore next 6 */
  // FIXME: https://github.com/graphql/graphql-js/issues/2317
  aM ? function(t, n) {
    return t instanceof n;
  } : function(t, n) {
    if (t instanceof n)
      return !0;
    if (typeof t == "object" && t !== null) {
      var r;
      const i = n.prototype[Symbol.toStringTag], s = (
        // We still need to support constructor's name to detect conflicts with older versions of this library.
        Symbol.toStringTag in t ? t[Symbol.toStringTag] : (r = t.constructor) === null || r === void 0 ? void 0 : r.name
      );
      if (i === s) {
        const o = _e(t);
        throw new Error(`Cannot use ${i} "${o}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
      }
    }
    return !1;
  }
);
class qu {
  constructor(t, n = "GraphQL request", r = {
    line: 1,
    column: 1
  }) {
    typeof t == "string" || it(!1, `Body must be a string. Received: ${_e(t)}.`), this.body = t, this.name = n, this.locationOffset = r, this.locationOffset.line > 0 || it(
      !1,
      "line in locationOffset is 1-indexed and must be positive."
    ), this.locationOffset.column > 0 || it(
      !1,
      "column in locationOffset is 1-indexed and must be positive."
    );
  }
  get [Symbol.toStringTag]() {
    return "Source";
  }
}
function Nw(e) {
  return tr(e, qu);
}
function Ht(e, t) {
  if (!!!e)
    throw new Error(
      t ?? "Unexpected invariant triggered."
    );
}
const lM = /\r\n|[\n\r]/g;
function Ql(e, t) {
  let n = 0, r = 1;
  for (const i of e.body.matchAll(lM)) {
    if (typeof i.index == "number" || Ht(!1), i.index >= t)
      break;
    n = i.index + i[0].length, r += 1;
  }
  return {
    line: r,
    column: t + 1 - n
  };
}
function Ow(e) {
  return ph(
    e.source,
    Ql(e.source, e.start)
  );
}
function ph(e, t) {
  const n = e.locationOffset.column - 1, r = "".padStart(n) + e.body, i = t.line - 1, s = e.locationOffset.line - 1, o = t.line + s, a = t.line === 1 ? n : 0, l = t.column + a, c = `${e.name}:${o}:${l}
`, u = r.split(/\r\n|[\n\r]/g), f = u[i];
  if (f.length > 120) {
    const d = Math.floor(l / 80), p = l % 80, h = [];
    for (let m = 0; m < f.length; m += 80)
      h.push(f.slice(m, m + 80));
    return c + kg([
      [`${o} |`, h[0]],
      ...h.slice(1, d + 1).map((m) => ["|", m]),
      ["|", "^".padStart(p)],
      ["|", h[d + 1]]
    ]);
  }
  return c + kg([
    // Lines specified like this: ["prefix", "string"],
    [`${o - 1} |`, u[i - 1]],
    [`${o} |`, f],
    ["|", "^".padStart(l)],
    [`${o + 1} |`, u[i + 1]]
  ]);
}
function kg(e) {
  const t = e.filter(([r, i]) => i !== void 0), n = Math.max(...t.map(([r]) => r.length));
  return t.map(([r, i]) => r.padStart(n) + (i ? " " + i : "")).join(`
`);
}
var Q;
(function(e) {
  e.NAME = "Name", e.DOCUMENT = "Document", e.OPERATION_DEFINITION = "OperationDefinition", e.VARIABLE_DEFINITION = "VariableDefinition", e.SELECTION_SET = "SelectionSet", e.FIELD = "Field", e.ARGUMENT = "Argument", e.FRAGMENT_SPREAD = "FragmentSpread", e.INLINE_FRAGMENT = "InlineFragment", e.FRAGMENT_DEFINITION = "FragmentDefinition", e.VARIABLE = "Variable", e.INT = "IntValue", e.FLOAT = "FloatValue", e.STRING = "StringValue", e.BOOLEAN = "BooleanValue", e.NULL = "NullValue", e.ENUM = "EnumValue", e.LIST = "ListValue", e.OBJECT = "ObjectValue", e.OBJECT_FIELD = "ObjectField", e.DIRECTIVE = "Directive", e.NAMED_TYPE = "NamedType", e.LIST_TYPE = "ListType", e.NON_NULL_TYPE = "NonNullType", e.SCHEMA_DEFINITION = "SchemaDefinition", e.OPERATION_TYPE_DEFINITION = "OperationTypeDefinition", e.SCALAR_TYPE_DEFINITION = "ScalarTypeDefinition", e.OBJECT_TYPE_DEFINITION = "ObjectTypeDefinition", e.FIELD_DEFINITION = "FieldDefinition", e.INPUT_VALUE_DEFINITION = "InputValueDefinition", e.INTERFACE_TYPE_DEFINITION = "InterfaceTypeDefinition", e.UNION_TYPE_DEFINITION = "UnionTypeDefinition", e.ENUM_TYPE_DEFINITION = "EnumTypeDefinition", e.ENUM_VALUE_DEFINITION = "EnumValueDefinition", e.INPUT_OBJECT_TYPE_DEFINITION = "InputObjectTypeDefinition", e.DIRECTIVE_DEFINITION = "DirectiveDefinition", e.SCHEMA_EXTENSION = "SchemaExtension", e.SCALAR_TYPE_EXTENSION = "ScalarTypeExtension", e.OBJECT_TYPE_EXTENSION = "ObjectTypeExtension", e.INTERFACE_TYPE_EXTENSION = "InterfaceTypeExtension", e.UNION_TYPE_EXTENSION = "UnionTypeExtension", e.ENUM_TYPE_EXTENSION = "EnumTypeExtension", e.INPUT_OBJECT_TYPE_EXTENSION = "InputObjectTypeExtension";
})(Q || (Q = {}));
var be;
(function(e) {
  e.SOF = "<SOF>", e.EOF = "<EOF>", e.BANG = "!", e.DOLLAR = "$", e.AMP = "&", e.PAREN_L = "(", e.PAREN_R = ")", e.SPREAD = "...", e.COLON = ":", e.EQUALS = "=", e.AT = "@", e.BRACKET_L = "[", e.BRACKET_R = "]", e.BRACE_L = "{", e.PIPE = "|", e.BRACE_R = "}", e.NAME = "Name", e.INT = "Int", e.FLOAT = "Float", e.STRING = "String", e.BLOCK_STRING = "BlockString", e.COMMENT = "Comment";
})(be || (be = {}));
function vn(e) {
  return typeof e == "object" && e !== null;
}
function uM(e) {
  const t = e[0];
  return t == null || "kind" in t || "length" in t ? {
    nodes: t,
    source: e[1],
    positions: e[2],
    path: e[3],
    originalError: e[4],
    extensions: e[5]
  } : t;
}
let ge = class Iw extends Error {
  /**
   * An array of `{ line, column }` locations within the source GraphQL document
   * which correspond to this error.
   *
   * Errors during validation often contain multiple locations, for example to
   * point out two things with the same name. Errors during execution include a
   * single location, the field which produced the error.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */
  /**
   * An array describing the JSON-path into the execution response which
   * corresponds to this error. Only included for errors during execution.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */
  /**
   * An array of GraphQL AST Nodes corresponding to this error.
   */
  /**
   * The source GraphQL document for the first location of this error.
   *
   * Note that if this Error represents more than one node, the source may not
   * represent nodes after the first node.
   */
  /**
   * An array of character offsets within the source GraphQL document
   * which correspond to this error.
   */
  /**
   * The original error thrown from a field resolver during execution.
   */
  /**
   * Extension fields to add to the formatted error.
   */
  /**
   * @deprecated Please use the `GraphQLErrorOptions` constructor overload instead.
   */
  constructor(t, ...n) {
    var r, i, s;
    const { nodes: o, source: a, positions: l, path: c, originalError: u, extensions: f } = uM(n);
    super(t), this.name = "GraphQLError", this.path = c ?? void 0, this.originalError = u ?? void 0, this.nodes = Lg(
      Array.isArray(o) ? o : o ? [o] : void 0
    );
    const d = Lg(
      (r = this.nodes) === null || r === void 0 ? void 0 : r.map((h) => h.loc).filter((h) => h != null)
    );
    this.source = a ?? (d == null || (i = d[0]) === null || i === void 0 ? void 0 : i.source), this.positions = l ?? d?.map((h) => h.start), this.locations = l && a ? l.map((h) => Ql(a, h)) : d?.map((h) => Ql(h.source, h.start));
    const p = vn(
      u?.extensions
    ) ? u?.extensions : void 0;
    this.extensions = (s = f ?? p) !== null && s !== void 0 ? s : /* @__PURE__ */ Object.create(null), Object.defineProperties(this, {
      message: {
        writable: !0,
        enumerable: !0
      },
      name: {
        enumerable: !1
      },
      nodes: {
        enumerable: !1
      },
      source: {
        enumerable: !1
      },
      positions: {
        enumerable: !1
      },
      originalError: {
        enumerable: !1
      }
    }), u != null && u.stack ? Object.defineProperty(this, "stack", {
      value: u.stack,
      writable: !0,
      configurable: !0
    }) : Error.captureStackTrace ? Error.captureStackTrace(this, Iw) : Object.defineProperty(this, "stack", {
      value: Error().stack,
      writable: !0,
      configurable: !0
    });
  }
  get [Symbol.toStringTag]() {
    return "GraphQLError";
  }
  toString() {
    let t = this.message;
    if (this.nodes)
      for (const n of this.nodes)
        n.loc && (t += `

` + Ow(n.loc));
    else if (this.source && this.locations)
      for (const n of this.locations)
        t += `

` + ph(this.source, n);
    return t;
  }
  toJSON() {
    const t = {
      message: this.message
    };
    return this.locations != null && (t.locations = this.locations), this.path != null && (t.path = this.path), this.extensions != null && Object.keys(this.extensions).length > 0 && (t.extensions = this.extensions), t;
  }
};
function Lg(e) {
  return e === void 0 || e.length === 0 ? void 0 : e;
}
function cM(e) {
  return e.toString();
}
function fM(e) {
  return e.toJSON();
}
function Gt(e, t, n) {
  return new ge(`Syntax Error: ${n}`, {
    source: e,
    positions: [t]
  });
}
class Rw {
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The Token at which this Node begins.
   */
  /**
   * The Token at which this Node ends.
   */
  /**
   * The Source document the AST represents.
   */
  constructor(t, n, r) {
    this.start = t.start, this.end = n.end, this.startToken = t, this.endToken = n, this.source = r;
  }
  get [Symbol.toStringTag]() {
    return "Location";
  }
  toJSON() {
    return {
      start: this.start,
      end: this.end
    };
  }
}
class hh {
  /**
   * The kind of Token.
   */
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The 1-indexed line number on which this Token appears.
   */
  /**
   * The 1-indexed column number at which this Token begins.
   */
  /**
   * For non-punctuation tokens, represents the interpreted value of the token.
   *
   * Note: is undefined for punctuation tokens, but typed as string for
   * convenience in the parser.
   */
  /**
   * Tokens exist as nodes in a double-linked-list amongst all tokens
   * including ignored tokens. <SOF> is always the first node and <EOF>
   * the last.
   */
  constructor(t, n, r, i, s, o) {
    this.kind = t, this.start = n, this.end = r, this.line = i, this.column = s, this.value = o, this.prev = null, this.next = null;
  }
  get [Symbol.toStringTag]() {
    return "Token";
  }
  toJSON() {
    return {
      kind: this.kind,
      value: this.value,
      line: this.line,
      column: this.column
    };
  }
}
const Aw = {
  Name: [],
  Document: ["definitions"],
  OperationDefinition: [
    "name",
    "variableDefinitions",
    "directives",
    "selectionSet"
  ],
  VariableDefinition: ["variable", "type", "defaultValue", "directives"],
  Variable: ["name"],
  SelectionSet: ["selections"],
  Field: ["alias", "name", "arguments", "directives", "selectionSet"],
  Argument: ["name", "value"],
  FragmentSpread: ["name", "directives"],
  InlineFragment: ["typeCondition", "directives", "selectionSet"],
  FragmentDefinition: [
    "name",
    // Note: fragment variable definitions are deprecated and will removed in v17.0.0
    "variableDefinitions",
    "typeCondition",
    "directives",
    "selectionSet"
  ],
  IntValue: [],
  FloatValue: [],
  StringValue: [],
  BooleanValue: [],
  NullValue: [],
  EnumValue: [],
  ListValue: ["values"],
  ObjectValue: ["fields"],
  ObjectField: ["name", "value"],
  Directive: ["name", "arguments"],
  NamedType: ["name"],
  ListType: ["type"],
  NonNullType: ["type"],
  SchemaDefinition: ["description", "directives", "operationTypes"],
  OperationTypeDefinition: ["type"],
  ScalarTypeDefinition: ["description", "name", "directives"],
  ObjectTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  FieldDefinition: ["description", "name", "arguments", "type", "directives"],
  InputValueDefinition: [
    "description",
    "name",
    "type",
    "defaultValue",
    "directives"
  ],
  InterfaceTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  UnionTypeDefinition: ["description", "name", "directives", "types"],
  EnumTypeDefinition: ["description", "name", "directives", "values"],
  EnumValueDefinition: ["description", "name", "directives"],
  InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
  DirectiveDefinition: ["description", "name", "arguments", "locations"],
  SchemaExtension: ["directives", "operationTypes"],
  ScalarTypeExtension: ["name", "directives"],
  ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
  InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
  UnionTypeExtension: ["name", "directives", "types"],
  EnumTypeExtension: ["name", "directives", "values"],
  InputObjectTypeExtension: ["name", "directives", "fields"]
}, dM = new Set(Object.keys(Aw));
function md(e) {
  const t = e?.kind;
  return typeof t == "string" && dM.has(t);
}
var zt;
(function(e) {
  e.QUERY = "query", e.MUTATION = "mutation", e.SUBSCRIPTION = "subscription";
})(zt || (zt = {}));
function yd(e) {
  return e === 9 || e === 32;
}
function Yo(e) {
  return e >= 48 && e <= 57;
}
function xw(e) {
  return e >= 97 && e <= 122 || // A-Z
  e >= 65 && e <= 90;
}
function mh(e) {
  return xw(e) || e === 95;
}
function Dw(e) {
  return xw(e) || Yo(e) || e === 95;
}
function pM(e) {
  var t;
  let n = Number.MAX_SAFE_INTEGER, r = null, i = -1;
  for (let o = 0; o < e.length; ++o) {
    var s;
    const a = e[o], l = hM(a);
    l !== a.length && (r = (s = r) !== null && s !== void 0 ? s : o, i = o, o !== 0 && l < n && (n = l));
  }
  return e.map((o, a) => a === 0 ? o : o.slice(n)).slice(
    (t = r) !== null && t !== void 0 ? t : 0,
    i + 1
  );
}
function hM(e) {
  let t = 0;
  for (; t < e.length && yd(e.charCodeAt(t)); )
    ++t;
  return t;
}
function mM(e) {
  if (e === "")
    return !0;
  let t = !0, n = !1, r = !0, i = !1;
  for (let s = 0; s < e.length; ++s)
    switch (e.codePointAt(s)) {
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
      case 8:
      case 11:
      case 12:
      case 14:
      case 15:
        return !1;
      case 13:
        return !1;
      case 10:
        if (t && !i)
          return !1;
        i = !0, t = !0, n = !1;
        break;
      case 9:
      case 32:
        n || (n = t);
        break;
      default:
        r && (r = n), t = !1;
    }
  return !(t || r && i);
}
function Pw(e, t) {
  const n = e.replace(/"""/g, '\\"""'), r = n.split(/\r\n|[\n\r]/g), i = r.length === 1, s = r.length > 1 && r.slice(1).every((p) => p.length === 0 || yd(p.charCodeAt(0))), o = n.endsWith('\\"""'), a = e.endsWith('"') && !o, l = e.endsWith("\\"), c = a || l, u = !(t != null && t.minimize) && // add leading and trailing new lines only if it improves readability
  (!i || e.length > 70 || c || s || o);
  let f = "";
  const d = i && yd(e.charCodeAt(0));
  return (u && !d || s) && (f += `
`), f += n, (u || c) && (f += `
`), '"""' + f + '"""';
}
class yh {
  /**
   * The previously focused non-ignored token.
   */
  /**
   * The currently focused non-ignored token.
   */
  /**
   * The (1-indexed) line containing the current token.
   */
  /**
   * The character offset at which the current line begins.
   */
  constructor(t) {
    const n = new hh(be.SOF, 0, 0, 0, 0);
    this.source = t, this.lastToken = n, this.token = n, this.line = 1, this.lineStart = 0;
  }
  get [Symbol.toStringTag]() {
    return "Lexer";
  }
  /**
   * Advances the token stream to the next non-ignored token.
   */
  advance() {
    return this.lastToken = this.token, this.token = this.lookahead();
  }
  /**
   * Looks ahead and returns the next non-ignored token, but does not change
   * the state of Lexer.
   */
  lookahead() {
    let t = this.token;
    if (t.kind !== be.EOF)
      do
        if (t.next)
          t = t.next;
        else {
          const n = yM(this, t.end);
          t.next = n, n.prev = t, t = n;
        }
      while (t.kind === be.COMMENT);
    return t;
  }
}
function kw(e) {
  return e === be.BANG || e === be.DOLLAR || e === be.AMP || e === be.PAREN_L || e === be.PAREN_R || e === be.SPREAD || e === be.COLON || e === be.EQUALS || e === be.AT || e === be.BRACKET_L || e === be.BRACKET_R || e === be.BRACE_L || e === be.PIPE || e === be.BRACE_R;
}
function Us(e) {
  return e >= 0 && e <= 55295 || e >= 57344 && e <= 1114111;
}
function Hu(e, t) {
  return Lw(e.charCodeAt(t)) && jw(e.charCodeAt(t + 1));
}
function Lw(e) {
  return e >= 55296 && e <= 56319;
}
function jw(e) {
  return e >= 56320 && e <= 57343;
}
function Bi(e, t) {
  const n = e.source.body.codePointAt(t);
  if (n === void 0)
    return be.EOF;
  if (n >= 32 && n <= 126) {
    const r = String.fromCodePoint(n);
    return r === '"' ? `'"'` : `"${r}"`;
  }
  return "U+" + n.toString(16).toUpperCase().padStart(4, "0");
}
function Mt(e, t, n, r, i) {
  const s = e.line, o = 1 + n - e.lineStart;
  return new hh(t, n, r, s, o, i);
}
function yM(e, t) {
  const n = e.source.body, r = n.length;
  let i = t;
  for (; i < r; ) {
    const s = n.charCodeAt(i);
    switch (s) {
      case 65279:
      case 9:
      case 32:
      case 44:
        ++i;
        continue;
      case 10:
        ++i, ++e.line, e.lineStart = i;
        continue;
      case 13:
        n.charCodeAt(i + 1) === 10 ? i += 2 : ++i, ++e.line, e.lineStart = i;
        continue;
      case 35:
        return gM(e, i);
      case 33:
        return Mt(e, be.BANG, i, i + 1);
      case 36:
        return Mt(e, be.DOLLAR, i, i + 1);
      case 38:
        return Mt(e, be.AMP, i, i + 1);
      case 40:
        return Mt(e, be.PAREN_L, i, i + 1);
      case 41:
        return Mt(e, be.PAREN_R, i, i + 1);
      case 46:
        if (n.charCodeAt(i + 1) === 46 && n.charCodeAt(i + 2) === 46)
          return Mt(e, be.SPREAD, i, i + 3);
        break;
      case 58:
        return Mt(e, be.COLON, i, i + 1);
      case 61:
        return Mt(e, be.EQUALS, i, i + 1);
      case 64:
        return Mt(e, be.AT, i, i + 1);
      case 91:
        return Mt(e, be.BRACKET_L, i, i + 1);
      case 93:
        return Mt(e, be.BRACKET_R, i, i + 1);
      case 123:
        return Mt(e, be.BRACE_L, i, i + 1);
      case 124:
        return Mt(e, be.PIPE, i, i + 1);
      case 125:
        return Mt(e, be.BRACE_R, i, i + 1);
      case 34:
        return n.charCodeAt(i + 1) === 34 && n.charCodeAt(i + 2) === 34 ? SM(e, i) : vM(e, i);
    }
    if (Yo(s) || s === 45)
      return bM(e, i, s);
    if (mh(s))
      return TM(e, i);
    throw Gt(
      e.source,
      i,
      s === 39 ? `Unexpected single quote character ('), did you mean to use a double quote (")?` : Us(s) || Hu(n, i) ? `Unexpected character: ${Bi(e, i)}.` : `Invalid character: ${Bi(e, i)}.`
    );
  }
  return Mt(e, be.EOF, r, r);
}
function gM(e, t) {
  const n = e.source.body, r = n.length;
  let i = t + 1;
  for (; i < r; ) {
    const s = n.charCodeAt(i);
    if (s === 10 || s === 13)
      break;
    if (Us(s))
      ++i;
    else if (Hu(n, i))
      i += 2;
    else
      break;
  }
  return Mt(
    e,
    be.COMMENT,
    t,
    i,
    n.slice(t + 1, i)
  );
}
function bM(e, t, n) {
  const r = e.source.body;
  let i = t, s = n, o = !1;
  if (s === 45 && (s = r.charCodeAt(++i)), s === 48) {
    if (s = r.charCodeAt(++i), Yo(s))
      throw Gt(
        e.source,
        i,
        `Invalid number, unexpected digit after 0: ${Bi(
          e,
          i
        )}.`
      );
  } else
    i = If(e, i, s), s = r.charCodeAt(i);
  if (s === 46 && (o = !0, s = r.charCodeAt(++i), i = If(e, i, s), s = r.charCodeAt(i)), (s === 69 || s === 101) && (o = !0, s = r.charCodeAt(++i), (s === 43 || s === 45) && (s = r.charCodeAt(++i)), i = If(e, i, s), s = r.charCodeAt(i)), s === 46 || mh(s))
    throw Gt(
      e.source,
      i,
      `Invalid number, expected digit but got: ${Bi(
        e,
        i
      )}.`
    );
  return Mt(
    e,
    o ? be.FLOAT : be.INT,
    t,
    i,
    r.slice(t, i)
  );
}
function If(e, t, n) {
  if (!Yo(n))
    throw Gt(
      e.source,
      t,
      `Invalid number, expected digit but got: ${Bi(
        e,
        t
      )}.`
    );
  const r = e.source.body;
  let i = t + 1;
  for (; Yo(r.charCodeAt(i)); )
    ++i;
  return i;
}
function vM(e, t) {
  const n = e.source.body, r = n.length;
  let i = t + 1, s = i, o = "";
  for (; i < r; ) {
    const a = n.charCodeAt(i);
    if (a === 34)
      return o += n.slice(s, i), Mt(e, be.STRING, t, i + 1, o);
    if (a === 92) {
      o += n.slice(s, i);
      const l = n.charCodeAt(i + 1) === 117 ? n.charCodeAt(i + 2) === 123 ? _M(e, i) : wM(e, i) : EM(e, i);
      o += l.value, i += l.size, s = i;
      continue;
    }
    if (a === 10 || a === 13)
      break;
    if (Us(a))
      ++i;
    else if (Hu(n, i))
      i += 2;
    else
      throw Gt(
        e.source,
        i,
        `Invalid character within String: ${Bi(
          e,
          i
        )}.`
      );
  }
  throw Gt(e.source, i, "Unterminated string.");
}
function _M(e, t) {
  const n = e.source.body;
  let r = 0, i = 3;
  for (; i < 12; ) {
    const s = n.charCodeAt(t + i++);
    if (s === 125) {
      if (i < 5 || !Us(r))
        break;
      return {
        value: String.fromCodePoint(r),
        size: i
      };
    }
    if (r = r << 4 | Io(s), r < 0)
      break;
  }
  throw Gt(
    e.source,
    t,
    `Invalid Unicode escape sequence: "${n.slice(
      t,
      t + i
    )}".`
  );
}
function wM(e, t) {
  const n = e.source.body, r = jg(n, t + 2);
  if (Us(r))
    return {
      value: String.fromCodePoint(r),
      size: 6
    };
  if (Lw(r) && n.charCodeAt(t + 6) === 92 && n.charCodeAt(t + 7) === 117) {
    const i = jg(n, t + 8);
    if (jw(i))
      return {
        value: String.fromCodePoint(r, i),
        size: 12
      };
  }
  throw Gt(
    e.source,
    t,
    `Invalid Unicode escape sequence: "${n.slice(t, t + 6)}".`
  );
}
function jg(e, t) {
  return Io(e.charCodeAt(t)) << 12 | Io(e.charCodeAt(t + 1)) << 8 | Io(e.charCodeAt(t + 2)) << 4 | Io(e.charCodeAt(t + 3));
}
function Io(e) {
  return e >= 48 && e <= 57 ? e - 48 : e >= 65 && e <= 70 ? e - 55 : e >= 97 && e <= 102 ? e - 87 : -1;
}
function EM(e, t) {
  const n = e.source.body;
  switch (n.charCodeAt(t + 1)) {
    case 34:
      return {
        value: '"',
        size: 2
      };
    case 92:
      return {
        value: "\\",
        size: 2
      };
    case 47:
      return {
        value: "/",
        size: 2
      };
    case 98:
      return {
        value: "\b",
        size: 2
      };
    case 102:
      return {
        value: "\f",
        size: 2
      };
    case 110:
      return {
        value: `
`,
        size: 2
      };
    case 114:
      return {
        value: "\r",
        size: 2
      };
    case 116:
      return {
        value: "	",
        size: 2
      };
  }
  throw Gt(
    e.source,
    t,
    `Invalid character escape sequence: "${n.slice(
      t,
      t + 2
    )}".`
  );
}
function SM(e, t) {
  const n = e.source.body, r = n.length;
  let i = e.lineStart, s = t + 3, o = s, a = "";
  const l = [];
  for (; s < r; ) {
    const c = n.charCodeAt(s);
    if (c === 34 && n.charCodeAt(s + 1) === 34 && n.charCodeAt(s + 2) === 34) {
      a += n.slice(o, s), l.push(a);
      const u = Mt(
        e,
        be.BLOCK_STRING,
        t,
        s + 3,
        // Return a string of the lines joined with U+000A.
        pM(l).join(`
`)
      );
      return e.line += l.length - 1, e.lineStart = i, u;
    }
    if (c === 92 && n.charCodeAt(s + 1) === 34 && n.charCodeAt(s + 2) === 34 && n.charCodeAt(s + 3) === 34) {
      a += n.slice(o, s), o = s + 1, s += 4;
      continue;
    }
    if (c === 10 || c === 13) {
      a += n.slice(o, s), l.push(a), c === 13 && n.charCodeAt(s + 1) === 10 ? s += 2 : ++s, a = "", o = s, i = s;
      continue;
    }
    if (Us(c))
      ++s;
    else if (Hu(n, s))
      s += 2;
    else
      throw Gt(
        e.source,
        s,
        `Invalid character within String: ${Bi(
          e,
          s
        )}.`
      );
  }
  throw Gt(e.source, s, "Unterminated string.");
}
function TM(e, t) {
  const n = e.source.body, r = n.length;
  let i = t + 1;
  for (; i < r; ) {
    const s = n.charCodeAt(i);
    if (Dw(s))
      ++i;
    else
      break;
  }
  return Mt(
    e,
    be.NAME,
    t,
    i,
    n.slice(t, i)
  );
}
var Fe;
(function(e) {
  e.QUERY = "QUERY", e.MUTATION = "MUTATION", e.SUBSCRIPTION = "SUBSCRIPTION", e.FIELD = "FIELD", e.FRAGMENT_DEFINITION = "FRAGMENT_DEFINITION", e.FRAGMENT_SPREAD = "FRAGMENT_SPREAD", e.INLINE_FRAGMENT = "INLINE_FRAGMENT", e.VARIABLE_DEFINITION = "VARIABLE_DEFINITION", e.SCHEMA = "SCHEMA", e.SCALAR = "SCALAR", e.OBJECT = "OBJECT", e.FIELD_DEFINITION = "FIELD_DEFINITION", e.ARGUMENT_DEFINITION = "ARGUMENT_DEFINITION", e.INTERFACE = "INTERFACE", e.UNION = "UNION", e.ENUM = "ENUM", e.ENUM_VALUE = "ENUM_VALUE", e.INPUT_OBJECT = "INPUT_OBJECT", e.INPUT_FIELD_DEFINITION = "INPUT_FIELD_DEFINITION";
})(Fe || (Fe = {}));
function gh(e, t) {
  return new Wu(e, t).parseDocument();
}
function Cw(e, t) {
  const n = new Wu(e, t);
  n.expectToken(be.SOF);
  const r = n.parseValueLiteral(!1);
  return n.expectToken(be.EOF), r;
}
function $M(e, t) {
  const n = new Wu(e, t);
  n.expectToken(be.SOF);
  const r = n.parseConstValueLiteral();
  return n.expectToken(be.EOF), r;
}
function NM(e, t) {
  const n = new Wu(e, t);
  n.expectToken(be.SOF);
  const r = n.parseTypeReference();
  return n.expectToken(be.EOF), r;
}
class Wu {
  constructor(t, n = {}) {
    const r = Nw(t) ? t : new qu(t);
    this._lexer = new yh(r), this._options = n, this._tokenCounter = 0;
  }
  /**
   * Converts a name lex token into a name parse node.
   */
  parseName() {
    const t = this.expectToken(be.NAME);
    return this.node(t, {
      kind: Q.NAME,
      value: t.value
    });
  }
  // Implements the parsing rules in the Document section.
  /**
   * Document : Definition+
   */
  parseDocument() {
    return this.node(this._lexer.token, {
      kind: Q.DOCUMENT,
      definitions: this.many(
        be.SOF,
        this.parseDefinition,
        be.EOF
      )
    });
  }
  /**
   * Definition :
   *   - ExecutableDefinition
   *   - TypeSystemDefinition
   *   - TypeSystemExtension
   *
   * ExecutableDefinition :
   *   - OperationDefinition
   *   - FragmentDefinition
   *
   * TypeSystemDefinition :
   *   - SchemaDefinition
   *   - TypeDefinition
   *   - DirectiveDefinition
   *
   * TypeDefinition :
   *   - ScalarTypeDefinition
   *   - ObjectTypeDefinition
   *   - InterfaceTypeDefinition
   *   - UnionTypeDefinition
   *   - EnumTypeDefinition
   *   - InputObjectTypeDefinition
   */
  parseDefinition() {
    if (this.peek(be.BRACE_L))
      return this.parseOperationDefinition();
    const t = this.peekDescription(), n = t ? this._lexer.lookahead() : this._lexer.token;
    if (n.kind === be.NAME) {
      switch (n.value) {
        case "schema":
          return this.parseSchemaDefinition();
        case "scalar":
          return this.parseScalarTypeDefinition();
        case "type":
          return this.parseObjectTypeDefinition();
        case "interface":
          return this.parseInterfaceTypeDefinition();
        case "union":
          return this.parseUnionTypeDefinition();
        case "enum":
          return this.parseEnumTypeDefinition();
        case "input":
          return this.parseInputObjectTypeDefinition();
        case "directive":
          return this.parseDirectiveDefinition();
      }
      if (t)
        throw Gt(
          this._lexer.source,
          this._lexer.token.start,
          "Unexpected description, descriptions are supported only on type definitions."
        );
      switch (n.value) {
        case "query":
        case "mutation":
        case "subscription":
          return this.parseOperationDefinition();
        case "fragment":
          return this.parseFragmentDefinition();
        case "extend":
          return this.parseTypeSystemExtension();
      }
    }
    throw this.unexpected(n);
  }
  // Implements the parsing rules in the Operations section.
  /**
   * OperationDefinition :
   *  - SelectionSet
   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet
   */
  parseOperationDefinition() {
    const t = this._lexer.token;
    if (this.peek(be.BRACE_L))
      return this.node(t, {
        kind: Q.OPERATION_DEFINITION,
        operation: zt.QUERY,
        name: void 0,
        variableDefinitions: [],
        directives: [],
        selectionSet: this.parseSelectionSet()
      });
    const n = this.parseOperationType();
    let r;
    return this.peek(be.NAME) && (r = this.parseName()), this.node(t, {
      kind: Q.OPERATION_DEFINITION,
      operation: n,
      name: r,
      variableDefinitions: this.parseVariableDefinitions(),
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * OperationType : one of query mutation subscription
   */
  parseOperationType() {
    const t = this.expectToken(be.NAME);
    switch (t.value) {
      case "query":
        return zt.QUERY;
      case "mutation":
        return zt.MUTATION;
      case "subscription":
        return zt.SUBSCRIPTION;
    }
    throw this.unexpected(t);
  }
  /**
   * VariableDefinitions : ( VariableDefinition+ )
   */
  parseVariableDefinitions() {
    return this.optionalMany(
      be.PAREN_L,
      this.parseVariableDefinition,
      be.PAREN_R
    );
  }
  /**
   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?
   */
  parseVariableDefinition() {
    return this.node(this._lexer.token, {
      kind: Q.VARIABLE_DEFINITION,
      variable: this.parseVariable(),
      type: (this.expectToken(be.COLON), this.parseTypeReference()),
      defaultValue: this.expectOptionalToken(be.EQUALS) ? this.parseConstValueLiteral() : void 0,
      directives: this.parseConstDirectives()
    });
  }
  /**
   * Variable : $ Name
   */
  parseVariable() {
    const t = this._lexer.token;
    return this.expectToken(be.DOLLAR), this.node(t, {
      kind: Q.VARIABLE,
      name: this.parseName()
    });
  }
  /**
   * ```
   * SelectionSet : { Selection+ }
   * ```
   */
  parseSelectionSet() {
    return this.node(this._lexer.token, {
      kind: Q.SELECTION_SET,
      selections: this.many(
        be.BRACE_L,
        this.parseSelection,
        be.BRACE_R
      )
    });
  }
  /**
   * Selection :
   *   - Field
   *   - FragmentSpread
   *   - InlineFragment
   */
  parseSelection() {
    return this.peek(be.SPREAD) ? this.parseFragment() : this.parseField();
  }
  /**
   * Field : Alias? Name Arguments? Directives? SelectionSet?
   *
   * Alias : Name :
   */
  parseField() {
    const t = this._lexer.token, n = this.parseName();
    let r, i;
    return this.expectOptionalToken(be.COLON) ? (r = n, i = this.parseName()) : i = n, this.node(t, {
      kind: Q.FIELD,
      alias: r,
      name: i,
      arguments: this.parseArguments(!1),
      directives: this.parseDirectives(!1),
      selectionSet: this.peek(be.BRACE_L) ? this.parseSelectionSet() : void 0
    });
  }
  /**
   * Arguments[Const] : ( Argument[?Const]+ )
   */
  parseArguments(t) {
    const n = t ? this.parseConstArgument : this.parseArgument;
    return this.optionalMany(be.PAREN_L, n, be.PAREN_R);
  }
  /**
   * Argument[Const] : Name : Value[?Const]
   */
  parseArgument(t = !1) {
    const n = this._lexer.token, r = this.parseName();
    return this.expectToken(be.COLON), this.node(n, {
      kind: Q.ARGUMENT,
      name: r,
      value: this.parseValueLiteral(t)
    });
  }
  parseConstArgument() {
    return this.parseArgument(!0);
  }
  // Implements the parsing rules in the Fragments section.
  /**
   * Corresponds to both FragmentSpread and InlineFragment in the spec.
   *
   * FragmentSpread : ... FragmentName Directives?
   *
   * InlineFragment : ... TypeCondition? Directives? SelectionSet
   */
  parseFragment() {
    const t = this._lexer.token;
    this.expectToken(be.SPREAD);
    const n = this.expectOptionalKeyword("on");
    return !n && this.peek(be.NAME) ? this.node(t, {
      kind: Q.FRAGMENT_SPREAD,
      name: this.parseFragmentName(),
      directives: this.parseDirectives(!1)
    }) : this.node(t, {
      kind: Q.INLINE_FRAGMENT,
      typeCondition: n ? this.parseNamedType() : void 0,
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * FragmentDefinition :
   *   - fragment FragmentName on TypeCondition Directives? SelectionSet
   *
   * TypeCondition : NamedType
   */
  parseFragmentDefinition() {
    const t = this._lexer.token;
    return this.expectKeyword("fragment"), this._options.allowLegacyFragmentVariables === !0 ? this.node(t, {
      kind: Q.FRAGMENT_DEFINITION,
      name: this.parseFragmentName(),
      variableDefinitions: this.parseVariableDefinitions(),
      typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet()
    }) : this.node(t, {
      kind: Q.FRAGMENT_DEFINITION,
      name: this.parseFragmentName(),
      typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * FragmentName : Name but not `on`
   */
  parseFragmentName() {
    if (this._lexer.token.value === "on")
      throw this.unexpected();
    return this.parseName();
  }
  // Implements the parsing rules in the Values section.
  /**
   * Value[Const] :
   *   - [~Const] Variable
   *   - IntValue
   *   - FloatValue
   *   - StringValue
   *   - BooleanValue
   *   - NullValue
   *   - EnumValue
   *   - ListValue[?Const]
   *   - ObjectValue[?Const]
   *
   * BooleanValue : one of `true` `false`
   *
   * NullValue : `null`
   *
   * EnumValue : Name but not `true`, `false` or `null`
   */
  parseValueLiteral(t) {
    const n = this._lexer.token;
    switch (n.kind) {
      case be.BRACKET_L:
        return this.parseList(t);
      case be.BRACE_L:
        return this.parseObject(t);
      case be.INT:
        return this.advanceLexer(), this.node(n, {
          kind: Q.INT,
          value: n.value
        });
      case be.FLOAT:
        return this.advanceLexer(), this.node(n, {
          kind: Q.FLOAT,
          value: n.value
        });
      case be.STRING:
      case be.BLOCK_STRING:
        return this.parseStringLiteral();
      case be.NAME:
        switch (this.advanceLexer(), n.value) {
          case "true":
            return this.node(n, {
              kind: Q.BOOLEAN,
              value: !0
            });
          case "false":
            return this.node(n, {
              kind: Q.BOOLEAN,
              value: !1
            });
          case "null":
            return this.node(n, {
              kind: Q.NULL
            });
          default:
            return this.node(n, {
              kind: Q.ENUM,
              value: n.value
            });
        }
      case be.DOLLAR:
        if (t)
          if (this.expectToken(be.DOLLAR), this._lexer.token.kind === be.NAME) {
            const r = this._lexer.token.value;
            throw Gt(
              this._lexer.source,
              n.start,
              `Unexpected variable "$${r}" in constant value.`
            );
          } else
            throw this.unexpected(n);
        return this.parseVariable();
      default:
        throw this.unexpected();
    }
  }
  parseConstValueLiteral() {
    return this.parseValueLiteral(!0);
  }
  parseStringLiteral() {
    const t = this._lexer.token;
    return this.advanceLexer(), this.node(t, {
      kind: Q.STRING,
      value: t.value,
      block: t.kind === be.BLOCK_STRING
    });
  }
  /**
   * ListValue[Const] :
   *   - [ ]
   *   - [ Value[?Const]+ ]
   */
  parseList(t) {
    const n = () => this.parseValueLiteral(t);
    return this.node(this._lexer.token, {
      kind: Q.LIST,
      values: this.any(be.BRACKET_L, n, be.BRACKET_R)
    });
  }
  /**
   * ```
   * ObjectValue[Const] :
   *   - { }
   *   - { ObjectField[?Const]+ }
   * ```
   */
  parseObject(t) {
    const n = () => this.parseObjectField(t);
    return this.node(this._lexer.token, {
      kind: Q.OBJECT,
      fields: this.any(be.BRACE_L, n, be.BRACE_R)
    });
  }
  /**
   * ObjectField[Const] : Name : Value[?Const]
   */
  parseObjectField(t) {
    const n = this._lexer.token, r = this.parseName();
    return this.expectToken(be.COLON), this.node(n, {
      kind: Q.OBJECT_FIELD,
      name: r,
      value: this.parseValueLiteral(t)
    });
  }
  // Implements the parsing rules in the Directives section.
  /**
   * Directives[Const] : Directive[?Const]+
   */
  parseDirectives(t) {
    const n = [];
    for (; this.peek(be.AT); )
      n.push(this.parseDirective(t));
    return n;
  }
  parseConstDirectives() {
    return this.parseDirectives(!0);
  }
  /**
   * ```
   * Directive[Const] : @ Name Arguments[?Const]?
   * ```
   */
  parseDirective(t) {
    const n = this._lexer.token;
    return this.expectToken(be.AT), this.node(n, {
      kind: Q.DIRECTIVE,
      name: this.parseName(),
      arguments: this.parseArguments(t)
    });
  }
  // Implements the parsing rules in the Types section.
  /**
   * Type :
   *   - NamedType
   *   - ListType
   *   - NonNullType
   */
  parseTypeReference() {
    const t = this._lexer.token;
    let n;
    if (this.expectOptionalToken(be.BRACKET_L)) {
      const r = this.parseTypeReference();
      this.expectToken(be.BRACKET_R), n = this.node(t, {
        kind: Q.LIST_TYPE,
        type: r
      });
    } else
      n = this.parseNamedType();
    return this.expectOptionalToken(be.BANG) ? this.node(t, {
      kind: Q.NON_NULL_TYPE,
      type: n
    }) : n;
  }
  /**
   * NamedType : Name
   */
  parseNamedType() {
    return this.node(this._lexer.token, {
      kind: Q.NAMED_TYPE,
      name: this.parseName()
    });
  }
  // Implements the parsing rules in the Type Definition section.
  peekDescription() {
    return this.peek(be.STRING) || this.peek(be.BLOCK_STRING);
  }
  /**
   * Description : StringValue
   */
  parseDescription() {
    if (this.peekDescription())
      return this.parseStringLiteral();
  }
  /**
   * ```
   * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }
   * ```
   */
  parseSchemaDefinition() {
    const t = this._lexer.token, n = this.parseDescription();
    this.expectKeyword("schema");
    const r = this.parseConstDirectives(), i = this.many(
      be.BRACE_L,
      this.parseOperationTypeDefinition,
      be.BRACE_R
    );
    return this.node(t, {
      kind: Q.SCHEMA_DEFINITION,
      description: n,
      directives: r,
      operationTypes: i
    });
  }
  /**
   * OperationTypeDefinition : OperationType : NamedType
   */
  parseOperationTypeDefinition() {
    const t = this._lexer.token, n = this.parseOperationType();
    this.expectToken(be.COLON);
    const r = this.parseNamedType();
    return this.node(t, {
      kind: Q.OPERATION_TYPE_DEFINITION,
      operation: n,
      type: r
    });
  }
  /**
   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?
   */
  parseScalarTypeDefinition() {
    const t = this._lexer.token, n = this.parseDescription();
    this.expectKeyword("scalar");
    const r = this.parseName(), i = this.parseConstDirectives();
    return this.node(t, {
      kind: Q.SCALAR_TYPE_DEFINITION,
      description: n,
      name: r,
      directives: i
    });
  }
  /**
   * ObjectTypeDefinition :
   *   Description?
   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?
   */
  parseObjectTypeDefinition() {
    const t = this._lexer.token, n = this.parseDescription();
    this.expectKeyword("type");
    const r = this.parseName(), i = this.parseImplementsInterfaces(), s = this.parseConstDirectives(), o = this.parseFieldsDefinition();
    return this.node(t, {
      kind: Q.OBJECT_TYPE_DEFINITION,
      description: n,
      name: r,
      interfaces: i,
      directives: s,
      fields: o
    });
  }
  /**
   * ImplementsInterfaces :
   *   - implements `&`? NamedType
   *   - ImplementsInterfaces & NamedType
   */
  parseImplementsInterfaces() {
    return this.expectOptionalKeyword("implements") ? this.delimitedMany(be.AMP, this.parseNamedType) : [];
  }
  /**
   * ```
   * FieldsDefinition : { FieldDefinition+ }
   * ```
   */
  parseFieldsDefinition() {
    return this.optionalMany(
      be.BRACE_L,
      this.parseFieldDefinition,
      be.BRACE_R
    );
  }
  /**
   * FieldDefinition :
   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?
   */
  parseFieldDefinition() {
    const t = this._lexer.token, n = this.parseDescription(), r = this.parseName(), i = this.parseArgumentDefs();
    this.expectToken(be.COLON);
    const s = this.parseTypeReference(), o = this.parseConstDirectives();
    return this.node(t, {
      kind: Q.FIELD_DEFINITION,
      description: n,
      name: r,
      arguments: i,
      type: s,
      directives: o
    });
  }
  /**
   * ArgumentsDefinition : ( InputValueDefinition+ )
   */
  parseArgumentDefs() {
    return this.optionalMany(
      be.PAREN_L,
      this.parseInputValueDef,
      be.PAREN_R
    );
  }
  /**
   * InputValueDefinition :
   *   - Description? Name : Type DefaultValue? Directives[Const]?
   */
  parseInputValueDef() {
    const t = this._lexer.token, n = this.parseDescription(), r = this.parseName();
    this.expectToken(be.COLON);
    const i = this.parseTypeReference();
    let s;
    this.expectOptionalToken(be.EQUALS) && (s = this.parseConstValueLiteral());
    const o = this.parseConstDirectives();
    return this.node(t, {
      kind: Q.INPUT_VALUE_DEFINITION,
      description: n,
      name: r,
      type: i,
      defaultValue: s,
      directives: o
    });
  }
  /**
   * InterfaceTypeDefinition :
   *   - Description? interface Name Directives[Const]? FieldsDefinition?
   */
  parseInterfaceTypeDefinition() {
    const t = this._lexer.token, n = this.parseDescription();
    this.expectKeyword("interface");
    const r = this.parseName(), i = this.parseImplementsInterfaces(), s = this.parseConstDirectives(), o = this.parseFieldsDefinition();
    return this.node(t, {
      kind: Q.INTERFACE_TYPE_DEFINITION,
      description: n,
      name: r,
      interfaces: i,
      directives: s,
      fields: o
    });
  }
  /**
   * UnionTypeDefinition :
   *   - Description? union Name Directives[Const]? UnionMemberTypes?
   */
  parseUnionTypeDefinition() {
    const t = this._lexer.token, n = this.parseDescription();
    this.expectKeyword("union");
    const r = this.parseName(), i = this.parseConstDirectives(), s = this.parseUnionMemberTypes();
    return this.node(t, {
      kind: Q.UNION_TYPE_DEFINITION,
      description: n,
      name: r,
      directives: i,
      types: s
    });
  }
  /**
   * UnionMemberTypes :
   *   - = `|`? NamedType
   *   - UnionMemberTypes | NamedType
   */
  parseUnionMemberTypes() {
    return this.expectOptionalToken(be.EQUALS) ? this.delimitedMany(be.PIPE, this.parseNamedType) : [];
  }
  /**
   * EnumTypeDefinition :
   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?
   */
  parseEnumTypeDefinition() {
    const t = this._lexer.token, n = this.parseDescription();
    this.expectKeyword("enum");
    const r = this.parseName(), i = this.parseConstDirectives(), s = this.parseEnumValuesDefinition();
    return this.node(t, {
      kind: Q.ENUM_TYPE_DEFINITION,
      description: n,
      name: r,
      directives: i,
      values: s
    });
  }
  /**
   * ```
   * EnumValuesDefinition : { EnumValueDefinition+ }
   * ```
   */
  parseEnumValuesDefinition() {
    return this.optionalMany(
      be.BRACE_L,
      this.parseEnumValueDefinition,
      be.BRACE_R
    );
  }
  /**
   * EnumValueDefinition : Description? EnumValue Directives[Const]?
   */
  parseEnumValueDefinition() {
    const t = this._lexer.token, n = this.parseDescription(), r = this.parseEnumValueName(), i = this.parseConstDirectives();
    return this.node(t, {
      kind: Q.ENUM_VALUE_DEFINITION,
      description: n,
      name: r,
      directives: i
    });
  }
  /**
   * EnumValue : Name but not `true`, `false` or `null`
   */
  parseEnumValueName() {
    if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null")
      throw Gt(
        this._lexer.source,
        this._lexer.token.start,
        `${tl(
          this._lexer.token
        )} is reserved and cannot be used for an enum value.`
      );
    return this.parseName();
  }
  /**
   * InputObjectTypeDefinition :
   *   - Description? input Name Directives[Const]? InputFieldsDefinition?
   */
  parseInputObjectTypeDefinition() {
    const t = this._lexer.token, n = this.parseDescription();
    this.expectKeyword("input");
    const r = this.parseName(), i = this.parseConstDirectives(), s = this.parseInputFieldsDefinition();
    return this.node(t, {
      kind: Q.INPUT_OBJECT_TYPE_DEFINITION,
      description: n,
      name: r,
      directives: i,
      fields: s
    });
  }
  /**
   * ```
   * InputFieldsDefinition : { InputValueDefinition+ }
   * ```
   */
  parseInputFieldsDefinition() {
    return this.optionalMany(
      be.BRACE_L,
      this.parseInputValueDef,
      be.BRACE_R
    );
  }
  /**
   * TypeSystemExtension :
   *   - SchemaExtension
   *   - TypeExtension
   *
   * TypeExtension :
   *   - ScalarTypeExtension
   *   - ObjectTypeExtension
   *   - InterfaceTypeExtension
   *   - UnionTypeExtension
   *   - EnumTypeExtension
   *   - InputObjectTypeDefinition
   */
  parseTypeSystemExtension() {
    const t = this._lexer.lookahead();
    if (t.kind === be.NAME)
      switch (t.value) {
        case "schema":
          return this.parseSchemaExtension();
        case "scalar":
          return this.parseScalarTypeExtension();
        case "type":
          return this.parseObjectTypeExtension();
        case "interface":
          return this.parseInterfaceTypeExtension();
        case "union":
          return this.parseUnionTypeExtension();
        case "enum":
          return this.parseEnumTypeExtension();
        case "input":
          return this.parseInputObjectTypeExtension();
      }
    throw this.unexpected(t);
  }
  /**
   * ```
   * SchemaExtension :
   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }
   *  - extend schema Directives[Const]
   * ```
   */
  parseSchemaExtension() {
    const t = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("schema");
    const n = this.parseConstDirectives(), r = this.optionalMany(
      be.BRACE_L,
      this.parseOperationTypeDefinition,
      be.BRACE_R
    );
    if (n.length === 0 && r.length === 0)
      throw this.unexpected();
    return this.node(t, {
      kind: Q.SCHEMA_EXTENSION,
      directives: n,
      operationTypes: r
    });
  }
  /**
   * ScalarTypeExtension :
   *   - extend scalar Name Directives[Const]
   */
  parseScalarTypeExtension() {
    const t = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("scalar");
    const n = this.parseName(), r = this.parseConstDirectives();
    if (r.length === 0)
      throw this.unexpected();
    return this.node(t, {
      kind: Q.SCALAR_TYPE_EXTENSION,
      name: n,
      directives: r
    });
  }
  /**
   * ObjectTypeExtension :
   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
   *  - extend type Name ImplementsInterfaces? Directives[Const]
   *  - extend type Name ImplementsInterfaces
   */
  parseObjectTypeExtension() {
    const t = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("type");
    const n = this.parseName(), r = this.parseImplementsInterfaces(), i = this.parseConstDirectives(), s = this.parseFieldsDefinition();
    if (r.length === 0 && i.length === 0 && s.length === 0)
      throw this.unexpected();
    return this.node(t, {
      kind: Q.OBJECT_TYPE_EXTENSION,
      name: n,
      interfaces: r,
      directives: i,
      fields: s
    });
  }
  /**
   * InterfaceTypeExtension :
   *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
   *  - extend interface Name ImplementsInterfaces? Directives[Const]
   *  - extend interface Name ImplementsInterfaces
   */
  parseInterfaceTypeExtension() {
    const t = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("interface");
    const n = this.parseName(), r = this.parseImplementsInterfaces(), i = this.parseConstDirectives(), s = this.parseFieldsDefinition();
    if (r.length === 0 && i.length === 0 && s.length === 0)
      throw this.unexpected();
    return this.node(t, {
      kind: Q.INTERFACE_TYPE_EXTENSION,
      name: n,
      interfaces: r,
      directives: i,
      fields: s
    });
  }
  /**
   * UnionTypeExtension :
   *   - extend union Name Directives[Const]? UnionMemberTypes
   *   - extend union Name Directives[Const]
   */
  parseUnionTypeExtension() {
    const t = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("union");
    const n = this.parseName(), r = this.parseConstDirectives(), i = this.parseUnionMemberTypes();
    if (r.length === 0 && i.length === 0)
      throw this.unexpected();
    return this.node(t, {
      kind: Q.UNION_TYPE_EXTENSION,
      name: n,
      directives: r,
      types: i
    });
  }
  /**
   * EnumTypeExtension :
   *   - extend enum Name Directives[Const]? EnumValuesDefinition
   *   - extend enum Name Directives[Const]
   */
  parseEnumTypeExtension() {
    const t = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("enum");
    const n = this.parseName(), r = this.parseConstDirectives(), i = this.parseEnumValuesDefinition();
    if (r.length === 0 && i.length === 0)
      throw this.unexpected();
    return this.node(t, {
      kind: Q.ENUM_TYPE_EXTENSION,
      name: n,
      directives: r,
      values: i
    });
  }
  /**
   * InputObjectTypeExtension :
   *   - extend input Name Directives[Const]? InputFieldsDefinition
   *   - extend input Name Directives[Const]
   */
  parseInputObjectTypeExtension() {
    const t = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("input");
    const n = this.parseName(), r = this.parseConstDirectives(), i = this.parseInputFieldsDefinition();
    if (r.length === 0 && i.length === 0)
      throw this.unexpected();
    return this.node(t, {
      kind: Q.INPUT_OBJECT_TYPE_EXTENSION,
      name: n,
      directives: r,
      fields: i
    });
  }
  /**
   * ```
   * DirectiveDefinition :
   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations
   * ```
   */
  parseDirectiveDefinition() {
    const t = this._lexer.token, n = this.parseDescription();
    this.expectKeyword("directive"), this.expectToken(be.AT);
    const r = this.parseName(), i = this.parseArgumentDefs(), s = this.expectOptionalKeyword("repeatable");
    this.expectKeyword("on");
    const o = this.parseDirectiveLocations();
    return this.node(t, {
      kind: Q.DIRECTIVE_DEFINITION,
      description: n,
      name: r,
      arguments: i,
      repeatable: s,
      locations: o
    });
  }
  /**
   * DirectiveLocations :
   *   - `|`? DirectiveLocation
   *   - DirectiveLocations | DirectiveLocation
   */
  parseDirectiveLocations() {
    return this.delimitedMany(be.PIPE, this.parseDirectiveLocation);
  }
  /*
   * DirectiveLocation :
   *   - ExecutableDirectiveLocation
   *   - TypeSystemDirectiveLocation
   *
   * ExecutableDirectiveLocation : one of
   *   `QUERY`
   *   `MUTATION`
   *   `SUBSCRIPTION`
   *   `FIELD`
   *   `FRAGMENT_DEFINITION`
   *   `FRAGMENT_SPREAD`
   *   `INLINE_FRAGMENT`
   *
   * TypeSystemDirectiveLocation : one of
   *   `SCHEMA`
   *   `SCALAR`
   *   `OBJECT`
   *   `FIELD_DEFINITION`
   *   `ARGUMENT_DEFINITION`
   *   `INTERFACE`
   *   `UNION`
   *   `ENUM`
   *   `ENUM_VALUE`
   *   `INPUT_OBJECT`
   *   `INPUT_FIELD_DEFINITION`
   */
  parseDirectiveLocation() {
    const t = this._lexer.token, n = this.parseName();
    if (Object.prototype.hasOwnProperty.call(Fe, n.value))
      return n;
    throw this.unexpected(t);
  }
  // Core parsing utility functions
  /**
   * Returns a node that, if configured to do so, sets a "loc" field as a
   * location object, used to identify the place in the source that created a
   * given parsed object.
   */
  node(t, n) {
    return this._options.noLocation !== !0 && (n.loc = new Rw(
      t,
      this._lexer.lastToken,
      this._lexer.source
    )), n;
  }
  /**
   * Determines if the next token is of a given kind
   */
  peek(t) {
    return this._lexer.token.kind === t;
  }
  /**
   * If the next token is of the given kind, return that token after advancing the lexer.
   * Otherwise, do not change the parser state and throw an error.
   */
  expectToken(t) {
    const n = this._lexer.token;
    if (n.kind === t)
      return this.advanceLexer(), n;
    throw Gt(
      this._lexer.source,
      n.start,
      `Expected ${Mw(t)}, found ${tl(n)}.`
    );
  }
  /**
   * If the next token is of the given kind, return "true" after advancing the lexer.
   * Otherwise, do not change the parser state and return "false".
   */
  expectOptionalToken(t) {
    return this._lexer.token.kind === t ? (this.advanceLexer(), !0) : !1;
  }
  /**
   * If the next token is a given keyword, advance the lexer.
   * Otherwise, do not change the parser state and throw an error.
   */
  expectKeyword(t) {
    const n = this._lexer.token;
    if (n.kind === be.NAME && n.value === t)
      this.advanceLexer();
    else
      throw Gt(
        this._lexer.source,
        n.start,
        `Expected "${t}", found ${tl(n)}.`
      );
  }
  /**
   * If the next token is a given keyword, return "true" after advancing the lexer.
   * Otherwise, do not change the parser state and return "false".
   */
  expectOptionalKeyword(t) {
    const n = this._lexer.token;
    return n.kind === be.NAME && n.value === t ? (this.advanceLexer(), !0) : !1;
  }
  /**
   * Helper function for creating an error when an unexpected lexed token is encountered.
   */
  unexpected(t) {
    const n = t ?? this._lexer.token;
    return Gt(
      this._lexer.source,
      n.start,
      `Unexpected ${tl(n)}.`
    );
  }
  /**
   * Returns a possibly empty list of parse nodes, determined by the parseFn.
   * This list begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  any(t, n, r) {
    this.expectToken(t);
    const i = [];
    for (; !this.expectOptionalToken(r); )
      i.push(n.call(this));
    return i;
  }
  /**
   * Returns a list of parse nodes, determined by the parseFn.
   * It can be empty only if open token is missing otherwise it will always return non-empty list
   * that begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  optionalMany(t, n, r) {
    if (this.expectOptionalToken(t)) {
      const i = [];
      do
        i.push(n.call(this));
      while (!this.expectOptionalToken(r));
      return i;
    }
    return [];
  }
  /**
   * Returns a non-empty list of parse nodes, determined by the parseFn.
   * This list begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  many(t, n, r) {
    this.expectToken(t);
    const i = [];
    do
      i.push(n.call(this));
    while (!this.expectOptionalToken(r));
    return i;
  }
  /**
   * Returns a non-empty list of parse nodes, determined by the parseFn.
   * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.
   * Advances the parser to the next lex token after last item in the list.
   */
  delimitedMany(t, n) {
    this.expectOptionalToken(t);
    const r = [];
    do
      r.push(n.call(this));
    while (this.expectOptionalToken(t));
    return r;
  }
  advanceLexer() {
    const { maxTokens: t } = this._options, n = this._lexer.advance();
    if (t !== void 0 && n.kind !== be.EOF && (++this._tokenCounter, this._tokenCounter > t))
      throw Gt(
        this._lexer.source,
        n.start,
        `Document contains more that ${t} tokens. Parsing aborted.`
      );
  }
}
function tl(e) {
  const t = e.value;
  return Mw(e.kind) + (t != null ? ` "${t}"` : "");
}
function Mw(e) {
  return kw(e) ? `"${e}"` : e;
}
function OM(e) {
  return `"${e.replace(IM, RM)}"`;
}
const IM = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
function RM(e) {
  return AM[e.charCodeAt(0)];
}
const AM = [
  "\\u0000",
  "\\u0001",
  "\\u0002",
  "\\u0003",
  "\\u0004",
  "\\u0005",
  "\\u0006",
  "\\u0007",
  "\\b",
  "\\t",
  "\\n",
  "\\u000B",
  "\\f",
  "\\r",
  "\\u000E",
  "\\u000F",
  "\\u0010",
  "\\u0011",
  "\\u0012",
  "\\u0013",
  "\\u0014",
  "\\u0015",
  "\\u0016",
  "\\u0017",
  "\\u0018",
  "\\u0019",
  "\\u001A",
  "\\u001B",
  "\\u001C",
  "\\u001D",
  "\\u001E",
  "\\u001F",
  "",
  "",
  '\\"',
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 2F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 3F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 4F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\\\",
  "",
  "",
  "",
  // 5F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 6F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\u007F",
  "\\u0080",
  "\\u0081",
  "\\u0082",
  "\\u0083",
  "\\u0084",
  "\\u0085",
  "\\u0086",
  "\\u0087",
  "\\u0088",
  "\\u0089",
  "\\u008A",
  "\\u008B",
  "\\u008C",
  "\\u008D",
  "\\u008E",
  "\\u008F",
  "\\u0090",
  "\\u0091",
  "\\u0092",
  "\\u0093",
  "\\u0094",
  "\\u0095",
  "\\u0096",
  "\\u0097",
  "\\u0098",
  "\\u0099",
  "\\u009A",
  "\\u009B",
  "\\u009C",
  "\\u009D",
  "\\u009E",
  "\\u009F"
], ds = Object.freeze({});
function Qu(e, t, n = Aw) {
  const r = /* @__PURE__ */ new Map();
  for (const b of Object.values(Q))
    r.set(b, Ns(t, b));
  let i, s = Array.isArray(e), o = [e], a = -1, l = [], c = e, u, f;
  const d = [], p = [];
  do {
    a++;
    const b = a === o.length, E = b && l.length !== 0;
    if (b) {
      if (u = p.length === 0 ? void 0 : d[d.length - 1], c = f, f = p.pop(), E)
        if (s) {
          c = c.slice();
          let D = 0;
          for (const [F, W] of l) {
            const J = F - D;
            W === null ? (c.splice(J, 1), D++) : c[J] = W;
          }
        } else {
          c = Object.defineProperties(
            {},
            Object.getOwnPropertyDescriptors(c)
          );
          for (const [D, F] of l)
            c[D] = F;
        }
      a = i.index, o = i.keys, l = i.edits, s = i.inArray, i = i.prev;
    } else if (f) {
      if (u = s ? a : o[a], c = f[u], c == null)
        continue;
      d.push(u);
    }
    let y;
    if (!Array.isArray(c)) {
      var h, m;
      md(c) || it(!1, `Invalid AST Node: ${_e(c)}.`);
      const D = b ? (h = r.get(c.kind)) === null || h === void 0 ? void 0 : h.leave : (m = r.get(c.kind)) === null || m === void 0 ? void 0 : m.enter;
      if (y = D?.call(t, c, u, f, d, p), y === ds)
        break;
      if (y === !1) {
        if (!b) {
          d.pop();
          continue;
        }
      } else if (y !== void 0 && (l.push([u, y]), !b))
        if (md(y))
          c = y;
        else {
          d.pop();
          continue;
        }
    }
    if (y === void 0 && E && l.push([u, c]), b)
      d.pop();
    else {
      var v;
      i = {
        inArray: s,
        index: a,
        keys: o,
        edits: l,
        prev: i
      }, s = Array.isArray(c), o = s ? c : (v = n[c.kind]) !== null && v !== void 0 ? v : [], a = -1, l = [], f && p.push(f), f = c;
    }
  } while (i !== void 0);
  return l.length !== 0 ? l[l.length - 1][1] : e;
}
function Fw(e) {
  const t = new Array(e.length).fill(null), n = /* @__PURE__ */ Object.create(null);
  for (const r of Object.values(Q)) {
    let i = !1;
    const s = new Array(e.length).fill(void 0), o = new Array(e.length).fill(void 0);
    for (let l = 0; l < e.length; ++l) {
      const { enter: c, leave: u } = Ns(e[l], r);
      i || (i = c != null || u != null), s[l] = c, o[l] = u;
    }
    if (!i)
      continue;
    const a = {
      enter(...l) {
        const c = l[0];
        for (let f = 0; f < e.length; f++)
          if (t[f] === null) {
            var u;
            const d = (u = s[f]) === null || u === void 0 ? void 0 : u.apply(e[f], l);
            if (d === !1)
              t[f] = c;
            else if (d === ds)
              t[f] = ds;
            else if (d !== void 0)
              return d;
          }
      },
      leave(...l) {
        const c = l[0];
        for (let f = 0; f < e.length; f++)
          if (t[f] === null) {
            var u;
            const d = (u = o[f]) === null || u === void 0 ? void 0 : u.apply(e[f], l);
            if (d === ds)
              t[f] = ds;
            else if (d !== void 0 && d !== !1)
              return d;
          } else
            t[f] === c && (t[f] = null);
      }
    };
    n[r] = a;
  }
  return n;
}
function Ns(e, t) {
  const n = e[t];
  return typeof n == "object" ? n : typeof n == "function" ? {
    enter: n,
    leave: void 0
  } : {
    enter: e.enter,
    leave: e.leave
  };
}
function xM(e, t, n) {
  const { enter: r, leave: i } = Ns(e, t);
  return n ? i : r;
}
function Et(e) {
  return Qu(e, PM);
}
const DM = 80, PM = {
  Name: {
    leave: (e) => e.value
  },
  Variable: {
    leave: (e) => "$" + e.name
  },
  // Document
  Document: {
    leave: (e) => ke(e.definitions, `

`)
  },
  OperationDefinition: {
    leave(e) {
      const t = ot("(", ke(e.variableDefinitions, ", "), ")"), n = ke(
        [
          e.operation,
          ke([e.name, t]),
          ke(e.directives, " ")
        ],
        " "
      );
      return (n === "query" ? "" : n + " ") + e.selectionSet;
    }
  },
  VariableDefinition: {
    leave: ({ variable: e, type: t, defaultValue: n, directives: r }) => e + ": " + t + ot(" = ", n) + ot(" ", ke(r, " "))
  },
  SelectionSet: {
    leave: ({ selections: e }) => Gn(e)
  },
  Field: {
    leave({ alias: e, name: t, arguments: n, directives: r, selectionSet: i }) {
      const s = ot("", e, ": ") + t;
      let o = s + ot("(", ke(n, ", "), ")");
      return o.length > DM && (o = s + ot(`(
`, Tl(ke(n, `
`)), `
)`)), ke([o, ke(r, " "), i], " ");
    }
  },
  Argument: {
    leave: ({ name: e, value: t }) => e + ": " + t
  },
  // Fragments
  FragmentSpread: {
    leave: ({ name: e, directives: t }) => "..." + e + ot(" ", ke(t, " "))
  },
  InlineFragment: {
    leave: ({ typeCondition: e, directives: t, selectionSet: n }) => ke(
      [
        "...",
        ot("on ", e),
        ke(t, " "),
        n
      ],
      " "
    )
  },
  FragmentDefinition: {
    leave: ({ name: e, typeCondition: t, variableDefinitions: n, directives: r, selectionSet: i }) => (
      // or removed in the future.
      `fragment ${e}${ot("(", ke(n, ", "), ")")} on ${t} ${ot("", ke(r, " "), " ")}` + i
    )
  },
  // Value
  IntValue: {
    leave: ({ value: e }) => e
  },
  FloatValue: {
    leave: ({ value: e }) => e
  },
  StringValue: {
    leave: ({ value: e, block: t }) => t ? Pw(e) : OM(e)
  },
  BooleanValue: {
    leave: ({ value: e }) => e ? "true" : "false"
  },
  NullValue: {
    leave: () => "null"
  },
  EnumValue: {
    leave: ({ value: e }) => e
  },
  ListValue: {
    leave: ({ values: e }) => "[" + ke(e, ", ") + "]"
  },
  ObjectValue: {
    leave: ({ fields: e }) => "{" + ke(e, ", ") + "}"
  },
  ObjectField: {
    leave: ({ name: e, value: t }) => e + ": " + t
  },
  // Directive
  Directive: {
    leave: ({ name: e, arguments: t }) => "@" + e + ot("(", ke(t, ", "), ")")
  },
  // Type
  NamedType: {
    leave: ({ name: e }) => e
  },
  ListType: {
    leave: ({ type: e }) => "[" + e + "]"
  },
  NonNullType: {
    leave: ({ type: e }) => e + "!"
  },
  // Type System Definitions
  SchemaDefinition: {
    leave: ({ description: e, directives: t, operationTypes: n }) => ot("", e, `
`) + ke(["schema", ke(t, " "), Gn(n)], " ")
  },
  OperationTypeDefinition: {
    leave: ({ operation: e, type: t }) => e + ": " + t
  },
  ScalarTypeDefinition: {
    leave: ({ description: e, name: t, directives: n }) => ot("", e, `
`) + ke(["scalar", t, ke(n, " ")], " ")
  },
  ObjectTypeDefinition: {
    leave: ({ description: e, name: t, interfaces: n, directives: r, fields: i }) => ot("", e, `
`) + ke(
      [
        "type",
        t,
        ot("implements ", ke(n, " & ")),
        ke(r, " "),
        Gn(i)
      ],
      " "
    )
  },
  FieldDefinition: {
    leave: ({ description: e, name: t, arguments: n, type: r, directives: i }) => ot("", e, `
`) + t + (Cg(n) ? ot(`(
`, Tl(ke(n, `
`)), `
)`) : ot("(", ke(n, ", "), ")")) + ": " + r + ot(" ", ke(i, " "))
  },
  InputValueDefinition: {
    leave: ({ description: e, name: t, type: n, defaultValue: r, directives: i }) => ot("", e, `
`) + ke(
      [t + ": " + n, ot("= ", r), ke(i, " ")],
      " "
    )
  },
  InterfaceTypeDefinition: {
    leave: ({ description: e, name: t, interfaces: n, directives: r, fields: i }) => ot("", e, `
`) + ke(
      [
        "interface",
        t,
        ot("implements ", ke(n, " & ")),
        ke(r, " "),
        Gn(i)
      ],
      " "
    )
  },
  UnionTypeDefinition: {
    leave: ({ description: e, name: t, directives: n, types: r }) => ot("", e, `
`) + ke(
      ["union", t, ke(n, " "), ot("= ", ke(r, " | "))],
      " "
    )
  },
  EnumTypeDefinition: {
    leave: ({ description: e, name: t, directives: n, values: r }) => ot("", e, `
`) + ke(["enum", t, ke(n, " "), Gn(r)], " ")
  },
  EnumValueDefinition: {
    leave: ({ description: e, name: t, directives: n }) => ot("", e, `
`) + ke([t, ke(n, " ")], " ")
  },
  InputObjectTypeDefinition: {
    leave: ({ description: e, name: t, directives: n, fields: r }) => ot("", e, `
`) + ke(["input", t, ke(n, " "), Gn(r)], " ")
  },
  DirectiveDefinition: {
    leave: ({ description: e, name: t, arguments: n, repeatable: r, locations: i }) => ot("", e, `
`) + "directive @" + t + (Cg(n) ? ot(`(
`, Tl(ke(n, `
`)), `
)`) : ot("(", ke(n, ", "), ")")) + (r ? " repeatable" : "") + " on " + ke(i, " | ")
  },
  SchemaExtension: {
    leave: ({ directives: e, operationTypes: t }) => ke(
      ["extend schema", ke(e, " "), Gn(t)],
      " "
    )
  },
  ScalarTypeExtension: {
    leave: ({ name: e, directives: t }) => ke(["extend scalar", e, ke(t, " ")], " ")
  },
  ObjectTypeExtension: {
    leave: ({ name: e, interfaces: t, directives: n, fields: r }) => ke(
      [
        "extend type",
        e,
        ot("implements ", ke(t, " & ")),
        ke(n, " "),
        Gn(r)
      ],
      " "
    )
  },
  InterfaceTypeExtension: {
    leave: ({ name: e, interfaces: t, directives: n, fields: r }) => ke(
      [
        "extend interface",
        e,
        ot("implements ", ke(t, " & ")),
        ke(n, " "),
        Gn(r)
      ],
      " "
    )
  },
  UnionTypeExtension: {
    leave: ({ name: e, directives: t, types: n }) => ke(
      [
        "extend union",
        e,
        ke(t, " "),
        ot("= ", ke(n, " | "))
      ],
      " "
    )
  },
  EnumTypeExtension: {
    leave: ({ name: e, directives: t, values: n }) => ke(["extend enum", e, ke(t, " "), Gn(n)], " ")
  },
  InputObjectTypeExtension: {
    leave: ({ name: e, directives: t, fields: n }) => ke(["extend input", e, ke(t, " "), Gn(n)], " ")
  }
};
function ke(e, t = "") {
  var n;
  return (n = e?.filter((r) => r).join(t)) !== null && n !== void 0 ? n : "";
}
function Gn(e) {
  return ot(`{
`, Tl(ke(e, `
`)), `
}`);
}
function ot(e, t, n = "") {
  return t != null && t !== "" ? e + t + n : "";
}
function Tl(e) {
  return ot("  ", e.replace(/\n/g, `
  `));
}
function Cg(e) {
  var t;
  return (t = e?.some((n) => n.includes(`
`))) !== null && t !== void 0 ? t : !1;
}
function kM(e) {
  return bh(e) || vh(e) || _h(e);
}
function bh(e) {
  return e.kind === Q.OPERATION_DEFINITION || e.kind === Q.FRAGMENT_DEFINITION;
}
function LM(e) {
  return e.kind === Q.FIELD || e.kind === Q.FRAGMENT_SPREAD || e.kind === Q.INLINE_FRAGMENT;
}
function Uw(e) {
  return e.kind === Q.VARIABLE || e.kind === Q.INT || e.kind === Q.FLOAT || e.kind === Q.STRING || e.kind === Q.BOOLEAN || e.kind === Q.NULL || e.kind === Q.ENUM || e.kind === Q.LIST || e.kind === Q.OBJECT;
}
function gd(e) {
  return Uw(e) && (e.kind === Q.LIST ? e.values.some(gd) : e.kind === Q.OBJECT ? e.fields.some((t) => gd(t.value)) : e.kind !== Q.VARIABLE);
}
function jM(e) {
  return e.kind === Q.NAMED_TYPE || e.kind === Q.LIST_TYPE || e.kind === Q.NON_NULL_TYPE;
}
function vh(e) {
  return e.kind === Q.SCHEMA_DEFINITION || Vs(e) || e.kind === Q.DIRECTIVE_DEFINITION;
}
function Vs(e) {
  return e.kind === Q.SCALAR_TYPE_DEFINITION || e.kind === Q.OBJECT_TYPE_DEFINITION || e.kind === Q.INTERFACE_TYPE_DEFINITION || e.kind === Q.UNION_TYPE_DEFINITION || e.kind === Q.ENUM_TYPE_DEFINITION || e.kind === Q.INPUT_OBJECT_TYPE_DEFINITION;
}
function _h(e) {
  return e.kind === Q.SCHEMA_EXTENSION || Ju(e);
}
function Ju(e) {
  return e.kind === Q.SCALAR_TYPE_EXTENSION || e.kind === Q.OBJECT_TYPE_EXTENSION || e.kind === Q.INTERFACE_TYPE_EXTENSION || e.kind === Q.UNION_TYPE_EXTENSION || e.kind === Q.ENUM_TYPE_EXTENSION || e.kind === Q.INPUT_OBJECT_TYPE_EXTENSION;
}
const CM = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BREAK: ds,
  get DirectiveLocation() {
    return Fe;
  },
  get Kind() {
    return Q;
  },
  Lexer: yh,
  Location: Rw,
  get OperationTypeNode() {
    return zt;
  },
  Source: qu,
  Token: hh,
  get TokenKind() {
    return be;
  },
  getEnterLeaveForKind: Ns,
  getLocation: Ql,
  getVisitFn: xM,
  isConstValueNode: gd,
  isDefinitionNode: kM,
  isExecutableDefinitionNode: bh,
  isSelectionNode: LM,
  isTypeDefinitionNode: Vs,
  isTypeExtensionNode: Ju,
  isTypeNode: jM,
  isTypeSystemDefinitionNode: vh,
  isTypeSystemExtensionNode: _h,
  isValueNode: Uw,
  parse: gh,
  parseConstValue: $M,
  parseType: NM,
  parseValue: Cw,
  print: Et,
  printLocation: Ow,
  printSourceLocation: ph,
  visit: Qu,
  visitInParallel: Fw
}, Symbol.toStringTag, { value: "Module" })), MM = /* @__PURE__ */ Hi(CM);
function Fn(e) {
  if (e == null)
    return /* @__PURE__ */ Object.create(null);
  if (Object.getPrototypeOf(e) === null)
    return e;
  const t = /* @__PURE__ */ Object.create(null);
  for (const [n, r] of Object.entries(e))
    t[n] = r;
  return t;
}
const FM = 5;
function Gr(e, t) {
  const [n, r] = t ? [e, t] : [void 0, e];
  let i = " Did you mean ";
  n && (i += n + " ");
  const s = r.map((l) => `"${l}"`);
  switch (s.length) {
    case 0:
      return "";
    case 1:
      return i + s[0] + "?";
    case 2:
      return i + s[0] + " or " + s[1] + "?";
  }
  const o = s.slice(0, FM), a = o.pop();
  return i + o.join(", ") + ", or " + a + "?";
}
function Mg(e) {
  return e;
}
function zr(e, t) {
  const n = /* @__PURE__ */ Object.create(null);
  for (const r of e)
    n[t(r)] = r;
  return n;
}
function ni(e, t, n) {
  const r = /* @__PURE__ */ Object.create(null);
  for (const i of e)
    r[t(i)] = n(i);
  return r;
}
function xr(e, t) {
  const n = /* @__PURE__ */ Object.create(null);
  for (const r of Object.keys(e))
    n[r] = t(e[r], r);
  return n;
}
function wa(e, t) {
  let n = 0, r = 0;
  for (; n < e.length && r < t.length; ) {
    let i = e.charCodeAt(n), s = t.charCodeAt(r);
    if (nl(i) && nl(s)) {
      let o = 0;
      do
        ++n, o = o * 10 + i - bd, i = e.charCodeAt(n);
      while (nl(i) && o > 0);
      let a = 0;
      do
        ++r, a = a * 10 + s - bd, s = t.charCodeAt(r);
      while (nl(s) && a > 0);
      if (o < a)
        return -1;
      if (o > a)
        return 1;
    } else {
      if (i < s)
        return -1;
      if (i > s)
        return 1;
      ++n, ++r;
    }
  }
  return e.length - t.length;
}
const bd = 48, UM = 57;
function nl(e) {
  return !isNaN(e) && bd <= e && e <= UM;
}
function di(e, t) {
  const n = /* @__PURE__ */ Object.create(null), r = new VM(e), i = Math.floor(e.length * 0.4) + 1;
  for (const s of t) {
    const o = r.measure(s, i);
    o !== void 0 && (n[s] = o);
  }
  return Object.keys(n).sort((s, o) => {
    const a = n[s] - n[o];
    return a !== 0 ? a : wa(s, o);
  });
}
class VM {
  constructor(t) {
    this._input = t, this._inputLowerCase = t.toLowerCase(), this._inputArray = Fg(this._inputLowerCase), this._rows = [
      new Array(t.length + 1).fill(0),
      new Array(t.length + 1).fill(0),
      new Array(t.length + 1).fill(0)
    ];
  }
  measure(t, n) {
    if (this._input === t)
      return 0;
    const r = t.toLowerCase();
    if (this._inputLowerCase === r)
      return 1;
    let i = Fg(r), s = this._inputArray;
    if (i.length < s.length) {
      const u = i;
      i = s, s = u;
    }
    const o = i.length, a = s.length;
    if (o - a > n)
      return;
    const l = this._rows;
    for (let u = 0; u <= a; u++)
      l[0][u] = u;
    for (let u = 1; u <= o; u++) {
      const f = l[(u - 1) % 3], d = l[u % 3];
      let p = d[0] = u;
      for (let h = 1; h <= a; h++) {
        const m = i[u - 1] === s[h - 1] ? 0 : 1;
        let v = Math.min(
          f[h] + 1,
          // delete
          d[h - 1] + 1,
          // insert
          f[h - 1] + m
          // substitute
        );
        if (u > 1 && h > 1 && i[u - 1] === s[h - 2] && i[u - 2] === s[h - 1]) {
          const b = l[(u - 2) % 3][h - 2];
          v = Math.min(v, b + 1);
        }
        v < p && (p = v), d[h] = v;
      }
      if (p > n)
        return;
    }
    const c = l[o % 3][a];
    return c <= n ? c : void 0;
  }
}
function Fg(e) {
  const t = e.length, n = new Array(t);
  for (let r = 0; r < t; ++r)
    n[r] = e.charCodeAt(r);
  return n;
}
function Jl(e, t) {
  switch (e.kind) {
    case Q.NULL:
      return null;
    case Q.INT:
      return parseInt(e.value, 10);
    case Q.FLOAT:
      return parseFloat(e.value);
    case Q.STRING:
    case Q.ENUM:
    case Q.BOOLEAN:
      return e.value;
    case Q.LIST:
      return e.values.map(
        (n) => Jl(n, t)
      );
    case Q.OBJECT:
      return ni(
        e.fields,
        (n) => n.name.value,
        (n) => Jl(n.value, t)
      );
    case Q.VARIABLE:
      return t?.[e.name.value];
  }
}
function _n(e) {
  if (e != null || it(!1, "Must provide name."), typeof e == "string" || it(!1, "Expected name to be a string."), e.length === 0)
    throw new ge("Expected name to be a non-empty string.");
  for (let t = 1; t < e.length; ++t)
    if (!Dw(e.charCodeAt(t)))
      throw new ge(
        `Names must only contain [_a-zA-Z0-9] but "${e}" does not.`
      );
  if (!mh(e.charCodeAt(0)))
    throw new ge(
      `Names must start with [_a-zA-Z] but "${e}" does not.`
    );
  return e;
}
function Vw(e) {
  if (e === "true" || e === "false" || e === "null")
    throw new ge(`Enum values cannot be named: ${e}`);
  return _n(e);
}
function Ea(e) {
  return wn(e) || lt(e) || pt(e) || qt(e) || Ft(e) || St(e) || Tt(e) || Qe(e);
}
function BM(e) {
  if (!Ea(e))
    throw new Error(`Expected ${_e(e)} to be a GraphQL type.`);
  return e;
}
function wn(e) {
  return tr(e, wr);
}
function GM(e) {
  if (!wn(e))
    throw new Error(`Expected ${_e(e)} to be a GraphQL Scalar type.`);
  return e;
}
function lt(e) {
  return tr(e, Dn);
}
function Bw(e) {
  if (!lt(e))
    throw new Error(`Expected ${_e(e)} to be a GraphQL Object type.`);
  return e;
}
function pt(e) {
  return tr(e, Os);
}
function Gw(e) {
  if (!pt(e))
    throw new Error(
      `Expected ${_e(e)} to be a GraphQL Interface type.`
    );
  return e;
}
function qt(e) {
  return tr(e, Is);
}
function zM(e) {
  if (!qt(e))
    throw new Error(`Expected ${_e(e)} to be a GraphQL Union type.`);
  return e;
}
function Ft(e) {
  return tr(e, ui);
}
function qM(e) {
  if (!Ft(e))
    throw new Error(`Expected ${_e(e)} to be a GraphQL Enum type.`);
  return e;
}
function St(e) {
  return tr(e, Rs);
}
function HM(e) {
  if (!St(e))
    throw new Error(
      `Expected ${_e(e)} to be a GraphQL Input Object type.`
    );
  return e;
}
function Tt(e) {
  return tr(e, Kt);
}
function WM(e) {
  if (!Tt(e))
    throw new Error(`Expected ${_e(e)} to be a GraphQL List type.`);
  return e;
}
function Qe(e) {
  return tr(e, Ye);
}
function QM(e) {
  if (!Qe(e))
    throw new Error(`Expected ${_e(e)} to be a GraphQL Non-Null type.`);
  return e;
}
function fn(e) {
  return wn(e) || Ft(e) || St(e) || Sa(e) && fn(e.ofType);
}
function JM(e) {
  if (!fn(e))
    throw new Error(`Expected ${_e(e)} to be a GraphQL input type.`);
  return e;
}
function oi(e) {
  return wn(e) || lt(e) || pt(e) || qt(e) || Ft(e) || Sa(e) && oi(e.ofType);
}
function KM(e) {
  if (!oi(e))
    throw new Error(`Expected ${_e(e)} to be a GraphQL output type.`);
  return e;
}
function vr(e) {
  return wn(e) || Ft(e);
}
function YM(e) {
  if (!vr(e))
    throw new Error(`Expected ${_e(e)} to be a GraphQL leaf type.`);
  return e;
}
function _r(e) {
  return lt(e) || pt(e) || qt(e);
}
function XM(e) {
  if (!_r(e))
    throw new Error(
      `Expected ${_e(e)} to be a GraphQL composite type.`
    );
  return e;
}
function gr(e) {
  return pt(e) || qt(e);
}
function ZM(e) {
  if (!gr(e))
    throw new Error(`Expected ${_e(e)} to be a GraphQL abstract type.`);
  return e;
}
class Kt {
  constructor(t) {
    Ea(t) || it(!1, `Expected ${_e(t)} to be a GraphQL type.`), this.ofType = t;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLList";
  }
  toString() {
    return "[" + String(this.ofType) + "]";
  }
  toJSON() {
    return this.toString();
  }
}
class Ye {
  constructor(t) {
    wh(t) || it(
      !1,
      `Expected ${_e(t)} to be a GraphQL nullable type.`
    ), this.ofType = t;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLNonNull";
  }
  toString() {
    return String(this.ofType) + "!";
  }
  toJSON() {
    return this.toString();
  }
}
function Sa(e) {
  return Tt(e) || Qe(e);
}
function eF(e) {
  if (!Sa(e))
    throw new Error(`Expected ${_e(e)} to be a GraphQL wrapping type.`);
  return e;
}
function wh(e) {
  return Ea(e) && !Qe(e);
}
function zw(e) {
  if (!wh(e))
    throw new Error(`Expected ${_e(e)} to be a GraphQL nullable type.`);
  return e;
}
function Eh(e) {
  if (e)
    return Qe(e) ? e.ofType : e;
}
function Ta(e) {
  return wn(e) || lt(e) || pt(e) || qt(e) || Ft(e) || St(e);
}
function tF(e) {
  if (!Ta(e))
    throw new Error(`Expected ${_e(e)} to be a GraphQL named type.`);
  return e;
}
function An(e) {
  if (e) {
    let t = e;
    for (; Sa(t); )
      t = t.ofType;
    return t;
  }
}
function Sh(e) {
  return typeof e == "function" ? e() : e;
}
function Th(e) {
  return typeof e == "function" ? e() : e;
}
let wr = class {
  constructor(t) {
    var n, r, i, s;
    const o = (n = t.parseValue) !== null && n !== void 0 ? n : Mg;
    this.name = _n(t.name), this.description = t.description, this.specifiedByURL = t.specifiedByURL, this.serialize = (r = t.serialize) !== null && r !== void 0 ? r : Mg, this.parseValue = o, this.parseLiteral = (i = t.parseLiteral) !== null && i !== void 0 ? i : (a, l) => o(Jl(a, l)), this.extensions = Fn(t.extensions), this.astNode = t.astNode, this.extensionASTNodes = (s = t.extensionASTNodes) !== null && s !== void 0 ? s : [], t.specifiedByURL == null || typeof t.specifiedByURL == "string" || it(
      !1,
      `${this.name} must provide "specifiedByURL" as a string, but got: ${_e(t.specifiedByURL)}.`
    ), t.serialize == null || typeof t.serialize == "function" || it(
      !1,
      `${this.name} must provide "serialize" function. If this custom Scalar is also used as an input type, ensure "parseValue" and "parseLiteral" functions are also provided.`
    ), t.parseLiteral && (typeof t.parseValue == "function" && typeof t.parseLiteral == "function" || it(
      !1,
      `${this.name} must provide both "parseValue" and "parseLiteral" functions.`
    ));
  }
  get [Symbol.toStringTag]() {
    return "GraphQLScalarType";
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      specifiedByURL: this.specifiedByURL,
      serialize: this.serialize,
      parseValue: this.parseValue,
      parseLiteral: this.parseLiteral,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}, Dn = class {
  constructor(t) {
    var n;
    this.name = _n(t.name), this.description = t.description, this.isTypeOf = t.isTypeOf, this.extensions = Fn(t.extensions), this.astNode = t.astNode, this.extensionASTNodes = (n = t.extensionASTNodes) !== null && n !== void 0 ? n : [], this._fields = () => Hw(t), this._interfaces = () => qw(t), t.isTypeOf == null || typeof t.isTypeOf == "function" || it(
      !1,
      `${this.name} must provide "isTypeOf" as a function, but got: ${_e(t.isTypeOf)}.`
    );
  }
  get [Symbol.toStringTag]() {
    return "GraphQLObjectType";
  }
  getFields() {
    return typeof this._fields == "function" && (this._fields = this._fields()), this._fields;
  }
  getInterfaces() {
    return typeof this._interfaces == "function" && (this._interfaces = this._interfaces()), this._interfaces;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      interfaces: this.getInterfaces(),
      fields: Qw(this.getFields()),
      isTypeOf: this.isTypeOf,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
function qw(e) {
  var t;
  const n = Sh(
    (t = e.interfaces) !== null && t !== void 0 ? t : []
  );
  return Array.isArray(n) || it(
    !1,
    `${e.name} interfaces must be an Array or a function which returns an Array.`
  ), n;
}
function Hw(e) {
  const t = Th(e.fields);
  return vs(t) || it(
    !1,
    `${e.name} fields must be an object with field names as keys or a function which returns such an object.`
  ), xr(t, (n, r) => {
    var i;
    vs(n) || it(
      !1,
      `${e.name}.${r} field config must be an object.`
    ), n.resolve == null || typeof n.resolve == "function" || it(
      !1,
      `${e.name}.${r} field resolver must be a function if provided, but got: ${_e(n.resolve)}.`
    );
    const s = (i = n.args) !== null && i !== void 0 ? i : {};
    return vs(s) || it(
      !1,
      `${e.name}.${r} args must be an object with argument names as keys.`
    ), {
      name: _n(r),
      description: n.description,
      type: n.type,
      args: Ww(s),
      resolve: n.resolve,
      subscribe: n.subscribe,
      deprecationReason: n.deprecationReason,
      extensions: Fn(n.extensions),
      astNode: n.astNode
    };
  });
}
function Ww(e) {
  return Object.entries(e).map(([t, n]) => ({
    name: _n(t),
    description: n.description,
    type: n.type,
    defaultValue: n.defaultValue,
    deprecationReason: n.deprecationReason,
    extensions: Fn(n.extensions),
    astNode: n.astNode
  }));
}
function vs(e) {
  return vn(e) && !Array.isArray(e);
}
function Qw(e) {
  return xr(e, (t) => ({
    description: t.description,
    type: t.type,
    args: Jw(t.args),
    resolve: t.resolve,
    subscribe: t.subscribe,
    deprecationReason: t.deprecationReason,
    extensions: t.extensions,
    astNode: t.astNode
  }));
}
function Jw(e) {
  return ni(
    e,
    (t) => t.name,
    (t) => ({
      description: t.description,
      type: t.type,
      defaultValue: t.defaultValue,
      deprecationReason: t.deprecationReason,
      extensions: t.extensions,
      astNode: t.astNode
    })
  );
}
function pi(e) {
  return Qe(e.type) && e.defaultValue === void 0;
}
let Os = class {
  constructor(t) {
    var n;
    this.name = _n(t.name), this.description = t.description, this.resolveType = t.resolveType, this.extensions = Fn(t.extensions), this.astNode = t.astNode, this.extensionASTNodes = (n = t.extensionASTNodes) !== null && n !== void 0 ? n : [], this._fields = Hw.bind(void 0, t), this._interfaces = qw.bind(void 0, t), t.resolveType == null || typeof t.resolveType == "function" || it(
      !1,
      `${this.name} must provide "resolveType" as a function, but got: ${_e(t.resolveType)}.`
    );
  }
  get [Symbol.toStringTag]() {
    return "GraphQLInterfaceType";
  }
  getFields() {
    return typeof this._fields == "function" && (this._fields = this._fields()), this._fields;
  }
  getInterfaces() {
    return typeof this._interfaces == "function" && (this._interfaces = this._interfaces()), this._interfaces;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      interfaces: this.getInterfaces(),
      fields: Qw(this.getFields()),
      resolveType: this.resolveType,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}, Is = class {
  constructor(t) {
    var n;
    this.name = _n(t.name), this.description = t.description, this.resolveType = t.resolveType, this.extensions = Fn(t.extensions), this.astNode = t.astNode, this.extensionASTNodes = (n = t.extensionASTNodes) !== null && n !== void 0 ? n : [], this._types = nF.bind(void 0, t), t.resolveType == null || typeof t.resolveType == "function" || it(
      !1,
      `${this.name} must provide "resolveType" as a function, but got: ${_e(t.resolveType)}.`
    );
  }
  get [Symbol.toStringTag]() {
    return "GraphQLUnionType";
  }
  getTypes() {
    return typeof this._types == "function" && (this._types = this._types()), this._types;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      types: this.getTypes(),
      resolveType: this.resolveType,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
function nF(e) {
  const t = Sh(e.types);
  return Array.isArray(t) || it(
    !1,
    `Must provide Array of types or a function which returns such an array for Union ${e.name}.`
  ), t;
}
let ui = class {
  /* <T> */
  constructor(t) {
    var n;
    this.name = _n(t.name), this.description = t.description, this.extensions = Fn(t.extensions), this.astNode = t.astNode, this.extensionASTNodes = (n = t.extensionASTNodes) !== null && n !== void 0 ? n : [], this._values = typeof t.values == "function" ? t.values : Ug(this.name, t.values), this._valueLookup = null, this._nameLookup = null;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLEnumType";
  }
  getValues() {
    return typeof this._values == "function" && (this._values = Ug(this.name, this._values())), this._values;
  }
  getValue(t) {
    return this._nameLookup === null && (this._nameLookup = zr(this.getValues(), (n) => n.name)), this._nameLookup[t];
  }
  serialize(t) {
    this._valueLookup === null && (this._valueLookup = new Map(
      this.getValues().map((r) => [r.value, r])
    ));
    const n = this._valueLookup.get(t);
    if (n === void 0)
      throw new ge(
        `Enum "${this.name}" cannot represent value: ${_e(t)}`
      );
    return n.name;
  }
  parseValue(t) {
    if (typeof t != "string") {
      const r = _e(t);
      throw new ge(
        `Enum "${this.name}" cannot represent non-string value: ${r}.` + rl(this, r)
      );
    }
    const n = this.getValue(t);
    if (n == null)
      throw new ge(
        `Value "${t}" does not exist in "${this.name}" enum.` + rl(this, t)
      );
    return n.value;
  }
  parseLiteral(t, n) {
    if (t.kind !== Q.ENUM) {
      const i = Et(t);
      throw new ge(
        `Enum "${this.name}" cannot represent non-enum value: ${i}.` + rl(this, i),
        {
          nodes: t
        }
      );
    }
    const r = this.getValue(t.value);
    if (r == null) {
      const i = Et(t);
      throw new ge(
        `Value "${i}" does not exist in "${this.name}" enum.` + rl(this, i),
        {
          nodes: t
        }
      );
    }
    return r.value;
  }
  toConfig() {
    const t = ni(
      this.getValues(),
      (n) => n.name,
      (n) => ({
        description: n.description,
        value: n.value,
        deprecationReason: n.deprecationReason,
        extensions: n.extensions,
        astNode: n.astNode
      })
    );
    return {
      name: this.name,
      description: this.description,
      values: t,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
function rl(e, t) {
  const n = e.getValues().map((i) => i.name), r = di(t, n);
  return Gr("the enum value", r);
}
function Ug(e, t) {
  return vs(t) || it(
    !1,
    `${e} values must be an object with value names as keys.`
  ), Object.entries(t).map(([n, r]) => (vs(r) || it(
    !1,
    `${e}.${n} must refer to an object with a "value" key representing an internal value but got: ${_e(r)}.`
  ), {
    name: Vw(n),
    description: r.description,
    value: r.value !== void 0 ? r.value : n,
    deprecationReason: r.deprecationReason,
    extensions: Fn(r.extensions),
    astNode: r.astNode
  }));
}
class Rs {
  constructor(t) {
    var n, r;
    this.name = _n(t.name), this.description = t.description, this.extensions = Fn(t.extensions), this.astNode = t.astNode, this.extensionASTNodes = (n = t.extensionASTNodes) !== null && n !== void 0 ? n : [], this.isOneOf = (r = t.isOneOf) !== null && r !== void 0 ? r : !1, this._fields = rF.bind(void 0, t);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLInputObjectType";
  }
  getFields() {
    return typeof this._fields == "function" && (this._fields = this._fields()), this._fields;
  }
  toConfig() {
    const t = xr(this.getFields(), (n) => ({
      description: n.description,
      type: n.type,
      defaultValue: n.defaultValue,
      deprecationReason: n.deprecationReason,
      extensions: n.extensions,
      astNode: n.astNode
    }));
    return {
      name: this.name,
      description: this.description,
      fields: t,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes,
      isOneOf: this.isOneOf
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}
function rF(e) {
  const t = Th(e.fields);
  return vs(t) || it(
    !1,
    `${e.name} fields must be an object with field names as keys or a function which returns such an object.`
  ), xr(t, (n, r) => (!("resolve" in n) || it(
    !1,
    `${e.name}.${r} field has a resolve property, but Input Types cannot define resolvers.`
  ), {
    name: _n(r),
    description: n.description,
    type: n.type,
    defaultValue: n.defaultValue,
    deprecationReason: n.deprecationReason,
    extensions: Fn(n.extensions),
    astNode: n.astNode
  }));
}
function Ku(e) {
  return Qe(e.type) && e.defaultValue === void 0;
}
const $l = 2147483647, Nl = -2147483648, Kw = new wr({
  name: "Int",
  description: "The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.",
  serialize(e) {
    const t = Na(e);
    if (typeof t == "boolean")
      return t ? 1 : 0;
    let n = t;
    if (typeof t == "string" && t !== "" && (n = Number(t)), typeof n != "number" || !Number.isInteger(n))
      throw new ge(
        `Int cannot represent non-integer value: ${_e(t)}`
      );
    if (n > $l || n < Nl)
      throw new ge(
        "Int cannot represent non 32-bit signed integer value: " + _e(t)
      );
    return n;
  },
  parseValue(e) {
    if (typeof e != "number" || !Number.isInteger(e))
      throw new ge(
        `Int cannot represent non-integer value: ${_e(e)}`
      );
    if (e > $l || e < Nl)
      throw new ge(
        `Int cannot represent non 32-bit signed integer value: ${e}`
      );
    return e;
  },
  parseLiteral(e) {
    if (e.kind !== Q.INT)
      throw new ge(
        `Int cannot represent non-integer value: ${Et(e)}`,
        {
          nodes: e
        }
      );
    const t = parseInt(e.value, 10);
    if (t > $l || t < Nl)
      throw new ge(
        `Int cannot represent non 32-bit signed integer value: ${e.value}`,
        {
          nodes: e
        }
      );
    return t;
  }
}), Yw = new wr({
  name: "Float",
  description: "The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).",
  serialize(e) {
    const t = Na(e);
    if (typeof t == "boolean")
      return t ? 1 : 0;
    let n = t;
    if (typeof t == "string" && t !== "" && (n = Number(t)), typeof n != "number" || !Number.isFinite(n))
      throw new ge(
        `Float cannot represent non numeric value: ${_e(t)}`
      );
    return n;
  },
  parseValue(e) {
    if (typeof e != "number" || !Number.isFinite(e))
      throw new ge(
        `Float cannot represent non numeric value: ${_e(e)}`
      );
    return e;
  },
  parseLiteral(e) {
    if (e.kind !== Q.FLOAT && e.kind !== Q.INT)
      throw new ge(
        `Float cannot represent non numeric value: ${Et(e)}`,
        e
      );
    return parseFloat(e.value);
  }
}), Dt = new wr({
  name: "String",
  description: "The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.",
  serialize(e) {
    const t = Na(e);
    if (typeof t == "string")
      return t;
    if (typeof t == "boolean")
      return t ? "true" : "false";
    if (typeof t == "number" && Number.isFinite(t))
      return t.toString();
    throw new ge(
      `String cannot represent value: ${_e(e)}`
    );
  },
  parseValue(e) {
    if (typeof e != "string")
      throw new ge(
        `String cannot represent a non string value: ${_e(e)}`
      );
    return e;
  },
  parseLiteral(e) {
    if (e.kind !== Q.STRING)
      throw new ge(
        `String cannot represent a non string value: ${Et(e)}`,
        {
          nodes: e
        }
      );
    return e.value;
  }
}), dn = new wr({
  name: "Boolean",
  description: "The `Boolean` scalar type represents `true` or `false`.",
  serialize(e) {
    const t = Na(e);
    if (typeof t == "boolean")
      return t;
    if (Number.isFinite(t))
      return t !== 0;
    throw new ge(
      `Boolean cannot represent a non boolean value: ${_e(t)}`
    );
  },
  parseValue(e) {
    if (typeof e != "boolean")
      throw new ge(
        `Boolean cannot represent a non boolean value: ${_e(e)}`
      );
    return e;
  },
  parseLiteral(e) {
    if (e.kind !== Q.BOOLEAN)
      throw new ge(
        `Boolean cannot represent a non boolean value: ${Et(e)}`,
        {
          nodes: e
        }
      );
    return e.value;
  }
}), $h = new wr({
  name: "ID",
  description: 'The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.',
  serialize(e) {
    const t = Na(e);
    if (typeof t == "string")
      return t;
    if (Number.isInteger(t))
      return String(t);
    throw new ge(
      `ID cannot represent value: ${_e(e)}`
    );
  },
  parseValue(e) {
    if (typeof e == "string")
      return e;
    if (typeof e == "number" && Number.isInteger(e))
      return e.toString();
    throw new ge(`ID cannot represent value: ${_e(e)}`);
  },
  parseLiteral(e) {
    if (e.kind !== Q.STRING && e.kind !== Q.INT)
      throw new ge(
        "ID cannot represent a non-string and non-integer value: " + Et(e),
        {
          nodes: e
        }
      );
    return e.value;
  }
}), $a = Object.freeze([
  Dt,
  Kw,
  Yw,
  dn,
  $h
]);
function Yu(e) {
  return $a.some(({ name: t }) => e.name === t);
}
function Na(e) {
  if (vn(e)) {
    if (typeof e.valueOf == "function") {
      const t = e.valueOf();
      if (!vn(t))
        return t;
    }
    if (typeof e.toJSON == "function")
      return e.toJSON();
  }
  return e;
}
function Xu(e) {
  return tr(e, er);
}
function iF(e) {
  if (!Xu(e))
    throw new Error(
      `Expected ${_e(e)} to be a GraphQL directive.`
    );
  return e;
}
class er {
  constructor(t) {
    var n, r;
    this.name = _n(t.name), this.description = t.description, this.locations = t.locations, this.isRepeatable = (n = t.isRepeatable) !== null && n !== void 0 ? n : !1, this.extensions = Fn(t.extensions), this.astNode = t.astNode, Array.isArray(t.locations) || it(!1, `@${t.name} locations must be an Array.`);
    const i = (r = t.args) !== null && r !== void 0 ? r : {};
    vn(i) && !Array.isArray(i) || it(
      !1,
      `@${t.name} args must be an object with argument names as keys.`
    ), this.args = Ww(i);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLDirective";
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      locations: this.locations,
      args: Jw(this.args),
      isRepeatable: this.isRepeatable,
      extensions: this.extensions,
      astNode: this.astNode
    };
  }
  toString() {
    return "@" + this.name;
  }
  toJSON() {
    return this.toString();
  }
}
const Nh = new er({
  name: "include",
  description: "Directs the executor to include this field or fragment only when the `if` argument is true.",
  locations: [
    Fe.FIELD,
    Fe.FRAGMENT_SPREAD,
    Fe.INLINE_FRAGMENT
  ],
  args: {
    if: {
      type: new Ye(dn),
      description: "Included when true."
    }
  }
}), Oh = new er({
  name: "skip",
  description: "Directs the executor to skip this field or fragment when the `if` argument is true.",
  locations: [
    Fe.FIELD,
    Fe.FRAGMENT_SPREAD,
    Fe.INLINE_FRAGMENT
  ],
  args: {
    if: {
      type: new Ye(dn),
      description: "Skipped when true."
    }
  }
}), Ih = "No longer supported", Zu = new er({
  name: "deprecated",
  description: "Marks an element of a GraphQL schema as no longer supported.",
  locations: [
    Fe.FIELD_DEFINITION,
    Fe.ARGUMENT_DEFINITION,
    Fe.INPUT_FIELD_DEFINITION,
    Fe.ENUM_VALUE
  ],
  args: {
    reason: {
      type: Dt,
      description: "Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax, as specified by [CommonMark](https://commonmark.org/).",
      defaultValue: Ih
    }
  }
}), Rh = new er({
  name: "specifiedBy",
  description: "Exposes a URL that specifies the behavior of this scalar.",
  locations: [Fe.SCALAR],
  args: {
    url: {
      type: new Ye(Dt),
      description: "The URL that specifies the behavior of this scalar."
    }
  }
}), Ah = new er({
  name: "oneOf",
  description: "Indicates exactly one field must be supplied and this field must not be `null`.",
  locations: [Fe.INPUT_OBJECT],
  args: {}
}), hi = Object.freeze([
  Nh,
  Oh,
  Zu,
  Rh,
  Ah
]);
function xh(e) {
  return hi.some(({ name: t }) => t === e.name);
}
function Dh(e) {
  return typeof e == "object" && typeof e?.[Symbol.iterator] == "function";
}
function ri(e, t) {
  if (Qe(t)) {
    const n = ri(e, t.ofType);
    return n?.kind === Q.NULL ? null : n;
  }
  if (e === null)
    return {
      kind: Q.NULL
    };
  if (e === void 0)
    return null;
  if (Tt(t)) {
    const n = t.ofType;
    if (Dh(e)) {
      const r = [];
      for (const i of e) {
        const s = ri(i, n);
        s != null && r.push(s);
      }
      return {
        kind: Q.LIST,
        values: r
      };
    }
    return ri(e, n);
  }
  if (St(t)) {
    if (!vn(e))
      return null;
    const n = [];
    for (const r of Object.values(t.getFields())) {
      const i = ri(e[r.name], r.type);
      i && n.push({
        kind: Q.OBJECT_FIELD,
        name: {
          kind: Q.NAME,
          value: r.name
        },
        value: i
      });
    }
    return {
      kind: Q.OBJECT,
      fields: n
    };
  }
  if (vr(t)) {
    const n = t.serialize(e);
    if (n == null)
      return null;
    if (typeof n == "boolean")
      return {
        kind: Q.BOOLEAN,
        value: n
      };
    if (typeof n == "number" && Number.isFinite(n)) {
      const r = String(n);
      return Vg.test(r) ? {
        kind: Q.INT,
        value: r
      } : {
        kind: Q.FLOAT,
        value: r
      };
    }
    if (typeof n == "string")
      return Ft(t) ? {
        kind: Q.ENUM,
        value: n
      } : t === $h && Vg.test(n) ? {
        kind: Q.INT,
        value: n
      } : {
        kind: Q.STRING,
        value: n
      };
    throw new TypeError(`Cannot convert value to AST: ${_e(n)}.`);
  }
  Ht(!1, "Unexpected input type: " + _e(t));
}
const Vg = /^-?(?:0|[1-9][0-9]*)$/, ec = new Dn({
  name: "__Schema",
  description: "A GraphQL Schema defines the capabilities of a GraphQL server. It exposes all available types and directives on the server, as well as the entry points for query, mutation, and subscription operations.",
  fields: () => ({
    description: {
      type: Dt,
      resolve: (e) => e.description
    },
    types: {
      description: "A list of all types supported by this server.",
      type: new Ye(new Kt(new Ye(xn))),
      resolve(e) {
        return Object.values(e.getTypeMap());
      }
    },
    queryType: {
      description: "The type that query operations will be rooted at.",
      type: new Ye(xn),
      resolve: (e) => e.getQueryType()
    },
    mutationType: {
      description: "If this server supports mutation, the type that mutation operations will be rooted at.",
      type: xn,
      resolve: (e) => e.getMutationType()
    },
    subscriptionType: {
      description: "If this server support subscription, the type that subscription operations will be rooted at.",
      type: xn,
      resolve: (e) => e.getSubscriptionType()
    },
    directives: {
      description: "A list of all directives supported by this server.",
      type: new Ye(
        new Kt(new Ye(Ph))
      ),
      resolve: (e) => e.getDirectives()
    }
  })
}), Ph = new Dn({
  name: "__Directive",
  description: `A Directive provides a way to describe alternate runtime execution and type validation behavior in a GraphQL document.

In some cases, you need to provide options to alter GraphQL's execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor.`,
  fields: () => ({
    name: {
      type: new Ye(Dt),
      resolve: (e) => e.name
    },
    description: {
      type: Dt,
      resolve: (e) => e.description
    },
    isRepeatable: {
      type: new Ye(dn),
      resolve: (e) => e.isRepeatable
    },
    locations: {
      type: new Ye(
        new Kt(new Ye(kh))
      ),
      resolve: (e) => e.locations
    },
    args: {
      type: new Ye(
        new Kt(new Ye(Oa))
      ),
      args: {
        includeDeprecated: {
          type: dn,
          defaultValue: !1
        }
      },
      resolve(e, { includeDeprecated: t }) {
        return t ? e.args : e.args.filter((n) => n.deprecationReason == null);
      }
    }
  })
}), kh = new ui({
  name: "__DirectiveLocation",
  description: "A Directive can be adjacent to many parts of the GraphQL language, a __DirectiveLocation describes one such possible adjacencies.",
  values: {
    QUERY: {
      value: Fe.QUERY,
      description: "Location adjacent to a query operation."
    },
    MUTATION: {
      value: Fe.MUTATION,
      description: "Location adjacent to a mutation operation."
    },
    SUBSCRIPTION: {
      value: Fe.SUBSCRIPTION,
      description: "Location adjacent to a subscription operation."
    },
    FIELD: {
      value: Fe.FIELD,
      description: "Location adjacent to a field."
    },
    FRAGMENT_DEFINITION: {
      value: Fe.FRAGMENT_DEFINITION,
      description: "Location adjacent to a fragment definition."
    },
    FRAGMENT_SPREAD: {
      value: Fe.FRAGMENT_SPREAD,
      description: "Location adjacent to a fragment spread."
    },
    INLINE_FRAGMENT: {
      value: Fe.INLINE_FRAGMENT,
      description: "Location adjacent to an inline fragment."
    },
    VARIABLE_DEFINITION: {
      value: Fe.VARIABLE_DEFINITION,
      description: "Location adjacent to a variable definition."
    },
    SCHEMA: {
      value: Fe.SCHEMA,
      description: "Location adjacent to a schema definition."
    },
    SCALAR: {
      value: Fe.SCALAR,
      description: "Location adjacent to a scalar definition."
    },
    OBJECT: {
      value: Fe.OBJECT,
      description: "Location adjacent to an object type definition."
    },
    FIELD_DEFINITION: {
      value: Fe.FIELD_DEFINITION,
      description: "Location adjacent to a field definition."
    },
    ARGUMENT_DEFINITION: {
      value: Fe.ARGUMENT_DEFINITION,
      description: "Location adjacent to an argument definition."
    },
    INTERFACE: {
      value: Fe.INTERFACE,
      description: "Location adjacent to an interface definition."
    },
    UNION: {
      value: Fe.UNION,
      description: "Location adjacent to a union definition."
    },
    ENUM: {
      value: Fe.ENUM,
      description: "Location adjacent to an enum definition."
    },
    ENUM_VALUE: {
      value: Fe.ENUM_VALUE,
      description: "Location adjacent to an enum value definition."
    },
    INPUT_OBJECT: {
      value: Fe.INPUT_OBJECT,
      description: "Location adjacent to an input object type definition."
    },
    INPUT_FIELD_DEFINITION: {
      value: Fe.INPUT_FIELD_DEFINITION,
      description: "Location adjacent to an input object field definition."
    }
  }
}), xn = new Dn({
  name: "__Type",
  description: "The fundamental unit of any GraphQL Schema is the type. There are many kinds of types in GraphQL as represented by the `__TypeKind` enum.\n\nDepending on the kind of a type, certain fields describe information about that type. Scalar types provide no information beyond a name, description and optional `specifiedByURL`, while Enum types provide their values. Object and Interface types provide the fields they describe. Abstract types, Union and Interface, provide the Object types possible at runtime. List and NonNull types compose other types.",
  fields: () => ({
    kind: {
      type: new Ye(Ch),
      resolve(e) {
        if (wn(e))
          return ht.SCALAR;
        if (lt(e))
          return ht.OBJECT;
        if (pt(e))
          return ht.INTERFACE;
        if (qt(e))
          return ht.UNION;
        if (Ft(e))
          return ht.ENUM;
        if (St(e))
          return ht.INPUT_OBJECT;
        if (Tt(e))
          return ht.LIST;
        if (Qe(e))
          return ht.NON_NULL;
        Ht(!1, `Unexpected type: "${_e(e)}".`);
      }
    },
    name: {
      type: Dt,
      resolve: (e) => "name" in e ? e.name : void 0
    },
    description: {
      type: Dt,
      resolve: (e) => (
        /* c8 ignore next */
        "description" in e ? e.description : void 0
      )
    },
    specifiedByURL: {
      type: Dt,
      resolve: (e) => "specifiedByURL" in e ? e.specifiedByURL : void 0
    },
    fields: {
      type: new Kt(new Ye(Lh)),
      args: {
        includeDeprecated: {
          type: dn,
          defaultValue: !1
        }
      },
      resolve(e, { includeDeprecated: t }) {
        if (lt(e) || pt(e)) {
          const n = Object.values(e.getFields());
          return t ? n : n.filter((r) => r.deprecationReason == null);
        }
      }
    },
    interfaces: {
      type: new Kt(new Ye(xn)),
      resolve(e) {
        if (lt(e) || pt(e))
          return e.getInterfaces();
      }
    },
    possibleTypes: {
      type: new Kt(new Ye(xn)),
      resolve(e, t, n, { schema: r }) {
        if (gr(e))
          return r.getPossibleTypes(e);
      }
    },
    enumValues: {
      type: new Kt(new Ye(jh)),
      args: {
        includeDeprecated: {
          type: dn,
          defaultValue: !1
        }
      },
      resolve(e, { includeDeprecated: t }) {
        if (Ft(e)) {
          const n = e.getValues();
          return t ? n : n.filter((r) => r.deprecationReason == null);
        }
      }
    },
    inputFields: {
      type: new Kt(new Ye(Oa)),
      args: {
        includeDeprecated: {
          type: dn,
          defaultValue: !1
        }
      },
      resolve(e, { includeDeprecated: t }) {
        if (St(e)) {
          const n = Object.values(e.getFields());
          return t ? n : n.filter((r) => r.deprecationReason == null);
        }
      }
    },
    ofType: {
      type: xn,
      resolve: (e) => "ofType" in e ? e.ofType : void 0
    },
    isOneOf: {
      type: dn,
      resolve: (e) => {
        if (St(e))
          return e.isOneOf;
      }
    }
  })
}), Lh = new Dn({
  name: "__Field",
  description: "Object and Interface types are described by a list of Fields, each of which has a name, potentially a list of arguments, and a return type.",
  fields: () => ({
    name: {
      type: new Ye(Dt),
      resolve: (e) => e.name
    },
    description: {
      type: Dt,
      resolve: (e) => e.description
    },
    args: {
      type: new Ye(
        new Kt(new Ye(Oa))
      ),
      args: {
        includeDeprecated: {
          type: dn,
          defaultValue: !1
        }
      },
      resolve(e, { includeDeprecated: t }) {
        return t ? e.args : e.args.filter((n) => n.deprecationReason == null);
      }
    },
    type: {
      type: new Ye(xn),
      resolve: (e) => e.type
    },
    isDeprecated: {
      type: new Ye(dn),
      resolve: (e) => e.deprecationReason != null
    },
    deprecationReason: {
      type: Dt,
      resolve: (e) => e.deprecationReason
    }
  })
}), Oa = new Dn({
  name: "__InputValue",
  description: "Arguments provided to Fields or Directives and the input fields of an InputObject are represented as Input Values which describe their type and optionally a default value.",
  fields: () => ({
    name: {
      type: new Ye(Dt),
      resolve: (e) => e.name
    },
    description: {
      type: Dt,
      resolve: (e) => e.description
    },
    type: {
      type: new Ye(xn),
      resolve: (e) => e.type
    },
    defaultValue: {
      type: Dt,
      description: "A GraphQL-formatted string representing the default value for this input value.",
      resolve(e) {
        const { type: t, defaultValue: n } = e, r = ri(n, t);
        return r ? Et(r) : null;
      }
    },
    isDeprecated: {
      type: new Ye(dn),
      resolve: (e) => e.deprecationReason != null
    },
    deprecationReason: {
      type: Dt,
      resolve: (e) => e.deprecationReason
    }
  })
}), jh = new Dn({
  name: "__EnumValue",
  description: "One possible value for a given Enum. Enum values are unique values, not a placeholder for a string or numeric value. However an Enum value is returned in a JSON response as a string.",
  fields: () => ({
    name: {
      type: new Ye(Dt),
      resolve: (e) => e.name
    },
    description: {
      type: Dt,
      resolve: (e) => e.description
    },
    isDeprecated: {
      type: new Ye(dn),
      resolve: (e) => e.deprecationReason != null
    },
    deprecationReason: {
      type: Dt,
      resolve: (e) => e.deprecationReason
    }
  })
});
var ht;
(function(e) {
  e.SCALAR = "SCALAR", e.OBJECT = "OBJECT", e.INTERFACE = "INTERFACE", e.UNION = "UNION", e.ENUM = "ENUM", e.INPUT_OBJECT = "INPUT_OBJECT", e.LIST = "LIST", e.NON_NULL = "NON_NULL";
})(ht || (ht = {}));
const Ch = new ui({
  name: "__TypeKind",
  description: "An enum describing what kind of type a given `__Type` is.",
  values: {
    SCALAR: {
      value: ht.SCALAR,
      description: "Indicates this type is a scalar."
    },
    OBJECT: {
      value: ht.OBJECT,
      description: "Indicates this type is an object. `fields` and `interfaces` are valid fields."
    },
    INTERFACE: {
      value: ht.INTERFACE,
      description: "Indicates this type is an interface. `fields`, `interfaces`, and `possibleTypes` are valid fields."
    },
    UNION: {
      value: ht.UNION,
      description: "Indicates this type is a union. `possibleTypes` is a valid field."
    },
    ENUM: {
      value: ht.ENUM,
      description: "Indicates this type is an enum. `enumValues` is a valid field."
    },
    INPUT_OBJECT: {
      value: ht.INPUT_OBJECT,
      description: "Indicates this type is an input object. `inputFields` is a valid field."
    },
    LIST: {
      value: ht.LIST,
      description: "Indicates this type is a list. `ofType` is a valid field."
    },
    NON_NULL: {
      value: ht.NON_NULL,
      description: "Indicates this type is a non-null. `ofType` is a valid field."
    }
  }
}), Xo = {
  name: "__schema",
  type: new Ye(ec),
  description: "Access the current type schema of this server.",
  args: [],
  resolve: (e, t, n, { schema: r }) => r,
  deprecationReason: void 0,
  extensions: /* @__PURE__ */ Object.create(null),
  astNode: void 0
}, Zo = {
  name: "__type",
  type: xn,
  description: "Request the type information of a single type.",
  args: [
    {
      name: "name",
      description: void 0,
      type: new Ye(Dt),
      defaultValue: void 0,
      deprecationReason: void 0,
      extensions: /* @__PURE__ */ Object.create(null),
      astNode: void 0
    }
  ],
  resolve: (e, { name: t }, n, { schema: r }) => r.getType(t),
  deprecationReason: void 0,
  extensions: /* @__PURE__ */ Object.create(null),
  astNode: void 0
}, ea = {
  name: "__typename",
  type: new Ye(Dt),
  description: "The name of the current Object type at runtime.",
  args: [],
  resolve: (e, t, n, { parentType: r }) => r.name,
  deprecationReason: void 0,
  extensions: /* @__PURE__ */ Object.create(null),
  astNode: void 0
}, Ia = Object.freeze([
  ec,
  Ph,
  kh,
  xn,
  Lh,
  Oa,
  jh,
  Ch
]);
function Bs(e) {
  return Ia.some(({ name: t }) => e.name === t);
}
function Xw(e) {
  return tr(e, Gs);
}
function Mh(e) {
  if (!Xw(e))
    throw new Error(`Expected ${_e(e)} to be a GraphQL schema.`);
  return e;
}
let Gs = class {
  // Used as a cache for validateSchema().
  constructor(t) {
    var n, r;
    this.__validationErrors = t.assumeValid === !0 ? [] : void 0, vn(t) || it(!1, "Must provide configuration object."), !t.types || Array.isArray(t.types) || it(
      !1,
      `"types" must be Array if provided but got: ${_e(t.types)}.`
    ), !t.directives || Array.isArray(t.directives) || it(
      !1,
      `"directives" must be Array if provided but got: ${_e(t.directives)}.`
    ), this.description = t.description, this.extensions = Fn(t.extensions), this.astNode = t.astNode, this.extensionASTNodes = (n = t.extensionASTNodes) !== null && n !== void 0 ? n : [], this._queryType = t.query, this._mutationType = t.mutation, this._subscriptionType = t.subscription, this._directives = (r = t.directives) !== null && r !== void 0 ? r : hi;
    const i = new Set(t.types);
    if (t.types != null)
      for (const s of t.types)
        i.delete(s), Wn(s, i);
    this._queryType != null && Wn(this._queryType, i), this._mutationType != null && Wn(this._mutationType, i), this._subscriptionType != null && Wn(this._subscriptionType, i);
    for (const s of this._directives)
      if (Xu(s))
        for (const o of s.args)
          Wn(o.type, i);
    Wn(ec, i), this._typeMap = /* @__PURE__ */ Object.create(null), this._subTypeMap = /* @__PURE__ */ Object.create(null), this._implementationsMap = /* @__PURE__ */ Object.create(null);
    for (const s of i) {
      if (s == null)
        continue;
      const o = s.name;
      if (o || it(
        !1,
        "One of the provided types for building the Schema is missing a name."
      ), this._typeMap[o] !== void 0)
        throw new Error(
          `Schema must contain uniquely named types but contains multiple types named "${o}".`
        );
      if (this._typeMap[o] = s, pt(s)) {
        for (const a of s.getInterfaces())
          if (pt(a)) {
            let l = this._implementationsMap[a.name];
            l === void 0 && (l = this._implementationsMap[a.name] = {
              objects: [],
              interfaces: []
            }), l.interfaces.push(s);
          }
      } else if (lt(s)) {
        for (const a of s.getInterfaces())
          if (pt(a)) {
            let l = this._implementationsMap[a.name];
            l === void 0 && (l = this._implementationsMap[a.name] = {
              objects: [],
              interfaces: []
            }), l.objects.push(s);
          }
      }
    }
  }
  get [Symbol.toStringTag]() {
    return "GraphQLSchema";
  }
  getQueryType() {
    return this._queryType;
  }
  getMutationType() {
    return this._mutationType;
  }
  getSubscriptionType() {
    return this._subscriptionType;
  }
  getRootType(t) {
    switch (t) {
      case zt.QUERY:
        return this.getQueryType();
      case zt.MUTATION:
        return this.getMutationType();
      case zt.SUBSCRIPTION:
        return this.getSubscriptionType();
    }
  }
  getTypeMap() {
    return this._typeMap;
  }
  getType(t) {
    return this.getTypeMap()[t];
  }
  getPossibleTypes(t) {
    return qt(t) ? t.getTypes() : this.getImplementations(t).objects;
  }
  getImplementations(t) {
    const n = this._implementationsMap[t.name];
    return n ?? {
      objects: [],
      interfaces: []
    };
  }
  isSubType(t, n) {
    let r = this._subTypeMap[t.name];
    if (r === void 0) {
      if (r = /* @__PURE__ */ Object.create(null), qt(t))
        for (const i of t.getTypes())
          r[i.name] = !0;
      else {
        const i = this.getImplementations(t);
        for (const s of i.objects)
          r[s.name] = !0;
        for (const s of i.interfaces)
          r[s.name] = !0;
      }
      this._subTypeMap[t.name] = r;
    }
    return r[n.name] !== void 0;
  }
  getDirectives() {
    return this._directives;
  }
  getDirective(t) {
    return this.getDirectives().find((n) => n.name === t);
  }
  toConfig() {
    return {
      description: this.description,
      query: this.getQueryType(),
      mutation: this.getMutationType(),
      subscription: this.getSubscriptionType(),
      types: Object.values(this.getTypeMap()),
      directives: this.getDirectives(),
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes,
      assumeValid: this.__validationErrors !== void 0
    };
  }
};
function Wn(e, t) {
  const n = An(e);
  if (!t.has(n)) {
    if (t.add(n), qt(n))
      for (const r of n.getTypes())
        Wn(r, t);
    else if (lt(n) || pt(n)) {
      for (const r of n.getInterfaces())
        Wn(r, t);
      for (const r of Object.values(n.getFields())) {
        Wn(r.type, t);
        for (const i of r.args)
          Wn(i.type, t);
      }
    } else if (St(n))
      for (const r of Object.values(n.getFields()))
        Wn(r.type, t);
  }
  return t;
}
function Kl(e, t) {
  return e === t ? !0 : Qe(e) && Qe(t) || Tt(e) && Tt(t) ? Kl(e.ofType, t.ofType) : !1;
}
function Mi(e, t, n) {
  return t === n ? !0 : Qe(n) ? Qe(t) ? Mi(e, t.ofType, n.ofType) : !1 : Qe(t) ? Mi(e, t.ofType, n) : Tt(n) ? Tt(t) ? Mi(e, t.ofType, n.ofType) : !1 : Tt(t) ? !1 : gr(n) && (pt(t) || lt(t)) && e.isSubType(n, t);
}
function vd(e, t, n) {
  return t === n ? !0 : gr(t) ? gr(n) ? e.getPossibleTypes(t).some((r) => e.isSubType(n, r)) : e.isSubType(t, n) : gr(n) ? e.isSubType(n, t) : !1;
}
function Zw(e) {
  if (Mh(e), e.__validationErrors)
    return e.__validationErrors;
  const t = new sF(e);
  oF(t), aF(t), lF(t);
  const n = t.getErrors();
  return e.__validationErrors = n, n;
}
function eE(e) {
  const t = Zw(e);
  if (t.length !== 0)
    throw new Error(t.map((n) => n.message).join(`

`));
}
class sF {
  constructor(t) {
    this._errors = [], this.schema = t;
  }
  reportError(t, n) {
    const r = Array.isArray(n) ? n.filter(Boolean) : n;
    this._errors.push(
      new ge(t, {
        nodes: r
      })
    );
  }
  getErrors() {
    return this._errors;
  }
}
function oF(e) {
  const t = e.schema, n = t.getQueryType();
  if (!n)
    e.reportError("Query root type must be provided.", t.astNode);
  else if (!lt(n)) {
    var r;
    e.reportError(
      `Query root type must be Object type, it cannot be ${_e(
        n
      )}.`,
      (r = Rf(
        t,
        zt.QUERY
      )) !== null && r !== void 0 ? r : n.astNode
    );
  }
  const i = t.getMutationType();
  if (i && !lt(i)) {
    var s;
    e.reportError(
      `Mutation root type must be Object type if provided, it cannot be ${_e(i)}.`,
      (s = Rf(
        t,
        zt.MUTATION
      )) !== null && s !== void 0 ? s : i.astNode
    );
  }
  const o = t.getSubscriptionType();
  if (o && !lt(o)) {
    var a;
    e.reportError(
      `Subscription root type must be Object type if provided, it cannot be ${_e(o)}.`,
      (a = Rf(
        t,
        zt.SUBSCRIPTION
      )) !== null && a !== void 0 ? a : o.astNode
    );
  }
}
function Rf(e, t) {
  var n;
  return (n = [e.astNode, ...e.extensionASTNodes].flatMap(
    // FIXME: https://github.com/graphql/graphql-js/issues/2203
    (r) => {
      var i;
      return (
        /* c8 ignore next */
        (i = r?.operationTypes) !== null && i !== void 0 ? i : []
      );
    }
  ).find((r) => r.operation === t)) === null || n === void 0 ? void 0 : n.type;
}
function aF(e) {
  for (const n of e.schema.getDirectives()) {
    if (!Xu(n)) {
      e.reportError(
        `Expected directive but got: ${_e(n)}.`,
        n?.astNode
      );
      continue;
    }
    Gi(e, n);
    for (const r of n.args)
      if (Gi(e, r), fn(r.type) || e.reportError(
        `The type of @${n.name}(${r.name}:) must be Input Type but got: ${_e(r.type)}.`,
        r.astNode
      ), pi(r) && r.deprecationReason != null) {
        var t;
        e.reportError(
          `Required argument @${n.name}(${r.name}:) cannot be deprecated.`,
          [
            Fh(r.astNode),
            (t = r.astNode) === null || t === void 0 ? void 0 : t.type
          ]
        );
      }
  }
}
function Gi(e, t) {
  t.name.startsWith("__") && e.reportError(
    `Name "${t.name}" must not begin with "__", which is reserved by GraphQL introspection.`,
    t.astNode
  );
}
function lF(e) {
  const t = mF(e), n = e.schema.getTypeMap();
  for (const r of Object.values(n)) {
    if (!Ta(r)) {
      e.reportError(
        `Expected GraphQL named type but got: ${_e(r)}.`,
        r.astNode
      );
      continue;
    }
    Bs(r) || Gi(e, r), lt(r) || pt(r) ? (Bg(e, r), Gg(e, r)) : qt(r) ? fF(e, r) : Ft(r) ? dF(e, r) : St(r) && (pF(e, r), t(r));
  }
}
function Bg(e, t) {
  const n = Object.values(t.getFields());
  n.length === 0 && e.reportError(`Type ${t.name} must define one or more fields.`, [
    t.astNode,
    ...t.extensionASTNodes
  ]);
  for (const o of n) {
    if (Gi(e, o), !oi(o.type)) {
      var r;
      e.reportError(
        `The type of ${t.name}.${o.name} must be Output Type but got: ${_e(o.type)}.`,
        (r = o.astNode) === null || r === void 0 ? void 0 : r.type
      );
    }
    for (const a of o.args) {
      const l = a.name;
      if (Gi(e, a), !fn(a.type)) {
        var i;
        e.reportError(
          `The type of ${t.name}.${o.name}(${l}:) must be Input Type but got: ${_e(a.type)}.`,
          (i = a.astNode) === null || i === void 0 ? void 0 : i.type
        );
      }
      if (pi(a) && a.deprecationReason != null) {
        var s;
        e.reportError(
          `Required argument ${t.name}.${o.name}(${l}:) cannot be deprecated.`,
          [
            Fh(a.astNode),
            (s = a.astNode) === null || s === void 0 ? void 0 : s.type
          ]
        );
      }
    }
  }
}
function Gg(e, t) {
  const n = /* @__PURE__ */ Object.create(null);
  for (const r of t.getInterfaces()) {
    if (!pt(r)) {
      e.reportError(
        `Type ${_e(t)} must only implement Interface types, it cannot implement ${_e(r)}.`,
        Mo(t, r)
      );
      continue;
    }
    if (t === r) {
      e.reportError(
        `Type ${t.name} cannot implement itself because it would create a circular reference.`,
        Mo(t, r)
      );
      continue;
    }
    if (n[r.name]) {
      e.reportError(
        `Type ${t.name} can only implement ${r.name} once.`,
        Mo(t, r)
      );
      continue;
    }
    n[r.name] = !0, cF(e, t, r), uF(e, t, r);
  }
}
function uF(e, t, n) {
  const r = t.getFields();
  for (const l of Object.values(n.getFields())) {
    const c = l.name, u = r[c];
    if (!u) {
      e.reportError(
        `Interface field ${n.name}.${c} expected but ${t.name} does not provide it.`,
        [l.astNode, t.astNode, ...t.extensionASTNodes]
      );
      continue;
    }
    if (!Mi(e.schema, u.type, l.type)) {
      var i, s;
      e.reportError(
        `Interface field ${n.name}.${c} expects type ${_e(l.type)} but ${t.name}.${c} is type ${_e(u.type)}.`,
        [
          (i = l.astNode) === null || i === void 0 ? void 0 : i.type,
          (s = u.astNode) === null || s === void 0 ? void 0 : s.type
        ]
      );
    }
    for (const f of l.args) {
      const d = f.name, p = u.args.find((h) => h.name === d);
      if (!p) {
        e.reportError(
          `Interface field argument ${n.name}.${c}(${d}:) expected but ${t.name}.${c} does not provide it.`,
          [f.astNode, u.astNode]
        );
        continue;
      }
      if (!Kl(f.type, p.type)) {
        var o, a;
        e.reportError(
          `Interface field argument ${n.name}.${c}(${d}:) expects type ${_e(f.type)} but ${t.name}.${c}(${d}:) is type ${_e(p.type)}.`,
          [
            (o = f.astNode) === null || o === void 0 ? void 0 : o.type,
            (a = p.astNode) === null || a === void 0 ? void 0 : a.type
          ]
        );
      }
    }
    for (const f of u.args) {
      const d = f.name;
      !l.args.find((h) => h.name === d) && pi(f) && e.reportError(
        `Object field ${t.name}.${c} includes required argument ${d} that is missing from the Interface field ${n.name}.${c}.`,
        [f.astNode, l.astNode]
      );
    }
  }
}
function cF(e, t, n) {
  const r = t.getInterfaces();
  for (const i of n.getInterfaces())
    r.includes(i) || e.reportError(
      i === t ? `Type ${t.name} cannot implement ${n.name} because it would create a circular reference.` : `Type ${t.name} must implement ${i.name} because it is implemented by ${n.name}.`,
      [
        ...Mo(n, i),
        ...Mo(t, n)
      ]
    );
}
function fF(e, t) {
  const n = t.getTypes();
  n.length === 0 && e.reportError(
    `Union type ${t.name} must define one or more member types.`,
    [t.astNode, ...t.extensionASTNodes]
  );
  const r = /* @__PURE__ */ Object.create(null);
  for (const i of n) {
    if (r[i.name]) {
      e.reportError(
        `Union type ${t.name} can only include type ${i.name} once.`,
        zg(t, i.name)
      );
      continue;
    }
    r[i.name] = !0, lt(i) || e.reportError(
      `Union type ${t.name} can only include Object types, it cannot include ${_e(i)}.`,
      zg(t, String(i))
    );
  }
}
function dF(e, t) {
  const n = t.getValues();
  n.length === 0 && e.reportError(
    `Enum type ${t.name} must define one or more values.`,
    [t.astNode, ...t.extensionASTNodes]
  );
  for (const r of n)
    Gi(e, r);
}
function pF(e, t) {
  const n = Object.values(t.getFields());
  n.length === 0 && e.reportError(
    `Input Object type ${t.name} must define one or more fields.`,
    [t.astNode, ...t.extensionASTNodes]
  );
  for (const s of n) {
    if (Gi(e, s), !fn(s.type)) {
      var r;
      e.reportError(
        `The type of ${t.name}.${s.name} must be Input Type but got: ${_e(s.type)}.`,
        (r = s.astNode) === null || r === void 0 ? void 0 : r.type
      );
    }
    if (Ku(s) && s.deprecationReason != null) {
      var i;
      e.reportError(
        `Required input field ${t.name}.${s.name} cannot be deprecated.`,
        [
          Fh(s.astNode),
          (i = s.astNode) === null || i === void 0 ? void 0 : i.type
        ]
      );
    }
    t.isOneOf && hF(t, s, e);
  }
}
function hF(e, t, n) {
  if (Qe(t.type)) {
    var r;
    n.reportError(
      `OneOf input field ${e.name}.${t.name} must be nullable.`,
      (r = t.astNode) === null || r === void 0 ? void 0 : r.type
    );
  }
  t.defaultValue !== void 0 && n.reportError(
    `OneOf input field ${e.name}.${t.name} cannot have a default value.`,
    t.astNode
  );
}
function mF(e) {
  const t = /* @__PURE__ */ Object.create(null), n = [], r = /* @__PURE__ */ Object.create(null);
  return i;
  function i(s) {
    if (t[s.name])
      return;
    t[s.name] = !0, r[s.name] = n.length;
    const o = Object.values(s.getFields());
    for (const a of o)
      if (Qe(a.type) && St(a.type.ofType)) {
        const l = a.type.ofType, c = r[l.name];
        if (n.push(a), c === void 0)
          i(l);
        else {
          const u = n.slice(c), f = u.map((d) => d.name).join(".");
          e.reportError(
            `Cannot reference Input Object "${l.name}" within itself through a series of non-null fields: "${f}".`,
            u.map((d) => d.astNode)
          );
        }
        n.pop();
      }
    r[s.name] = void 0;
  }
}
function Mo(e, t) {
  const { astNode: n, extensionASTNodes: r } = e;
  return (n != null ? [n, ...r] : r).flatMap((s) => {
    var o;
    return (
      /* c8 ignore next */
      (o = s.interfaces) !== null && o !== void 0 ? o : []
    );
  }).filter((s) => s.name.value === t.name);
}
function zg(e, t) {
  const { astNode: n, extensionASTNodes: r } = e;
  return (n != null ? [n, ...r] : r).flatMap((s) => {
    var o;
    return (
      /* c8 ignore next */
      (o = s.types) !== null && o !== void 0 ? o : []
    );
  }).filter((s) => s.name.value === t);
}
function Fh(e) {
  var t;
  return e == null || (t = e.directives) === null || t === void 0 ? void 0 : t.find(
    (n) => n.name.value === Zu.name
  );
}
const yF = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  DEFAULT_DEPRECATION_REASON: Ih,
  GRAPHQL_MAX_INT: $l,
  GRAPHQL_MIN_INT: Nl,
  GraphQLBoolean: dn,
  GraphQLDeprecatedDirective: Zu,
  GraphQLDirective: er,
  GraphQLEnumType: ui,
  GraphQLFloat: Yw,
  GraphQLID: $h,
  GraphQLIncludeDirective: Nh,
  GraphQLInputObjectType: Rs,
  GraphQLInt: Kw,
  GraphQLInterfaceType: Os,
  GraphQLList: Kt,
  GraphQLNonNull: Ye,
  GraphQLObjectType: Dn,
  GraphQLOneOfDirective: Ah,
  GraphQLScalarType: wr,
  GraphQLSchema: Gs,
  GraphQLSkipDirective: Oh,
  GraphQLSpecifiedByDirective: Rh,
  GraphQLString: Dt,
  GraphQLUnionType: Is,
  SchemaMetaFieldDef: Xo,
  get TypeKind() {
    return ht;
  },
  TypeMetaFieldDef: Zo,
  TypeNameMetaFieldDef: ea,
  __Directive: Ph,
  __DirectiveLocation: kh,
  __EnumValue: jh,
  __Field: Lh,
  __InputValue: Oa,
  __Schema: ec,
  __Type: xn,
  __TypeKind: Ch,
  assertAbstractType: ZM,
  assertCompositeType: XM,
  assertDirective: iF,
  assertEnumType: qM,
  assertEnumValueName: Vw,
  assertInputObjectType: HM,
  assertInputType: JM,
  assertInterfaceType: Gw,
  assertLeafType: YM,
  assertListType: WM,
  assertName: _n,
  assertNamedType: tF,
  assertNonNullType: QM,
  assertNullableType: zw,
  assertObjectType: Bw,
  assertOutputType: KM,
  assertScalarType: GM,
  assertSchema: Mh,
  assertType: BM,
  assertUnionType: zM,
  assertValidSchema: eE,
  assertWrappingType: eF,
  getNamedType: An,
  getNullableType: Eh,
  introspectionTypes: Ia,
  isAbstractType: gr,
  isCompositeType: _r,
  isDirective: Xu,
  isEnumType: Ft,
  isInputObjectType: St,
  isInputType: fn,
  isInterfaceType: pt,
  isIntrospectionType: Bs,
  isLeafType: vr,
  isListType: Tt,
  isNamedType: Ta,
  isNonNullType: Qe,
  isNullableType: wh,
  isObjectType: lt,
  isOutputType: oi,
  isRequiredArgument: pi,
  isRequiredInputField: Ku,
  isScalarType: wn,
  isSchema: Xw,
  isSpecifiedDirective: xh,
  isSpecifiedScalarType: Yu,
  isType: Ea,
  isUnionType: qt,
  isWrappingType: Sa,
  resolveObjMapThunk: Th,
  resolveReadonlyArrayThunk: Sh,
  specifiedDirectives: hi,
  specifiedScalarTypes: $a,
  validateSchema: Zw
}, Symbol.toStringTag, { value: "Module" })), tE = /* @__PURE__ */ Hi(yF);
var tc = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.nodejsCustomInspectSymbol = void 0, e.nodejsCustomInspectSymbol = Symbol.for("nodejs.util.inspect.custom");
  function t(n = 10, r = 2) {
    return function(f) {
      return i(f, []);
    };
    function i(u, f) {
      switch (typeof u) {
        case "string":
          return JSON.stringify(u);
        case "function":
          return u.name ? `[function ${u.name}]` : "[function]";
        case "object":
          return s(u, f);
        default:
          return String(u);
      }
    }
    function s(u, f) {
      if (f.indexOf(u) !== -1)
        return "[Circular]";
      const d = [...f, u];
      if (u) {
        const p = l(u);
        if (p) {
          const h = p.call(u);
          if (h !== u)
            return typeof h == "string" ? h : i(h, d);
        } else if (Array.isArray(u))
          return a(u, d);
        return o(u, d);
      }
      return String(u);
    }
    function o(u, f) {
      const d = Object.keys(u);
      return d.length === 0 ? "{}" : f.length > r ? "[" + c(u) + "]" : "{ " + d.map((h) => {
        const m = i(u[h], f);
        return h + ": " + m;
      }).join(", ") + " }";
    }
    function a(u, f) {
      if (u.length === 0)
        return "[]";
      if (f.length > r)
        return "[Array]";
      const d = Math.min(n, u.length), p = u.length - d, h = [];
      for (let m = 0; m < d; ++m)
        h.push(i(u[m], f));
      return p === 1 ? h.push("... 1 more item") : p > 1 && h.push(`... ${p} more items`), "[" + h.join(", ") + "]";
    }
    function l(u) {
      const f = u[String(e.nodejsCustomInspectSymbol)];
      if (typeof f == "function")
        return f;
      if (typeof u.inspect == "function")
        return u.inspect;
    }
    function c(u) {
      const f = Object.prototype.toString.call(u).replace(/^\[object /, "").replace(/]$/, "");
      if (f === "Object" && typeof u.constructor == "function") {
        const d = u.constructor.name;
        if (typeof d == "string")
          return d;
      }
      return f;
    }
  }
  e.default = t;
})(tc);
var bn = {};
function gF(e) {
  return e instanceof Error ? e : new bF(e);
}
class bF extends Error {
  constructor(t) {
    super("Unexpected error value: " + _e(t)), this.name = "NonErrorThrown", this.thrownValue = t;
  }
}
function ta(e, t, n) {
  var r;
  const i = gF(e);
  return vF(i) ? i : new ge(i.message, {
    nodes: (r = i.nodes) !== null && r !== void 0 ? r : t,
    source: i.source,
    positions: i.positions,
    path: n,
    originalError: i
  });
}
function vF(e) {
  return Array.isArray(e.path);
}
const _F = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  GraphQLError: ge,
  formatError: fM,
  locatedError: ta,
  printError: cM,
  syntaxError: Gt
}, Symbol.toStringTag, { value: "Module" })), wF = /* @__PURE__ */ Hi(_F);
function nE(e) {
  const t = {
    descriptions: !0,
    specifiedByUrl: !1,
    directiveIsRepeatable: !1,
    schemaDescription: !1,
    inputValueDeprecation: !1,
    oneOf: !1,
    ...e
  }, n = t.descriptions ? "description" : "", r = t.specifiedByUrl ? "specifiedByURL" : "", i = t.directiveIsRepeatable ? "isRepeatable" : "", s = t.schemaDescription ? n : "";
  function o(l) {
    return t.inputValueDeprecation ? l : "";
  }
  const a = t.oneOf ? "isOneOf" : "";
  return `
    query IntrospectionQuery {
      __schema {
        ${s}
        queryType { name }
        mutationType { name }
        subscriptionType { name }
        types {
          ...FullType
        }
        directives {
          name
          ${n}
          ${i}
          locations
          args${o("(includeDeprecated: true)")} {
            ...InputValue
          }
        }
      }
    }

    fragment FullType on __Type {
      kind
      name
      ${n}
      ${r}
      ${a}
      fields(includeDeprecated: true) {
        name
        ${n}
        args${o("(includeDeprecated: true)")} {
          ...InputValue
        }
        type {
          ...TypeRef
        }
        isDeprecated
        deprecationReason
      }
      inputFields${o("(includeDeprecated: true)")} {
        ...InputValue
      }
      interfaces {
        ...TypeRef
      }
      enumValues(includeDeprecated: true) {
        name
        ${n}
        isDeprecated
        deprecationReason
      }
      possibleTypes {
        ...TypeRef
      }
    }

    fragment InputValue on __InputValue {
      name
      ${n}
      type { ...TypeRef }
      defaultValue
      ${o("isDeprecated")}
      ${o("deprecationReason")}
    }

    fragment TypeRef on __Type {
      kind
      name
      ofType {
        kind
        name
        ofType {
          kind
          name
          ofType {
            kind
            name
            ofType {
              kind
              name
              ofType {
                kind
                name
                ofType {
                  kind
                  name
                  ofType {
                    kind
                    name
                    ofType {
                      kind
                      name
                      ofType {
                        kind
                        name
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  `;
}
function EF(e, t) {
  let n = null;
  for (const i of e.definitions)
    if (i.kind === Q.OPERATION_DEFINITION) {
      var r;
      if (t == null) {
        if (n)
          return null;
        n = i;
      } else if (((r = i.name) === null || r === void 0 ? void 0 : r.value) === t)
        return i;
    }
  return n;
}
function SF(e, t) {
  if (t.operation === "query") {
    const n = e.getQueryType();
    if (!n)
      throw new ge(
        "Schema does not define the required query root type.",
        {
          nodes: t
        }
      );
    return n;
  }
  if (t.operation === "mutation") {
    const n = e.getMutationType();
    if (!n)
      throw new ge("Schema is not configured for mutations.", {
        nodes: t
      });
    return n;
  }
  if (t.operation === "subscription") {
    const n = e.getSubscriptionType();
    if (!n)
      throw new ge("Schema is not configured for subscriptions.", {
        nodes: t
      });
    return n;
  }
  throw new ge(
    "Can only have query, mutation and subscription operations.",
    {
      nodes: t
    }
  );
}
function Pn(e) {
  return typeof e?.then == "function";
}
function TF(e) {
  let t;
  return function(r, i, s) {
    t === void 0 && (t = /* @__PURE__ */ new WeakMap());
    let o = t.get(r);
    o === void 0 && (o = /* @__PURE__ */ new WeakMap(), t.set(r, o));
    let a = o.get(i);
    a === void 0 && (a = /* @__PURE__ */ new WeakMap(), o.set(i, a));
    let l = a.get(s);
    return l === void 0 && (l = e(r, i, s), a.set(s, l)), l;
  };
}
function qg(e) {
  return Promise.all(Object.values(e)).then((t) => {
    const n = /* @__PURE__ */ Object.create(null);
    for (const [r, i] of Object.keys(e).entries())
      n[i] = t[r];
    return n;
  });
}
function $F(e, t, n) {
  let r = n;
  for (const i of e)
    r = Pn(r) ? r.then((s) => t(s, i)) : t(r, i);
  return r;
}
function pn(e, t) {
  switch (t.kind) {
    case Q.LIST_TYPE: {
      const n = pn(e, t.type);
      return n && new Kt(n);
    }
    case Q.NON_NULL_TYPE: {
      const n = pn(e, t.type);
      return n && new Ye(n);
    }
    case Q.NAMED_TYPE:
      return e.getType(t.name.value);
  }
}
function rE(e) {
  return e.map(
    (t) => typeof t == "number" ? "[" + t.toString() + "]" : "." + t
  ).join("");
}
function iE(e, t, n = NF) {
  return Ro(e, t, n, void 0);
}
function NF(e, t, n) {
  let r = "Invalid value " + _e(t);
  throw e.length > 0 && (r += ` at "value${rE(e)}"`), n.message = r + ": " + n.message, n;
}
function Ro(e, t, n, r) {
  if (Qe(t)) {
    if (e != null)
      return Ro(e, t.ofType, n, r);
    n(
      un(r),
      e,
      new ge(
        `Expected non-nullable type "${_e(t)}" not to be null.`
      )
    );
    return;
  }
  if (e == null)
    return null;
  if (Tt(t)) {
    const i = t.ofType;
    return Dh(e) ? Array.from(e, (s, o) => {
      const a = $s(r, o, void 0);
      return Ro(s, i, n, a);
    }) : [Ro(e, i, n, r)];
  }
  if (St(t)) {
    if (!vn(e)) {
      n(
        un(r),
        e,
        new ge(`Expected type "${t.name}" to be an object.`)
      );
      return;
    }
    const i = {}, s = t.getFields();
    for (const o of Object.values(s)) {
      const a = e[o.name];
      if (a === void 0) {
        if (o.defaultValue !== void 0)
          i[o.name] = o.defaultValue;
        else if (Qe(o.type)) {
          const l = _e(o.type);
          n(
            un(r),
            e,
            new ge(
              `Field "${o.name}" of required type "${l}" was not provided.`
            )
          );
        }
        continue;
      }
      i[o.name] = Ro(
        a,
        o.type,
        n,
        $s(r, o.name, t.name)
      );
    }
    for (const o of Object.keys(e))
      if (!s[o]) {
        const a = di(
          o,
          Object.keys(t.getFields())
        );
        n(
          un(r),
          e,
          new ge(
            `Field "${o}" is not defined by type "${t.name}".` + Gr(a)
          )
        );
      }
    if (t.isOneOf) {
      const o = Object.keys(i);
      o.length !== 1 && n(
        un(r),
        e,
        new ge(
          `Exactly one key must be specified for OneOf type "${t.name}".`
        )
      );
      const a = o[0], l = i[a];
      l === null && n(
        un(r).concat(a),
        l,
        new ge(`Field "${a}" must be non-null.`)
      );
    }
    return i;
  }
  if (vr(t)) {
    let i;
    try {
      i = t.parseValue(e);
    } catch (s) {
      s instanceof ge ? n(un(r), e, s) : n(
        un(r),
        e,
        new ge(`Expected type "${t.name}". ` + s.message, {
          originalError: s
        })
      );
      return;
    }
    return i === void 0 && n(
      un(r),
      e,
      new ge(`Expected type "${t.name}".`)
    ), i;
  }
  Ht(!1, "Unexpected input type: " + _e(t));
}
function hr(e, t, n) {
  if (e) {
    if (e.kind === Q.VARIABLE) {
      const r = e.name.value;
      if (n == null || n[r] === void 0)
        return;
      const i = n[r];
      return i === null && Qe(t) ? void 0 : i;
    }
    if (Qe(t))
      return e.kind === Q.NULL ? void 0 : hr(e, t.ofType, n);
    if (e.kind === Q.NULL)
      return null;
    if (Tt(t)) {
      const r = t.ofType;
      if (e.kind === Q.LIST) {
        const s = [];
        for (const o of e.values)
          if (Hg(o, n)) {
            if (Qe(r))
              return;
            s.push(null);
          } else {
            const a = hr(o, r, n);
            if (a === void 0)
              return;
            s.push(a);
          }
        return s;
      }
      const i = hr(e, r, n);
      return i === void 0 ? void 0 : [i];
    }
    if (St(t)) {
      if (e.kind !== Q.OBJECT)
        return;
      const r = /* @__PURE__ */ Object.create(null), i = zr(e.fields, (s) => s.name.value);
      for (const s of Object.values(t.getFields())) {
        const o = i[s.name];
        if (!o || Hg(o.value, n)) {
          if (s.defaultValue !== void 0)
            r[s.name] = s.defaultValue;
          else if (Qe(s.type))
            return;
          continue;
        }
        const a = hr(o.value, s.type, n);
        if (a === void 0)
          return;
        r[s.name] = a;
      }
      if (t.isOneOf) {
        const s = Object.keys(r);
        if (s.length !== 1 || r[s[0]] === null)
          return;
      }
      return r;
    }
    if (vr(t)) {
      let r;
      try {
        r = t.parseLiteral(e, n);
      } catch {
        return;
      }
      return r === void 0 ? void 0 : r;
    }
    Ht(!1, "Unexpected input type: " + _e(t));
  }
}
function Hg(e, t) {
  return e.kind === Q.VARIABLE && (t == null || t[e.name.value] === void 0);
}
function OF(e, t, n, r) {
  const i = [], s = r?.maxErrors;
  try {
    const o = IF(
      e,
      t,
      n,
      (a) => {
        if (s != null && i.length >= s)
          throw new ge(
            "Too many errors processing variables, error limit reached. Execution aborted."
          );
        i.push(a);
      }
    );
    if (i.length === 0)
      return {
        coerced: o
      };
  } catch (o) {
    i.push(o);
  }
  return {
    errors: i
  };
}
function IF(e, t, n, r) {
  const i = {};
  for (const s of t) {
    const o = s.variable.name.value, a = pn(e, s.type);
    if (!fn(a)) {
      const c = Et(s.type);
      r(
        new ge(
          `Variable "$${o}" expected value of type "${c}" which cannot be used as an input type.`,
          {
            nodes: s.type
          }
        )
      );
      continue;
    }
    if (!oE(n, o)) {
      if (s.defaultValue)
        i[o] = hr(s.defaultValue, a);
      else if (Qe(a)) {
        const c = _e(a);
        r(
          new ge(
            `Variable "$${o}" of required type "${c}" was not provided.`,
            {
              nodes: s
            }
          )
        );
      }
      continue;
    }
    const l = n[o];
    if (l === null && Qe(a)) {
      const c = _e(a);
      r(
        new ge(
          `Variable "$${o}" of non-null type "${c}" must not be null.`,
          {
            nodes: s
          }
        )
      );
      continue;
    }
    i[o] = iE(
      l,
      a,
      (c, u, f) => {
        let d = `Variable "$${o}" got invalid value ` + _e(u);
        c.length > 0 && (d += ` at "${o}${rE(c)}"`), r(
          new ge(d + "; " + f.message, {
            nodes: s,
            originalError: f
          })
        );
      }
    );
  }
  return i;
}
function sE(e, t, n) {
  var r;
  const i = {}, s = (r = t.arguments) !== null && r !== void 0 ? r : [], o = zr(s, (a) => a.name.value);
  for (const a of e.args) {
    const l = a.name, c = a.type, u = o[l];
    if (!u) {
      if (a.defaultValue !== void 0)
        i[l] = a.defaultValue;
      else if (Qe(c))
        throw new ge(
          `Argument "${l}" of required type "${_e(c)}" was not provided.`,
          {
            nodes: t
          }
        );
      continue;
    }
    const f = u.value;
    let d = f.kind === Q.NULL;
    if (f.kind === Q.VARIABLE) {
      const h = f.name.value;
      if (n == null || !oE(n, h)) {
        if (a.defaultValue !== void 0)
          i[l] = a.defaultValue;
        else if (Qe(c))
          throw new ge(
            `Argument "${l}" of required type "${_e(c)}" was provided the variable "$${h}" which was not provided a runtime value.`,
            {
              nodes: f
            }
          );
        continue;
      }
      d = n[h] == null;
    }
    if (d && Qe(c))
      throw new ge(
        `Argument "${l}" of non-null type "${_e(c)}" must not be null.`,
        {
          nodes: f
        }
      );
    const p = hr(f, c, n);
    if (p === void 0)
      throw new ge(
        `Argument "${l}" has invalid value ${Et(f)}.`,
        {
          nodes: f
        }
      );
    i[l] = p;
  }
  return i;
}
function na(e, t, n) {
  var r;
  const i = (r = t.directives) === null || r === void 0 ? void 0 : r.find(
    (s) => s.name.value === e.name
  );
  if (i)
    return sE(e, i, n);
}
function oE(e, t) {
  return Object.prototype.hasOwnProperty.call(e, t);
}
function aE(e, t, n, r, i) {
  const s = /* @__PURE__ */ new Map();
  return Yl(
    e,
    t,
    n,
    r,
    i,
    s,
    /* @__PURE__ */ new Set()
  ), s;
}
function RF(e, t, n, r, i) {
  const s = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Set();
  for (const a of i)
    a.selectionSet && Yl(
      e,
      t,
      n,
      r,
      a.selectionSet,
      s,
      o
    );
  return s;
}
function Yl(e, t, n, r, i, s, o) {
  for (const a of i.selections)
    switch (a.kind) {
      case Q.FIELD: {
        if (!Af(n, a))
          continue;
        const l = AF(a), c = s.get(l);
        c !== void 0 ? c.push(a) : s.set(l, [a]);
        break;
      }
      case Q.INLINE_FRAGMENT: {
        if (!Af(n, a) || !Wg(e, a, r))
          continue;
        Yl(
          e,
          t,
          n,
          r,
          a.selectionSet,
          s,
          o
        );
        break;
      }
      case Q.FRAGMENT_SPREAD: {
        const l = a.name.value;
        if (o.has(l) || !Af(n, a))
          continue;
        o.add(l);
        const c = t[l];
        if (!c || !Wg(e, c, r))
          continue;
        Yl(
          e,
          t,
          n,
          r,
          c.selectionSet,
          s,
          o
        );
        break;
      }
    }
}
function Af(e, t) {
  const n = na(Oh, t, e);
  if (n?.if === !0)
    return !1;
  const r = na(
    Nh,
    t,
    e
  );
  return r?.if !== !1;
}
function Wg(e, t, n) {
  const r = t.typeCondition;
  if (!r)
    return !0;
  const i = pn(e, r);
  return i === n ? !0 : gr(i) ? e.isSubType(i, n) : !1;
}
function AF(e) {
  return e.alias ? e.alias.value : e.name.value;
}
const xF = TF(
  (e, t, n) => RF(
    e.schema,
    e.fragments,
    e.variableValues,
    t,
    n
  )
);
function lE(e) {
  arguments.length < 2 || it(
    !1,
    "graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead."
  );
  const { schema: t, document: n, variableValues: r, rootValue: i } = e;
  cE(t, n, r);
  const s = fE(e);
  if (!("schema" in s))
    return {
      errors: s
    };
  try {
    const { operation: o } = s, a = DF(s, o, i);
    return Pn(a) ? a.then(
      (l) => il(l, s.errors),
      (l) => (s.errors.push(l), il(null, s.errors))
    ) : il(a, s.errors);
  } catch (o) {
    return s.errors.push(o), il(null, s.errors);
  }
}
function uE(e) {
  const t = lE(e);
  if (Pn(t))
    throw new Error("GraphQL execution failed to complete synchronously.");
  return t;
}
function il(e, t) {
  return t.length === 0 ? {
    data: e
  } : {
    errors: t,
    data: e
  };
}
function cE(e, t, n) {
  t || it(!1, "Must provide document."), eE(e), n == null || vn(n) || it(
    !1,
    "Variables must be provided as an Object where each property is a variable value. Perhaps look to see if an unparsed JSON string was provided."
  );
}
function fE(e) {
  var t, n;
  const {
    schema: r,
    document: i,
    rootValue: s,
    contextValue: o,
    variableValues: a,
    operationName: l,
    fieldResolver: c,
    typeResolver: u,
    subscribeFieldResolver: f
  } = e;
  let d;
  const p = /* @__PURE__ */ Object.create(null);
  for (const v of i.definitions)
    switch (v.kind) {
      case Q.OPERATION_DEFINITION:
        if (l == null) {
          if (d !== void 0)
            return [
              new ge(
                "Must provide operation name if query contains multiple operations."
              )
            ];
          d = v;
        } else
          ((t = v.name) === null || t === void 0 ? void 0 : t.value) === l && (d = v);
        break;
      case Q.FRAGMENT_DEFINITION:
        p[v.name.value] = v;
        break;
    }
  if (!d)
    return l != null ? [new ge(`Unknown operation named "${l}".`)] : [new ge("Must provide an operation.")];
  const h = (n = d.variableDefinitions) !== null && n !== void 0 ? n : [], m = OF(
    r,
    h,
    a ?? {},
    {
      maxErrors: 50
    }
  );
  return m.errors ? m.errors : {
    schema: r,
    fragments: p,
    rootValue: s,
    contextValue: o,
    operation: d,
    variableValues: m.coerced,
    fieldResolver: c ?? wd,
    typeResolver: u ?? hE,
    subscribeFieldResolver: f ?? wd,
    errors: []
  };
}
function DF(e, t, n) {
  const r = e.schema.getRootType(t.operation);
  if (r == null)
    throw new ge(
      `Schema is not configured to execute ${t.operation} operation.`,
      {
        nodes: t
      }
    );
  const i = aE(
    e.schema,
    e.fragments,
    e.variableValues,
    r,
    t.selectionSet
  ), s = void 0;
  switch (t.operation) {
    case zt.QUERY:
      return Xl(e, r, n, s, i);
    case zt.MUTATION:
      return PF(
        e,
        r,
        n,
        s,
        i
      );
    case zt.SUBSCRIPTION:
      return Xl(e, r, n, s, i);
  }
}
function PF(e, t, n, r, i) {
  return $F(
    i.entries(),
    (s, [o, a]) => {
      const l = $s(r, o, t.name), c = dE(
        e,
        t,
        n,
        a,
        l
      );
      return c === void 0 ? s : Pn(c) ? c.then((u) => (s[o] = u, s)) : (s[o] = c, s);
    },
    /* @__PURE__ */ Object.create(null)
  );
}
function Xl(e, t, n, r, i) {
  const s = /* @__PURE__ */ Object.create(null);
  let o = !1;
  try {
    for (const [a, l] of i.entries()) {
      const c = $s(r, a, t.name), u = dE(
        e,
        t,
        n,
        l,
        c
      );
      u !== void 0 && (s[a] = u, Pn(u) && (o = !0));
    }
  } catch (a) {
    if (o)
      return qg(s).finally(() => {
        throw a;
      });
    throw a;
  }
  return o ? qg(s) : s;
}
function dE(e, t, n, r, i) {
  var s;
  const o = mE(e.schema, t, r[0]);
  if (!o)
    return;
  const a = o.type, l = (s = o.resolve) !== null && s !== void 0 ? s : e.fieldResolver, c = pE(
    e,
    o,
    r,
    t,
    i
  );
  try {
    const u = sE(
      o,
      r[0],
      e.variableValues
    ), f = e.contextValue, d = l(n, u, f, c);
    let p;
    return Pn(d) ? p = d.then(
      (h) => ra(e, a, r, c, i, h)
    ) : p = ra(
      e,
      a,
      r,
      c,
      i,
      d
    ), Pn(p) ? p.then(void 0, (h) => {
      const m = ta(h, r, un(i));
      return Zl(m, a, e);
    }) : p;
  } catch (u) {
    const f = ta(u, r, un(i));
    return Zl(f, a, e);
  }
}
function pE(e, t, n, r, i) {
  return {
    fieldName: t.name,
    fieldNodes: n,
    returnType: t.type,
    parentType: r,
    path: i,
    schema: e.schema,
    fragments: e.fragments,
    rootValue: e.rootValue,
    operation: e.operation,
    variableValues: e.variableValues
  };
}
function Zl(e, t, n) {
  if (Qe(t))
    throw e;
  return n.errors.push(e), null;
}
function ra(e, t, n, r, i, s) {
  if (s instanceof Error)
    throw s;
  if (Qe(t)) {
    const o = ra(
      e,
      t.ofType,
      n,
      r,
      i,
      s
    );
    if (o === null)
      throw new Error(
        `Cannot return null for non-nullable field ${r.parentType.name}.${r.fieldName}.`
      );
    return o;
  }
  if (s == null)
    return null;
  if (Tt(t))
    return kF(
      e,
      t,
      n,
      r,
      i,
      s
    );
  if (vr(t))
    return LF(t, s);
  if (gr(t))
    return jF(
      e,
      t,
      n,
      r,
      i,
      s
    );
  if (lt(t))
    return _d(
      e,
      t,
      n,
      r,
      i,
      s
    );
  Ht(
    !1,
    "Cannot complete value of unexpected output type: " + _e(t)
  );
}
function kF(e, t, n, r, i, s) {
  if (!Dh(s))
    throw new ge(
      `Expected Iterable, but did not find one for field "${r.parentType.name}.${r.fieldName}".`
    );
  const o = t.ofType;
  let a = !1;
  const l = Array.from(s, (c, u) => {
    const f = $s(i, u, void 0);
    try {
      let d;
      return Pn(c) ? d = c.then(
        (p) => ra(
          e,
          o,
          n,
          r,
          f,
          p
        )
      ) : d = ra(
        e,
        o,
        n,
        r,
        f,
        c
      ), Pn(d) ? (a = !0, d.then(void 0, (p) => {
        const h = ta(
          p,
          n,
          un(f)
        );
        return Zl(h, o, e);
      })) : d;
    } catch (d) {
      const p = ta(d, n, un(f));
      return Zl(p, o, e);
    }
  });
  return a ? Promise.all(l) : l;
}
function LF(e, t) {
  const n = e.serialize(t);
  if (n == null)
    throw new Error(
      `Expected \`${_e(e)}.serialize(${_e(t)})\` to return non-nullable value, returned: ${_e(n)}`
    );
  return n;
}
function jF(e, t, n, r, i, s) {
  var o;
  const a = (o = t.resolveType) !== null && o !== void 0 ? o : e.typeResolver, l = e.contextValue, c = a(s, l, r, t);
  return Pn(c) ? c.then(
    (u) => _d(
      e,
      Qg(
        u,
        e,
        t,
        n,
        r,
        s
      ),
      n,
      r,
      i,
      s
    )
  ) : _d(
    e,
    Qg(
      c,
      e,
      t,
      n,
      r,
      s
    ),
    n,
    r,
    i,
    s
  );
}
function Qg(e, t, n, r, i, s) {
  if (e == null)
    throw new ge(
      `Abstract type "${n.name}" must resolve to an Object type at runtime for field "${i.parentType.name}.${i.fieldName}". Either the "${n.name}" type should provide a "resolveType" function or each possible type should provide an "isTypeOf" function.`,
      r
    );
  if (lt(e))
    throw new ge(
      "Support for returning GraphQLObjectType from resolveType was removed in graphql-js@16.0.0 please return type name instead."
    );
  if (typeof e != "string")
    throw new ge(
      `Abstract type "${n.name}" must resolve to an Object type at runtime for field "${i.parentType.name}.${i.fieldName}" with value ${_e(s)}, received "${_e(e)}".`
    );
  const o = t.schema.getType(e);
  if (o == null)
    throw new ge(
      `Abstract type "${n.name}" was resolved to a type "${e}" that does not exist inside the schema.`,
      {
        nodes: r
      }
    );
  if (!lt(o))
    throw new ge(
      `Abstract type "${n.name}" was resolved to a non-object type "${e}".`,
      {
        nodes: r
      }
    );
  if (!t.schema.isSubType(n, o))
    throw new ge(
      `Runtime Object type "${o.name}" is not a possible type for "${n.name}".`,
      {
        nodes: r
      }
    );
  return o;
}
function _d(e, t, n, r, i, s) {
  const o = xF(e, t, n);
  if (t.isTypeOf) {
    const a = t.isTypeOf(s, e.contextValue, r);
    if (Pn(a))
      return a.then((l) => {
        if (!l)
          throw Jg(t, s, n);
        return Xl(
          e,
          t,
          s,
          i,
          o
        );
      });
    if (!a)
      throw Jg(t, s, n);
  }
  return Xl(e, t, s, i, o);
}
function Jg(e, t, n) {
  return new ge(
    `Expected value of type "${e.name}" but got: ${_e(t)}.`,
    {
      nodes: n
    }
  );
}
const hE = function(e, t, n, r) {
  if (vn(e) && typeof e.__typename == "string")
    return e.__typename;
  const i = n.schema.getPossibleTypes(r), s = [];
  for (let o = 0; o < i.length; o++) {
    const a = i[o];
    if (a.isTypeOf) {
      const l = a.isTypeOf(e, t, n);
      if (Pn(l))
        s[o] = l;
      else if (l)
        return a.name;
    }
  }
  if (s.length)
    return Promise.all(s).then((o) => {
      for (let a = 0; a < o.length; a++)
        if (o[a])
          return i[a].name;
    });
}, wd = function(e, t, n, r) {
  if (vn(e) || typeof e == "function") {
    const i = e[r.fieldName];
    return typeof i == "function" ? e[r.fieldName](t, n, r) : i;
  }
};
function mE(e, t, n) {
  const r = n.name.value;
  return r === Xo.name && e.getQueryType() === t ? Xo : r === Zo.name && e.getQueryType() === t ? Zo : r === ea.name ? ea : t.getFields()[r];
}
const CF = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  assertValidExecutionArguments: cE,
  buildExecutionContext: fE,
  buildResolveInfo: pE,
  defaultFieldResolver: wd,
  defaultTypeResolver: hE,
  execute: lE,
  executeSync: uE,
  getFieldDef: mE
}, Symbol.toStringTag, { value: "Module" }));
function MF(e, t) {
  const n = {
    specifiedByUrl: !0,
    directiveIsRepeatable: !0,
    schemaDescription: !0,
    inputValueDeprecation: !0,
    oneOf: !0,
    ...t
  }, r = gh(nE(n)), i = uE({
    schema: e,
    document: r
  });
  return !i.errors && i.data || Ht(!1), i.data;
}
function FF(e, t) {
  vn(e) && vn(e.__schema) || it(
    !1,
    `Invalid or incomplete introspection result. Ensure that you are passing "data" property of introspection response and no "errors" was returned alongside: ${_e(
      e
    )}.`
  );
  const n = e.__schema, r = ni(
    n.types,
    (j) => j.name,
    (j) => d(j)
  );
  for (const j of [...$a, ...Ia])
    r[j.name] && (r[j.name] = j);
  const i = n.queryType ? u(n.queryType) : null, s = n.mutationType ? u(n.mutationType) : null, o = n.subscriptionType ? u(n.subscriptionType) : null, a = n.directives ? n.directives.map(Z) : [];
  return new Gs({
    description: n.description,
    query: i,
    mutation: s,
    subscription: o,
    types: Object.values(r),
    directives: a,
    assumeValid: t?.assumeValid
  });
  function l(j) {
    if (j.kind === ht.LIST) {
      const ee = j.ofType;
      if (!ee)
        throw new Error("Decorated type deeper than introspection query.");
      return new Kt(l(ee));
    }
    if (j.kind === ht.NON_NULL) {
      const ee = j.ofType;
      if (!ee)
        throw new Error("Decorated type deeper than introspection query.");
      const le = l(ee);
      return new Ye(zw(le));
    }
    return c(j);
  }
  function c(j) {
    const ee = j.name;
    if (!ee)
      throw new Error(`Unknown type reference: ${_e(j)}.`);
    const le = r[ee];
    if (!le)
      throw new Error(
        `Invalid or incomplete schema, unknown type: ${ee}. Ensure that a full introspection query is used in order to build a client schema.`
      );
    return le;
  }
  function u(j) {
    return Bw(c(j));
  }
  function f(j) {
    return Gw(c(j));
  }
  function d(j) {
    if (j != null && j.name != null && j.kind != null)
      switch (j.kind) {
        case ht.SCALAR:
          return p(j);
        case ht.OBJECT:
          return m(j);
        case ht.INTERFACE:
          return v(j);
        case ht.UNION:
          return b(j);
        case ht.ENUM:
          return E(j);
        case ht.INPUT_OBJECT:
          return y(j);
      }
    const ee = _e(j);
    throw new Error(
      `Invalid or incomplete introspection result. Ensure that a full introspection query is used in order to build a client schema: ${ee}.`
    );
  }
  function p(j) {
    return new wr({
      name: j.name,
      description: j.description,
      specifiedByURL: j.specifiedByURL
    });
  }
  function h(j) {
    if (j.interfaces === null && j.kind === ht.INTERFACE)
      return [];
    if (!j.interfaces) {
      const ee = _e(j);
      throw new Error(
        `Introspection result missing interfaces: ${ee}.`
      );
    }
    return j.interfaces.map(f);
  }
  function m(j) {
    return new Dn({
      name: j.name,
      description: j.description,
      interfaces: () => h(j),
      fields: () => D(j)
    });
  }
  function v(j) {
    return new Os({
      name: j.name,
      description: j.description,
      interfaces: () => h(j),
      fields: () => D(j)
    });
  }
  function b(j) {
    if (!j.possibleTypes) {
      const ee = _e(j);
      throw new Error(
        `Introspection result missing possibleTypes: ${ee}.`
      );
    }
    return new Is({
      name: j.name,
      description: j.description,
      types: () => j.possibleTypes.map(u)
    });
  }
  function E(j) {
    if (!j.enumValues) {
      const ee = _e(j);
      throw new Error(
        `Introspection result missing enumValues: ${ee}.`
      );
    }
    return new ui({
      name: j.name,
      description: j.description,
      values: ni(
        j.enumValues,
        (ee) => ee.name,
        (ee) => ({
          description: ee.description,
          deprecationReason: ee.deprecationReason
        })
      )
    });
  }
  function y(j) {
    if (!j.inputFields) {
      const ee = _e(j);
      throw new Error(
        `Introspection result missing inputFields: ${ee}.`
      );
    }
    return new Rs({
      name: j.name,
      description: j.description,
      fields: () => W(j.inputFields),
      isOneOf: j.isOneOf
    });
  }
  function D(j) {
    if (!j.fields)
      throw new Error(
        `Introspection result missing fields: ${_e(j)}.`
      );
    return ni(
      j.fields,
      (ee) => ee.name,
      F
    );
  }
  function F(j) {
    const ee = l(j.type);
    if (!oi(ee)) {
      const le = _e(ee);
      throw new Error(
        `Introspection must provide output type for fields, but received: ${le}.`
      );
    }
    if (!j.args) {
      const le = _e(j);
      throw new Error(
        `Introspection result missing field args: ${le}.`
      );
    }
    return {
      description: j.description,
      deprecationReason: j.deprecationReason,
      type: ee,
      args: W(j.args)
    };
  }
  function W(j) {
    return ni(
      j,
      (ee) => ee.name,
      J
    );
  }
  function J(j) {
    const ee = l(j.type);
    if (!fn(ee)) {
      const ce = _e(ee);
      throw new Error(
        `Introspection must provide input type for arguments, but received: ${ce}.`
      );
    }
    const le = j.defaultValue != null ? hr(Cw(j.defaultValue), ee) : void 0;
    return {
      description: j.description,
      type: ee,
      defaultValue: le,
      deprecationReason: j.deprecationReason
    };
  }
  function Z(j) {
    if (!j.args) {
      const ee = _e(j);
      throw new Error(
        `Introspection result missing directive args: ${ee}.`
      );
    }
    if (!j.locations) {
      const ee = _e(j);
      throw new Error(
        `Introspection result missing directive locations: ${ee}.`
      );
    }
    return new er({
      name: j.name,
      description: j.description,
      isRepeatable: j.isRepeatable,
      locations: j.locations.slice(),
      args: W(j.args)
    });
  }
}
class UF {
  constructor(t, n, r) {
    this._schema = t, this._typeStack = [], this._parentTypeStack = [], this._inputTypeStack = [], this._fieldDefStack = [], this._defaultValueStack = [], this._directive = null, this._argument = null, this._enumValue = null, this._getFieldDef = r ?? VF, n && (fn(n) && this._inputTypeStack.push(n), _r(n) && this._parentTypeStack.push(n), oi(n) && this._typeStack.push(n));
  }
  get [Symbol.toStringTag]() {
    return "TypeInfo";
  }
  getType() {
    if (this._typeStack.length > 0)
      return this._typeStack[this._typeStack.length - 1];
  }
  getParentType() {
    if (this._parentTypeStack.length > 0)
      return this._parentTypeStack[this._parentTypeStack.length - 1];
  }
  getInputType() {
    if (this._inputTypeStack.length > 0)
      return this._inputTypeStack[this._inputTypeStack.length - 1];
  }
  getParentInputType() {
    if (this._inputTypeStack.length > 1)
      return this._inputTypeStack[this._inputTypeStack.length - 2];
  }
  getFieldDef() {
    if (this._fieldDefStack.length > 0)
      return this._fieldDefStack[this._fieldDefStack.length - 1];
  }
  getDefaultValue() {
    if (this._defaultValueStack.length > 0)
      return this._defaultValueStack[this._defaultValueStack.length - 1];
  }
  getDirective() {
    return this._directive;
  }
  getArgument() {
    return this._argument;
  }
  getEnumValue() {
    return this._enumValue;
  }
  enter(t) {
    const n = this._schema;
    switch (t.kind) {
      case Q.SELECTION_SET: {
        const i = An(this.getType());
        this._parentTypeStack.push(
          _r(i) ? i : void 0
        );
        break;
      }
      case Q.FIELD: {
        const i = this.getParentType();
        let s, o;
        i && (s = this._getFieldDef(n, i, t), s && (o = s.type)), this._fieldDefStack.push(s), this._typeStack.push(oi(o) ? o : void 0);
        break;
      }
      case Q.DIRECTIVE:
        this._directive = n.getDirective(t.name.value);
        break;
      case Q.OPERATION_DEFINITION: {
        const i = n.getRootType(t.operation);
        this._typeStack.push(lt(i) ? i : void 0);
        break;
      }
      case Q.INLINE_FRAGMENT:
      case Q.FRAGMENT_DEFINITION: {
        const i = t.typeCondition, s = i ? pn(n, i) : An(this.getType());
        this._typeStack.push(oi(s) ? s : void 0);
        break;
      }
      case Q.VARIABLE_DEFINITION: {
        const i = pn(n, t.type);
        this._inputTypeStack.push(
          fn(i) ? i : void 0
        );
        break;
      }
      case Q.ARGUMENT: {
        var r;
        let i, s;
        const o = (r = this.getDirective()) !== null && r !== void 0 ? r : this.getFieldDef();
        o && (i = o.args.find(
          (a) => a.name === t.name.value
        ), i && (s = i.type)), this._argument = i, this._defaultValueStack.push(i ? i.defaultValue : void 0), this._inputTypeStack.push(fn(s) ? s : void 0);
        break;
      }
      case Q.LIST: {
        const i = Eh(this.getInputType()), s = Tt(i) ? i.ofType : i;
        this._defaultValueStack.push(void 0), this._inputTypeStack.push(fn(s) ? s : void 0);
        break;
      }
      case Q.OBJECT_FIELD: {
        const i = An(this.getInputType());
        let s, o;
        St(i) && (o = i.getFields()[t.name.value], o && (s = o.type)), this._defaultValueStack.push(
          o ? o.defaultValue : void 0
        ), this._inputTypeStack.push(
          fn(s) ? s : void 0
        );
        break;
      }
      case Q.ENUM: {
        const i = An(this.getInputType());
        let s;
        Ft(i) && (s = i.getValue(t.value)), this._enumValue = s;
        break;
      }
    }
  }
  leave(t) {
    switch (t.kind) {
      case Q.SELECTION_SET:
        this._parentTypeStack.pop();
        break;
      case Q.FIELD:
        this._fieldDefStack.pop(), this._typeStack.pop();
        break;
      case Q.DIRECTIVE:
        this._directive = null;
        break;
      case Q.OPERATION_DEFINITION:
      case Q.INLINE_FRAGMENT:
      case Q.FRAGMENT_DEFINITION:
        this._typeStack.pop();
        break;
      case Q.VARIABLE_DEFINITION:
        this._inputTypeStack.pop();
        break;
      case Q.ARGUMENT:
        this._argument = null, this._defaultValueStack.pop(), this._inputTypeStack.pop();
        break;
      case Q.LIST:
      case Q.OBJECT_FIELD:
        this._defaultValueStack.pop(), this._inputTypeStack.pop();
        break;
      case Q.ENUM:
        this._enumValue = null;
        break;
    }
  }
}
function VF(e, t, n) {
  const r = n.name.value;
  if (r === Xo.name && e.getQueryType() === t)
    return Xo;
  if (r === Zo.name && e.getQueryType() === t)
    return Zo;
  if (r === ea.name && _r(t))
    return ea;
  if (lt(t) || pt(t))
    return t.getFields()[r];
}
function BF(e, t) {
  return {
    enter(...n) {
      const r = n[0];
      e.enter(r);
      const i = Ns(t, r.kind).enter;
      if (i) {
        const s = i.apply(t, n);
        return s !== void 0 && (e.leave(r), md(s) && e.enter(s)), s;
      }
    },
    leave(...n) {
      const r = n[0], i = Ns(t, r.kind).leave;
      let s;
      return i && (s = i.apply(t, n)), e.leave(r), s;
    }
  };
}
function GF(e) {
  return {
    Document(t) {
      for (const n of t.definitions)
        if (!bh(n)) {
          const r = n.kind === Q.SCHEMA_DEFINITION || n.kind === Q.SCHEMA_EXTENSION ? "schema" : '"' + n.name.value + '"';
          e.reportError(
            new ge(`The ${r} definition is not executable.`, {
              nodes: n
            })
          );
        }
      return !1;
    }
  };
}
function zF(e) {
  return {
    Field(t) {
      const n = e.getParentType();
      if (n && !e.getFieldDef()) {
        const i = e.getSchema(), s = t.name.value;
        let o = Gr(
          "to use an inline fragment on",
          qF(i, n, s)
        );
        o === "" && (o = Gr(HF(n, s))), e.reportError(
          new ge(
            `Cannot query field "${s}" on type "${n.name}".` + o,
            {
              nodes: t
            }
          )
        );
      }
    }
  };
}
function qF(e, t, n) {
  if (!gr(t))
    return [];
  const r = /* @__PURE__ */ new Set(), i = /* @__PURE__ */ Object.create(null);
  for (const o of e.getPossibleTypes(t))
    if (o.getFields()[n]) {
      r.add(o), i[o.name] = 1;
      for (const a of o.getInterfaces()) {
        var s;
        a.getFields()[n] && (r.add(a), i[a.name] = ((s = i[a.name]) !== null && s !== void 0 ? s : 0) + 1);
      }
    }
  return [...r].sort((o, a) => {
    const l = i[a.name] - i[o.name];
    return l !== 0 ? l : pt(o) && e.isSubType(o, a) ? -1 : pt(a) && e.isSubType(a, o) ? 1 : wa(o.name, a.name);
  }).map((o) => o.name);
}
function HF(e, t) {
  if (lt(e) || pt(e)) {
    const n = Object.keys(e.getFields());
    return di(t, n);
  }
  return [];
}
function WF(e) {
  return {
    InlineFragment(t) {
      const n = t.typeCondition;
      if (n) {
        const r = pn(e.getSchema(), n);
        if (r && !_r(r)) {
          const i = Et(n);
          e.reportError(
            new ge(
              `Fragment cannot condition on non composite type "${i}".`,
              {
                nodes: n
              }
            )
          );
        }
      }
    },
    FragmentDefinition(t) {
      const n = pn(e.getSchema(), t.typeCondition);
      if (n && !_r(n)) {
        const r = Et(t.typeCondition);
        e.reportError(
          new ge(
            `Fragment "${t.name.value}" cannot condition on non composite type "${r}".`,
            {
              nodes: t.typeCondition
            }
          )
        );
      }
    }
  };
}
function QF(e) {
  return {
    // eslint-disable-next-line new-cap
    ...yE(e),
    Argument(t) {
      const n = e.getArgument(), r = e.getFieldDef(), i = e.getParentType();
      if (!n && r && i) {
        const s = t.name.value, o = r.args.map((l) => l.name), a = di(s, o);
        e.reportError(
          new ge(
            `Unknown argument "${s}" on field "${i.name}.${r.name}".` + Gr(a),
            {
              nodes: t
            }
          )
        );
      }
    }
  };
}
function yE(e) {
  const t = /* @__PURE__ */ Object.create(null), n = e.getSchema(), r = n ? n.getDirectives() : hi;
  for (const o of r)
    t[o.name] = o.args.map((a) => a.name);
  const i = e.getDocument().definitions;
  for (const o of i)
    if (o.kind === Q.DIRECTIVE_DEFINITION) {
      var s;
      const a = (s = o.arguments) !== null && s !== void 0 ? s : [];
      t[o.name.value] = a.map((l) => l.name.value);
    }
  return {
    Directive(o) {
      const a = o.name.value, l = t[a];
      if (o.arguments && l)
        for (const c of o.arguments) {
          const u = c.name.value;
          if (!l.includes(u)) {
            const f = di(u, l);
            e.reportError(
              new ge(
                `Unknown argument "${u}" on directive "@${a}".` + Gr(f),
                {
                  nodes: c
                }
              )
            );
          }
        }
      return !1;
    }
  };
}
function gE(e) {
  const t = /* @__PURE__ */ Object.create(null), n = e.getSchema(), r = n ? n.getDirectives() : hi;
  for (const s of r)
    t[s.name] = s.locations;
  const i = e.getDocument().definitions;
  for (const s of i)
    s.kind === Q.DIRECTIVE_DEFINITION && (t[s.name.value] = s.locations.map((o) => o.value));
  return {
    Directive(s, o, a, l, c) {
      const u = s.name.value, f = t[u];
      if (!f) {
        e.reportError(
          new ge(`Unknown directive "@${u}".`, {
            nodes: s
          })
        );
        return;
      }
      const d = JF(c);
      d && !f.includes(d) && e.reportError(
        new ge(
          `Directive "@${u}" may not be used on ${d}.`,
          {
            nodes: s
          }
        )
      );
    }
  };
}
function JF(e) {
  const t = e[e.length - 1];
  switch ("kind" in t || Ht(!1), t.kind) {
    case Q.OPERATION_DEFINITION:
      return KF(t.operation);
    case Q.FIELD:
      return Fe.FIELD;
    case Q.FRAGMENT_SPREAD:
      return Fe.FRAGMENT_SPREAD;
    case Q.INLINE_FRAGMENT:
      return Fe.INLINE_FRAGMENT;
    case Q.FRAGMENT_DEFINITION:
      return Fe.FRAGMENT_DEFINITION;
    case Q.VARIABLE_DEFINITION:
      return Fe.VARIABLE_DEFINITION;
    case Q.SCHEMA_DEFINITION:
    case Q.SCHEMA_EXTENSION:
      return Fe.SCHEMA;
    case Q.SCALAR_TYPE_DEFINITION:
    case Q.SCALAR_TYPE_EXTENSION:
      return Fe.SCALAR;
    case Q.OBJECT_TYPE_DEFINITION:
    case Q.OBJECT_TYPE_EXTENSION:
      return Fe.OBJECT;
    case Q.FIELD_DEFINITION:
      return Fe.FIELD_DEFINITION;
    case Q.INTERFACE_TYPE_DEFINITION:
    case Q.INTERFACE_TYPE_EXTENSION:
      return Fe.INTERFACE;
    case Q.UNION_TYPE_DEFINITION:
    case Q.UNION_TYPE_EXTENSION:
      return Fe.UNION;
    case Q.ENUM_TYPE_DEFINITION:
    case Q.ENUM_TYPE_EXTENSION:
      return Fe.ENUM;
    case Q.ENUM_VALUE_DEFINITION:
      return Fe.ENUM_VALUE;
    case Q.INPUT_OBJECT_TYPE_DEFINITION:
    case Q.INPUT_OBJECT_TYPE_EXTENSION:
      return Fe.INPUT_OBJECT;
    case Q.INPUT_VALUE_DEFINITION: {
      const n = e[e.length - 3];
      return "kind" in n || Ht(!1), n.kind === Q.INPUT_OBJECT_TYPE_DEFINITION ? Fe.INPUT_FIELD_DEFINITION : Fe.ARGUMENT_DEFINITION;
    }
    default:
      Ht(!1, "Unexpected kind: " + _e(t.kind));
  }
}
function KF(e) {
  switch (e) {
    case zt.QUERY:
      return Fe.QUERY;
    case zt.MUTATION:
      return Fe.MUTATION;
    case zt.SUBSCRIPTION:
      return Fe.SUBSCRIPTION;
  }
}
function YF(e) {
  return {
    FragmentSpread(t) {
      const n = t.name.value;
      e.getFragment(n) || e.reportError(
        new ge(`Unknown fragment "${n}".`, {
          nodes: t.name
        })
      );
    }
  };
}
function bE(e) {
  const t = e.getSchema(), n = t ? t.getTypeMap() : /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ Object.create(null);
  for (const s of e.getDocument().definitions)
    Vs(s) && (r[s.name.value] = !0);
  const i = [
    ...Object.keys(n),
    ...Object.keys(r)
  ];
  return {
    NamedType(s, o, a, l, c) {
      const u = s.name.value;
      if (!n[u] && !r[u]) {
        var f;
        const d = (f = c[2]) !== null && f !== void 0 ? f : a, p = d != null && XF(d);
        if (p && Kg.includes(u))
          return;
        const h = di(
          u,
          p ? Kg.concat(i) : i
        );
        e.reportError(
          new ge(
            `Unknown type "${u}".` + Gr(h),
            {
              nodes: s
            }
          )
        );
      }
    }
  };
}
const Kg = [...$a, ...Ia].map(
  (e) => e.name
);
function XF(e) {
  return "kind" in e && (vh(e) || _h(e));
}
function ZF(e) {
  let t = 0;
  return {
    Document(n) {
      t = n.definitions.filter(
        (r) => r.kind === Q.OPERATION_DEFINITION
      ).length;
    },
    OperationDefinition(n) {
      !n.name && t > 1 && e.reportError(
        new ge(
          "This anonymous operation must be the only defined operation.",
          {
            nodes: n
          }
        )
      );
    }
  };
}
function e2(e) {
  var t, n, r;
  const i = e.getSchema(), s = (t = (n = (r = i?.astNode) !== null && r !== void 0 ? r : i?.getQueryType()) !== null && n !== void 0 ? n : i?.getMutationType()) !== null && t !== void 0 ? t : i?.getSubscriptionType();
  let o = 0;
  return {
    SchemaDefinition(a) {
      if (s) {
        e.reportError(
          new ge(
            "Cannot define a new schema within a schema extension.",
            {
              nodes: a
            }
          )
        );
        return;
      }
      o > 0 && e.reportError(
        new ge("Must provide only one schema definition.", {
          nodes: a
        })
      ), ++o;
    }
  };
}
const t2 = 3;
function n2(e) {
  function t(n, r = /* @__PURE__ */ Object.create(null), i = 0) {
    if (n.kind === Q.FRAGMENT_SPREAD) {
      const s = n.name.value;
      if (r[s] === !0)
        return !1;
      const o = e.getFragment(s);
      if (!o)
        return !1;
      try {
        return r[s] = !0, t(o, r, i);
      } finally {
        r[s] = void 0;
      }
    }
    if (n.kind === Q.FIELD && // check all introspection lists
    (n.name.value === "fields" || n.name.value === "interfaces" || n.name.value === "possibleTypes" || n.name.value === "inputFields") && (i++, i >= t2))
      return !0;
    if ("selectionSet" in n && n.selectionSet) {
      for (const s of n.selectionSet.selections)
        if (t(s, r, i))
          return !0;
    }
    return !1;
  }
  return {
    Field(n) {
      if ((n.name.value === "__schema" || n.name.value === "__type") && t(n))
        return e.reportError(
          new ge("Maximum introspection depth exceeded", {
            nodes: [n]
          })
        ), !1;
    }
  };
}
function r2(e) {
  const t = /* @__PURE__ */ Object.create(null), n = [], r = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: () => !1,
    FragmentDefinition(s) {
      return i(s), !1;
    }
  };
  function i(s) {
    if (t[s.name.value])
      return;
    const o = s.name.value;
    t[o] = !0;
    const a = e.getFragmentSpreads(s.selectionSet);
    if (a.length !== 0) {
      r[o] = n.length;
      for (const l of a) {
        const c = l.name.value, u = r[c];
        if (n.push(l), u === void 0) {
          const f = e.getFragment(c);
          f && i(f);
        } else {
          const f = n.slice(u), d = f.slice(0, -1).map((p) => '"' + p.name.value + '"').join(", ");
          e.reportError(
            new ge(
              `Cannot spread fragment "${c}" within itself` + (d !== "" ? ` via ${d}.` : "."),
              {
                nodes: f
              }
            )
          );
        }
        n.pop();
      }
      r[o] = void 0;
    }
  }
}
function i2(e) {
  let t = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: {
      enter() {
        t = /* @__PURE__ */ Object.create(null);
      },
      leave(n) {
        const r = e.getRecursiveVariableUsages(n);
        for (const { node: i } of r) {
          const s = i.name.value;
          t[s] !== !0 && e.reportError(
            new ge(
              n.name ? `Variable "$${s}" is not defined by operation "${n.name.value}".` : `Variable "$${s}" is not defined.`,
              {
                nodes: [i, n]
              }
            )
          );
        }
      }
    },
    VariableDefinition(n) {
      t[n.variable.name.value] = !0;
    }
  };
}
function s2(e) {
  const t = [], n = [];
  return {
    OperationDefinition(r) {
      return t.push(r), !1;
    },
    FragmentDefinition(r) {
      return n.push(r), !1;
    },
    Document: {
      leave() {
        const r = /* @__PURE__ */ Object.create(null);
        for (const i of t)
          for (const s of e.getRecursivelyReferencedFragments(
            i
          ))
            r[s.name.value] = !0;
        for (const i of n) {
          const s = i.name.value;
          r[s] !== !0 && e.reportError(
            new ge(`Fragment "${s}" is never used.`, {
              nodes: i
            })
          );
        }
      }
    }
  };
}
function o2(e) {
  let t = [];
  return {
    OperationDefinition: {
      enter() {
        t = [];
      },
      leave(n) {
        const r = /* @__PURE__ */ Object.create(null), i = e.getRecursiveVariableUsages(n);
        for (const { node: s } of i)
          r[s.name.value] = !0;
        for (const s of t) {
          const o = s.variable.name.value;
          r[o] !== !0 && e.reportError(
            new ge(
              n.name ? `Variable "$${o}" is never used in operation "${n.name.value}".` : `Variable "$${o}" is never used.`,
              {
                nodes: s
              }
            )
          );
        }
      }
    },
    VariableDefinition(n) {
      t.push(n);
    }
  };
}
function nc(e) {
  switch (e.kind) {
    case Q.OBJECT:
      return { ...e, fields: a2(e.fields) };
    case Q.LIST:
      return { ...e, values: e.values.map(nc) };
    case Q.INT:
    case Q.FLOAT:
    case Q.STRING:
    case Q.BOOLEAN:
    case Q.NULL:
    case Q.ENUM:
    case Q.VARIABLE:
      return e;
  }
}
function a2(e) {
  return e.map((t) => ({
    ...t,
    value: nc(t.value)
  })).sort(
    (t, n) => wa(t.name.value, n.name.value)
  );
}
function vE(e) {
  return Array.isArray(e) ? e.map(
    ([t, n]) => `subfields "${t}" conflict because ` + vE(n)
  ).join(" and ") : e;
}
function l2(e) {
  const t = new h2(), n = /* @__PURE__ */ new Map();
  return {
    SelectionSet(r) {
      const i = u2(
        e,
        n,
        t,
        e.getParentType(),
        r
      );
      for (const [[s, o], a, l] of i) {
        const c = vE(o);
        e.reportError(
          new ge(
            `Fields "${s}" conflict because ${c}. Use different aliases on the fields to fetch both if this was intentional.`,
            {
              nodes: a.concat(l)
            }
          )
        );
      }
    }
  };
}
function u2(e, t, n, r, i) {
  const s = [], [o, a] = nu(
    e,
    t,
    r,
    i
  );
  if (f2(
    e,
    s,
    t,
    n,
    o
  ), a.length !== 0)
    for (let l = 0; l < a.length; l++) {
      eu(
        e,
        s,
        t,
        n,
        !1,
        o,
        a[l]
      );
      for (let c = l + 1; c < a.length; c++)
        tu(
          e,
          s,
          t,
          n,
          !1,
          a[l],
          a[c]
        );
    }
  return s;
}
function eu(e, t, n, r, i, s, o) {
  const a = e.getFragment(o);
  if (!a)
    return;
  const [l, c] = Sd(
    e,
    n,
    a
  );
  if (s !== l) {
    Uh(
      e,
      t,
      n,
      r,
      i,
      s,
      l
    );
    for (const u of c)
      r.has(
        u,
        o,
        i
      ) || (r.add(
        u,
        o,
        i
      ), eu(
        e,
        t,
        n,
        r,
        i,
        s,
        u
      ));
  }
}
function tu(e, t, n, r, i, s, o) {
  if (s === o || r.has(
    s,
    o,
    i
  ))
    return;
  r.add(s, o, i);
  const a = e.getFragment(s), l = e.getFragment(o);
  if (!a || !l)
    return;
  const [c, u] = Sd(
    e,
    n,
    a
  ), [f, d] = Sd(
    e,
    n,
    l
  );
  Uh(
    e,
    t,
    n,
    r,
    i,
    c,
    f
  );
  for (const p of d)
    tu(
      e,
      t,
      n,
      r,
      i,
      s,
      p
    );
  for (const p of u)
    tu(
      e,
      t,
      n,
      r,
      i,
      p,
      o
    );
}
function c2(e, t, n, r, i, s, o, a) {
  const l = [], [c, u] = nu(
    e,
    t,
    i,
    s
  ), [f, d] = nu(
    e,
    t,
    o,
    a
  );
  Uh(
    e,
    l,
    t,
    n,
    r,
    c,
    f
  );
  for (const p of d)
    eu(
      e,
      l,
      t,
      n,
      r,
      c,
      p
    );
  for (const p of u)
    eu(
      e,
      l,
      t,
      n,
      r,
      f,
      p
    );
  for (const p of u)
    for (const h of d)
      tu(
        e,
        l,
        t,
        n,
        r,
        p,
        h
      );
  return l;
}
function f2(e, t, n, r, i) {
  for (const [s, o] of Object.entries(i))
    if (o.length > 1)
      for (let a = 0; a < o.length; a++)
        for (let l = a + 1; l < o.length; l++) {
          const c = _E(
            e,
            n,
            r,
            !1,
            // within one collection is never mutually exclusive
            s,
            o[a],
            o[l]
          );
          c && t.push(c);
        }
}
function Uh(e, t, n, r, i, s, o) {
  for (const [a, l] of Object.entries(s)) {
    const c = o[a];
    if (c)
      for (const u of l)
        for (const f of c) {
          const d = _E(
            e,
            n,
            r,
            i,
            a,
            u,
            f
          );
          d && t.push(d);
        }
  }
}
function _E(e, t, n, r, i, s, o) {
  const [a, l, c] = s, [u, f, d] = o, p = r || a !== u && lt(a) && lt(u);
  if (!p) {
    const E = l.name.value, y = f.name.value;
    if (E !== y)
      return [
        [i, `"${E}" and "${y}" are different fields`],
        [l],
        [f]
      ];
    if (!d2(l, f))
      return [
        [i, "they have differing arguments"],
        [l],
        [f]
      ];
  }
  const h = c?.type, m = d?.type;
  if (h && m && Ed(h, m))
    return [
      [
        i,
        `they return conflicting types "${_e(h)}" and "${_e(
          m
        )}"`
      ],
      [l],
      [f]
    ];
  const v = l.selectionSet, b = f.selectionSet;
  if (v && b) {
    const E = c2(
      e,
      t,
      n,
      p,
      An(h),
      v,
      An(m),
      b
    );
    return p2(E, i, l, f);
  }
}
function d2(e, t) {
  const n = e.arguments, r = t.arguments;
  if (n === void 0 || n.length === 0)
    return r === void 0 || r.length === 0;
  if (r === void 0 || r.length === 0 || n.length !== r.length)
    return !1;
  const i = new Map(r.map(({ name: s, value: o }) => [s.value, o]));
  return n.every((s) => {
    const o = s.value, a = i.get(s.name.value);
    return a === void 0 ? !1 : Yg(o) === Yg(a);
  });
}
function Yg(e) {
  return Et(nc(e));
}
function Ed(e, t) {
  return Tt(e) ? Tt(t) ? Ed(e.ofType, t.ofType) : !0 : Tt(t) ? !0 : Qe(e) ? Qe(t) ? Ed(e.ofType, t.ofType) : !0 : Qe(t) ? !0 : vr(e) || vr(t) ? e !== t : !1;
}
function nu(e, t, n, r) {
  const i = t.get(r);
  if (i)
    return i;
  const s = /* @__PURE__ */ Object.create(null), o = /* @__PURE__ */ Object.create(null);
  wE(
    e,
    n,
    r,
    s,
    o
  );
  const a = [s, Object.keys(o)];
  return t.set(r, a), a;
}
function Sd(e, t, n) {
  const r = t.get(n.selectionSet);
  if (r)
    return r;
  const i = pn(e.getSchema(), n.typeCondition);
  return nu(
    e,
    t,
    i,
    n.selectionSet
  );
}
function wE(e, t, n, r, i) {
  for (const s of n.selections)
    switch (s.kind) {
      case Q.FIELD: {
        const o = s.name.value;
        let a;
        (lt(t) || pt(t)) && (a = t.getFields()[o]);
        const l = s.alias ? s.alias.value : o;
        r[l] || (r[l] = []), r[l].push([t, s, a]);
        break;
      }
      case Q.FRAGMENT_SPREAD:
        i[s.name.value] = !0;
        break;
      case Q.INLINE_FRAGMENT: {
        const o = s.typeCondition, a = o ? pn(e.getSchema(), o) : t;
        wE(
          e,
          a,
          s.selectionSet,
          r,
          i
        );
        break;
      }
    }
}
function p2(e, t, n, r) {
  if (e.length > 0)
    return [
      [t, e.map(([i]) => i)],
      [n, ...e.map(([, i]) => i).flat()],
      [r, ...e.map(([, , i]) => i).flat()]
    ];
}
class h2 {
  constructor() {
    this._data = /* @__PURE__ */ new Map();
  }
  has(t, n, r) {
    var i;
    const [s, o] = t < n ? [t, n] : [n, t], a = (i = this._data.get(s)) === null || i === void 0 ? void 0 : i.get(o);
    return a === void 0 ? !1 : r ? !0 : r === a;
  }
  add(t, n, r) {
    const [i, s] = t < n ? [t, n] : [n, t], o = this._data.get(i);
    o === void 0 ? this._data.set(i, /* @__PURE__ */ new Map([[s, r]])) : o.set(s, r);
  }
}
function m2(e) {
  return {
    InlineFragment(t) {
      const n = e.getType(), r = e.getParentType();
      if (_r(n) && _r(r) && !vd(e.getSchema(), n, r)) {
        const i = _e(r), s = _e(n);
        e.reportError(
          new ge(
            `Fragment cannot be spread here as objects of type "${i}" can never be of type "${s}".`,
            {
              nodes: t
            }
          )
        );
      }
    },
    FragmentSpread(t) {
      const n = t.name.value, r = y2(e, n), i = e.getParentType();
      if (r && i && !vd(e.getSchema(), r, i)) {
        const s = _e(i), o = _e(r);
        e.reportError(
          new ge(
            `Fragment "${n}" cannot be spread here as objects of type "${s}" can never be of type "${o}".`,
            {
              nodes: t
            }
          )
        );
      }
    }
  };
}
function y2(e, t) {
  const n = e.getFragment(t);
  if (n) {
    const r = pn(e.getSchema(), n.typeCondition);
    if (_r(r))
      return r;
  }
}
function g2(e) {
  const t = e.getSchema(), n = /* @__PURE__ */ Object.create(null);
  for (const i of e.getDocument().definitions)
    Vs(i) && (n[i.name.value] = i);
  return {
    ScalarTypeExtension: r,
    ObjectTypeExtension: r,
    InterfaceTypeExtension: r,
    UnionTypeExtension: r,
    EnumTypeExtension: r,
    InputObjectTypeExtension: r
  };
  function r(i) {
    const s = i.name.value, o = n[s], a = t?.getType(s);
    let l;
    if (o ? l = b2[o.kind] : a && (l = v2(a)), l) {
      if (l !== i.kind) {
        const c = _2(i.kind);
        e.reportError(
          new ge(`Cannot extend non-${c} type "${s}".`, {
            nodes: o ? [o, i] : i
          })
        );
      }
    } else {
      const c = Object.keys({
        ...n,
        ...t?.getTypeMap()
      }), u = di(s, c);
      e.reportError(
        new ge(
          `Cannot extend type "${s}" because it is not defined.` + Gr(u),
          {
            nodes: i.name
          }
        )
      );
    }
  }
}
const b2 = {
  [Q.SCALAR_TYPE_DEFINITION]: Q.SCALAR_TYPE_EXTENSION,
  [Q.OBJECT_TYPE_DEFINITION]: Q.OBJECT_TYPE_EXTENSION,
  [Q.INTERFACE_TYPE_DEFINITION]: Q.INTERFACE_TYPE_EXTENSION,
  [Q.UNION_TYPE_DEFINITION]: Q.UNION_TYPE_EXTENSION,
  [Q.ENUM_TYPE_DEFINITION]: Q.ENUM_TYPE_EXTENSION,
  [Q.INPUT_OBJECT_TYPE_DEFINITION]: Q.INPUT_OBJECT_TYPE_EXTENSION
};
function v2(e) {
  if (wn(e))
    return Q.SCALAR_TYPE_EXTENSION;
  if (lt(e))
    return Q.OBJECT_TYPE_EXTENSION;
  if (pt(e))
    return Q.INTERFACE_TYPE_EXTENSION;
  if (qt(e))
    return Q.UNION_TYPE_EXTENSION;
  if (Ft(e))
    return Q.ENUM_TYPE_EXTENSION;
  if (St(e))
    return Q.INPUT_OBJECT_TYPE_EXTENSION;
  Ht(!1, "Unexpected type: " + _e(e));
}
function _2(e) {
  switch (e) {
    case Q.SCALAR_TYPE_EXTENSION:
      return "scalar";
    case Q.OBJECT_TYPE_EXTENSION:
      return "object";
    case Q.INTERFACE_TYPE_EXTENSION:
      return "interface";
    case Q.UNION_TYPE_EXTENSION:
      return "union";
    case Q.ENUM_TYPE_EXTENSION:
      return "enum";
    case Q.INPUT_OBJECT_TYPE_EXTENSION:
      return "input object";
    default:
      Ht(!1, "Unexpected kind: " + _e(e));
  }
}
function w2(e) {
  return {
    // eslint-disable-next-line new-cap
    ...EE(e),
    Field: {
      // Validate on leave to allow for deeper errors to appear first.
      leave(t) {
        var n;
        const r = e.getFieldDef();
        if (!r)
          return !1;
        const i = new Set(
          // FIXME: https://github.com/graphql/graphql-js/issues/2203
          /* c8 ignore next */
          (n = t.arguments) === null || n === void 0 ? void 0 : n.map((s) => s.name.value)
        );
        for (const s of r.args)
          if (!i.has(s.name) && pi(s)) {
            const o = _e(s.type);
            e.reportError(
              new ge(
                `Field "${r.name}" argument "${s.name}" of type "${o}" is required, but it was not provided.`,
                {
                  nodes: t
                }
              )
            );
          }
      }
    }
  };
}
function EE(e) {
  var t;
  const n = /* @__PURE__ */ Object.create(null), r = e.getSchema(), i = (t = r?.getDirectives()) !== null && t !== void 0 ? t : hi;
  for (const a of i)
    n[a.name] = zr(
      a.args.filter(pi),
      (l) => l.name
    );
  const s = e.getDocument().definitions;
  for (const a of s)
    if (a.kind === Q.DIRECTIVE_DEFINITION) {
      var o;
      const l = (o = a.arguments) !== null && o !== void 0 ? o : [];
      n[a.name.value] = zr(
        l.filter(E2),
        (c) => c.name.value
      );
    }
  return {
    Directive: {
      // Validate on leave to allow for deeper errors to appear first.
      leave(a) {
        const l = a.name.value, c = n[l];
        if (c) {
          var u;
          const f = (u = a.arguments) !== null && u !== void 0 ? u : [], d = new Set(f.map((p) => p.name.value));
          for (const [p, h] of Object.entries(c))
            if (!d.has(p)) {
              const m = Ea(h.type) ? _e(h.type) : Et(h.type);
              e.reportError(
                new ge(
                  `Directive "@${l}" argument "${p}" of type "${m}" is required, but it was not provided.`,
                  {
                    nodes: a
                  }
                )
              );
            }
        }
      }
    }
  };
}
function E2(e) {
  return e.type.kind === Q.NON_NULL_TYPE && e.defaultValue == null;
}
function S2(e) {
  return {
    Field(t) {
      const n = e.getType(), r = t.selectionSet;
      if (n) {
        if (vr(An(n))) {
          if (r) {
            const i = t.name.value, s = _e(n);
            e.reportError(
              new ge(
                `Field "${i}" must not have a selection since type "${s}" has no subfields.`,
                {
                  nodes: r
                }
              )
            );
          }
        } else if (!r) {
          const i = t.name.value, s = _e(n);
          e.reportError(
            new ge(
              `Field "${i}" of type "${s}" must have a selection of subfields. Did you mean "${i} { ... }"?`,
              {
                nodes: t
              }
            )
          );
        }
      }
    }
  };
}
function T2(e) {
  return {
    OperationDefinition(t) {
      if (t.operation === "subscription") {
        const n = e.getSchema(), r = n.getSubscriptionType();
        if (r) {
          const i = t.name ? t.name.value : null, s = /* @__PURE__ */ Object.create(null), o = e.getDocument(), a = /* @__PURE__ */ Object.create(null);
          for (const c of o.definitions)
            c.kind === Q.FRAGMENT_DEFINITION && (a[c.name.value] = c);
          const l = aE(
            n,
            a,
            s,
            r,
            t.selectionSet
          );
          if (l.size > 1) {
            const f = [...l.values()].slice(1).flat();
            e.reportError(
              new ge(
                i != null ? `Subscription "${i}" must select only one top level field.` : "Anonymous Subscription must select only one top level field.",
                {
                  nodes: f
                }
              )
            );
          }
          for (const c of l.values())
            c[0].name.value.startsWith("__") && e.reportError(
              new ge(
                i != null ? `Subscription "${i}" must not select an introspection top level field.` : "Anonymous Subscription must not select an introspection top level field.",
                {
                  nodes: c
                }
              )
            );
        }
      }
    }
  };
}
function Vh(e, t) {
  const n = /* @__PURE__ */ new Map();
  for (const r of e) {
    const i = t(r), s = n.get(i);
    s === void 0 ? n.set(i, [r]) : s.push(r);
  }
  return n;
}
function $2(e) {
  return {
    DirectiveDefinition(r) {
      var i;
      const s = (i = r.arguments) !== null && i !== void 0 ? i : [];
      return n(`@${r.name.value}`, s);
    },
    InterfaceTypeDefinition: t,
    InterfaceTypeExtension: t,
    ObjectTypeDefinition: t,
    ObjectTypeExtension: t
  };
  function t(r) {
    var i;
    const s = r.name.value, o = (i = r.fields) !== null && i !== void 0 ? i : [];
    for (const l of o) {
      var a;
      const c = l.name.value, u = (a = l.arguments) !== null && a !== void 0 ? a : [];
      n(`${s}.${c}`, u);
    }
    return !1;
  }
  function n(r, i) {
    const s = Vh(i, (o) => o.name.value);
    for (const [o, a] of s)
      a.length > 1 && e.reportError(
        new ge(
          `Argument "${r}(${o}:)" can only be defined once.`,
          {
            nodes: a.map((l) => l.name)
          }
        )
      );
    return !1;
  }
}
function SE(e) {
  return {
    Field: t,
    Directive: t
  };
  function t(n) {
    var r;
    const i = (r = n.arguments) !== null && r !== void 0 ? r : [], s = Vh(i, (o) => o.name.value);
    for (const [o, a] of s)
      a.length > 1 && e.reportError(
        new ge(
          `There can be only one argument named "${o}".`,
          {
            nodes: a.map((l) => l.name)
          }
        )
      );
  }
}
function N2(e) {
  const t = /* @__PURE__ */ Object.create(null), n = e.getSchema();
  return {
    DirectiveDefinition(r) {
      const i = r.name.value;
      if (n != null && n.getDirective(i)) {
        e.reportError(
          new ge(
            `Directive "@${i}" already exists in the schema. It cannot be redefined.`,
            {
              nodes: r.name
            }
          )
        );
        return;
      }
      return t[i] ? e.reportError(
        new ge(
          `There can be only one directive named "@${i}".`,
          {
            nodes: [t[i], r.name]
          }
        )
      ) : t[i] = r.name, !1;
    }
  };
}
function TE(e) {
  const t = /* @__PURE__ */ Object.create(null), n = e.getSchema(), r = n ? n.getDirectives() : hi;
  for (const a of r)
    t[a.name] = !a.isRepeatable;
  const i = e.getDocument().definitions;
  for (const a of i)
    a.kind === Q.DIRECTIVE_DEFINITION && (t[a.name.value] = !a.repeatable);
  const s = /* @__PURE__ */ Object.create(null), o = /* @__PURE__ */ Object.create(null);
  return {
    // Many different AST nodes may contain directives. Rather than listing
    // them all, just listen for entering any node, and check to see if it
    // defines any directives.
    enter(a) {
      if (!("directives" in a) || !a.directives)
        return;
      let l;
      if (a.kind === Q.SCHEMA_DEFINITION || a.kind === Q.SCHEMA_EXTENSION)
        l = s;
      else if (Vs(a) || Ju(a)) {
        const c = a.name.value;
        l = o[c], l === void 0 && (o[c] = l = /* @__PURE__ */ Object.create(null));
      } else
        l = /* @__PURE__ */ Object.create(null);
      for (const c of a.directives) {
        const u = c.name.value;
        t[u] && (l[u] ? e.reportError(
          new ge(
            `The directive "@${u}" can only be used once at this location.`,
            {
              nodes: [l[u], c]
            }
          )
        ) : l[u] = c);
      }
    }
  };
}
function O2(e) {
  const t = e.getSchema(), n = t ? t.getTypeMap() : /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ Object.create(null);
  return {
    EnumTypeDefinition: i,
    EnumTypeExtension: i
  };
  function i(s) {
    var o;
    const a = s.name.value;
    r[a] || (r[a] = /* @__PURE__ */ Object.create(null));
    const l = (o = s.values) !== null && o !== void 0 ? o : [], c = r[a];
    for (const u of l) {
      const f = u.name.value, d = n[a];
      Ft(d) && d.getValue(f) ? e.reportError(
        new ge(
          `Enum value "${a}.${f}" already exists in the schema. It cannot also be defined in this type extension.`,
          {
            nodes: u.name
          }
        )
      ) : c[f] ? e.reportError(
        new ge(
          `Enum value "${a}.${f}" can only be defined once.`,
          {
            nodes: [c[f], u.name]
          }
        )
      ) : c[f] = u.name;
    }
    return !1;
  }
}
function I2(e) {
  const t = e.getSchema(), n = t ? t.getTypeMap() : /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ Object.create(null);
  return {
    InputObjectTypeDefinition: i,
    InputObjectTypeExtension: i,
    InterfaceTypeDefinition: i,
    InterfaceTypeExtension: i,
    ObjectTypeDefinition: i,
    ObjectTypeExtension: i
  };
  function i(s) {
    var o;
    const a = s.name.value;
    r[a] || (r[a] = /* @__PURE__ */ Object.create(null));
    const l = (o = s.fields) !== null && o !== void 0 ? o : [], c = r[a];
    for (const u of l) {
      const f = u.name.value;
      R2(n[a], f) ? e.reportError(
        new ge(
          `Field "${a}.${f}" already exists in the schema. It cannot also be defined in this type extension.`,
          {
            nodes: u.name
          }
        )
      ) : c[f] ? e.reportError(
        new ge(
          `Field "${a}.${f}" can only be defined once.`,
          {
            nodes: [c[f], u.name]
          }
        )
      ) : c[f] = u.name;
    }
    return !1;
  }
}
function R2(e, t) {
  return lt(e) || pt(e) || St(e) ? e.getFields()[t] != null : !1;
}
function A2(e) {
  const t = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: () => !1,
    FragmentDefinition(n) {
      const r = n.name.value;
      return t[r] ? e.reportError(
        new ge(
          `There can be only one fragment named "${r}".`,
          {
            nodes: [t[r], n.name]
          }
        )
      ) : t[r] = n.name, !1;
    }
  };
}
function $E(e) {
  const t = [];
  let n = /* @__PURE__ */ Object.create(null);
  return {
    ObjectValue: {
      enter() {
        t.push(n), n = /* @__PURE__ */ Object.create(null);
      },
      leave() {
        const r = t.pop();
        r || Ht(!1), n = r;
      }
    },
    ObjectField(r) {
      const i = r.name.value;
      n[i] ? e.reportError(
        new ge(
          `There can be only one input field named "${i}".`,
          {
            nodes: [n[i], r.name]
          }
        )
      ) : n[i] = r.name;
    }
  };
}
function x2(e) {
  const t = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition(n) {
      const r = n.name;
      return r && (t[r.value] ? e.reportError(
        new ge(
          `There can be only one operation named "${r.value}".`,
          {
            nodes: [
              t[r.value],
              r
            ]
          }
        )
      ) : t[r.value] = r), !1;
    },
    FragmentDefinition: () => !1
  };
}
function D2(e) {
  const t = e.getSchema(), n = /* @__PURE__ */ Object.create(null), r = t ? {
    query: t.getQueryType(),
    mutation: t.getMutationType(),
    subscription: t.getSubscriptionType()
  } : {};
  return {
    SchemaDefinition: i,
    SchemaExtension: i
  };
  function i(s) {
    var o;
    const a = (o = s.operationTypes) !== null && o !== void 0 ? o : [];
    for (const l of a) {
      const c = l.operation, u = n[c];
      r[c] ? e.reportError(
        new ge(
          `Type for ${c} already defined in the schema. It cannot be redefined.`,
          {
            nodes: l
          }
        )
      ) : u ? e.reportError(
        new ge(
          `There can be only one ${c} type in schema.`,
          {
            nodes: [u, l]
          }
        )
      ) : n[c] = l;
    }
    return !1;
  }
}
function P2(e) {
  const t = /* @__PURE__ */ Object.create(null), n = e.getSchema();
  return {
    ScalarTypeDefinition: r,
    ObjectTypeDefinition: r,
    InterfaceTypeDefinition: r,
    UnionTypeDefinition: r,
    EnumTypeDefinition: r,
    InputObjectTypeDefinition: r
  };
  function r(i) {
    const s = i.name.value;
    if (n != null && n.getType(s)) {
      e.reportError(
        new ge(
          `Type "${s}" already exists in the schema. It cannot also be defined in this type definition.`,
          {
            nodes: i.name
          }
        )
      );
      return;
    }
    return t[s] ? e.reportError(
      new ge(`There can be only one type named "${s}".`, {
        nodes: [t[s], i.name]
      })
    ) : t[s] = i.name, !1;
  }
}
function k2(e) {
  return {
    OperationDefinition(t) {
      var n;
      const r = (n = t.variableDefinitions) !== null && n !== void 0 ? n : [], i = Vh(
        r,
        (s) => s.variable.name.value
      );
      for (const [s, o] of i)
        o.length > 1 && e.reportError(
          new ge(
            `There can be only one variable named "$${s}".`,
            {
              nodes: o.map((a) => a.variable.name)
            }
          )
        );
    }
  };
}
function L2(e) {
  let t = {};
  return {
    OperationDefinition: {
      enter() {
        t = {};
      }
    },
    VariableDefinition(n) {
      t[n.variable.name.value] = n;
    },
    ListValue(n) {
      const r = Eh(e.getParentInputType());
      if (!Tt(r))
        return Oi(e, n), !1;
    },
    ObjectValue(n) {
      const r = An(e.getInputType());
      if (!St(r))
        return Oi(e, n), !1;
      const i = zr(n.fields, (s) => s.name.value);
      for (const s of Object.values(r.getFields()))
        if (!i[s.name] && Ku(s)) {
          const a = _e(s.type);
          e.reportError(
            new ge(
              `Field "${r.name}.${s.name}" of required type "${a}" was not provided.`,
              {
                nodes: n
              }
            )
          );
        }
      r.isOneOf && j2(
        e,
        n,
        r,
        i,
        t
      );
    },
    ObjectField(n) {
      const r = An(e.getParentInputType());
      if (!e.getInputType() && St(r)) {
        const s = di(
          n.name.value,
          Object.keys(r.getFields())
        );
        e.reportError(
          new ge(
            `Field "${n.name.value}" is not defined by type "${r.name}".` + Gr(s),
            {
              nodes: n
            }
          )
        );
      }
    },
    NullValue(n) {
      const r = e.getInputType();
      Qe(r) && e.reportError(
        new ge(
          `Expected value of type "${_e(r)}", found ${Et(n)}.`,
          {
            nodes: n
          }
        )
      );
    },
    EnumValue: (n) => Oi(e, n),
    IntValue: (n) => Oi(e, n),
    FloatValue: (n) => Oi(e, n),
    StringValue: (n) => Oi(e, n),
    BooleanValue: (n) => Oi(e, n)
  };
}
function Oi(e, t) {
  const n = e.getInputType();
  if (!n)
    return;
  const r = An(n);
  if (!vr(r)) {
    const i = _e(n);
    e.reportError(
      new ge(
        `Expected value of type "${i}", found ${Et(t)}.`,
        {
          nodes: t
        }
      )
    );
    return;
  }
  try {
    if (r.parseLiteral(
      t,
      void 0
      /* variables */
    ) === void 0) {
      const s = _e(n);
      e.reportError(
        new ge(
          `Expected value of type "${s}", found ${Et(t)}.`,
          {
            nodes: t
          }
        )
      );
    }
  } catch (i) {
    const s = _e(n);
    i instanceof ge ? e.reportError(i) : e.reportError(
      new ge(
        `Expected value of type "${s}", found ${Et(t)}; ` + i.message,
        {
          nodes: t,
          originalError: i
        }
      )
    );
  }
}
function j2(e, t, n, r, i) {
  var s;
  const o = Object.keys(r);
  if (o.length !== 1) {
    e.reportError(
      new ge(
        `OneOf Input Object "${n.name}" must specify exactly one key.`,
        {
          nodes: [t]
        }
      )
    );
    return;
  }
  const l = (s = r[o[0]]) === null || s === void 0 ? void 0 : s.value, c = !l || l.kind === Q.NULL, u = l?.kind === Q.VARIABLE;
  if (c) {
    e.reportError(
      new ge(`Field "${n.name}.${o[0]}" must be non-null.`, {
        nodes: [t]
      })
    );
    return;
  }
  if (u) {
    const f = l.name.value;
    i[f].type.kind !== Q.NON_NULL_TYPE && e.reportError(
      new ge(
        `Variable "${f}" must be non-nullable to be used for OneOf Input Object "${n.name}".`,
        {
          nodes: [t]
        }
      )
    );
  }
}
function C2(e) {
  return {
    VariableDefinition(t) {
      const n = pn(e.getSchema(), t.type);
      if (n !== void 0 && !fn(n)) {
        const r = t.variable.name.value, i = Et(t.type);
        e.reportError(
          new ge(
            `Variable "$${r}" cannot be non-input type "${i}".`,
            {
              nodes: t.type
            }
          )
        );
      }
    }
  };
}
function M2(e) {
  let t = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: {
      enter() {
        t = /* @__PURE__ */ Object.create(null);
      },
      leave(n) {
        const r = e.getRecursiveVariableUsages(n);
        for (const { node: i, type: s, defaultValue: o } of r) {
          const a = i.name.value, l = t[a];
          if (l && s) {
            const c = e.getSchema(), u = pn(c, l.type);
            if (u && !F2(
              c,
              u,
              l.defaultValue,
              s,
              o
            )) {
              const f = _e(u), d = _e(s);
              e.reportError(
                new ge(
                  `Variable "$${a}" of type "${f}" used in position expecting type "${d}".`,
                  {
                    nodes: [l, i]
                  }
                )
              );
            }
          }
        }
      }
    },
    VariableDefinition(n) {
      t[n.variable.name.value] = n;
    }
  };
}
function F2(e, t, n, r, i) {
  if (Qe(r) && !Qe(t)) {
    if (!(n != null && n.kind !== Q.NULL) && !(i !== void 0))
      return !1;
    const a = r.ofType;
    return Mi(e, t, a);
  }
  return Mi(e, t, r);
}
const U2 = Object.freeze([n2]);
Object.freeze([
  GF,
  x2,
  ZF,
  T2,
  bE,
  WF,
  C2,
  S2,
  zF,
  A2,
  YF,
  s2,
  m2,
  r2,
  k2,
  i2,
  o2,
  gE,
  TE,
  QF,
  SE,
  L2,
  w2,
  M2,
  l2,
  $E,
  ...U2
]);
const V2 = Object.freeze([
  e2,
  D2,
  P2,
  O2,
  I2,
  $2,
  N2,
  bE,
  gE,
  TE,
  g2,
  yE,
  SE,
  $E,
  EE
]);
class B2 {
  constructor(t, n) {
    this._ast = t, this._fragments = void 0, this._fragmentSpreads = /* @__PURE__ */ new Map(), this._recursivelyReferencedFragments = /* @__PURE__ */ new Map(), this._onError = n;
  }
  get [Symbol.toStringTag]() {
    return "ASTValidationContext";
  }
  reportError(t) {
    this._onError(t);
  }
  getDocument() {
    return this._ast;
  }
  getFragment(t) {
    let n;
    if (this._fragments)
      n = this._fragments;
    else {
      n = /* @__PURE__ */ Object.create(null);
      for (const r of this.getDocument().definitions)
        r.kind === Q.FRAGMENT_DEFINITION && (n[r.name.value] = r);
      this._fragments = n;
    }
    return n[t];
  }
  getFragmentSpreads(t) {
    let n = this._fragmentSpreads.get(t);
    if (!n) {
      n = [];
      const r = [t];
      let i;
      for (; i = r.pop(); )
        for (const s of i.selections)
          s.kind === Q.FRAGMENT_SPREAD ? n.push(s) : s.selectionSet && r.push(s.selectionSet);
      this._fragmentSpreads.set(t, n);
    }
    return n;
  }
  getRecursivelyReferencedFragments(t) {
    let n = this._recursivelyReferencedFragments.get(t);
    if (!n) {
      n = [];
      const r = /* @__PURE__ */ Object.create(null), i = [t.selectionSet];
      let s;
      for (; s = i.pop(); )
        for (const o of this.getFragmentSpreads(s)) {
          const a = o.name.value;
          if (r[a] !== !0) {
            r[a] = !0;
            const l = this.getFragment(a);
            l && (n.push(l), i.push(l.selectionSet));
          }
        }
      this._recursivelyReferencedFragments.set(t, n);
    }
    return n;
  }
}
class G2 extends B2 {
  constructor(t, n, r) {
    super(t, r), this._schema = n;
  }
  get [Symbol.toStringTag]() {
    return "SDLValidationContext";
  }
  getSchema() {
    return this._schema;
  }
}
function NE(e, t, n = V2) {
  const r = [], i = new G2(
    e,
    t,
    (o) => {
      r.push(o);
    }
  ), s = n.map((o) => o(i));
  return Qu(e, Fw(s)), r;
}
function z2(e) {
  const t = NE(e);
  if (t.length !== 0)
    throw new Error(t.map((n) => n.message).join(`

`));
}
function q2(e, t) {
  const n = NE(e, t);
  if (n.length !== 0)
    throw new Error(n.map((r) => r.message).join(`

`));
}
function H2(e, t, n) {
  Mh(e), t != null && t.kind === Q.DOCUMENT || it(!1, "Must provide valid Document AST."), n?.assumeValid !== !0 && n?.assumeValidSDL !== !0 && q2(t, e);
  const r = e.toConfig(), i = OE(r, t, n);
  return r === i ? e : new Gs(i);
}
function OE(e, t, n) {
  var r, i, s, o;
  const a = [], l = /* @__PURE__ */ Object.create(null), c = [];
  let u;
  const f = [];
  for (const M of t.definitions)
    if (M.kind === Q.SCHEMA_DEFINITION)
      u = M;
    else if (M.kind === Q.SCHEMA_EXTENSION)
      f.push(M);
    else if (Vs(M))
      a.push(M);
    else if (Ju(M)) {
      const N = M.name.value, T = l[N];
      l[N] = T ? T.concat([M]) : [M];
    } else
      M.kind === Q.DIRECTIVE_DEFINITION && c.push(M);
  if (Object.keys(l).length === 0 && a.length === 0 && c.length === 0 && f.length === 0 && u == null)
    return e;
  const d = /* @__PURE__ */ Object.create(null);
  for (const M of e.types)
    d[M.name] = E(M);
  for (const M of a) {
    var p;
    const N = M.name.value;
    d[N] = (p = Xg[N]) !== null && p !== void 0 ? p : B(M);
  }
  const h = {
    // Get the extended root operation types.
    query: e.query && v(e.query),
    mutation: e.mutation && v(e.mutation),
    subscription: e.subscription && v(e.subscription),
    // Then, incorporate schema definition and all schema extensions.
    ...u && le([u]),
    ...le(f)
  };
  return {
    description: (r = u) === null || r === void 0 || (i = r.description) === null || i === void 0 ? void 0 : i.value,
    ...h,
    types: Object.values(d),
    directives: [
      ...e.directives.map(b),
      ...c.map(z)
    ],
    extensions: /* @__PURE__ */ Object.create(null),
    astNode: (s = u) !== null && s !== void 0 ? s : e.astNode,
    extensionASTNodes: e.extensionASTNodes.concat(f),
    assumeValid: (o = n?.assumeValid) !== null && o !== void 0 ? o : !1
  };
  function m(M) {
    return Tt(M) ? new Kt(m(M.ofType)) : Qe(M) ? new Ye(m(M.ofType)) : v(M);
  }
  function v(M) {
    return d[M.name];
  }
  function b(M) {
    const N = M.toConfig();
    return new er({
      ...N,
      args: xr(N.args, ee)
    });
  }
  function E(M) {
    if (Bs(M) || Yu(M))
      return M;
    if (wn(M))
      return F(M);
    if (lt(M))
      return W(M);
    if (pt(M))
      return J(M);
    if (qt(M))
      return Z(M);
    if (Ft(M))
      return D(M);
    if (St(M))
      return y(M);
    Ht(!1, "Unexpected type: " + _e(M));
  }
  function y(M) {
    var N;
    const T = M.toConfig(), P = (N = l[T.name]) !== null && N !== void 0 ? N : [];
    return new Rs({
      ...T,
      fields: () => ({
        ...xr(T.fields, (k) => ({
          ...k,
          type: m(k.type)
        })),
        ...se(P)
      }),
      extensionASTNodes: T.extensionASTNodes.concat(P)
    });
  }
  function D(M) {
    var N;
    const T = M.toConfig(), P = (N = l[M.name]) !== null && N !== void 0 ? N : [];
    return new ui({
      ...T,
      values: { ...T.values, ...re(P) },
      extensionASTNodes: T.extensionASTNodes.concat(P)
    });
  }
  function F(M) {
    var N;
    const T = M.toConfig(), P = (N = l[T.name]) !== null && N !== void 0 ? N : [];
    let k = T.specifiedByURL;
    for (const Y of P) {
      var q;
      k = (q = Zg(Y)) !== null && q !== void 0 ? q : k;
    }
    return new wr({
      ...T,
      specifiedByURL: k,
      extensionASTNodes: T.extensionASTNodes.concat(P)
    });
  }
  function W(M) {
    var N;
    const T = M.toConfig(), P = (N = l[T.name]) !== null && N !== void 0 ? N : [];
    return new Dn({
      ...T,
      interfaces: () => [
        ...M.getInterfaces().map(v),
        ...ue(P)
      ],
      fields: () => ({
        ...xr(T.fields, j),
        ...ne(P)
      }),
      extensionASTNodes: T.extensionASTNodes.concat(P)
    });
  }
  function J(M) {
    var N;
    const T = M.toConfig(), P = (N = l[T.name]) !== null && N !== void 0 ? N : [];
    return new Os({
      ...T,
      interfaces: () => [
        ...M.getInterfaces().map(v),
        ...ue(P)
      ],
      fields: () => ({
        ...xr(T.fields, j),
        ...ne(P)
      }),
      extensionASTNodes: T.extensionASTNodes.concat(P)
    });
  }
  function Z(M) {
    var N;
    const T = M.toConfig(), P = (N = l[T.name]) !== null && N !== void 0 ? N : [];
    return new Is({
      ...T,
      types: () => [
        ...M.getTypes().map(v),
        ...te(P)
      ],
      extensionASTNodes: T.extensionASTNodes.concat(P)
    });
  }
  function j(M) {
    return {
      ...M,
      type: m(M.type),
      args: M.args && xr(M.args, ee)
    };
  }
  function ee(M) {
    return { ...M, type: m(M.type) };
  }
  function le(M) {
    const N = {};
    for (const P of M) {
      var T;
      const k = (
        /* c8 ignore next */
        (T = P.operationTypes) !== null && T !== void 0 ? T : []
      );
      for (const q of k)
        N[q.operation] = ce(q.type);
    }
    return N;
  }
  function ce(M) {
    var N;
    const T = M.name.value, P = (N = Xg[T]) !== null && N !== void 0 ? N : d[T];
    if (P === void 0)
      throw new Error(`Unknown type: "${T}".`);
    return P;
  }
  function U(M) {
    return M.kind === Q.LIST_TYPE ? new Kt(U(M.type)) : M.kind === Q.NON_NULL_TYPE ? new Ye(U(M.type)) : ce(M);
  }
  function z(M) {
    var N;
    return new er({
      name: M.name.value,
      description: (N = M.description) === null || N === void 0 ? void 0 : N.value,
      // @ts-expect-error
      locations: M.locations.map(({ value: T }) => T),
      isRepeatable: M.repeatable,
      args: K(M.arguments),
      astNode: M
    });
  }
  function ne(M) {
    const N = /* @__PURE__ */ Object.create(null);
    for (const k of M) {
      var T;
      const q = (
        /* c8 ignore next */
        (T = k.fields) !== null && T !== void 0 ? T : []
      );
      for (const Y of q) {
        var P;
        N[Y.name.value] = {
          // Note: While this could make assertions to get the correctly typed
          // value, that would throw immediately while type system validation
          // with validateSchema() will produce more actionable results.
          type: U(Y.type),
          description: (P = Y.description) === null || P === void 0 ? void 0 : P.value,
          args: K(Y.arguments),
          deprecationReason: sl(Y),
          astNode: Y
        };
      }
    }
    return N;
  }
  function K(M) {
    const N = (
      /* c8 ignore next */
      M ?? []
    ), T = /* @__PURE__ */ Object.create(null);
    for (const k of N) {
      var P;
      const q = U(k.type);
      T[k.name.value] = {
        type: q,
        description: (P = k.description) === null || P === void 0 ? void 0 : P.value,
        defaultValue: hr(k.defaultValue, q),
        deprecationReason: sl(k),
        astNode: k
      };
    }
    return T;
  }
  function se(M) {
    const N = /* @__PURE__ */ Object.create(null);
    for (const k of M) {
      var T;
      const q = (
        /* c8 ignore next */
        (T = k.fields) !== null && T !== void 0 ? T : []
      );
      for (const Y of q) {
        var P;
        const ve = U(Y.type);
        N[Y.name.value] = {
          type: ve,
          description: (P = Y.description) === null || P === void 0 ? void 0 : P.value,
          defaultValue: hr(Y.defaultValue, ve),
          deprecationReason: sl(Y),
          astNode: Y
        };
      }
    }
    return N;
  }
  function re(M) {
    const N = /* @__PURE__ */ Object.create(null);
    for (const k of M) {
      var T;
      const q = (
        /* c8 ignore next */
        (T = k.values) !== null && T !== void 0 ? T : []
      );
      for (const Y of q) {
        var P;
        N[Y.name.value] = {
          description: (P = Y.description) === null || P === void 0 ? void 0 : P.value,
          deprecationReason: sl(Y),
          astNode: Y
        };
      }
    }
    return N;
  }
  function ue(M) {
    return M.flatMap(
      // FIXME: https://github.com/graphql/graphql-js/issues/2203
      (N) => {
        var T, P;
        return (
          /* c8 ignore next */
          (T = (P = N.interfaces) === null || P === void 0 ? void 0 : P.map(ce)) !== null && T !== void 0 ? T : []
        );
      }
    );
  }
  function te(M) {
    return M.flatMap(
      // FIXME: https://github.com/graphql/graphql-js/issues/2203
      (N) => {
        var T, P;
        return (
          /* c8 ignore next */
          (T = (P = N.types) === null || P === void 0 ? void 0 : P.map(ce)) !== null && T !== void 0 ? T : []
        );
      }
    );
  }
  function B(M) {
    var N;
    const T = M.name.value, P = (N = l[T]) !== null && N !== void 0 ? N : [];
    switch (M.kind) {
      case Q.OBJECT_TYPE_DEFINITION: {
        var k;
        const $ = [M, ...P];
        return new Dn({
          name: T,
          description: (k = M.description) === null || k === void 0 ? void 0 : k.value,
          interfaces: () => ue($),
          fields: () => ne($),
          astNode: M,
          extensionASTNodes: P
        });
      }
      case Q.INTERFACE_TYPE_DEFINITION: {
        var q;
        const $ = [M, ...P];
        return new Os({
          name: T,
          description: (q = M.description) === null || q === void 0 ? void 0 : q.value,
          interfaces: () => ue($),
          fields: () => ne($),
          astNode: M,
          extensionASTNodes: P
        });
      }
      case Q.ENUM_TYPE_DEFINITION: {
        var Y;
        const $ = [M, ...P];
        return new ui({
          name: T,
          description: (Y = M.description) === null || Y === void 0 ? void 0 : Y.value,
          values: re($),
          astNode: M,
          extensionASTNodes: P
        });
      }
      case Q.UNION_TYPE_DEFINITION: {
        var ve;
        const $ = [M, ...P];
        return new Is({
          name: T,
          description: (ve = M.description) === null || ve === void 0 ? void 0 : ve.value,
          types: () => te($),
          astNode: M,
          extensionASTNodes: P
        });
      }
      case Q.SCALAR_TYPE_DEFINITION: {
        var oe;
        return new wr({
          name: T,
          description: (oe = M.description) === null || oe === void 0 ? void 0 : oe.value,
          specifiedByURL: Zg(M),
          astNode: M,
          extensionASTNodes: P
        });
      }
      case Q.INPUT_OBJECT_TYPE_DEFINITION: {
        var S;
        const $ = [M, ...P];
        return new Rs({
          name: T,
          description: (S = M.description) === null || S === void 0 ? void 0 : S.value,
          fields: () => se($),
          astNode: M,
          extensionASTNodes: P,
          isOneOf: W2(M)
        });
      }
    }
  }
}
const Xg = zr(
  [...$a, ...Ia],
  (e) => e.name
);
function sl(e) {
  const t = na(Zu, e);
  return t?.reason;
}
function Zg(e) {
  const t = na(Rh, e);
  return t?.url;
}
function W2(e) {
  return !!na(Ah, e);
}
function IE(e, t) {
  e != null && e.kind === Q.DOCUMENT || it(!1, "Must provide valid Document AST."), t?.assumeValid !== !0 && t?.assumeValidSDL !== !0 && z2(e);
  const r = OE({
    description: void 0,
    types: [],
    directives: [],
    extensions: /* @__PURE__ */ Object.create(null),
    extensionASTNodes: [],
    assumeValid: !1
  }, e, t);
  if (r.astNode == null)
    for (const s of r.types)
      switch (s.name) {
        case "Query":
          r.query = s;
          break;
        case "Mutation":
          r.mutation = s;
          break;
        case "Subscription":
          r.subscription = s;
          break;
      }
  const i = [
    ...r.directives,
    // If specified directives were not explicitly declared, add them.
    ...hi.filter(
      (s) => r.directives.every(
        (o) => o.name !== s.name
      )
    )
  ];
  return new Gs({ ...r, directives: i });
}
function Q2(e, t) {
  const n = gh(e, {
    noLocation: t?.noLocation,
    allowLegacyFragmentVariables: t?.allowLegacyFragmentVariables
  });
  return IE(n, {
    assumeValidSDL: t?.assumeValidSDL,
    assumeValid: t?.assumeValid
  });
}
function J2(e) {
  const t = e.toConfig(), n = ni(
    xf(t.types),
    (d) => d.name,
    f
  );
  return new Gs({
    ...t,
    types: Object.values(n),
    directives: xf(t.directives).map(o),
    query: s(t.query),
    mutation: s(t.mutation),
    subscription: s(t.subscription)
  });
  function r(d) {
    return Tt(d) ? new Kt(r(d.ofType)) : Qe(d) ? new Ye(r(d.ofType)) : i(d);
  }
  function i(d) {
    return n[d.name];
  }
  function s(d) {
    return d && i(d);
  }
  function o(d) {
    const p = d.toConfig();
    return new er({
      ...p,
      locations: RE(p.locations, (h) => h),
      args: a(p.args)
    });
  }
  function a(d) {
    return ol(d, (p) => ({ ...p, type: r(p.type) }));
  }
  function l(d) {
    return ol(d, (p) => ({
      ...p,
      type: r(p.type),
      args: p.args && a(p.args)
    }));
  }
  function c(d) {
    return ol(d, (p) => ({
      ...p,
      type: r(p.type)
    }));
  }
  function u(d) {
    return xf(d).map(i);
  }
  function f(d) {
    if (wn(d) || Bs(d))
      return d;
    if (lt(d)) {
      const p = d.toConfig();
      return new Dn({
        ...p,
        interfaces: () => u(p.interfaces),
        fields: () => l(p.fields)
      });
    }
    if (pt(d)) {
      const p = d.toConfig();
      return new Os({
        ...p,
        interfaces: () => u(p.interfaces),
        fields: () => l(p.fields)
      });
    }
    if (qt(d)) {
      const p = d.toConfig();
      return new Is({
        ...p,
        types: () => u(p.types)
      });
    }
    if (Ft(d)) {
      const p = d.toConfig();
      return new ui({
        ...p,
        values: ol(p.values, (h) => h)
      });
    }
    if (St(d)) {
      const p = d.toConfig();
      return new Rs({
        ...p,
        fields: () => c(p.fields)
      });
    }
    Ht(!1, "Unexpected type: " + _e(d));
  }
}
function ol(e, t) {
  const n = /* @__PURE__ */ Object.create(null);
  for (const r of Object.keys(e).sort(wa))
    n[r] = t(e[r]);
  return n;
}
function xf(e) {
  return RE(e, (t) => t.name);
}
function RE(e, t) {
  return e.slice().sort((n, r) => {
    const i = t(n), s = t(r);
    return wa(i, s);
  });
}
function K2(e) {
  return AE(
    e,
    (t) => !xh(t),
    X2
  );
}
function Y2(e) {
  return AE(e, xh, Bs);
}
function X2(e) {
  return !Yu(e) && !Bs(e);
}
function AE(e, t, n) {
  const r = e.getDirectives().filter(t), i = Object.values(e.getTypeMap()).filter(n);
  return [
    Z2(e),
    ...r.map((s) => aU(s)),
    ...i.map((s) => xE(s))
  ].filter(Boolean).join(`

`);
}
function Z2(e) {
  if (e.description == null && eU(e))
    return;
  const t = [], n = e.getQueryType();
  n && t.push(`  query: ${n.name}`);
  const r = e.getMutationType();
  r && t.push(`  mutation: ${r.name}`);
  const i = e.getSubscriptionType();
  return i && t.push(`  subscription: ${i.name}`), kn(e) + `schema {
${t.join(`
`)}
}`;
}
function eU(e) {
  const t = e.getQueryType();
  if (t && t.name !== "Query")
    return !1;
  const n = e.getMutationType();
  if (n && n.name !== "Mutation")
    return !1;
  const r = e.getSubscriptionType();
  return !(r && r.name !== "Subscription");
}
function xE(e) {
  if (wn(e))
    return tU(e);
  if (lt(e))
    return nU(e);
  if (pt(e))
    return rU(e);
  if (qt(e))
    return iU(e);
  if (Ft(e))
    return sU(e);
  if (St(e))
    return oU(e);
  Ht(!1, "Unexpected type: " + _e(e));
}
function tU(e) {
  return kn(e) + `scalar ${e.name}` + lU(e);
}
function DE(e) {
  const t = e.getInterfaces();
  return t.length ? " implements " + t.map((n) => n.name).join(" & ") : "";
}
function nU(e) {
  return kn(e) + `type ${e.name}` + DE(e) + PE(e);
}
function rU(e) {
  return kn(e) + `interface ${e.name}` + DE(e) + PE(e);
}
function iU(e) {
  const t = e.getTypes(), n = t.length ? " = " + t.join(" | ") : "";
  return kn(e) + "union " + e.name + n;
}
function sU(e) {
  const t = e.getValues().map(
    (n, r) => kn(n, "  ", !r) + "  " + n.name + Gh(n.deprecationReason)
  );
  return kn(e) + `enum ${e.name}` + Bh(t);
}
function oU(e) {
  const t = Object.values(e.getFields()).map(
    (n, r) => kn(n, "  ", !r) + "  " + Td(n)
  );
  return kn(e) + `input ${e.name}` + (e.isOneOf ? " @oneOf" : "") + Bh(t);
}
function PE(e) {
  const t = Object.values(e.getFields()).map(
    (n, r) => kn(n, "  ", !r) + "  " + n.name + kE(n.args, "  ") + ": " + String(n.type) + Gh(n.deprecationReason)
  );
  return Bh(t);
}
function Bh(e) {
  return e.length !== 0 ? ` {
` + e.join(`
`) + `
}` : "";
}
function kE(e, t = "") {
  return e.length === 0 ? "" : e.every((n) => !n.description) ? "(" + e.map(Td).join(", ") + ")" : `(
` + e.map(
    (n, r) => kn(n, "  " + t, !r) + "  " + t + Td(n)
  ).join(`
`) + `
` + t + ")";
}
function Td(e) {
  const t = ri(e.defaultValue, e.type);
  let n = e.name + ": " + String(e.type);
  return t && (n += ` = ${Et(t)}`), n + Gh(e.deprecationReason);
}
function aU(e) {
  return kn(e) + "directive @" + e.name + kE(e.args) + (e.isRepeatable ? " repeatable" : "") + " on " + e.locations.join(" | ");
}
function Gh(e) {
  return e == null ? "" : e !== Ih ? ` @deprecated(reason: ${Et({
    kind: Q.STRING,
    value: e
  })})` : " @deprecated";
}
function lU(e) {
  return e.specifiedByURL == null ? "" : ` @specifiedBy(url: ${Et({
    kind: Q.STRING,
    value: e.specifiedByURL
  })})`;
}
function kn(e, t = "", n = !0) {
  const { description: r } = e;
  if (r == null)
    return "";
  const i = Et({
    kind: Q.STRING,
    value: r,
    block: mM(r)
  });
  return (t && !n ? `
` + t : t) + i.replace(/\n/g, `
` + t) + `
`;
}
function uU(e) {
  const t = [];
  for (const n of e)
    t.push(...n.definitions);
  return {
    kind: Q.DOCUMENT,
    definitions: t
  };
}
function cU(e) {
  const t = [], n = /* @__PURE__ */ Object.create(null);
  for (const i of e.definitions)
    switch (i.kind) {
      case Q.OPERATION_DEFINITION:
        t.push(i);
        break;
      case Q.FRAGMENT_DEFINITION:
        n[i.name.value] = e0(
          i.selectionSet
        );
        break;
    }
  const r = /* @__PURE__ */ Object.create(null);
  for (const i of t) {
    const s = /* @__PURE__ */ new Set();
    for (const a of e0(i.selectionSet))
      LE(s, n, a);
    const o = i.name ? i.name.value : "";
    r[o] = {
      kind: Q.DOCUMENT,
      definitions: e.definitions.filter(
        (a) => a === i || a.kind === Q.FRAGMENT_DEFINITION && s.has(a.name.value)
      )
    };
  }
  return r;
}
function LE(e, t, n) {
  if (!e.has(n)) {
    e.add(n);
    const r = t[n];
    if (r !== void 0)
      for (const i of r)
        LE(e, t, i);
  }
}
function e0(e) {
  const t = [];
  return Qu(e, {
    FragmentSpread(n) {
      t.push(n.name.value);
    }
  }), t;
}
function fU(e) {
  const t = Nw(e) ? e : new qu(e), n = t.body, r = new yh(t);
  let i = "", s = !1;
  for (; r.advance().kind !== be.EOF; ) {
    const o = r.token, a = o.kind, l = !kw(o.kind);
    s && (l || o.kind === be.SPREAD) && (i += " ");
    const c = n.slice(o.start, o.end);
    a === be.BLOCK_STRING ? i += Pw(o.value, {
      minimize: !0
    }) : i += c, s = l;
  }
  return i;
}
function dU(e) {
  const t = jE(e);
  if (t)
    throw t;
  return e;
}
function jE(e) {
  if (typeof e == "string" || it(!1, "Expected name to be a string."), e.startsWith("__"))
    return new ge(
      `Name "${e}" must not begin with "__", which is reserved by GraphQL introspection.`
    );
  try {
    _n(e);
  } catch (t) {
    return t;
  }
}
var xt;
(function(e) {
  e.TYPE_REMOVED = "TYPE_REMOVED", e.TYPE_CHANGED_KIND = "TYPE_CHANGED_KIND", e.TYPE_REMOVED_FROM_UNION = "TYPE_REMOVED_FROM_UNION", e.VALUE_REMOVED_FROM_ENUM = "VALUE_REMOVED_FROM_ENUM", e.REQUIRED_INPUT_FIELD_ADDED = "REQUIRED_INPUT_FIELD_ADDED", e.IMPLEMENTED_INTERFACE_REMOVED = "IMPLEMENTED_INTERFACE_REMOVED", e.FIELD_REMOVED = "FIELD_REMOVED", e.FIELD_CHANGED_KIND = "FIELD_CHANGED_KIND", e.REQUIRED_ARG_ADDED = "REQUIRED_ARG_ADDED", e.ARG_REMOVED = "ARG_REMOVED", e.ARG_CHANGED_KIND = "ARG_CHANGED_KIND", e.DIRECTIVE_REMOVED = "DIRECTIVE_REMOVED", e.DIRECTIVE_ARG_REMOVED = "DIRECTIVE_ARG_REMOVED", e.REQUIRED_DIRECTIVE_ARG_ADDED = "REQUIRED_DIRECTIVE_ARG_ADDED", e.DIRECTIVE_REPEATABLE_REMOVED = "DIRECTIVE_REPEATABLE_REMOVED", e.DIRECTIVE_LOCATION_REMOVED = "DIRECTIVE_LOCATION_REMOVED";
})(xt || (xt = {}));
var Yn;
(function(e) {
  e.VALUE_ADDED_TO_ENUM = "VALUE_ADDED_TO_ENUM", e.TYPE_ADDED_TO_UNION = "TYPE_ADDED_TO_UNION", e.OPTIONAL_INPUT_FIELD_ADDED = "OPTIONAL_INPUT_FIELD_ADDED", e.OPTIONAL_ARG_ADDED = "OPTIONAL_ARG_ADDED", e.IMPLEMENTED_INTERFACE_ADDED = "IMPLEMENTED_INTERFACE_ADDED", e.ARG_DEFAULT_VALUE_CHANGE = "ARG_DEFAULT_VALUE_CHANGE";
})(Yn || (Yn = {}));
function pU(e, t) {
  return CE(e, t).filter(
    (n) => n.type in xt
  );
}
function hU(e, t) {
  return CE(e, t).filter(
    (n) => n.type in Yn
  );
}
function CE(e, t) {
  return [
    ...yU(e, t),
    ...mU(e, t)
  ];
}
function mU(e, t) {
  const n = [], r = qr(
    e.getDirectives(),
    t.getDirectives()
  );
  for (const i of r.removed)
    n.push({
      type: xt.DIRECTIVE_REMOVED,
      description: `${i.name} was removed.`
    });
  for (const [i, s] of r.persisted) {
    const o = qr(i.args, s.args);
    for (const a of o.added)
      pi(a) && n.push({
        type: xt.REQUIRED_DIRECTIVE_ARG_ADDED,
        description: `A required arg ${a.name} on directive ${i.name} was added.`
      });
    for (const a of o.removed)
      n.push({
        type: xt.DIRECTIVE_ARG_REMOVED,
        description: `${a.name} was removed from ${i.name}.`
      });
    i.isRepeatable && !s.isRepeatable && n.push({
      type: xt.DIRECTIVE_REPEATABLE_REMOVED,
      description: `Repeatable flag was removed from ${i.name}.`
    });
    for (const a of i.locations)
      s.locations.includes(a) || n.push({
        type: xt.DIRECTIVE_LOCATION_REMOVED,
        description: `${a} was removed from ${i.name}.`
      });
  }
  return n;
}
function yU(e, t) {
  const n = [], r = qr(
    Object.values(e.getTypeMap()),
    Object.values(t.getTypeMap())
  );
  for (const i of r.removed)
    n.push({
      type: xt.TYPE_REMOVED,
      description: Yu(i) ? `Standard scalar ${i.name} was removed because it is not referenced anymore.` : `${i.name} was removed.`
    });
  for (const [i, s] of r.persisted)
    Ft(i) && Ft(s) ? n.push(...vU(i, s)) : qt(i) && qt(s) ? n.push(...bU(i, s)) : St(i) && St(s) ? n.push(...gU(i, s)) : lt(i) && lt(s) ? n.push(
      ...n0(i, s),
      ...t0(i, s)
    ) : pt(i) && pt(s) ? n.push(
      ...n0(i, s),
      ...t0(i, s)
    ) : i.constructor !== s.constructor && n.push({
      type: xt.TYPE_CHANGED_KIND,
      description: `${i.name} changed from ${r0(i)} to ${r0(s)}.`
    });
  return n;
}
function gU(e, t) {
  const n = [], r = qr(
    Object.values(e.getFields()),
    Object.values(t.getFields())
  );
  for (const i of r.added)
    Ku(i) ? n.push({
      type: xt.REQUIRED_INPUT_FIELD_ADDED,
      description: `A required field ${i.name} on input type ${e.name} was added.`
    }) : n.push({
      type: Yn.OPTIONAL_INPUT_FIELD_ADDED,
      description: `An optional field ${i.name} on input type ${e.name} was added.`
    });
  for (const i of r.removed)
    n.push({
      type: xt.FIELD_REMOVED,
      description: `${e.name}.${i.name} was removed.`
    });
  for (const [i, s] of r.persisted)
    Fo(
      i.type,
      s.type
    ) || n.push({
      type: xt.FIELD_CHANGED_KIND,
      description: `${e.name}.${i.name} changed type from ${String(i.type)} to ${String(s.type)}.`
    });
  return n;
}
function bU(e, t) {
  const n = [], r = qr(e.getTypes(), t.getTypes());
  for (const i of r.added)
    n.push({
      type: Yn.TYPE_ADDED_TO_UNION,
      description: `${i.name} was added to union type ${e.name}.`
    });
  for (const i of r.removed)
    n.push({
      type: xt.TYPE_REMOVED_FROM_UNION,
      description: `${i.name} was removed from union type ${e.name}.`
    });
  return n;
}
function vU(e, t) {
  const n = [], r = qr(e.getValues(), t.getValues());
  for (const i of r.added)
    n.push({
      type: Yn.VALUE_ADDED_TO_ENUM,
      description: `${i.name} was added to enum type ${e.name}.`
    });
  for (const i of r.removed)
    n.push({
      type: xt.VALUE_REMOVED_FROM_ENUM,
      description: `${i.name} was removed from enum type ${e.name}.`
    });
  return n;
}
function t0(e, t) {
  const n = [], r = qr(e.getInterfaces(), t.getInterfaces());
  for (const i of r.added)
    n.push({
      type: Yn.IMPLEMENTED_INTERFACE_ADDED,
      description: `${i.name} added to interfaces implemented by ${e.name}.`
    });
  for (const i of r.removed)
    n.push({
      type: xt.IMPLEMENTED_INTERFACE_REMOVED,
      description: `${e.name} no longer implements interface ${i.name}.`
    });
  return n;
}
function n0(e, t) {
  const n = [], r = qr(
    Object.values(e.getFields()),
    Object.values(t.getFields())
  );
  for (const i of r.removed)
    n.push({
      type: xt.FIELD_REMOVED,
      description: `${e.name}.${i.name} was removed.`
    });
  for (const [i, s] of r.persisted)
    n.push(..._U(e, i, s)), Ao(
      i.type,
      s.type
    ) || n.push({
      type: xt.FIELD_CHANGED_KIND,
      description: `${e.name}.${i.name} changed type from ${String(i.type)} to ${String(s.type)}.`
    });
  return n;
}
function _U(e, t, n) {
  const r = [], i = qr(t.args, n.args);
  for (const s of i.removed)
    r.push({
      type: xt.ARG_REMOVED,
      description: `${e.name}.${t.name} arg ${s.name} was removed.`
    });
  for (const [s, o] of i.persisted)
    if (!Fo(
      s.type,
      o.type
    ))
      r.push({
        type: xt.ARG_CHANGED_KIND,
        description: `${e.name}.${t.name} arg ${s.name} has changed type from ${String(s.type)} to ${String(o.type)}.`
      });
    else if (s.defaultValue !== void 0)
      if (o.defaultValue === void 0)
        r.push({
          type: Yn.ARG_DEFAULT_VALUE_CHANGE,
          description: `${e.name}.${t.name} arg ${s.name} defaultValue was removed.`
        });
      else {
        const l = i0(s.defaultValue, s.type), c = i0(o.defaultValue, o.type);
        l !== c && r.push({
          type: Yn.ARG_DEFAULT_VALUE_CHANGE,
          description: `${e.name}.${t.name} arg ${s.name} has changed defaultValue from ${l} to ${c}.`
        });
      }
  for (const s of i.added)
    pi(s) ? r.push({
      type: xt.REQUIRED_ARG_ADDED,
      description: `A required arg ${s.name} on ${e.name}.${t.name} was added.`
    }) : r.push({
      type: Yn.OPTIONAL_ARG_ADDED,
      description: `An optional arg ${s.name} on ${e.name}.${t.name} was added.`
    });
  return r;
}
function Ao(e, t) {
  return Tt(e) ? (
    // if they're both lists, make sure the underlying types are compatible
    Tt(t) && Ao(
      e.ofType,
      t.ofType
    ) || // moving from nullable to non-null of the same underlying type is safe
    Qe(t) && Ao(e, t.ofType)
  ) : Qe(e) ? Qe(t) && Ao(e.ofType, t.ofType) : (
    // if they're both named types, see if their names are equivalent
    Ta(t) && e.name === t.name || // moving from nullable to non-null of the same underlying type is safe
    Qe(t) && Ao(e, t.ofType)
  );
}
function Fo(e, t) {
  return Tt(e) ? Tt(t) && Fo(e.ofType, t.ofType) : Qe(e) ? (
    // if they're both non-null, make sure the underlying types are
    // compatible
    Qe(t) && Fo(
      e.ofType,
      t.ofType
    ) || // moving from non-null to nullable of the same underlying type is safe
    !Qe(t) && Fo(e.ofType, t)
  ) : Ta(t) && e.name === t.name;
}
function r0(e) {
  if (wn(e))
    return "a Scalar type";
  if (lt(e))
    return "an Object type";
  if (pt(e))
    return "an Interface type";
  if (qt(e))
    return "a Union type";
  if (Ft(e))
    return "an Enum type";
  if (St(e))
    return "an Input type";
  Ht(!1, "Unexpected type: " + _e(e));
}
function i0(e, t) {
  const n = ri(e, t);
  return n != null || Ht(!1), Et(nc(n));
}
function qr(e, t) {
  const n = [], r = [], i = [], s = zr(e, ({ name: a }) => a), o = zr(t, ({ name: a }) => a);
  for (const a of e) {
    const l = o[a.name];
    l === void 0 ? r.push(a) : i.push([a, l]);
  }
  for (const a of t)
    s[a.name] === void 0 && n.push(a);
  return {
    added: n,
    persisted: i,
    removed: r
  };
}
const wU = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get BreakingChangeType() {
    return xt;
  },
  get DangerousChangeType() {
    return Yn;
  },
  TypeInfo: UF,
  assertValidName: dU,
  astFromValue: ri,
  buildASTSchema: IE,
  buildClientSchema: FF,
  buildSchema: Q2,
  coerceInputValue: iE,
  concatAST: uU,
  doTypesOverlap: vd,
  extendSchema: H2,
  findBreakingChanges: pU,
  findDangerousChanges: hU,
  getIntrospectionQuery: nE,
  getOperationAST: EF,
  getOperationRootType: SF,
  introspectionFromSchema: MF,
  isEqualType: Kl,
  isTypeSubTypeOf: Mi,
  isValidNameError: jE,
  lexicographicSortSchema: J2,
  printIntrospectionSchema: Y2,
  printSchema: K2,
  printType: xE,
  separateOperations: cU,
  stripIgnoredCharacters: fU,
  typeFromAST: pn,
  valueFromAST: hr,
  valueFromASTUntyped: Jl,
  visitWithTypeInfo: BF
}, Symbol.toStringTag, { value: "Module" })), EU = /* @__PURE__ */ Hi(wU), ME = /* @__PURE__ */ Hi(CF);
var SU = We && We.__createBinding || (Object.create ? function(e, t, n, r) {
  r === void 0 && (r = n), Object.defineProperty(e, r, { enumerable: !0, get: function() {
    return t[n];
  } });
} : function(e, t, n, r) {
  r === void 0 && (r = n), e[r] = t[n];
}), TU = We && We.__setModuleDefault || (Object.create ? function(e, t) {
  Object.defineProperty(e, "default", { enumerable: !0, value: t });
} : function(e, t) {
  e.default = t;
}), zh = We && We.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var t = {};
  if (e != null)
    for (var n in e)
      n !== "default" && Object.prototype.hasOwnProperty.call(e, n) && SU(t, e, n);
  return TU(t, e), t;
};
Object.defineProperty(bn, "__esModule", { value: !0 });
bn.resolveFieldDef = bn.getGraphQLErrorOptions = bn.formatError = bn.getOperationRootType = void 0;
const ia = Ln, $U = zh(wF), NU = zh(EU), s0 = zh(ME);
function OU(e, t) {
  if (ia.versionInfo.major < 16)
    return NU.getOperationRootType(e, t);
  const n = e.getRootType(t.operation);
  if (!n)
    throw new Error(`No root type for operation ${t.operation}`);
  return n;
}
bn.getOperationRootType = OU;
function IU(e) {
  return ia.versionInfo.major < 16 ? $U.formatError(e) : e.toJSON();
}
bn.formatError = IU;
function RU(e) {
  return ia.versionInfo.major < 16 ? e : { nodes: e };
}
bn.getGraphQLErrorOptions = RU;
function AU(e, t, n) {
  const r = n[0];
  if (ia.versionInfo.major < 16) {
    const i = r.name.value;
    return s0.getFieldDef(e.schema, t, i);
  }
  return ia.versionInfo.major < 17 ? s0.getFieldDef(e.schema, t, r) : e.schema.getField(t, r.name.value);
}
bn.resolveFieldDef = AU;
var o0;
function rc() {
  return o0 || (o0 = 1, function(e) {
    var t = We && We.__importDefault || function(K) {
      return K && K.__esModule ? K : { default: K };
    };
    Object.defineProperty(e, "__esModule", { value: !0 }), e.joinSkipIncludePath = e.serializeObjectPathForSkipInclude = e.flattenPath = e.addPath = e.computeLocations = e.valueFromAST = e.getArgumentDefs = e.collectSubfields = e.resolveFieldDef = e.collectFields = void 0;
    const n = t(Gu), r = Ln, i = MM, s = tE, o = KE(), a = t(tc), l = bn;
    Object.defineProperty(e, "resolveFieldDef", { enumerable: !0, get: function() {
      return l.resolveFieldDef;
    } });
    const c = (0, a.default)();
    function u(K, se, re, ue, te, B) {
      return f(K, se, re, ue, te, void 0, U(B));
    }
    e.collectFields = u;
    function f(K, se, re, ue, te, B = "", M = "") {
      for (const N of re.selections)
        switch (N.kind) {
          case i.Kind.FIELD: {
            const T = D(N);
            ue[T] || (ue[T] = []);
            const P = N, k = z(
              M,
              // use alias(instead of selection.name.value) if available as the responsePath used for lookup uses alias
              T
            ), q = h(K, N);
            K.options.useExperimentalPathBasedSkipInclude ? (P.__internalShouldIncludePath || (P.__internalShouldIncludePath = {}), P.__internalShouldIncludePath[k] = p(P.__internalShouldIncludePath?.[k] ?? "", B, q)) : P.__internalShouldInclude = p(P.__internalShouldInclude ?? "", B, q), d(K, P, k), ue[T].push(P);
            break;
          }
          case i.Kind.INLINE_FRAGMENT: {
            if (!y(K, N, se))
              continue;
            const T = h(K, N);
            f(K, se, N.selectionSet, ue, te, p(
              // `should include`s from previous fragments
              B,
              // current fragment's shouldInclude
              T
            ), M);
            break;
          }
          case i.Kind.FRAGMENT_SPREAD: {
            const T = N.name.value;
            if (te[T])
              continue;
            te[T] = !0;
            const P = K.fragments[T];
            if (!P || !y(K, P, se))
              continue;
            const k = h(K, N);
            f(K, se, P.selectionSet, ue, te, p(
              // `should include`s from previous fragments
              B,
              // current fragment's shouldInclude
              k
            ), M);
            break;
          }
        }
      return ue;
    }
    function d(K, se, re) {
      for (const te of se.selectionSet?.selections ?? [])
        ue(se, te, !1, re);
      function ue(te, B, M = !1, N) {
        switch (B.kind) {
          case i.Kind.FIELD: {
            const T = B, P = z(
              N,
              // use alias(instead of selection.name.value) if available as the responsePath used for lookup uses alias
              D(T)
            );
            M || (K.options.useExperimentalPathBasedSkipInclude ? (T.__internalShouldIncludePath || (T.__internalShouldIncludePath = {}), T.__internalShouldIncludePath[P] = p(te.__internalShouldIncludePath?.[N] ?? "", T.__internalShouldIncludePath?.[P] ?? "")) : T.__internalShouldInclude = p(te.__internalShouldInclude ?? "", T.__internalShouldInclude ?? ""));
            for (const k of T.selectionSet?.selections ?? [])
              ue(T, k, !1, P);
            break;
          }
          case i.Kind.INLINE_FRAGMENT: {
            for (const T of B.selectionSet.selections)
              ue(te, T, !0, N);
            break;
          }
          case i.Kind.FRAGMENT_SPREAD: {
            const T = K.fragments[B.name.value];
            for (const P of T.selectionSet.selections)
              ue(te, P, !0, N);
          }
        }
      }
    }
    function p(...K) {
      let se = K.filter((re) => re);
      return se = [].concat(...se.map((re) => re.split(" && ").map((ue) => ue.trim()))), se = Array.from(new Set(se)), se.join(" && ");
    }
    function h(K, se) {
      const re = (0, n.default)(), { skipValue: ue, includeValue: te } = m(K, se);
      return ue != null && te != null ? re(`${ue} === false && ${te} === true`) : ue != null ? re(`(${ue} === false)`) : te != null ? re(`(${te} === true)`) : re("true"), re.toString();
    }
    function m(K, se) {
      const re = se.directives?.find((M) => M.name.value === r.GraphQLSkipDirective.name), ue = se.directives?.find((M) => M.name.value === r.GraphQLIncludeDirective.name), te = re ? v(K, re) : (
        // The null here indicates the absense of the directive
        // which is later used to determine if both skip and include
        // are present
        null
      ), B = ue ? v(K, ue) : (
        // The null here indicates the absense of the directive
        // which is later used to determine if both skip and include
        // are present
        null
      );
      return { skipValue: te, includeValue: B };
    }
    function v(K, se) {
      const re = se.arguments?.find((ue) => ue.name.value === "if");
      if (re == null)
        throw new r.GraphQLError(`Directive '${se.name.value}' is missing required arguments: 'if'`, (0, l.getGraphQLErrorOptions)([se]));
      switch (re.value.kind) {
        case i.Kind.VARIABLE:
          return b(K, re.value), `${o.GLOBAL_VARIABLES_NAME}["${re.value.name.value}"]`;
        case i.Kind.BOOLEAN:
          return `${re.value.value.toString()}`;
        default:
          throw new r.GraphQLError(`Argument 'if' on Directive '${se.name.value}' has an invalid value (${(0, r.valueFromASTUntyped)(re.value)}). Expected type 'Boolean!'`, (0, l.getGraphQLErrorOptions)([re]));
      }
    }
    function b(K, se) {
      const re = K.operation.variableDefinitions?.find((ue) => ue.variable.name.value === se.name.value);
      if (re == null)
        throw new r.GraphQLError(`Variable '${se.name.value}' is not defined`, (0, l.getGraphQLErrorOptions)([se]));
      if (!// The variable defintion is a Non-nullable Boolean type
      (re.type.kind === i.Kind.NON_NULL_TYPE && re.type.type.kind === i.Kind.NAMED_TYPE && re.type.type.name.value === "Boolean" || // or the variable definition is a nullable Boolean type with a default value
      re.type.kind === i.Kind.NAMED_TYPE && re.type.name.value === "Boolean" && re.defaultValue != null))
        throw new r.GraphQLError(`Variable '${se.name.value}' of type '${E(re.type)}' used in position expecting type 'Boolean!'`, (0, l.getGraphQLErrorOptions)([re]));
    }
    function E(K) {
      switch (K.kind) {
        case i.Kind.NAMED_TYPE:
          return K.name.value;
        case i.Kind.NON_NULL_TYPE:
          return `${E(K.type)}!`;
        case i.Kind.LIST_TYPE:
          return `[${E(K.type)}]`;
      }
    }
    function y(K, se, re) {
      const ue = se.typeCondition;
      if (!ue)
        return !0;
      const te = (0, r.typeFromAST)(K.schema, ue);
      return te === re ? !0 : te && (0, s.isAbstractType)(te) ? K.schema.isSubType(te, re) : !1;
    }
    function D(K) {
      return K.alias ? K.alias.value : K.name.value;
    }
    function F(K, se, re, ue) {
      let te = /* @__PURE__ */ Object.create(null);
      const B = /* @__PURE__ */ Object.create(null);
      for (const M of re) {
        const N = M.selectionSet;
        N && (te = u(K, se, N, te, B, ue));
      }
      return te;
    }
    e.collectSubfields = F;
    function W(K, se) {
      const re = {}, ue = [], te = K.args, B = se.arguments || [], M = j(B, (N) => N.name.value);
      for (const N of te) {
        const T = N.name;
        N.defaultValue !== void 0 && (re[T] = N.defaultValue);
        const P = N.type, k = M[T];
        let q = !1;
        if (k && k.value.kind === i.Kind.VARIABLE)
          q = !0, ue.push({
            valueNode: k.value,
            path: le(void 0, T, "literal"),
            argument: { definition: N, node: k }
          });
        else if (k) {
          const Y = Z(k.value, P);
          if (Y === void 0)
            throw new r.GraphQLError(`Argument "${T}" of type "${P}" has invalid value ${(0, r.print)(k.value)}.`, (0, l.getGraphQLErrorOptions)(k.value));
          J(Y) && ue.push(...Y.variables.map(({ valueNode: ve, path: oe }) => ({
            valueNode: ve,
            path: le(oe, T, "literal")
          }))), re[T] = Y.value;
        }
        if ((0, r.isNonNullType)(P) && re[T] === void 0 && !q)
          throw new r.GraphQLError(k ? `Argument "${T}" of non-null type "${P}" must not be null.` : `Argument "${T}" of required type "${P}" was not provided.`, (0, l.getGraphQLErrorOptions)(se));
      }
      return { values: re, missing: ue };
    }
    e.getArgumentDefs = W;
    function J(K) {
      return !!K.variables;
    }
    function Z(K, se) {
      if ((0, r.isNonNullType)(se))
        return K.kind === i.Kind.NULL ? void 0 : Z(K, se.ofType);
      if (K.kind === i.Kind.NULL)
        return {
          value: null
        };
      if (K.kind === i.Kind.VARIABLE)
        return { value: null, variables: [{ valueNode: K, path: void 0 }] };
      if ((0, r.isListType)(se)) {
        const re = se.ofType;
        if (K.kind === i.Kind.LIST) {
          const te = [], B = [], M = K.values;
          for (let N = 0; N < M.length; N++) {
            const T = M[N];
            if (T.kind === i.Kind.VARIABLE)
              te.push(null), B.push({
                valueNode: T,
                path: le(void 0, N.toString(), "literal")
              });
            else {
              const P = Z(T, re);
              if (!P)
                return;
              te.push(P.value), J(P) && B.push(...P.variables.map(({ valueNode: k, path: q }) => ({
                valueNode: k,
                path: le(q, N.toString(), "literal")
              })));
            }
          }
          return { value: te, variables: B };
        }
        const ue = Z(K, re);
        return ue === void 0 ? void 0 : J(ue) ? {
          value: [ue.value],
          variables: ue.variables.map(({ valueNode: te, path: B }) => ({
            valueNode: te,
            path: le(B, "0", "literal")
          }))
        } : { value: [ue.value] };
      }
      if ((0, r.isInputObjectType)(se)) {
        if (K.kind !== i.Kind.OBJECT)
          return;
        const re = /* @__PURE__ */ Object.create(null), ue = [], te = j(K.fields, (M) => M.name.value), B = Object.values(se.getFields());
        for (const M of B) {
          M.defaultValue !== void 0 && (re[M.name] = M.defaultValue);
          const N = te[M.name];
          if (!N)
            continue;
          const T = Z(N.value, M.type);
          if (!T)
            return;
          J(T) && ue.push(...T.variables.map(({ valueNode: P, path: k }) => ({
            valueNode: P,
            path: le(k, M.name, "literal")
          }))), re[M.name] = T.value;
        }
        return { value: re, variables: ue };
      }
      if ((0, r.isEnumType)(se)) {
        if (K.kind !== i.Kind.ENUM)
          return;
        const re = se.getValue(K.value);
        return re ? { value: re.value } : void 0;
      }
      if ((0, r.isScalarType)(se)) {
        let re;
        try {
          se.parseLiteral.length > 1 && console.error("Scalar with variable inputs detected for parsing AST literals. This is not supported."), re = se.parseLiteral(K, {});
        } catch {
          return;
        }
        return ne(re) ? void 0 : { value: re };
      }
      throw new Error(`Unexpected input type: "${c(se)}".`);
    }
    e.valueFromAST = Z;
    function j(K, se) {
      return K.reduce(
        // eslint-disable-next-line no-sequences
        (re, ue) => (re[se(ue)] = ue, re),
        /* @__PURE__ */ Object.create(null)
      );
    }
    function ee(K) {
      return K.reduce((se, re) => (re.loc && se.push((0, r.getLocation)(re.loc.source, re.loc.start)), se), []);
    }
    e.computeLocations = ee;
    function le(K, se, re = "literal") {
      return { prev: K, key: se, type: re };
    }
    e.addPath = le;
    function ce(K) {
      const se = [];
      let re = K;
      for (; re; )
        se.push({ key: re.key, type: re.type }), re = re.prev;
      return se;
    }
    e.flattenPath = ce;
    function U(K) {
      let se = "", re = K;
      for (; re; )
        re.type === "literal" && (se = z(re.key, se)), re = re.prev;
      return se;
    }
    e.serializeObjectPathForSkipInclude = U;
    function z(K, se) {
      return K ? se ? `${K}.${se}` : K : se;
    }
    e.joinSkipIncludePath = z;
    function ne(K) {
      return K === void 0 || K !== K;
    }
  }(Of)), Of;
}
var Ra = {};
Object.defineProperty(Ra, "__esModule", { value: !0 });
Ra.GraphQLError = void 0;
const xU = Ln;
function ru(e, t, n, r, i) {
  const s = r && r.extensions;
  Object.defineProperties(this, {
    message: {
      value: e,
      enumerable: !0
    },
    locations: {
      value: t || void 0,
      enumerable: t && t.length > 0
    },
    path: {
      value: n || void 0,
      enumerable: !!n
    },
    originalError: {
      value: r
    },
    extensions: {
      // Coercing falsey values to undefined ensures they will not be included
      // in JSON.stringify() when not provided.
      value: s || void 0,
      enumerable: !!s
    }
  }), r && r.stack ? Object.defineProperty(this, "stack", {
    value: r.stack,
    writable: !0,
    configurable: !0
  }) : i || (Error.captureStackTrace ? Error.captureStackTrace(this, ru) : Object.defineProperty(this, "stack", {
    value: Error().stack,
    writable: !0,
    configurable: !0
  }));
}
Ra.GraphQLError = ru;
ru.prototype = Object.create(xU.GraphQLError.prototype, {
  constructor: { value: ru },
  name: { value: "GraphQLError" }
});
var mo = {}, a0;
function DU() {
  if (a0)
    return mo;
  a0 = 1, Object.defineProperty(mo, "__esModule", { value: !0 }), mo.queryToJSONSchema = void 0;
  const e = Ln, t = rc(), n = bn, r = {
    Int: "integer",
    Float: "number",
    String: "string",
    Boolean: "boolean",
    ID: "string"
  };
  function i(o) {
    const a = (0, n.getOperationRootType)(o.schema, o.operation), l = (0, t.collectFields)(o, a, o.operation.selectionSet, /* @__PURE__ */ Object.create(null), /* @__PURE__ */ Object.create(null)), c = /* @__PURE__ */ Object.create(null);
    for (const u of Object.keys(l)) {
      const f = (0, t.resolveFieldDef)(o, a, l[u]);
      f && (c[u] = s(o, l[u], f.type));
    }
    return {
      type: "object",
      properties: {
        data: {
          type: "object",
          properties: c,
          nullable: !0
        },
        errors: {
          type: "array",
          items: {
            type: "object",
            additionalProperties: !0,
            properties: {
              message: {
                type: "string"
              },
              path: {
                type: "array",
                items: {
                  type: ["string", "number"]
                }
              },
              locations: {
                type: "array",
                items: {
                  type: "object",
                  properties: {
                    line: {
                      type: "number"
                    },
                    column: {
                      type: "number"
                    }
                  }
                }
              }
            }
          }
        }
      }
    };
  }
  mo.queryToJSONSchema = i;
  function s(o, a, l) {
    if ((0, e.isObjectType)(l)) {
      const c = (0, t.collectSubfields)(o, l, a), u = /* @__PURE__ */ Object.create(null);
      for (const f of Object.keys(c)) {
        const d = (0, t.resolveFieldDef)(o, l, c[f]);
        d && (u[f] = s(o, c[f], d.type));
      }
      return {
        type: "object",
        properties: u,
        nullable: !0
      };
    }
    if ((0, e.isListType)(l))
      return {
        type: "array",
        items: s(o, a, l.ofType),
        nullable: !0
      };
    if ((0, e.isNonNullType)(l)) {
      const c = s(o, a, l.ofType);
      return c.nullable = !1, c;
    }
    if ((0, e.isEnumType)(l))
      return {
        type: "string",
        nullable: !0
      };
    if ((0, e.isScalarType)(l)) {
      const c = r[l.name];
      if (!c)
        throw new Error(`Got unexpected PRIMITIVES type: ${l.name}`);
      return {
        type: c,
        nullable: !0
      };
    }
    if ((0, e.isAbstractType)(l))
      return o.schema.getPossibleTypes(l).reduce((c, u) => {
        const f = s(o, a, u);
        return c.properties = {
          ...c.properties,
          ...f.properties
        }, c;
      }, {
        type: "object",
        properties: {},
        nullable: !0
      });
    throw new Error(`Got unhandled type: ${l.name}`);
  }
  return mo;
}
var yo = {}, iu = { exports: {} };
iu.exports;
(function(e, t) {
  var n = 200, r = "__lodash_hash_undefined__", i = 800, s = 16, o = 9007199254740991, a = "[object Arguments]", l = "[object Array]", c = "[object AsyncFunction]", u = "[object Boolean]", f = "[object Date]", d = "[object Error]", p = "[object Function]", h = "[object GeneratorFunction]", m = "[object Map]", v = "[object Number]", b = "[object Null]", E = "[object Object]", y = "[object Proxy]", D = "[object RegExp]", F = "[object Set]", W = "[object String]", J = "[object Undefined]", Z = "[object WeakMap]", j = "[object ArrayBuffer]", ee = "[object DataView]", le = "[object Float32Array]", ce = "[object Float64Array]", U = "[object Int8Array]", z = "[object Int16Array]", ne = "[object Int32Array]", K = "[object Uint8Array]", se = "[object Uint8ClampedArray]", re = "[object Uint16Array]", ue = "[object Uint32Array]", te = /[\\^$.*+?()[\]{}|]/g, B = /^\[object .+?Constructor\]$/, M = /^(?:0|[1-9]\d*)$/, N = {};
  N[le] = N[ce] = N[U] = N[z] = N[ne] = N[K] = N[se] = N[re] = N[ue] = !0, N[a] = N[l] = N[j] = N[u] = N[ee] = N[f] = N[d] = N[p] = N[m] = N[v] = N[E] = N[D] = N[F] = N[W] = N[Z] = !1;
  var T = typeof We == "object" && We && We.Object === Object && We, P = typeof self == "object" && self && self.Object === Object && self, k = T || P || Function("return this")(), q = t && !t.nodeType && t, Y = q && !0 && e && !e.nodeType && e, ve = Y && Y.exports === q, oe = ve && T.process, S = function() {
    try {
      var w = Y && Y.require && Y.require("util").types;
      return w || oe && oe.binding && oe.binding("util");
    } catch {
    }
  }(), $ = S && S.isTypedArray;
  function O(w, A, G) {
    switch (G.length) {
      case 0:
        return w.call(A);
      case 1:
        return w.call(A, G[0]);
      case 2:
        return w.call(A, G[0], G[1]);
      case 3:
        return w.call(A, G[0], G[1], G[2]);
    }
    return w.apply(A, G);
  }
  function I(w, A) {
    for (var G = -1, me = Array(w); ++G < w; )
      me[G] = A(G);
    return me;
  }
  function L(w) {
    return function(A) {
      return w(A);
    };
  }
  function H(w, A) {
    return w?.[A];
  }
  function ae(w, A) {
    return function(G) {
      return w(A(G));
    };
  }
  var Ee = Array.prototype, Oe = Function.prototype, Te = Object.prototype, Me = k["__core-js_shared__"], we = Oe.toString, Le = Te.hasOwnProperty, ut = function() {
    var w = /[^.]+$/.exec(Me && Me.keys && Me.keys.IE_PROTO || "");
    return w ? "Symbol(src)_1." + w : "";
  }(), Je = Te.toString, bt = we.call(Object), x = RegExp(
    "^" + we.call(Le).replace(te, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  ), g = ve ? k.Buffer : void 0, _ = k.Symbol, V = k.Uint8Array, X = g ? g.allocUnsafe : void 0, pe = ae(Object.getPrototypeOf, Object), ye = Object.create, Ge = Te.propertyIsEnumerable, ft = Ee.splice, ze = _ ? _.toStringTag : void 0, st = function() {
    try {
      var w = yi(Object, "defineProperty");
      return w({}, "", {}), w;
    } catch {
    }
  }(), nt = g ? g.isBuffer : void 0, nr = Math.max, rr = Date.now, ir = yi(k, "Map"), Ut = yi(Object, "create"), mi = function() {
    function w() {
    }
    return function(A) {
      if (!tn(A))
        return {};
      if (ye)
        return ye(A);
      w.prototype = A;
      var G = new w();
      return w.prototype = void 0, G;
    };
  }();
  function Vt(w) {
    var A = -1, G = w == null ? 0 : w.length;
    for (this.clear(); ++A < G; ) {
      var me = w[A];
      this.set(me[0], me[1]);
    }
  }
  function $r() {
    this.__data__ = Ut ? Ut(null) : {}, this.size = 0;
  }
  function ie(w) {
    var A = this.has(w) && delete this.__data__[w];
    return this.size -= A ? 1 : 0, A;
  }
  function R(w) {
    var A = this.__data__;
    if (Ut) {
      var G = A[w];
      return G === r ? void 0 : G;
    }
    return Le.call(A, w) ? A[w] : void 0;
  }
  function C(w) {
    var A = this.__data__;
    return Ut ? A[w] !== void 0 : Le.call(A, w);
  }
  function fe(w, A) {
    var G = this.__data__;
    return this.size += this.has(w) ? 0 : 1, G[w] = Ut && A === void 0 ? r : A, this;
  }
  Vt.prototype.clear = $r, Vt.prototype.delete = ie, Vt.prototype.get = R, Vt.prototype.has = C, Vt.prototype.set = fe;
  function de(w) {
    var A = -1, G = w == null ? 0 : w.length;
    for (this.clear(); ++A < G; ) {
      var me = w[A];
      this.set(me[0], me[1]);
    }
  }
  function he() {
    this.__data__ = [], this.size = 0;
  }
  function $e(w) {
    var A = this.__data__, G = En(A, w);
    if (G < 0)
      return !1;
    var me = A.length - 1;
    return G == me ? A.pop() : ft.call(A, G, 1), --this.size, !0;
  }
  function De(w) {
    var A = this.__data__, G = En(A, w);
    return G < 0 ? void 0 : A[G][1];
  }
  function Ne(w) {
    return En(this.__data__, w) > -1;
  }
  function Re(w, A) {
    var G = this.__data__, me = En(G, w);
    return me < 0 ? (++this.size, G.push([w, A])) : G[me][1] = A, this;
  }
  de.prototype.clear = he, de.prototype.delete = $e, de.prototype.get = De, de.prototype.has = Ne, de.prototype.set = Re;
  function Ue(w) {
    var A = -1, G = w == null ? 0 : w.length;
    for (this.clear(); ++A < G; ) {
      var me = w[A];
      this.set(me[0], me[1]);
    }
  }
  function rt() {
    this.size = 0, this.__data__ = {
      hash: new Vt(),
      map: new (ir || de)(),
      string: new Vt()
    };
  }
  function dt(w) {
    var A = Rr(this, w).delete(w);
    return this.size -= A ? 1 : 0, A;
  }
  function ct(w) {
    return Rr(this, w).get(w);
  }
  function Ze(w) {
    return Rr(this, w).has(w);
  }
  function et(w, A) {
    var G = Rr(this, w), me = G.size;
    return G.set(w, A), this.size += G.size == me ? 0 : 1, this;
  }
  Ue.prototype.clear = rt, Ue.prototype.delete = dt, Ue.prototype.get = ct, Ue.prototype.has = Ze, Ue.prototype.set = et;
  function qe(w) {
    var A = this.__data__ = new de(w);
    this.size = A.size;
  }
  function vt() {
    this.__data__ = new de(), this.size = 0;
  }
  function kt(w) {
    var A = this.__data__, G = A.delete(w);
    return this.size = A.size, G;
  }
  function Ct(w) {
    return this.__data__.get(w);
  }
  function Nr(w) {
    return this.__data__.has(w);
  }
  function Qr(w, A) {
    var G = this.__data__;
    if (G instanceof de) {
      var me = G.__data__;
      if (!ir || me.length < n - 1)
        return me.push([w, A]), this.size = ++G.size, this;
      G = this.__data__ = new Ue(me);
    }
    return G.set(w, A), this.size = G.size, this;
  }
  qe.prototype.clear = vt, qe.prototype.delete = kt, qe.prototype.get = Ct, qe.prototype.has = Nr, qe.prototype.set = Qr;
  function qs(w, A) {
    var G = vi(w), me = !G && bi(w), Ae = !G && !me && Xs(w), Ce = !G && !me && !Ae && eo(w), Ve = G || me || Ae || Ce, Ie = Ve ? I(w.length, String) : [], Be = Ie.length;
    for (var _t in w)
      (A || Le.call(w, _t)) && !(Ve && // Safari 9 has enumerable `arguments.length` in strict mode.
      (_t == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      Ae && (_t == "offset" || _t == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      Ce && (_t == "buffer" || _t == "byteLength" || _t == "byteOffset") || // Skip index properties.
      Ks(_t, Be))) && Ie.push(_t);
    return Ie;
  }
  function Or(w, A, G) {
    (G !== void 0 && !Ar(w[A], G) || G === void 0 && !(A in w)) && Jr(w, A, G);
  }
  function Hs(w, A, G) {
    var me = w[A];
    (!(Le.call(w, A) && Ar(me, G)) || G === void 0 && !(A in w)) && Jr(w, A, G);
  }
  function En(w, A) {
    for (var G = w.length; G--; )
      if (Ar(w[G][0], A))
        return G;
    return -1;
  }
  function Jr(w, A, G) {
    A == "__proto__" && st ? st(w, A, {
      configurable: !0,
      enumerable: !0,
      value: G,
      writable: !0
    }) : w[A] = G;
  }
  var Ws = bc();
  function Ir(w) {
    return w == null ? w === void 0 ? J : b : ze && ze in Object(w) ? vc(w) : $c(w);
  }
  function Qs(w) {
    return Un(w) && Ir(w) == a;
  }
  function oc(w) {
    if (!tn(w) || Sc(w))
      return !1;
    var A = wi(w) ? x : B;
    return A.test(Rc(w));
  }
  function ac(w) {
    return Un(w) && Zs(w.length) && !!N[Ir(w)];
  }
  function lc(w) {
    if (!tn(w))
      return Tc(w);
    var A = Ys(w), G = [];
    for (var me in w)
      me == "constructor" && (A || !Le.call(w, me)) || G.push(me);
    return G;
  }
  function Js(w, A, G, me, Ae) {
    w !== A && Ws(A, function(Ce, Ve) {
      if (Ae || (Ae = new qe()), tn(Ce))
        uc(w, A, Ve, G, Js, me, Ae);
      else {
        var Ie = me ? me(gi(w, Ve), Ce, Ve + "", w, A, Ae) : void 0;
        Ie === void 0 && (Ie = Ce), Or(w, Ve, Ie);
      }
    }, to);
  }
  function uc(w, A, G, me, Ae, Ce, Ve) {
    var Ie = gi(w, G), Be = gi(A, G), _t = Ve.get(Be);
    if (_t) {
      Or(w, G, _t);
      return;
    }
    var yt = Ce ? Ce(Ie, Be, G + "", w, A, Ve) : void 0, Vn = yt === void 0;
    if (Vn) {
      var Ei = vi(Be), Si = !Ei && Xs(Be), ro = !Ei && !Si && eo(Be);
      yt = Be, Ei || Si || ro ? vi(Ie) ? yt = Ie : Ac(Ie) ? yt = mc(Ie) : Si ? (Vn = !1, yt = dc(Be, !0)) : ro ? (Vn = !1, yt = hc(Be, !0)) : yt = [] : xc(Be) || bi(Be) ? (yt = Ie, bi(Ie) ? yt = Dc(Ie) : (!tn(Ie) || wi(Ie)) && (yt = _c(Be))) : Vn = !1;
    }
    Vn && (Ve.set(Be, yt), Ae(yt, Be, me, Ce, Ve), Ve.delete(Be)), Or(w, G, yt);
  }
  function cc(w, A) {
    return Oc(Nc(w, A, no), w + "");
  }
  var fc = st ? function(w, A) {
    return st(w, "toString", {
      configurable: !0,
      enumerable: !1,
      value: kc(A),
      writable: !0
    });
  } : no;
  function dc(w, A) {
    if (A)
      return w.slice();
    var G = w.length, me = X ? X(G) : new w.constructor(G);
    return w.copy(me), me;
  }
  function pc(w) {
    var A = new w.constructor(w.byteLength);
    return new V(A).set(new V(w)), A;
  }
  function hc(w, A) {
    var G = A ? pc(w.buffer) : w.buffer;
    return new w.constructor(G, w.byteOffset, w.length);
  }
  function mc(w, A) {
    var G = -1, me = w.length;
    for (A || (A = Array(me)); ++G < me; )
      A[G] = w[G];
    return A;
  }
  function yc(w, A, G, me) {
    var Ae = !G;
    G || (G = {});
    for (var Ce = -1, Ve = A.length; ++Ce < Ve; ) {
      var Ie = A[Ce], Be = me ? me(G[Ie], w[Ie], Ie, G, w) : void 0;
      Be === void 0 && (Be = w[Ie]), Ae ? Jr(G, Ie, Be) : Hs(G, Ie, Be);
    }
    return G;
  }
  function gc(w) {
    return cc(function(A, G) {
      var me = -1, Ae = G.length, Ce = Ae > 1 ? G[Ae - 1] : void 0, Ve = Ae > 2 ? G[2] : void 0;
      for (Ce = w.length > 3 && typeof Ce == "function" ? (Ae--, Ce) : void 0, Ve && wc(G[0], G[1], Ve) && (Ce = Ae < 3 ? void 0 : Ce, Ae = 1), A = Object(A); ++me < Ae; ) {
        var Ie = G[me];
        Ie && w(A, Ie, me, Ce);
      }
      return A;
    });
  }
  function bc(w) {
    return function(A, G, me) {
      for (var Ae = -1, Ce = Object(A), Ve = me(A), Ie = Ve.length; Ie--; ) {
        var Be = Ve[w ? Ie : ++Ae];
        if (G(Ce[Be], Be, Ce) === !1)
          break;
      }
      return A;
    };
  }
  function Rr(w, A) {
    var G = w.__data__;
    return Ec(A) ? G[typeof A == "string" ? "string" : "hash"] : G.map;
  }
  function yi(w, A) {
    var G = H(w, A);
    return oc(G) ? G : void 0;
  }
  function vc(w) {
    var A = Le.call(w, ze), G = w[ze];
    try {
      w[ze] = void 0;
      var me = !0;
    } catch {
    }
    var Ae = Je.call(w);
    return me && (A ? w[ze] = G : delete w[ze]), Ae;
  }
  function _c(w) {
    return typeof w.constructor == "function" && !Ys(w) ? mi(pe(w)) : {};
  }
  function Ks(w, A) {
    var G = typeof w;
    return A = A ?? o, !!A && (G == "number" || G != "symbol" && M.test(w)) && w > -1 && w % 1 == 0 && w < A;
  }
  function wc(w, A, G) {
    if (!tn(G))
      return !1;
    var me = typeof A;
    return (me == "number" ? _i(G) && Ks(A, G.length) : me == "string" && A in G) ? Ar(G[A], w) : !1;
  }
  function Ec(w) {
    var A = typeof w;
    return A == "string" || A == "number" || A == "symbol" || A == "boolean" ? w !== "__proto__" : w === null;
  }
  function Sc(w) {
    return !!ut && ut in w;
  }
  function Ys(w) {
    var A = w && w.constructor, G = typeof A == "function" && A.prototype || Te;
    return w === G;
  }
  function Tc(w) {
    var A = [];
    if (w != null)
      for (var G in Object(w))
        A.push(G);
    return A;
  }
  function $c(w) {
    return Je.call(w);
  }
  function Nc(w, A, G) {
    return A = nr(A === void 0 ? w.length - 1 : A, 0), function() {
      for (var me = arguments, Ae = -1, Ce = nr(me.length - A, 0), Ve = Array(Ce); ++Ae < Ce; )
        Ve[Ae] = me[A + Ae];
      Ae = -1;
      for (var Ie = Array(A + 1); ++Ae < A; )
        Ie[Ae] = me[Ae];
      return Ie[A] = G(Ve), O(w, this, Ie);
    };
  }
  function gi(w, A) {
    if (!(A === "constructor" && typeof w[A] == "function") && A != "__proto__")
      return w[A];
  }
  var Oc = Ic(fc);
  function Ic(w) {
    var A = 0, G = 0;
    return function() {
      var me = rr(), Ae = s - (me - G);
      if (G = me, Ae > 0) {
        if (++A >= i)
          return arguments[0];
      } else
        A = 0;
      return w.apply(void 0, arguments);
    };
  }
  function Rc(w) {
    if (w != null) {
      try {
        return we.call(w);
      } catch {
      }
      try {
        return w + "";
      } catch {
      }
    }
    return "";
  }
  function Ar(w, A) {
    return w === A || w !== w && A !== A;
  }
  var bi = Qs(function() {
    return arguments;
  }()) ? Qs : function(w) {
    return Un(w) && Le.call(w, "callee") && !Ge.call(w, "callee");
  }, vi = Array.isArray;
  function _i(w) {
    return w != null && Zs(w.length) && !wi(w);
  }
  function Ac(w) {
    return Un(w) && _i(w);
  }
  var Xs = nt || Lc;
  function wi(w) {
    if (!tn(w))
      return !1;
    var A = Ir(w);
    return A == p || A == h || A == c || A == y;
  }
  function Zs(w) {
    return typeof w == "number" && w > -1 && w % 1 == 0 && w <= o;
  }
  function tn(w) {
    var A = typeof w;
    return w != null && (A == "object" || A == "function");
  }
  function Un(w) {
    return w != null && typeof w == "object";
  }
  function xc(w) {
    if (!Un(w) || Ir(w) != E)
      return !1;
    var A = pe(w);
    if (A === null)
      return !0;
    var G = Le.call(A, "constructor") && A.constructor;
    return typeof G == "function" && G instanceof G && we.call(G) == bt;
  }
  var eo = $ ? L($) : ac;
  function Dc(w) {
    return yc(w, to(w));
  }
  function to(w) {
    return _i(w) ? qs(w, !0) : lc(w);
  }
  var Pc = gc(function(w, A, G) {
    Js(w, A, G);
  });
  function kc(w) {
    return function() {
      return w;
    };
  }
  function no(w) {
    return w;
  }
  function Lc() {
    return !1;
  }
  e.exports = Pc;
})(iu, iu.exports);
var PU = iu.exports, l0;
function kU() {
  if (l0)
    return yo;
  l0 = 1;
  var e = We && We.__importDefault || function(p) {
    return p && p.__esModule ? p : { default: p };
  };
  Object.defineProperty(yo, "__esModule", { value: !0 }), yo.createNullTrimmer = void 0;
  const t = Ln, n = tE, r = e(PU), i = rc(), s = bn;
  function o(p) {
    return a(f(p));
  }
  yo.createNullTrimmer = o;
  function a(p) {
    return (h, m) => {
      const v = [], b = /* @__PURE__ */ new Set();
      for (const E of m) {
        if (!E.path)
          throw new Error("no path available for tree trimming");
        if (b.has(E.path.join(".")))
          continue;
        const y = u(p, E.path);
        if (y.length === 0) {
          h = null, v.push(E);
          break;
        }
        l(h, y), b.add(E.path.join(".")), v.push(E);
      }
      return { data: h, errors: v };
    };
  }
  function l(p, h) {
    for (let v = 0; v < h.length - 1; ++v)
      p = p[h[v]];
    const m = h[h.length - 1];
    p[m] = null;
  }
  const c = "index";
  function u(p, h) {
    let m = 0;
    for (let v = 0; v < h.length; ++v) {
      const b = h[v], E = p.children[typeof b == "string" ? b : c];
      if (!E)
        break;
      E.isNullable && (m = v + 1), p = E;
    }
    return h.slice(0, m);
  }
  function f(p) {
    const h = (0, s.getOperationRootType)(p.schema, p.operation), m = (0, i.collectFields)(p, h, p.operation.selectionSet, /* @__PURE__ */ Object.create(null), /* @__PURE__ */ Object.create(null)), v = /* @__PURE__ */ Object.create(null);
    for (const b of Object.keys(m)) {
      const E = (0, i.resolveFieldDef)(p, h, m[b]);
      if (!E)
        continue;
      const y = d(p, m[b], E.type);
      y != null && (v[b] = y);
    }
    return {
      isNullable: !0,
      children: v
    };
  }
  function d(p, h, m) {
    if ((0, t.isNonNullType)(m)) {
      const v = d(p, h, m.ofType);
      return v != null ? (v.isNullable = !1, v) : null;
    }
    if ((0, t.isObjectType)(m)) {
      const v = (0, i.collectSubfields)(p, m, h), b = /* @__PURE__ */ Object.create(null);
      for (const E of Object.keys(v)) {
        const y = (0, i.resolveFieldDef)(p, m, v[E]);
        if (!y)
          continue;
        const D = d(p, v[E], y.type);
        D != null && (b[E] = D);
      }
      return {
        isNullable: !0,
        children: b
      };
    }
    if ((0, t.isListType)(m)) {
      const v = d(p, h, m.ofType);
      return v != null ? {
        isNullable: !0,
        children: { [c]: v }
      } : {
        isNullable: !0,
        children: {}
      };
    }
    return (0, n.isAbstractType)(m) ? p.schema.getPossibleTypes(m).reduce((v, b) => {
      const E = d(p, h, b);
      return E != null && (v.children = (0, r.default)(v.children, E.children)), v;
    }, {
      isNullable: !0,
      children: {}
    }) : null;
  }
  return yo;
}
var jr = {}, LU = "Expected a function", FE = "__lodash_hash_undefined__", jU = "[object Function]", CU = "[object GeneratorFunction]", MU = /[\\^$.*+?()[\]{}|]/g, FU = /^\[object .+?Constructor\]$/, UU = typeof We == "object" && We && We.Object === Object && We, VU = typeof self == "object" && self && self.Object === Object && self, UE = UU || VU || Function("return this")();
function BU(e, t) {
  return e?.[t];
}
function GU(e) {
  var t = !1;
  if (e != null && typeof e.toString != "function")
    try {
      t = !!(e + "");
    } catch {
    }
  return t;
}
var zU = Array.prototype, qU = Function.prototype, VE = Object.prototype, Df = UE["__core-js_shared__"], u0 = function() {
  var e = /[^.]+$/.exec(Df && Df.keys && Df.keys.IE_PROTO || "");
  return e ? "Symbol(src)_1." + e : "";
}(), BE = qU.toString, qh = VE.hasOwnProperty, HU = VE.toString, WU = RegExp(
  "^" + BE.call(qh).replace(MU, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
), QU = zU.splice, JU = GE(UE, "Map"), sa = GE(Object, "create");
function zi(e) {
  var t = -1, n = e ? e.length : 0;
  for (this.clear(); ++t < n; ) {
    var r = e[t];
    this.set(r[0], r[1]);
  }
}
function KU() {
  this.__data__ = sa ? sa(null) : {};
}
function YU(e) {
  return this.has(e) && delete this.__data__[e];
}
function XU(e) {
  var t = this.__data__;
  if (sa) {
    var n = t[e];
    return n === FE ? void 0 : n;
  }
  return qh.call(t, e) ? t[e] : void 0;
}
function ZU(e) {
  var t = this.__data__;
  return sa ? t[e] !== void 0 : qh.call(t, e);
}
function eV(e, t) {
  var n = this.__data__;
  return n[e] = sa && t === void 0 ? FE : t, this;
}
zi.prototype.clear = KU;
zi.prototype.delete = YU;
zi.prototype.get = XU;
zi.prototype.has = ZU;
zi.prototype.set = eV;
function zs(e) {
  var t = -1, n = e ? e.length : 0;
  for (this.clear(); ++t < n; ) {
    var r = e[t];
    this.set(r[0], r[1]);
  }
}
function tV() {
  this.__data__ = [];
}
function nV(e) {
  var t = this.__data__, n = ic(t, e);
  if (n < 0)
    return !1;
  var r = t.length - 1;
  return n == r ? t.pop() : QU.call(t, n, 1), !0;
}
function rV(e) {
  var t = this.__data__, n = ic(t, e);
  return n < 0 ? void 0 : t[n][1];
}
function iV(e) {
  return ic(this.__data__, e) > -1;
}
function sV(e, t) {
  var n = this.__data__, r = ic(n, e);
  return r < 0 ? n.push([e, t]) : n[r][1] = t, this;
}
zs.prototype.clear = tV;
zs.prototype.delete = nV;
zs.prototype.get = rV;
zs.prototype.has = iV;
zs.prototype.set = sV;
function rs(e) {
  var t = -1, n = e ? e.length : 0;
  for (this.clear(); ++t < n; ) {
    var r = e[t];
    this.set(r[0], r[1]);
  }
}
function oV() {
  this.__data__ = {
    hash: new zi(),
    map: new (JU || zs)(),
    string: new zi()
  };
}
function aV(e) {
  return sc(this, e).delete(e);
}
function lV(e) {
  return sc(this, e).get(e);
}
function uV(e) {
  return sc(this, e).has(e);
}
function cV(e, t) {
  return sc(this, e).set(e, t), this;
}
rs.prototype.clear = oV;
rs.prototype.delete = aV;
rs.prototype.get = lV;
rs.prototype.has = uV;
rs.prototype.set = cV;
function ic(e, t) {
  for (var n = e.length; n--; )
    if (mV(e[n][0], t))
      return n;
  return -1;
}
function fV(e) {
  if (!zE(e) || pV(e))
    return !1;
  var t = yV(e) || GU(e) ? WU : FU;
  return t.test(hV(e));
}
function sc(e, t) {
  var n = e.__data__;
  return dV(t) ? n[typeof t == "string" ? "string" : "hash"] : n.map;
}
function GE(e, t) {
  var n = BU(e, t);
  return fV(n) ? n : void 0;
}
function dV(e) {
  var t = typeof e;
  return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e !== "__proto__" : e === null;
}
function pV(e) {
  return !!u0 && u0 in e;
}
function hV(e) {
  if (e != null) {
    try {
      return BE.call(e);
    } catch {
    }
    try {
      return e + "";
    } catch {
    }
  }
  return "";
}
function Hh(e, t) {
  if (typeof e != "function" || t && typeof t != "function")
    throw new TypeError(LU);
  var n = function() {
    var r = arguments, i = t ? t.apply(this, r) : r[0], s = n.cache;
    if (s.has(i))
      return s.get(i);
    var o = e.apply(this, r);
    return n.cache = s.set(i, o), o;
  };
  return n.cache = new (Hh.Cache || rs)(), n;
}
Hh.Cache = rs;
function mV(e, t) {
  return e === t || e !== e && t !== t;
}
function yV(e) {
  var t = zE(e) ? HU.call(e) : "";
  return t == jU || t == CU;
}
function zE(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
var qE = Hh, su = { exports: {} };
su.exports;
(function(e, t) {
  var n = 200, r = "__lodash_hash_undefined__", i = 800, s = 16, o = 9007199254740991, a = "[object Arguments]", l = "[object Array]", c = "[object AsyncFunction]", u = "[object Boolean]", f = "[object Date]", d = "[object Error]", p = "[object Function]", h = "[object GeneratorFunction]", m = "[object Map]", v = "[object Number]", b = "[object Null]", E = "[object Object]", y = "[object Proxy]", D = "[object RegExp]", F = "[object Set]", W = "[object String]", J = "[object Undefined]", Z = "[object WeakMap]", j = "[object ArrayBuffer]", ee = "[object DataView]", le = "[object Float32Array]", ce = "[object Float64Array]", U = "[object Int8Array]", z = "[object Int16Array]", ne = "[object Int32Array]", K = "[object Uint8Array]", se = "[object Uint8ClampedArray]", re = "[object Uint16Array]", ue = "[object Uint32Array]", te = /[\\^$.*+?()[\]{}|]/g, B = /^\[object .+?Constructor\]$/, M = /^(?:0|[1-9]\d*)$/, N = {};
  N[le] = N[ce] = N[U] = N[z] = N[ne] = N[K] = N[se] = N[re] = N[ue] = !0, N[a] = N[l] = N[j] = N[u] = N[ee] = N[f] = N[d] = N[p] = N[m] = N[v] = N[E] = N[D] = N[F] = N[W] = N[Z] = !1;
  var T = typeof We == "object" && We && We.Object === Object && We, P = typeof self == "object" && self && self.Object === Object && self, k = T || P || Function("return this")(), q = t && !t.nodeType && t, Y = q && !0 && e && !e.nodeType && e, ve = Y && Y.exports === q, oe = ve && T.process, S = function() {
    try {
      var w = Y && Y.require && Y.require("util").types;
      return w || oe && oe.binding && oe.binding("util");
    } catch {
    }
  }(), $ = S && S.isTypedArray;
  function O(w, A, G) {
    switch (G.length) {
      case 0:
        return w.call(A);
      case 1:
        return w.call(A, G[0]);
      case 2:
        return w.call(A, G[0], G[1]);
      case 3:
        return w.call(A, G[0], G[1], G[2]);
    }
    return w.apply(A, G);
  }
  function I(w, A) {
    for (var G = -1, me = Array(w); ++G < w; )
      me[G] = A(G);
    return me;
  }
  function L(w) {
    return function(A) {
      return w(A);
    };
  }
  function H(w, A) {
    return w?.[A];
  }
  function ae(w, A) {
    return function(G) {
      return w(A(G));
    };
  }
  var Ee = Array.prototype, Oe = Function.prototype, Te = Object.prototype, Me = k["__core-js_shared__"], we = Oe.toString, Le = Te.hasOwnProperty, ut = function() {
    var w = /[^.]+$/.exec(Me && Me.keys && Me.keys.IE_PROTO || "");
    return w ? "Symbol(src)_1." + w : "";
  }(), Je = Te.toString, bt = we.call(Object), x = RegExp(
    "^" + we.call(Le).replace(te, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  ), g = ve ? k.Buffer : void 0, _ = k.Symbol, V = k.Uint8Array, X = g ? g.allocUnsafe : void 0, pe = ae(Object.getPrototypeOf, Object), ye = Object.create, Ge = Te.propertyIsEnumerable, ft = Ee.splice, ze = _ ? _.toStringTag : void 0, st = function() {
    try {
      var w = yi(Object, "defineProperty");
      return w({}, "", {}), w;
    } catch {
    }
  }(), nt = g ? g.isBuffer : void 0, nr = Math.max, rr = Date.now, ir = yi(k, "Map"), Ut = yi(Object, "create"), mi = function() {
    function w() {
    }
    return function(A) {
      if (!tn(A))
        return {};
      if (ye)
        return ye(A);
      w.prototype = A;
      var G = new w();
      return w.prototype = void 0, G;
    };
  }();
  function Vt(w) {
    var A = -1, G = w == null ? 0 : w.length;
    for (this.clear(); ++A < G; ) {
      var me = w[A];
      this.set(me[0], me[1]);
    }
  }
  function $r() {
    this.__data__ = Ut ? Ut(null) : {}, this.size = 0;
  }
  function ie(w) {
    var A = this.has(w) && delete this.__data__[w];
    return this.size -= A ? 1 : 0, A;
  }
  function R(w) {
    var A = this.__data__;
    if (Ut) {
      var G = A[w];
      return G === r ? void 0 : G;
    }
    return Le.call(A, w) ? A[w] : void 0;
  }
  function C(w) {
    var A = this.__data__;
    return Ut ? A[w] !== void 0 : Le.call(A, w);
  }
  function fe(w, A) {
    var G = this.__data__;
    return this.size += this.has(w) ? 0 : 1, G[w] = Ut && A === void 0 ? r : A, this;
  }
  Vt.prototype.clear = $r, Vt.prototype.delete = ie, Vt.prototype.get = R, Vt.prototype.has = C, Vt.prototype.set = fe;
  function de(w) {
    var A = -1, G = w == null ? 0 : w.length;
    for (this.clear(); ++A < G; ) {
      var me = w[A];
      this.set(me[0], me[1]);
    }
  }
  function he() {
    this.__data__ = [], this.size = 0;
  }
  function $e(w) {
    var A = this.__data__, G = En(A, w);
    if (G < 0)
      return !1;
    var me = A.length - 1;
    return G == me ? A.pop() : ft.call(A, G, 1), --this.size, !0;
  }
  function De(w) {
    var A = this.__data__, G = En(A, w);
    return G < 0 ? void 0 : A[G][1];
  }
  function Ne(w) {
    return En(this.__data__, w) > -1;
  }
  function Re(w, A) {
    var G = this.__data__, me = En(G, w);
    return me < 0 ? (++this.size, G.push([w, A])) : G[me][1] = A, this;
  }
  de.prototype.clear = he, de.prototype.delete = $e, de.prototype.get = De, de.prototype.has = Ne, de.prototype.set = Re;
  function Ue(w) {
    var A = -1, G = w == null ? 0 : w.length;
    for (this.clear(); ++A < G; ) {
      var me = w[A];
      this.set(me[0], me[1]);
    }
  }
  function rt() {
    this.size = 0, this.__data__ = {
      hash: new Vt(),
      map: new (ir || de)(),
      string: new Vt()
    };
  }
  function dt(w) {
    var A = Rr(this, w).delete(w);
    return this.size -= A ? 1 : 0, A;
  }
  function ct(w) {
    return Rr(this, w).get(w);
  }
  function Ze(w) {
    return Rr(this, w).has(w);
  }
  function et(w, A) {
    var G = Rr(this, w), me = G.size;
    return G.set(w, A), this.size += G.size == me ? 0 : 1, this;
  }
  Ue.prototype.clear = rt, Ue.prototype.delete = dt, Ue.prototype.get = ct, Ue.prototype.has = Ze, Ue.prototype.set = et;
  function qe(w) {
    var A = this.__data__ = new de(w);
    this.size = A.size;
  }
  function vt() {
    this.__data__ = new de(), this.size = 0;
  }
  function kt(w) {
    var A = this.__data__, G = A.delete(w);
    return this.size = A.size, G;
  }
  function Ct(w) {
    return this.__data__.get(w);
  }
  function Nr(w) {
    return this.__data__.has(w);
  }
  function Qr(w, A) {
    var G = this.__data__;
    if (G instanceof de) {
      var me = G.__data__;
      if (!ir || me.length < n - 1)
        return me.push([w, A]), this.size = ++G.size, this;
      G = this.__data__ = new Ue(me);
    }
    return G.set(w, A), this.size = G.size, this;
  }
  qe.prototype.clear = vt, qe.prototype.delete = kt, qe.prototype.get = Ct, qe.prototype.has = Nr, qe.prototype.set = Qr;
  function qs(w, A) {
    var G = vi(w), me = !G && bi(w), Ae = !G && !me && Xs(w), Ce = !G && !me && !Ae && eo(w), Ve = G || me || Ae || Ce, Ie = Ve ? I(w.length, String) : [], Be = Ie.length;
    for (var _t in w)
      (A || Le.call(w, _t)) && !(Ve && // Safari 9 has enumerable `arguments.length` in strict mode.
      (_t == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      Ae && (_t == "offset" || _t == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      Ce && (_t == "buffer" || _t == "byteLength" || _t == "byteOffset") || // Skip index properties.
      Ks(_t, Be))) && Ie.push(_t);
    return Ie;
  }
  function Or(w, A, G) {
    (G !== void 0 && !Ar(w[A], G) || G === void 0 && !(A in w)) && Jr(w, A, G);
  }
  function Hs(w, A, G) {
    var me = w[A];
    (!(Le.call(w, A) && Ar(me, G)) || G === void 0 && !(A in w)) && Jr(w, A, G);
  }
  function En(w, A) {
    for (var G = w.length; G--; )
      if (Ar(w[G][0], A))
        return G;
    return -1;
  }
  function Jr(w, A, G) {
    A == "__proto__" && st ? st(w, A, {
      configurable: !0,
      enumerable: !0,
      value: G,
      writable: !0
    }) : w[A] = G;
  }
  var Ws = bc();
  function Ir(w) {
    return w == null ? w === void 0 ? J : b : ze && ze in Object(w) ? vc(w) : $c(w);
  }
  function Qs(w) {
    return Un(w) && Ir(w) == a;
  }
  function oc(w) {
    if (!tn(w) || Sc(w))
      return !1;
    var A = wi(w) ? x : B;
    return A.test(Rc(w));
  }
  function ac(w) {
    return Un(w) && Zs(w.length) && !!N[Ir(w)];
  }
  function lc(w) {
    if (!tn(w))
      return Tc(w);
    var A = Ys(w), G = [];
    for (var me in w)
      me == "constructor" && (A || !Le.call(w, me)) || G.push(me);
    return G;
  }
  function Js(w, A, G, me, Ae) {
    w !== A && Ws(A, function(Ce, Ve) {
      if (Ae || (Ae = new qe()), tn(Ce))
        uc(w, A, Ve, G, Js, me, Ae);
      else {
        var Ie = me ? me(gi(w, Ve), Ce, Ve + "", w, A, Ae) : void 0;
        Ie === void 0 && (Ie = Ce), Or(w, Ve, Ie);
      }
    }, to);
  }
  function uc(w, A, G, me, Ae, Ce, Ve) {
    var Ie = gi(w, G), Be = gi(A, G), _t = Ve.get(Be);
    if (_t) {
      Or(w, G, _t);
      return;
    }
    var yt = Ce ? Ce(Ie, Be, G + "", w, A, Ve) : void 0, Vn = yt === void 0;
    if (Vn) {
      var Ei = vi(Be), Si = !Ei && Xs(Be), ro = !Ei && !Si && eo(Be);
      yt = Be, Ei || Si || ro ? vi(Ie) ? yt = Ie : Ac(Ie) ? yt = mc(Ie) : Si ? (Vn = !1, yt = dc(Be, !0)) : ro ? (Vn = !1, yt = hc(Be, !0)) : yt = [] : xc(Be) || bi(Be) ? (yt = Ie, bi(Ie) ? yt = Dc(Ie) : (!tn(Ie) || wi(Ie)) && (yt = _c(Be))) : Vn = !1;
    }
    Vn && (Ve.set(Be, yt), Ae(yt, Be, me, Ce, Ve), Ve.delete(Be)), Or(w, G, yt);
  }
  function cc(w, A) {
    return Oc(Nc(w, A, no), w + "");
  }
  var fc = st ? function(w, A) {
    return st(w, "toString", {
      configurable: !0,
      enumerable: !1,
      value: kc(A),
      writable: !0
    });
  } : no;
  function dc(w, A) {
    if (A)
      return w.slice();
    var G = w.length, me = X ? X(G) : new w.constructor(G);
    return w.copy(me), me;
  }
  function pc(w) {
    var A = new w.constructor(w.byteLength);
    return new V(A).set(new V(w)), A;
  }
  function hc(w, A) {
    var G = A ? pc(w.buffer) : w.buffer;
    return new w.constructor(G, w.byteOffset, w.length);
  }
  function mc(w, A) {
    var G = -1, me = w.length;
    for (A || (A = Array(me)); ++G < me; )
      A[G] = w[G];
    return A;
  }
  function yc(w, A, G, me) {
    var Ae = !G;
    G || (G = {});
    for (var Ce = -1, Ve = A.length; ++Ce < Ve; ) {
      var Ie = A[Ce], Be = me ? me(G[Ie], w[Ie], Ie, G, w) : void 0;
      Be === void 0 && (Be = w[Ie]), Ae ? Jr(G, Ie, Be) : Hs(G, Ie, Be);
    }
    return G;
  }
  function gc(w) {
    return cc(function(A, G) {
      var me = -1, Ae = G.length, Ce = Ae > 1 ? G[Ae - 1] : void 0, Ve = Ae > 2 ? G[2] : void 0;
      for (Ce = w.length > 3 && typeof Ce == "function" ? (Ae--, Ce) : void 0, Ve && wc(G[0], G[1], Ve) && (Ce = Ae < 3 ? void 0 : Ce, Ae = 1), A = Object(A); ++me < Ae; ) {
        var Ie = G[me];
        Ie && w(A, Ie, me, Ce);
      }
      return A;
    });
  }
  function bc(w) {
    return function(A, G, me) {
      for (var Ae = -1, Ce = Object(A), Ve = me(A), Ie = Ve.length; Ie--; ) {
        var Be = Ve[w ? Ie : ++Ae];
        if (G(Ce[Be], Be, Ce) === !1)
          break;
      }
      return A;
    };
  }
  function Rr(w, A) {
    var G = w.__data__;
    return Ec(A) ? G[typeof A == "string" ? "string" : "hash"] : G.map;
  }
  function yi(w, A) {
    var G = H(w, A);
    return oc(G) ? G : void 0;
  }
  function vc(w) {
    var A = Le.call(w, ze), G = w[ze];
    try {
      w[ze] = void 0;
      var me = !0;
    } catch {
    }
    var Ae = Je.call(w);
    return me && (A ? w[ze] = G : delete w[ze]), Ae;
  }
  function _c(w) {
    return typeof w.constructor == "function" && !Ys(w) ? mi(pe(w)) : {};
  }
  function Ks(w, A) {
    var G = typeof w;
    return A = A ?? o, !!A && (G == "number" || G != "symbol" && M.test(w)) && w > -1 && w % 1 == 0 && w < A;
  }
  function wc(w, A, G) {
    if (!tn(G))
      return !1;
    var me = typeof A;
    return (me == "number" ? _i(G) && Ks(A, G.length) : me == "string" && A in G) ? Ar(G[A], w) : !1;
  }
  function Ec(w) {
    var A = typeof w;
    return A == "string" || A == "number" || A == "symbol" || A == "boolean" ? w !== "__proto__" : w === null;
  }
  function Sc(w) {
    return !!ut && ut in w;
  }
  function Ys(w) {
    var A = w && w.constructor, G = typeof A == "function" && A.prototype || Te;
    return w === G;
  }
  function Tc(w) {
    var A = [];
    if (w != null)
      for (var G in Object(w))
        A.push(G);
    return A;
  }
  function $c(w) {
    return Je.call(w);
  }
  function Nc(w, A, G) {
    return A = nr(A === void 0 ? w.length - 1 : A, 0), function() {
      for (var me = arguments, Ae = -1, Ce = nr(me.length - A, 0), Ve = Array(Ce); ++Ae < Ce; )
        Ve[Ae] = me[A + Ae];
      Ae = -1;
      for (var Ie = Array(A + 1); ++Ae < A; )
        Ie[Ae] = me[Ae];
      return Ie[A] = G(Ve), O(w, this, Ie);
    };
  }
  function gi(w, A) {
    if (!(A === "constructor" && typeof w[A] == "function") && A != "__proto__")
      return w[A];
  }
  var Oc = Ic(fc);
  function Ic(w) {
    var A = 0, G = 0;
    return function() {
      var me = rr(), Ae = s - (me - G);
      if (G = me, Ae > 0) {
        if (++A >= i)
          return arguments[0];
      } else
        A = 0;
      return w.apply(void 0, arguments);
    };
  }
  function Rc(w) {
    if (w != null) {
      try {
        return we.call(w);
      } catch {
      }
      try {
        return w + "";
      } catch {
      }
    }
    return "";
  }
  function Ar(w, A) {
    return w === A || w !== w && A !== A;
  }
  var bi = Qs(function() {
    return arguments;
  }()) ? Qs : function(w) {
    return Un(w) && Le.call(w, "callee") && !Ge.call(w, "callee");
  }, vi = Array.isArray;
  function _i(w) {
    return w != null && Zs(w.length) && !wi(w);
  }
  function Ac(w) {
    return Un(w) && _i(w);
  }
  var Xs = nt || Lc;
  function wi(w) {
    if (!tn(w))
      return !1;
    var A = Ir(w);
    return A == p || A == h || A == c || A == y;
  }
  function Zs(w) {
    return typeof w == "number" && w > -1 && w % 1 == 0 && w <= o;
  }
  function tn(w) {
    var A = typeof w;
    return w != null && (A == "object" || A == "function");
  }
  function Un(w) {
    return w != null && typeof w == "object";
  }
  function xc(w) {
    if (!Un(w) || Ir(w) != E)
      return !1;
    var A = pe(w);
    if (A === null)
      return !0;
    var G = Le.call(A, "constructor") && A.constructor;
    return typeof G == "function" && G instanceof G && we.call(G) == bt;
  }
  var eo = $ ? L($) : ac;
  function Dc(w) {
    return yc(w, to(w));
  }
  function to(w) {
    return _i(w) ? qs(w, !0) : lc(w);
  }
  var Pc = gc(function(w, A, G, me) {
    Js(w, A, G, me);
  });
  function kc(w) {
    return function() {
      return w;
    };
  }
  function no(w) {
    return w;
  }
  function Lc() {
    return !1;
  }
  e.exports = Pc;
})(su, su.exports);
var gV = su.exports, ai = {}, bV = We && We.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(ai, "__esModule", { value: !0 });
ai.memoize4 = ai.memoize3 = ai.memoize2 = void 0;
const Pr = bV(qE);
function vV(e) {
  return (t, n) => e(t)(n);
}
function _V(e) {
  return (t, n, r) => e(t)(n)(r);
}
function wV(e) {
  return (t, n, r, i) => e(t)(n)(r)(i);
}
function EV(e) {
  return vV((0, Pr.default)((t) => (0, Pr.default)((n) => e(t, n))));
}
ai.memoize2 = EV;
function SV(e) {
  return _V((0, Pr.default)((t) => (0, Pr.default)((n) => (0, Pr.default)((r) => e(t, n, r)))));
}
ai.memoize3 = SV;
function TV(e) {
  return wV((0, Pr.default)((t) => (0, Pr.default)((n) => (0, Pr.default)((r) => (0, Pr.default)((i) => e(t, n, r, i))))));
}
ai.memoize4 = TV;
var Wh = We && We.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(jr, "__esModule", { value: !0 });
jr.fieldExpansionEnricher = jr.createResolveInfoThunk = jr.isLeafField = void 0;
const $V = Wh(Gu), Rn = Ln, NV = Wh(qE), OV = Wh(gV), Aa = ai, HE = Symbol("LeafFieldSymbol");
function IV(e) {
  return {
    [HE]: !0,
    ...e
  };
}
function Ol(e) {
  return e != null && Object.prototype.hasOwnProperty.call(e, HE);
}
jr.isLeafField = Ol;
function RV({ schema: e, fragments: t, operation: n, parentType: r, fieldName: i, fieldType: s, fieldNodes: o }, a) {
  let l = {};
  typeof a == "function" && (l = a({
    fieldName: i,
    fieldNodes: o,
    returnType: s,
    parentType: r,
    schema: e,
    fragments: t,
    operation: n
  }) || {}, (typeof l != "object" || Array.isArray(l)) && (l = {}));
  const c = (0, $V.default)();
  return c(`return function getGraphQLResolveInfo(rootValue, variableValues, path) {
      return {
          fieldName,
          fieldNodes,
          returnType: fieldType,
          parentType,
          path,
          schema,
          fragments,
          rootValue,
          operation,
          variableValues,`), Object.keys(l).forEach((u) => {
    c(`${u}: enrichedInfo["${u}"],
`);
  }), c("};};"), new Function("fieldName", "fieldNodes", "fieldType", "parentType", "schema", "fragments", "operation", "enrichedInfo", c.toString()).call(null, i, o, s, r, e, t, n, l);
}
jr.createResolveInfoThunk = RV;
function AV(e) {
  const { schema: t, fragments: n, returnType: r, fieldNodes: i } = e, s = {};
  for (const o of i)
    JE(s, QE(t, n, o, r));
  return {
    fieldExpansion: s
  };
}
jr.fieldExpansionEnricher = AV;
const xV = (0, Aa.memoize2)(CV), DV = (0, Aa.memoize2)(FV), Qh = (0, NV.default)(MV), PV = (0, Aa.memoize2)(jV), WE = (0, Aa.memoize4)(LV), QE = (0, Aa.memoize4)(kV);
function kV(e, t, n, r) {
  if (n.selectionSet == null)
    return IV({});
  const i = Qh(r), s = PV(e, i), o = {};
  for (const a of s)
    (0, Rn.isUnionType)(a) || (o[a.name] = WE(e, t, a, n.selectionSet));
  return o;
}
function LV(e, t, n, r) {
  const i = {};
  for (const s of r.selections)
    if (s.kind === Rn.Kind.FIELD)
      !(0, Rn.isUnionType)(n) && DV(n, s.name.value) && (i[s.name.value] = QE(e, t, s, xV(n, s.name.value)));
    else {
      const o = s.kind === Rn.Kind.INLINE_FRAGMENT ? s.selectionSet : t[s.name.value].selectionSet, a = s.kind === Rn.Kind.INLINE_FRAGMENT ? s.typeCondition ? e.getType(s.typeCondition.name.value) : n : e.getType(t[s.name.value].typeCondition.name.value);
      (a === n || (0, Rn.isAbstractType)(a)) && JE(i, WE(e, t, n, o));
    }
  return i;
}
function jV(e, t) {
  if ((0, Rn.isObjectType)(t))
    return [t];
  const n = [], r = e.getTypeMap();
  for (const i in r)
    if (Object.prototype.hasOwnProperty.call(r, i)) {
      const s = r[i];
      (0, Rn.isCompositeType)(s) && (0, Rn.doTypesOverlap)(e, s, t) && n.push(s);
    }
  return n;
}
function CV(e, t) {
  const n = e.getFields();
  if (!Object.prototype.hasOwnProperty.call(n, t))
    throw new Rn.GraphQLError(`Field "${t}" does not exist in "${e.name}"`);
  const r = n[t].type;
  return Qh(r);
}
function MV(e) {
  return (0, Rn.isListType)(e) || (0, Rn.isNonNullType)(e) ? Qh(e.ofType) : e;
}
function FV(e, t) {
  return Object.prototype.hasOwnProperty.call(e.getFields(), t);
}
function JE(e, t) {
  (0, OV.default)(e, t, (n, r) => {
    if (Ol(n))
      return Ol(r) ? {
        ...n,
        ...r
      } : n;
    if (Ol(r))
      return r;
  });
}
var Ii = {}, c0;
function UV() {
  if (c0)
    return Ii;
  c0 = 1;
  var e = We && We.__importDefault || function(b) {
    return b && b.__esModule ? b : { default: b };
  };
  Object.defineProperty(Ii, "__esModule", { value: !0 }), Ii.compileVariableParsing = Ii.failToParseVariables = void 0;
  const t = e(Gu), n = Ln, r = rc(), i = Ra, o = (0, e(tc).default)();
  function a(b) {
    return b.errors;
  }
  Ii.failToParseVariables = a;
  function l(b) {
    return { ...b };
  }
  function c(b, E) {
    const y = [], D = /* @__PURE__ */ Object.create(null);
    let F = "";
    const W = /* @__PURE__ */ new Map();
    for (const Z of E) {
      const j = {
        varDefNode: Z,
        depth: 0,
        inputPath: (0, r.addPath)(void 0, "input"),
        responsePath: (0, r.addPath)(void 0, "coerced"),
        dependencies: W
      }, ee = Z.variable.name.value, le = (0, n.typeFromAST)(b, Z.type);
      if (!le || !(0, n.isInputType)(le)) {
        y.push(new i.GraphQLError(`Variable "$${ee}" expected value of type "${le || (0, n.print)(Z.type)}" which cannot be used as an input type.`, (0, r.computeLocations)([Z.type])));
        continue;
      }
      D[ee] = void 0;
      const ce = p((0, r.addPath)(j.inputPath, ee));
      F += `const ${ce} = Object.prototype.hasOwnProperty.call(${m(j.inputPath)}, "${ee}");
`, j.inputPath = (0, r.addPath)(j.inputPath, ee), j.responsePath = (0, r.addPath)(j.responsePath, ee), F += d(j, le, ee, ce, (0, n.valueFromAST)(Z.defaultValue, le), !1);
    }
    if (y.length > 0)
      throw y;
    const J = (0, t.default)();
    return J(`
    return function getVariables(input) {
      const errors = [];
      const coerced = ${JSON.stringify(D)}
      ${F}
      if (errors.length > 0) {
        return {errors, coerced: undefined};
      }
      return {errors: undefined, coerced};
    }
  `), Function.apply(null, ["GraphQLJITError", "inspect"].concat(Array.from(W.keys())).concat(J.toString())).apply(null, [i.GraphQLError, o].concat(Array.from(W.values())));
  }
  Ii.compileVariableParsing = c;
  const u = 2147483647, f = -2147483648;
  function d(b, E, y, D, F, W) {
    const J = m(b.responsePath), Z = m(b.inputPath), j = h((0, r.computeLocations)([b.varDefNode])), ee = (0, t.default)();
    if (ee(`if (${Z} == null) {`), (0, n.isNonNullType)(E)) {
      let le, ce;
      if (b.errorMessage) {
        const U = v(b.responsePath);
        le = `${b.errorMessage} + \`Expected non-nullable type ${E} not to be null at ${U}.\``, ce = `${b.errorMessage} + \`Field ${U} of required type ${E} was not provided.\``;
      } else
        le = `'Variable "$${y}" of non-null type "${E}" must not be null.'`, ce = `'Variable "$${y}" of required type "${E}" was not provided.'`;
      E = E.ofType, ee(`
      if (${J} == null) {
        errors.push(new GraphQLJITError(${D} ? ${le} : ${ce}, ${j}));
      }
    `);
    } else
      ee(`
      if (${D}) { ${J} = null; }
    `), F !== void 0 && ee(`else { ${J} = ${JSON.stringify(F)} }`);
    if (ee("} else {"), (0, n.isScalarType)(E))
      switch (E.name) {
        case n.GraphQLID.name:
          ee(`
          if (typeof ${Z} === "string") {
            ${J} = ${Z};
          } else if (Number.isInteger(${Z})) {
            ${J} = ${Z}.toString();
          } else {
            errors.push(new GraphQLJITError('Variable "$${y}" got invalid value ' +
              inspect(${Z}) + "; " +
              'Expected type ${E.name}; ' +
              '${E.name} cannot represent value: ' +
              inspect(${Z}), ${j})
            );
          }
        `);
          break;
        case n.GraphQLString.name:
          ee(`
          if (typeof ${Z} === "string") {
              ${J} = ${Z};
          } else {
            errors.push(new GraphQLJITError('Variable "$${y}" got invalid value ' +
              inspect(${Z}) + "; " +
              'Expected type ${E.name}; ' +
              '${E.name} cannot represent a non string value: ' +
              inspect(${Z}), ${j})
            );
          }
        `);
          break;
        case n.GraphQLBoolean.name:
          ee(`
        if (typeof ${Z} === "boolean") {
            ${J} = ${Z};
        } else {
          errors.push(new GraphQLJITError('Variable "$${y}" got invalid value ' +
          inspect(${Z}) + "; " +
          'Expected type ${E.name}; ' +
          '${E.name} cannot represent a non boolean value: ' +
          inspect(${Z}), ${j}));
        }
        `);
          break;
        case n.GraphQLInt.name:
          ee(`
        if (Number.isInteger(${Z})) {
          if (${Z} > ${u} || ${Z} < ${f}) {
            errors.push(new GraphQLJITError('Variable "$${y}" got invalid value ' +
            inspect(${Z}) + "; " +
            'Expected type ${E.name}; ' +
            '${E.name} cannot represent non 32-bit signed integer value: ' +
            inspect(${Z}), ${j}));
          } else {
            ${J} = ${Z};
          }
        } else {
          errors.push(new GraphQLJITError('Variable "$${y}" got invalid value ' +
            inspect(${Z}) + "; " +
            'Expected type ${E.name}; ' +
            '${E.name} cannot represent non-integer value: ' +
            inspect(${Z}), ${j})
          );
        }
        `);
          break;
        case n.GraphQLFloat.name:
          ee(`
        if (Number.isFinite(${Z})) {
            ${J} = ${Z};
        } else {
          errors.push(new GraphQLJITError('Variable "$${y}" got invalid value ' +
            inspect(${Z}) + "; " +
            'Expected type ${E.name}; ' +
            '${E.name} cannot represent non numeric value: ' +
            inspect(${Z}), ${j})
          );
        }
        `);
          break;
        default:
          b.dependencies.set(`${E.name}parseValue`, E.parseValue.bind(E)), ee(`
          try {
            const parseResult = ${E.name}parseValue(${Z});
            if (parseResult === undefined || parseResult !== parseResult) {
              errors.push(new GraphQLJITError('Variable "$${y}" got invalid value ' +
              inspect(${Z}) + "; " +
              'Expected type ${E.name}.', ${j}));
            }
            ${J} = parseResult;
          } catch (error) {
            errors.push(new GraphQLJITError('Variable "$${y}" got invalid value ' +
              inspect(${Z}) + "; " +
              'Expected type ${E.name}.', ${j}, undefined, error)
            );
          }
        `);
      }
    else if ((0, n.isEnumType)(E))
      b.dependencies.set(`${E.name}getValue`, E.getValue.bind(E)), ee(`
      if (typeof ${Z} === "string") {
        const enumValue = ${E.name}getValue(${Z});
        if (enumValue) {
          ${J} = enumValue.value;
        } else {
          errors.push(
            new GraphQLJITError('Variable "$${y}" got invalid value ' +
            inspect(${Z}) + "; " +
            'Expected type ${E.name}.', ${j})
          );
        }
      } else {
        errors.push(
          new GraphQLJITError('Variable "$${y}" got invalid value ' +
          inspect(${Z}) + "; " +
          'Expected type ${E.name}.', ${j})
        );
      }
      `);
    else if ((0, n.isListType)(E)) {
      b.errorMessage = `'Variable "$${y}" got invalid value ' + inspect(${Z}) + '; '`;
      const le = p(b.inputPath), ce = `idx${b.depth}`, U = l(b);
      U.responsePath = (0, r.addPath)(U.responsePath, ce, "variable"), U.inputPath = (0, r.addPath)(U.inputPath, ce, "variable"), U.depth++, ee(`
      if (Array.isArray(${Z})) {
        ${J} = [];
        for (let ${ce} = 0; ${ce} < ${Z}.length; ++${ce}) {
          const ${le} =
          ${m(U.inputPath)} !== undefined;
          ${d(U, E.ofType, y, le, void 0, !1)}
        }
      } else {
        ${d(b, E.ofType, y, le, void 0, !0)}
      }
    `);
    } else if ((0, n.isInputType)(E)) {
      ee(`
      if (typeof ${Z} !== 'object') {
        errors.push(new GraphQLJITError('Variable "$${y}" got invalid value ' +
        inspect(${Z}) + "; " +
        'Expected type ${E.name} to be an object.', ${j}));
      } else {
        ${J} = {};
    `);
      const le = E.getFields(), ce = [];
      for (const U of Object.values(le)) {
        const z = l(b);
        ce.push(U.name);
        const ne = p((0, r.addPath)(z.inputPath, U.name));
        ee(`
        const ${ne} = Object.prototype.hasOwnProperty.call(
          ${m(z.inputPath)}, "${U.name}"
        );
      `), z.inputPath = (0, r.addPath)(z.inputPath, U.name), z.responsePath = (0, r.addPath)(z.responsePath, U.name), z.errorMessage = `'Variable "$${y}" got invalid value ' + inspect(${Z}) + '; '`, ee(`
        ${d(z, U.type, U.name, ne, U.defaultValue, !1)}
      `);
      }
      ee(`
      const allowedFields = ${JSON.stringify(ce)};
      for (const fieldName of Object.keys(${Z})) {
        if (!allowedFields.includes(fieldName)) {
          errors.push(new GraphQLJITError('Variable "$${y}" got invalid value ' +
            inspect(${Z}) + "; " +
            'Field "' + fieldName + '" is not defined by type ${E.name}.', ${j}));
          break;
        }
      }
    }`);
    } else
      throw new Error(`unknown type: ${E}`);
    return W && ee(`${J} = [${J}];`), ee("}"), ee.toString();
  }
  function p(b) {
    const E = [];
    let y = b;
    for (; y; )
      E.push(y.key), y = y.prev;
    return `hasValue${E.join("_")}`;
  }
  function h(b) {
    return JSON.stringify(b);
  }
  function m(b) {
    const E = [];
    let y = b;
    for (; y; )
      E.unshift({ key: y.key, type: y.type }), y = y.prev;
    let D = E[0].key;
    for (let F = 1; F < E.length; ++F)
      D += E[F].type === "literal" ? `["${E[F].key}"]` : `[${E[F].key}]`;
    return D;
  }
  function v(b) {
    const E = [];
    let y = b;
    for (; y; )
      E.unshift({ key: y.key, type: y.type }), y = y.prev;
    const D = Math.min(E.length - 1, 1);
    let F = "value";
    for (let W = D + 1; W < E.length; ++W)
      F += E[W].type === "literal" ? `.${E[W].key}` : `[\${${E[W].key}}]`;
    return F;
  }
  return Ii;
}
var f0;
function KE() {
  return f0 || (f0 = 1, function(e) {
    var t = We && We.__importDefault || function(ie) {
      return ie && ie.__esModule ? ie : { default: ie };
    };
    Object.defineProperty(e, "__esModule", { value: !0 }), e.isAsyncIterable = e.isPromiseInliner = e.isPromise = e.createBoundQuery = e.isCompiledQuery = e.compileQuery = e.GLOBAL_VARIABLES_NAME = void 0;
    const n = t(JC), r = t(Gu), i = Ln, s = eM, o = rc(), a = Ra, l = t(tc), c = DU(), u = kU(), f = jr, d = UV(), p = bn, h = (0, l.default)(), m = "__validNode", v = "__context.data", b = "__context.errors", E = "__context.nullErrors", y = "__context.rootValue";
    e.GLOBAL_VARIABLES_NAME = "__context.variables";
    const D = "__context.context", F = "__context", W = "__context.promiseCounter", J = "__context.inspect", Z = "__context.safeMap", j = "__context.GraphQLError", ee = "__context.resolve", le = "__parent", ce = "__field";
    function U(ie, R, C, fe) {
      if (!ie)
        throw new Error(`Expected ${ie} to be a GraphQL schema.`);
      if (!R)
        throw new Error("Must provide document.");
      if (fe && fe.resolverInfoEnricher && typeof fe.resolverInfoEnricher != "function")
        throw new Error("resolverInfoEnricher must be a function");
      try {
        const de = {
          disablingCapturingStackErrors: !1,
          customJSONSerializer: !1,
          disableLeafSerialization: !1,
          customSerializers: {},
          useExperimentalPathBasedSkipInclude: !1,
          ...fe
        }, he = g(ie, R, de, C);
        let $e;
        if (de.customJSONSerializer) {
          const dt = (0, c.queryToJSONSchema)(he);
          $e = (0, n.default)(dt);
        } else
          $e = JSON.stringify;
        const De = (0, d.compileVariableParsing)(ie, he.operation.variableDefinitions || []), Ne = (0, p.getOperationRootType)(he.schema, he.operation), Re = (0, o.collectFields)(he, Ne, he.operation.selectionSet, /* @__PURE__ */ Object.create(null), /* @__PURE__ */ Object.create(null)), Ue = se(he, Ne, Re), rt = {
          query: ne(
            he,
            R,
            // eslint-disable-next-line no-new-func
            new Function("return " + Ue)(),
            De,
            he.operation.name != null ? he.operation.name.value : void 0
          ),
          stringify: $e
        };
        return he.operation.operation === "subscription" && (rt.subscribe = Vt(he, R, mi(he, Ne, Re, rt.query), De, he.operation.name != null ? he.operation.name.value : void 0)), de.debug && (rt.__DO_NOT_USE_THIS_OR_YOU_WILL_BE_FIRED_compilation = Ue), rt;
      } catch (de) {
        return {
          errors: st(de)
        };
      }
    }
    e.compileQuery = U;
    function z(ie) {
      return "query" in ie && typeof ie.query == "function";
    }
    e.isCompiledQuery = z;
    function ne(ie, R, C, fe, de) {
      const { resolvers: he, typeResolvers: $e, isTypeOfs: De, serializers: Ne, resolveInfos: Re } = ie, Ue = (0, u.createNullTrimmer)(ie), rt = de || "query";
      return {
        [rt](ct, Ze, et) {
          const qe = fe(et || {});
          if ((0, d.failToParseVariables)(qe))
            return { errors: qe.errors };
          const vt = {
            rootValue: ct,
            context: Ze,
            variables: qe.coerced,
            safeMap: k,
            inspect: h,
            GraphQLError: a.GraphQLError,
            resolvers: he,
            typeResolvers: $e,
            isTypeOfs: De,
            serializers: Ne,
            resolveInfos: Re,
            trimmer: Ue,
            promiseCounter: 0,
            data: {},
            nullErrors: [],
            errors: []
          }, kt = C.call(null, vt);
          return Te(kt) ? kt.then(K) : K(vt);
        }
      }[rt];
    }
    e.createBoundQuery = ne;
    function K({ data: ie, nullErrors: R, errors: C, trimmer: fe }) {
      if (R.length > 0) {
        const de = fe(ie, R);
        return {
          data: de.data,
          errors: C.concat(de.errors)
        };
      } else if (C.length > 0)
        return {
          data: ie,
          errors: C
        };
      return { data: ie };
    }
    function se(ie, R, C) {
      const fe = ie.operation.operation === "mutation", de = N(ie, R, [], [y], [v], void 0, b, C, !0);
      let he = `function query (${F}) {
  "use strict";
`;
      return fe && (he += `${F}.queue = [];`), he += Ee(ie, !0), he += `${v} = ${de}
`, fe ? (he += te(ie), he += `
    ${F}.finalResolve = () => {};
    ${ee} = (context) => {
      if (context.jobCounter >= context.queue.length) {
        // All mutations have finished
        context.finalResolve(context);
        return;
      }
      context.queue[context.jobCounter++](context);
    };
    // There might not be a job to run due to invalid queries
    if (${F}.queue.length > 0) {
      ${F}.jobCounter = 1; // since the first one will be run manually
      ${F}.queue[0](${F});
    }
    // Promises have been scheduled so a new promise is returned
    // that will be resolved once every promise is done
    if (${W} > 0) {
      return new Promise(resolve => ${F}.finalResolve = resolve);
    }
  `) : (he += re(ie), he += `
    // Promises have been scheduled so a new promise is returned
    // that will be resolved once every promise is done
    if (${W} > 0) {
      return new Promise(resolve => ${ee} = resolve);
    }`), he += `
  // sync execution, the results are ready
  return undefined;
  }`, he += ie.hoistedFunctions.join(`
`), he;
    }
    function re(ie) {
      let R = "";
      return ie.deferred.forEach((C, fe) => {
        R += `
      if (${m}${fe}) {
        ${ue(ie, C)}
      }`;
      }), R;
    }
    function ue(ie, R, C) {
      const { name: fe, originPaths: de, destinationPaths: he, fieldNodes: $e, fieldType: De, fieldName: Ne, jsFieldName: Re, responsePath: Ue, parentType: rt, args: dt } = R, ct = Oe(ie), Ze = B(ct, rt, De, $e, [Re], [`${le}.${fe}`], Ue), et = rr(ie), qe = pe(rt.name, Ne), vt = V(ie, `${fe}${qe}Handler`), kt = I(qe), Ct = L(qe), Nr = X(ie, $e, Ue, "err.message != null ? err.message : err", "err"), Qr = O(ct, rt, De, Ne, $e, Ue), qs = X(ie, $e, Ue, '""'), Or = de.join("."), Hs = `${F}.resolvers.${qe}(
          ${Or},${kt},${D}, ${Qr})`, En = he.join("."), Ws = `
    ${ae(ct, dt, kt, Ct, De, Ue)}
    if (${Ct} === true) {
      var __value = null;
      try {
        __value = ${Hs};
      } catch (err) {
        ${Le(De)}.push(${Nr});
      }
      if (${Me("__value")}) {
      ${ft()}
       __value.then(result => {
        ${vt}(${F}, ${En}, result, ${et});
        ${ze()}
       }, err => {
        if (err) {
          ${Le(De)}.push(${Nr});
        } else {
          ${Le(De)}.push(${qs});
        }
        ${ze()}
       });
      } else {
        ${vt}(${F}, ${En}, __value, ${et});
      }
    }`;
      return ie.hoistedFunctions.push(`
    function ${vt}(${F}, ${le}, ${Re}, ${et}) {
      ${Ee(ct)}
      ${le}.${fe} = ${Ze};
      ${re(ct)}
      ${C || ""}
    }
  `), Ws;
    }
    function te(ie) {
      let R = "";
      return ie.deferred.forEach((C, fe) => {
        const { name: de, fieldName: he, parentType: $e } = C, De = pe($e.name, he), Ne = V(ie, `${de}${De}Mutation`);
        R += `
      if (${m}${fe}) {
        ${F}.queue.push(${Ne});
      }
    `;
        const Re = `
    if (${W} === 0) {
      ${ee}(${F});
    }
    `;
        ie.hoistedFunctions.push(`
      function ${Ne}(${F}) {
        ${ue(ie, C, Re)}
      }
      `);
      }), R;
    }
    function B(ie, R, C, fe, de, he, $e) {
      const De = de.join(".");
      let Ne = `${De} == null ? `, Re;
      if ((0, i.isNonNullType)(C)) {
        C = C.ofType;
        const rt = `"Cannot return null for non-nullable field ${R.name}.${_(fe)}."`;
        Ne += `(${E}.push(${X(ie, fe, $e, rt)}), null) :`, Re = E;
      } else
        Ne += "null : ", Re = b;
      Ne += "(";
      const Ue = `${De}.message != null ? ${De}.message : ${De}`;
      if (Ne += `${De} instanceof Error ? (${Re}.push(${X(ie, fe, $e, Ue, De)}), null) : `, (0, i.isLeafType)(C))
        Ne += M(ie, C, de, fe, $e, Re);
      else if ((0, i.isObjectType)(C)) {
        const rt = (0, o.collectSubfields)(ie, C, fe, $e);
        Ne += N(ie, C, fe, de, he, $e, Re, rt, !1);
      } else if ((0, i.isAbstractType)(C))
        Ne += T(ie, R, C, fe, de, $e, Re);
      else if ((0, i.isListType)(C))
        Ne += P(ie, R, C, fe, de, $e, Re);
      else
        throw new Error(`unsupported type: ${C.toString()}`);
      return Ne += ")", Ne;
    }
    function M(ie, R, C, fe, de, he) {
      let $e = "";
      if (ie.options.disableLeafSerialization && (R instanceof i.GraphQLEnumType || (0, i.isSpecifiedScalarType)(R)))
        $e += `${C.join(".")}`;
      else {
        const De = Ge(R.name);
        ie.serializers[De] = bt(R, ie.options.customSerializers[R.name]);
        const Ne = rr(ie), Re = V(ie, `${R.name}${C.join("")}SerializerErrorHandler`);
        ie.hoistedFunctions.push(`
    function ${Re}(${F}, message, ${Ne}) {
    ${he}.push(${X(ie, fe, de, "message")});}
    `), $e += `${F}.serializers.${De}(${F}, ${C.join(".")}, ${Re}, ${Ne})`;
      }
      return $e;
    }
    function N(ie, R, C, fe, de, he, $e, De, Ne) {
      const Re = (0, r.default)();
      Re("("), typeof R.isTypeOf == "function" && !Ne && (ie.isTypeOfs[R.name + "IsTypeOf"] = R.isTypeOf, Re(`!${F}.isTypeOfs["${R.name}IsTypeOf"](${fe.join(".")}) ? (${$e}.push(${X(ie, C, he, `\`Expected value of type "${R.name}" but got: \${${J}(${fe.join(".")})}.\``)}), null) :`)), Re("{");
      for (const Ue of Object.keys(De)) {
        const rt = De[Ue], dt = (0, o.resolveFieldDef)(ie, R, rt);
        if (!dt)
          continue;
        Re(`"${Ue}": `);
        const ct = (0, o.joinSkipIncludePath)((0, o.serializeObjectPathForSkipInclude)(he), Ue), Ze = ie.options.useExperimentalPathBasedSkipInclude ? rt.map((qe) => qe.__internalShouldIncludePath?.[ct]).filter((qe) => qe).join(" || ") || /* if(true) - default */
        "true" : rt.map((qe) => qe.__internalShouldInclude).filter((qe) => qe).join(" || ") || /* if(true) - default */
        "true";
        if (Re(`
      (
        ${Ze}
      )
    `), dt === i.TypeNameMetaFieldDef) {
          Re(`? "${R.name}" : undefined,`);
          continue;
        }
        let et = dt.resolve;
        if (!et && Ne) {
          const qe = dt.name;
          et = (vt) => vt && vt[qe];
        }
        et ? (ie.deferred.push({
          name: Ue,
          responsePath: (0, o.addPath)(he, Ue),
          originPaths: fe,
          destinationPaths: de,
          parentType: R,
          fieldName: dt.name,
          jsFieldName: ir(dt.name),
          fieldType: dt.type,
          fieldNodes: rt,
          args: (0, o.getArgumentDefs)(dt, rt[0])
        }), ie.resolvers[pe(R.name, dt.name)] = et, Re(`
          ? (
              ${m}${ie.deferred.length - 1} = true,
              null
            )
          : (
              ${m}${ie.deferred.length - 1} = false,
              undefined
            )
        `)) : (Re("?"), Re(B(ie, R, dt.type, rt, fe.concat(dt.name), de.concat(Ue), (0, o.addPath)(he, Ue))), Re(": undefined")), Re(",");
      }
      return Re("}"), Re(")"), Re.toString();
    }
    function T(ie, R, C, fe, de, he, $e) {
      let De;
      C.resolveType ? De = C.resolveType : De = (Ze, et, qe) => x(Ze, et, qe, C);
      const Ne = ye(C.name);
      ie.typeResolvers[Ne] = De;
      const Re = ie.schema.getPossibleTypes(C).map((Ze) => {
        const et = Oe(ie), qe = B(et, R, Ze, fe, de, ["__concrete"], (0, o.addPath)(he, Ze.name, "meta"));
        return `case "${Ze.name}": {
                  ${Ee(et)}
                  const __concrete = ${qe};
                  ${re(et)}
                  return __concrete;
              }`;
      }).join(`
`), Ue = "finalType", rt = `"Runtime Object type is not a possible type for \\"${C.name}\\"."`, dt = (
        // eslint-disable-next-line no-template-curly-in-string
        '`Runtime Object type "${nodeType}" is not a possible type for "' + C.name + '".`'
      ), ct = `${Ue} ? ${dt} : "Abstract type ${C.name} must resolve to an Object type at runtime for field ${R.name}.${_(fe)}. Either the ${C.name} type should provide a \\"resolveType\\" function or each possible types should provide an \\"isTypeOf\\" function."`;
      return `((nodeType, err) =>
  {
    if (err != null) {
      ${$e}.push(${X(ie, fe, he, "err.message != null ? err.message : err", "err")});
      return null;
    }
    if (nodeType == null) {
      ${$e}.push(${X(ie, fe, he, rt)})
      return null;
    }
    const ${Ue} = typeof nodeType === "string" ? nodeType : nodeType.name;
    switch(${Ue}) {
      ${Re}
      default:
      ${$e}.push(${X(ie, fe, he, ct)})
      return null;
    }
  })(
    ${F}.typeResolvers.${Ne}(${de.join(".")},
    ${D},
    ${O(ie, R, C, C.name, fe, he)}))`;
    }
    function P(ie, R, C, fe, de, he, $e) {
      const De = de.join("."), Ne = Oe(ie), Re = ++Ne.depth, Ue = C.ofType, rt = B(Ne, R, Ue, fe, ["__currentItem"], [`${le}[idx${Re}]`], (0, o.addPath)(he, "idx" + Re, "variable")), dt = `"Expected Iterable, but did not find one for field ${R.name}.${_(fe)}."`, ct = `(${$e}.push(${X(ie, fe, he, dt)}), null)`, Ze = X(ie, fe, (0, o.addPath)(he, "idx" + Re, "variable"), "err.message != null ? err.message : err", "err"), et = X(ie, fe, he, '""'), qe = Ee(Ne), vt = re(Ne), kt = V(ie, `${R.name}${de.join("")}MapItemHandler`), Ct = rr(Ne);
      Ne.hoistedFunctions.push(`
  function ${kt}(${F}, ${le}, __currentItem, ${Ct}) {
    ${qe}
    ${le}[idx${Re}] = ${rt};
    ${vt}
  }
  `);
      const Nr = V(ie, `${R.name}${de.join("")}MapHandler`), Qr = rr(ie);
      return Ne.hoistedFunctions.push(`
  function ${Nr}(${F}, __currentItem, idx${Re}, resultArray, ${Qr}) {
    if (${Me("__currentItem")}) {
      ${ft()}
      __currentItem.then(result => {
        ${kt}(${F}, resultArray, result, ${Ct});
        ${ze()}
      }, err => {
        resultArray.push(null);
        if (err) {
          ${Le(Ue)}.push(${Ze});
        } else {
          ${Le(Ue)}.push(${et});
        }
        ${ze()}
      });
    } else {
       ${kt}(${F}, resultArray, __currentItem, ${Ct});
    }
  }
  `), `(typeof ${De} === "string" || typeof ${De}[Symbol.iterator] !== "function") ?  ${ct} :
  ${Z}(${F}, ${De}, ${Nr}, ${Qr})`;
    }
    function k(ie, R, C, ...fe) {
      let de = 0;
      const he = [];
      for (const $e of R)
        C(ie, $e, de, he, ...fe), ++de;
      return he;
    }
    const q = "__MAGIC_MINUS_INFINITY__71d4310a_d4a3_4a05_b1fe_e60779d24998", Y = "__MAGIC_PLUS_INFINITY__bb201c39_3333_4695_b4ad_7f1722e7aa7a", ve = "__MAGIC_NAN__57f286b9_4c20_487f_b409_79804ddcb4f8", oe = "__MAGIC_DATE__33a9e76d_02e0_4128_8e92_3530ad3da74d";
    function S(ie, R) {
      return Number.isNaN(R) ? ve : R === 1 / 0 ? Y : R === -1 / 0 ? q : this[ie] instanceof Date ? oe + this[ie].getTime() : R;
    }
    function $(ie) {
      return JSON.stringify(ie, S).replace(new RegExp(`"${ve}"`, "g"), "NaN").replace(new RegExp(`"${Y}"`, "g"), "Infinity").replace(new RegExp(`"${q}"`, "g"), "-Infinity").replace(new RegExp(`"${oe}([^"]+)"`, "g"), "new Date($1)");
    }
    function O(ie, R, C, fe, de, he) {
      const $e = ut(he), { schema: De, fragments: Ne, operation: Re } = ie;
      return ie.resolveInfos[$e] = (0, f.createResolveInfoThunk)({
        schema: De,
        fragments: Ne,
        operation: Re,
        parentType: R,
        fieldName: fe,
        fieldType: C,
        fieldNodes: de
      }, ie.options.resolverInfoEnricher), `${F}.resolveInfos.${$e}(${y}, ${e.GLOBAL_VARIABLES_NAME}, ${Je(he)})`;
    }
    function I(ie) {
      return `${ie}Args`;
    }
    function L(ie) {
      return `${ie}ValidArgs`;
    }
    function H(ie, R) {
      if (!R)
        return ie;
      let C = ie;
      const fe = (0, o.flattenPath)(R);
      for (const de of fe)
        if (de.type === "literal")
          C += `["${de.key}"]`;
        else
          throw new Error("should only have received literal paths");
      return C;
    }
    function ae(ie, R, C, fe, de, he) {
      let $e = `
  let ${fe} = true;
  const ${C} = ${$(R.values)};
  `;
      const De = Le(de);
      for (const Ne of R.missing) {
        const Re = Ne.valueNode.name.value;
        if ($e += `if (Object.prototype.hasOwnProperty.call(${e.GLOBAL_VARIABLES_NAME}, "${Re}")) {`, Ne.argument && (0, i.isNonNullType)(Ne.argument.definition.type)) {
          const Ue = `'Argument "${Ne.argument.definition.name}" of non-null type "${Ne.argument.definition.type.toString()}" must not be null.'`;
          $e += `if (${e.GLOBAL_VARIABLES_NAME}['${Ne.valueNode.name.value}'] == null) {
      ${De}.push(${X(ie, [Ne.argument.node.value], he, Ue)});
      ${fe} = false;
      }`;
        }
        if ($e += `
    ${H(C, Ne.path)} = ${e.GLOBAL_VARIABLES_NAME}['${Ne.valueNode.name.value}'];
    }`, Ne.argument && (0, i.isNonNullType)(Ne.argument.definition.type) && Ne.argument.definition.defaultValue === void 0) {
          const Ue = `'Argument "${Ne.argument.definition.name}" of required type "${Ne.argument.definition.type.toString()}" was provided the variable "$${Re}" which was not provided a runtime value.'`;
          $e += ` else {
      ${De}.push(${X(ie, [Ne.argument.node.value], he, Ue)});
      ${fe} = false;
        }`;
        }
      }
      return $e;
    }
    function Ee(ie, R = !1) {
      return ie.deferred.map((C, fe) => `
        let ${m}${fe} = ${R};
      `).join(`
`);
    }
    function Oe(ie) {
      return { ...ie, deferred: [] };
    }
    function Te(ie) {
      return ie != null && typeof ie == "object" && typeof ie.then == "function";
    }
    e.isPromise = Te;
    function Me(ie) {
      return `${ie} != null && typeof ${ie} === "object" && typeof ${ie}.then === "function"`;
    }
    e.isPromiseInliner = Me;
    function we(ie) {
      const R = (0, o.flattenPath)(ie);
      let C = "[";
      for (let fe = R.length - 1; fe >= 0; fe--)
        R[fe].type !== "meta" && (C += R[fe].type === "literal" ? `"${R[fe].key}",` : `${R[fe].key},`);
      return C + "]";
    }
    function Le(ie) {
      return (0, i.isNonNullType)(ie) ? E : b;
    }
    function ut(ie) {
      return (0, o.flattenPath)(ie).map((R) => R.key).join("_") + "Info";
    }
    function Je(ie) {
      if (!ie)
        return "undefined";
      if (ie.type === "meta")
        return Je(ie.prev);
      const R = `"${ie.key}"`;
      return `{
    key:  ${ie.type === "literal" ? R : ie.key},
    prev: ${Je(ie.prev)}
  }`;
    }
    function bt(ie, R) {
      const { name: C } = ie, fe = R || ((de) => ie.serialize(de));
      return function(he, $e, De, ...Ne) {
        try {
          const Re = fe($e);
          return nr(Re) ? (De(he, `Expected a value of type "${C}" but received: ${$e}`, ...Ne), null) : Re;
        } catch (Re) {
          return De(he, Re && Re.message || `Expected a value of type "${C}" but received an Error`, ...Ne), null;
        }
      };
    }
    function x(ie, R, C, fe) {
      if (ie != null && typeof ie == "object" && typeof ie.__typename == "string")
        return ie.__typename;
      const de = C.schema.getPossibleTypes(fe);
      for (const he of de)
        if (he.isTypeOf) {
          const $e = he.isTypeOf(ie, R, C);
          if (Te($e))
            throw new Error(`Promises are not supported for resolving type of ${ie}`);
          if ($e)
            return he.name;
        }
      throw new Error(`Could not resolve the object type in possible types of ${fe.name} for the value: ` + h(ie));
    }
    function g(ie, R, C, fe) {
      const de = [];
      let he, $e = !1;
      const De = /* @__PURE__ */ Object.create(null);
      for (const Ne of R.definitions)
        switch (Ne.kind) {
          case i.Kind.OPERATION_DEFINITION:
            !fe && he ? $e = !0 : (!fe || Ne.name && Ne.name.value === fe) && (he = Ne);
            break;
          case i.Kind.FRAGMENT_DEFINITION:
            De[Ne.name.value] = Ne;
            break;
        }
      if (he) {
        if ($e)
          throw new i.GraphQLError("Must provide operation name if query contains multiple operations.");
      } else
        throw fe ? new i.GraphQLError(`Unknown operation named "${fe}".`) : new i.GraphQLError("Must provide an operation.");
      return {
        schema: ie,
        fragments: De,
        rootValue: null,
        contextValue: null,
        operation: he,
        options: C,
        resolvers: {},
        serializers: {},
        typeResolvers: {},
        isTypeOfs: {},
        resolveInfos: {},
        hoistedFunctions: [],
        hoistedFunctionNames: /* @__PURE__ */ new Map(),
        deferred: [],
        depth: -1,
        variableValues: {},
        errors: de
      };
    }
    function _(ie) {
      return ie.length > 1 ? "(" + ie.map(({ name: R }) => R.value).join(",") + ")" : ie[0].name.value;
    }
    function V(ie, R) {
      const C = ie.hoistedFunctionNames.get(R);
      return C === void 0 ? (ie.hoistedFunctionNames.set(R, 0), R) : (ie.hoistedFunctionNames.set(R, C + 1), `${R}${C + 1}`);
    }
    function X(ie, R, C, fe, de) {
      return `new ${j}(${fe},
    ${JSON.stringify((0, o.computeLocations)(R))},
      ${we(C)},
      ${de || "undefined"},
      ${ie.options.disablingCapturingStackErrors ? "true" : "false"})`;
    }
    function pe(ie, R) {
      return ie + R + "Resolver";
    }
    function ye(ie) {
      return ie + "TypeResolver";
    }
    function Ge(ie) {
      return ie + "Serializer";
    }
    function ft() {
      return `
     // increase the promise counter
     ++${W};
  `;
    }
    function ze() {
      return `
    --${W};
    if (${W} === 0) {
      ${ee}(${F});
    }
  `;
    }
    function st(ie) {
      return Array.isArray(ie) ? ie.map((R) => nt(R)) : [nt(ie)];
    }
    function nt(ie) {
      return ie instanceof i.GraphQLError ? ie : new a.GraphQLError(ie.message, ie.locations, ie.path, ie);
    }
    function nr(ie) {
      return ie === void 0 || ie !== ie;
    }
    function rr(ie) {
      let R = "";
      for (let C = 0; C <= ie.depth; ++C)
        C > 0 && (R += ", "), R += `idx${C}`;
      return R;
    }
    function ir(ie) {
      return `${ce}${ie}`;
    }
    function Ut(ie) {
      return typeof Object(ie)[Symbol.asyncIterator] == "function";
    }
    e.isAsyncIterable = Ut;
    function mi(ie, R, C, fe) {
      const de = Object.values(C)[0], $e = de[0].name.value, De = (0, o.resolveFieldDef)(ie, R, de);
      if (!De)
        throw new i.GraphQLError(`The subscription field "${$e}" is not defined.`, (0, p.getGraphQLErrorOptions)(de));
      const Ne = (0, o.addPath)(void 0, $e), Re = ut(Ne), Ue = De.subscribe;
      async function rt(ct) {
        const Ze = ct.resolveInfos[Re](ct.rootValue, ct.variables, Ne);
        try {
          const et = await Ue?.(ct.rootValue, ct.variables, ct.context, Ze);
          if (et instanceof Error)
            throw et;
          return et;
        } catch (et) {
          throw (0, i.locatedError)(et, Ze.fieldNodes, (0, s.pathToArray)(Ze.path));
        }
      }
      async function dt(ct) {
        try {
          const Ze = await rt(ct);
          if (!Ut(Ze))
            throw new Error(`Subscription field must return Async Iterable. Received: ${h(Ze)}.`);
          return Ze;
        } catch (Ze) {
          if (Ze instanceof i.GraphQLError)
            return { errors: [Ze] };
          throw Ze;
        }
      }
      return async function(Ze) {
        const et = await dt(Ze);
        return Ut(et) ? $r(et, (vt) => fe(vt, Ze.context, Ze.variables)) : et;
      };
    }
    function Vt(ie, R, C, fe, de) {
      const { resolvers: he, typeResolvers: $e, isTypeOfs: De, serializers: Ne, resolveInfos: Re } = ie, Ue = (0, u.createNullTrimmer)(ie), rt = de || "subscribe";
      return {
        async [rt](ct, Ze, et) {
          const qe = fe(et || {});
          if ((0, d.failToParseVariables)(qe))
            return { errors: qe.errors };
          const vt = {
            rootValue: ct,
            context: Ze,
            variables: qe.coerced,
            safeMap: k,
            inspect: h,
            GraphQLError: a.GraphQLError,
            resolvers: he,
            typeResolvers: $e,
            isTypeOfs: De,
            serializers: Ne,
            resolveInfos: Re,
            trimmer: Ue,
            promiseCounter: 0,
            nullErrors: [],
            errors: [],
            data: {}
          };
          return C.call(null, vt);
        }
      }[rt];
    }
    function $r(ie, R) {
      const C = ie[Symbol.asyncIterator]();
      async function fe(de) {
        if (de.done)
          return de;
        try {
          return { value: await R(de.value), done: !1 };
        } catch (he) {
          if (typeof C.return == "function")
            try {
              await C.return();
            } catch {
            }
          throw he;
        }
      }
      return {
        async next() {
          return fe(await C.next());
        },
        async return() {
          return typeof C.return == "function" ? fe(await C.return()) : { value: void 0, done: !0 };
        },
        async throw(de) {
          return typeof C.throw == "function" ? fe(await C.throw(de)) : Promise.reject(de);
        },
        [Symbol.asyncIterator]() {
          return this;
        }
      };
    }
  }(vf)), vf;
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.isLeafField = e.fieldExpansionEnricher = e.isCompiledQuery = e.compileQuery = void 0;
  var t = KE();
  Object.defineProperty(e, "compileQuery", { enumerable: !0, get: function() {
    return t.compileQuery;
  } }), Object.defineProperty(e, "isCompiledQuery", { enumerable: !0, get: function() {
    return t.isCompiledQuery;
  } });
  var n = jr;
  Object.defineProperty(e, "fieldExpansionEnricher", { enumerable: !0, get: function() {
    return n.fieldExpansionEnricher;
  } }), Object.defineProperty(e, "isLeafField", { enumerable: !0, get: function() {
    return n.isLeafField;
  } });
})(Zv);
const VV = Symbol("values");
var BV = VV, $d = { exports: {} };
(function(e, t) {
  const { hasOwnProperty: n } = Object.prototype, r = v();
  r.configure = v, r.stringify = r, r.default = r, t.stringify = r, t.configure = v, e.exports = r;
  const i = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]|[\ud800-\udbff](?![\udc00-\udfff])|(?:[^\ud800-\udbff]|^)[\udc00-\udfff]/;
  function s(b) {
    return b.length < 5e3 && !i.test(b) ? `"${b}"` : JSON.stringify(b);
  }
  function o(b) {
    if (b.length > 200)
      return b.sort();
    for (let E = 1; E < b.length; E++) {
      const y = b[E];
      let D = E;
      for (; D !== 0 && b[D - 1] > y; )
        b[D] = b[D - 1], D--;
      b[D] = y;
    }
    return b;
  }
  const a = Object.getOwnPropertyDescriptor(
    Object.getPrototypeOf(
      Object.getPrototypeOf(
        new Int8Array()
      )
    ),
    Symbol.toStringTag
  ).get;
  function l(b) {
    return a.call(b) !== void 0 && b.length !== 0;
  }
  function c(b, E, y) {
    b.length < y && (y = b.length);
    const D = E === "," ? "" : " ";
    let F = `"0":${D}${b[0]}`;
    for (let W = 1; W < y; W++)
      F += `${E}"${W}":${D}${b[W]}`;
    return F;
  }
  function u(b) {
    if (n.call(b, "circularValue")) {
      const E = b.circularValue;
      if (typeof E == "string")
        return `"${E}"`;
      if (E == null)
        return E;
      if (E === Error || E === TypeError)
        return {
          toString() {
            throw new TypeError("Converting circular structure to JSON");
          }
        };
      throw new TypeError('The "circularValue" argument must be of type string or the value null or undefined');
    }
    return '"[Circular]"';
  }
  function f(b, E) {
    let y;
    if (n.call(b, E) && (y = b[E], typeof y != "boolean"))
      throw new TypeError(`The "${E}" argument must be of type boolean`);
    return y === void 0 ? !0 : y;
  }
  function d(b, E) {
    let y;
    if (n.call(b, E)) {
      if (y = b[E], typeof y != "number")
        throw new TypeError(`The "${E}" argument must be of type number`);
      if (!Number.isInteger(y))
        throw new TypeError(`The "${E}" argument must be an integer`);
      if (y < 1)
        throw new RangeError(`The "${E}" argument must be >= 1`);
    }
    return y === void 0 ? 1 / 0 : y;
  }
  function p(b) {
    return b === 1 ? "1 item" : `${b} items`;
  }
  function h(b) {
    const E = /* @__PURE__ */ new Set();
    for (const y of b)
      (typeof y == "string" || typeof y == "number") && E.add(String(y));
    return E;
  }
  function m(b) {
    if (n.call(b, "strict")) {
      const E = b.strict;
      if (typeof E != "boolean")
        throw new TypeError('The "strict" argument must be of type boolean');
      if (E)
        return (y) => {
          let D = `Object can not safely be stringified. Received type ${typeof y}`;
          throw typeof y != "function" && (D += ` (${y.toString()})`), new Error(D);
        };
    }
  }
  function v(b) {
    b = { ...b };
    const E = m(b);
    E && (b.bigint === void 0 && (b.bigint = !1), "circularValue" in b || (b.circularValue = Error));
    const y = u(b), D = f(b, "bigint"), F = f(b, "deterministic"), W = d(b, "maximumDepth"), J = d(b, "maximumBreadth");
    function Z(U, z, ne, K, se, re) {
      let ue = z[U];
      switch (typeof ue == "object" && ue !== null && typeof ue.toJSON == "function" && (ue = ue.toJSON(U)), ue = K.call(z, U, ue), typeof ue) {
        case "string":
          return s(ue);
        case "object": {
          if (ue === null)
            return "null";
          if (ne.indexOf(ue) !== -1)
            return y;
          let te = "", B = ",";
          const M = re;
          if (Array.isArray(ue)) {
            if (ue.length === 0)
              return "[]";
            if (W < ne.length + 1)
              return '"[Array]"';
            ne.push(ue), se !== "" && (re += se, te += `
${re}`, B = `,
${re}`);
            const Y = Math.min(ue.length, J);
            let ve = 0;
            for (; ve < Y - 1; ve++) {
              const S = Z(String(ve), ue, ne, K, se, re);
              te += S !== void 0 ? S : "null", te += B;
            }
            const oe = Z(String(ve), ue, ne, K, se, re);
            if (te += oe !== void 0 ? oe : "null", ue.length - 1 > J) {
              const S = ue.length - J - 1;
              te += `${B}"... ${p(S)} not stringified"`;
            }
            return se !== "" && (te += `
${M}`), ne.pop(), `[${te}]`;
          }
          let N = Object.keys(ue);
          const T = N.length;
          if (T === 0)
            return "{}";
          if (W < ne.length + 1)
            return '"[Object]"';
          let P = "", k = "";
          se !== "" && (re += se, B = `,
${re}`, P = " ");
          const q = Math.min(T, J);
          F && !l(ue) && (N = o(N)), ne.push(ue);
          for (let Y = 0; Y < q; Y++) {
            const ve = N[Y], oe = Z(ve, ue, ne, K, se, re);
            oe !== void 0 && (te += `${k}${s(ve)}:${P}${oe}`, k = B);
          }
          if (T > J) {
            const Y = T - J;
            te += `${k}"...":${P}"${p(Y)} not stringified"`, k = B;
          }
          return se !== "" && k.length > 1 && (te = `
${re}${te}
${M}`), ne.pop(), `{${te}}`;
        }
        case "number":
          return isFinite(ue) ? String(ue) : E ? E(ue) : "null";
        case "boolean":
          return ue === !0 ? "true" : "false";
        case "undefined":
          return;
        case "bigint":
          if (D)
            return String(ue);
        default:
          return E ? E(ue) : void 0;
      }
    }
    function j(U, z, ne, K, se, re) {
      switch (typeof z == "object" && z !== null && typeof z.toJSON == "function" && (z = z.toJSON(U)), typeof z) {
        case "string":
          return s(z);
        case "object": {
          if (z === null)
            return "null";
          if (ne.indexOf(z) !== -1)
            return y;
          const ue = re;
          let te = "", B = ",";
          if (Array.isArray(z)) {
            if (z.length === 0)
              return "[]";
            if (W < ne.length + 1)
              return '"[Array]"';
            ne.push(z), se !== "" && (re += se, te += `
${re}`, B = `,
${re}`);
            const T = Math.min(z.length, J);
            let P = 0;
            for (; P < T - 1; P++) {
              const q = j(String(P), z[P], ne, K, se, re);
              te += q !== void 0 ? q : "null", te += B;
            }
            const k = j(String(P), z[P], ne, K, se, re);
            if (te += k !== void 0 ? k : "null", z.length - 1 > J) {
              const q = z.length - J - 1;
              te += `${B}"... ${p(q)} not stringified"`;
            }
            return se !== "" && (te += `
${ue}`), ne.pop(), `[${te}]`;
          }
          ne.push(z);
          let M = "";
          se !== "" && (re += se, B = `,
${re}`, M = " ");
          let N = "";
          for (const T of K) {
            const P = j(T, z[T], ne, K, se, re);
            P !== void 0 && (te += `${N}${s(T)}:${M}${P}`, N = B);
          }
          return se !== "" && N.length > 1 && (te = `
${re}${te}
${ue}`), ne.pop(), `{${te}}`;
        }
        case "number":
          return isFinite(z) ? String(z) : E ? E(z) : "null";
        case "boolean":
          return z === !0 ? "true" : "false";
        case "undefined":
          return;
        case "bigint":
          if (D)
            return String(z);
        default:
          return E ? E(z) : void 0;
      }
    }
    function ee(U, z, ne, K, se) {
      switch (typeof z) {
        case "string":
          return s(z);
        case "object": {
          if (z === null)
            return "null";
          if (typeof z.toJSON == "function") {
            if (z = z.toJSON(U), typeof z != "object")
              return ee(U, z, ne, K, se);
            if (z === null)
              return "null";
          }
          if (ne.indexOf(z) !== -1)
            return y;
          const re = se;
          if (Array.isArray(z)) {
            if (z.length === 0)
              return "[]";
            if (W < ne.length + 1)
              return '"[Array]"';
            ne.push(z), se += K;
            let P = `
${se}`;
            const k = `,
${se}`, q = Math.min(z.length, J);
            let Y = 0;
            for (; Y < q - 1; Y++) {
              const oe = ee(String(Y), z[Y], ne, K, se);
              P += oe !== void 0 ? oe : "null", P += k;
            }
            const ve = ee(String(Y), z[Y], ne, K, se);
            if (P += ve !== void 0 ? ve : "null", z.length - 1 > J) {
              const oe = z.length - J - 1;
              P += `${k}"... ${p(oe)} not stringified"`;
            }
            return P += `
${re}`, ne.pop(), `[${P}]`;
          }
          let ue = Object.keys(z);
          const te = ue.length;
          if (te === 0)
            return "{}";
          if (W < ne.length + 1)
            return '"[Object]"';
          se += K;
          const B = `,
${se}`;
          let M = "", N = "", T = Math.min(te, J);
          l(z) && (M += c(z, B, J), ue = ue.slice(z.length), T -= z.length, N = B), F && (ue = o(ue)), ne.push(z);
          for (let P = 0; P < T; P++) {
            const k = ue[P], q = ee(k, z[k], ne, K, se);
            q !== void 0 && (M += `${N}${s(k)}: ${q}`, N = B);
          }
          if (te > J) {
            const P = te - J;
            M += `${N}"...": "${p(P)} not stringified"`, N = B;
          }
          return N !== "" && (M = `
${se}${M}
${re}`), ne.pop(), `{${M}}`;
        }
        case "number":
          return isFinite(z) ? String(z) : E ? E(z) : "null";
        case "boolean":
          return z === !0 ? "true" : "false";
        case "undefined":
          return;
        case "bigint":
          if (D)
            return String(z);
        default:
          return E ? E(z) : void 0;
      }
    }
    function le(U, z, ne) {
      switch (typeof z) {
        case "string":
          return s(z);
        case "object": {
          if (z === null)
            return "null";
          if (typeof z.toJSON == "function") {
            if (z = z.toJSON(U), typeof z != "object")
              return le(U, z, ne);
            if (z === null)
              return "null";
          }
          if (ne.indexOf(z) !== -1)
            return y;
          let K = "";
          if (Array.isArray(z)) {
            if (z.length === 0)
              return "[]";
            if (W < ne.length + 1)
              return '"[Array]"';
            ne.push(z);
            const B = Math.min(z.length, J);
            let M = 0;
            for (; M < B - 1; M++) {
              const T = le(String(M), z[M], ne);
              K += T !== void 0 ? T : "null", K += ",";
            }
            const N = le(String(M), z[M], ne);
            if (K += N !== void 0 ? N : "null", z.length - 1 > J) {
              const T = z.length - J - 1;
              K += `,"... ${p(T)} not stringified"`;
            }
            return ne.pop(), `[${K}]`;
          }
          let se = Object.keys(z);
          const re = se.length;
          if (re === 0)
            return "{}";
          if (W < ne.length + 1)
            return '"[Object]"';
          let ue = "", te = Math.min(re, J);
          l(z) && (K += c(z, ",", J), se = se.slice(z.length), te -= z.length, ue = ","), F && (se = o(se)), ne.push(z);
          for (let B = 0; B < te; B++) {
            const M = se[B], N = le(M, z[M], ne);
            N !== void 0 && (K += `${ue}${s(M)}:${N}`, ue = ",");
          }
          if (re > J) {
            const B = re - J;
            K += `${ue}"...":"${p(B)} not stringified"`;
          }
          return ne.pop(), `{${K}}`;
        }
        case "number":
          return isFinite(z) ? String(z) : E ? E(z) : "null";
        case "boolean":
          return z === !0 ? "true" : "false";
        case "undefined":
          return;
        case "bigint":
          if (D)
            return String(z);
        default:
          return E ? E(z) : void 0;
      }
    }
    function ce(U, z, ne) {
      if (arguments.length > 1) {
        let K = "";
        if (typeof ne == "number" ? K = " ".repeat(Math.min(ne, 10)) : typeof ne == "string" && (K = ne.slice(0, 10)), z != null) {
          if (typeof z == "function")
            return Z("", { "": U }, [], z, K, "");
          if (Array.isArray(z))
            return j("", U, [], h(z), K, "");
        }
        if (K.length !== 0)
          return ee("", U, [], K, "");
      }
      return le("", U, []);
    }
    return ce;
  }
})($d, $d.exports);
var YE = $d.exports;
const Il = BV, GV = YE;
let zV = class {
  constructor() {
    this.Cache = class extends qV {
    };
  }
  add(t, n, r, i) {
    if (typeof n == "function" && (i = r, r = n, n = {}), typeof r != "function")
      throw new TypeError(`Missing the function parameter for '${t}'`);
    if (i && typeof i != "function")
      throw new TypeError("serialize must be a function");
    n = n || {};
    class s extends HV {
    }
    s.prototype.func = r, s.prototype.key = t, s.prototype.serialize = i, this.Cache.prototype[t] = function(o) {
      return this[Il][t] || (this[Il][t] = new s(this.ctx, n.cache)), this[Il][t].add(o);
    };
  }
  create(t) {
    return new this.Cache(t);
  }
};
class qV {
  constructor(t) {
    this[Il] = {}, this.ctx = t;
  }
}
class HV {
  constructor(t, n = !0) {
    this.ids = {}, this.toFetch = [], this.error = null, this.started = !1, this.ctx = t, this.cache = n;
  }
  add(t) {
    const n = this.serialize ? this.serialize(t) : t, r = typeof n == "string" ? n : GV(n);
    if (this.ids[r])
      return this.ids[r].promise;
    this.start();
    const i = new WV(n, t);
    return this.cache && (this.ids[r] = i), this.toFetch.push(i), i.promise;
  }
  start() {
    this.started || (this.started = !0, process.nextTick(() => {
      this.started = !1;
      const t = this.toFetch;
      this.toFetch = [], this.func(t.map((r) => r.args), this.ctx).then((r) => {
        if (!Array.isArray(r) && r.length !== t.length) {
          n(new Error(`The Number of elements in the response for ${this.key} does not match`));
          return;
        }
        for (let i = 0; i < t.length; i++)
          t[i].resolve(r[i]);
      }, n);
      function n(r) {
        for (let i = 0; i < t.length; i++)
          t[i].reject(r);
      }
    }));
  }
}
class WV {
  constructor(t, n) {
    this.resolve = null, this.reject = null, this.id = t, this.args = n, this.promise = new Promise((r, i) => {
      this.resolve = r, this.reject = i;
    });
  }
}
var QV = { Factory: zV };
const { Kind: JV } = Ln, { MER_ERR_GQL_QUERY_DEPTH: KV } = xs;
function YV(e, t) {
  const n = XV(e), r = {};
  for (const s in n)
    r[s] = XE(n[s]);
  const i = [];
  if (typeof t == "number")
    for (const s of Object.keys(r)) {
      const o = r[s];
      if (o > t) {
        const a = new KV(s, o, t);
        i.push(a);
      }
    }
  return i;
}
function XE(e, t = 0) {
  return e.selectionSet ? Math.max(...e.selectionSet.selections.map((n) => XE(n, t + 1))) : t;
}
function XV(e) {
  return e.reduce((t, n) => (n.kind === JV.OPERATION_DEFINITION && (t[n.name ? n.name.value : "unnamedQuery"] = n), t), {});
}
var ZV = YV, ZE = {}, Pf, d0;
function e3() {
  if (d0)
    return Pf;
  d0 = 1;
  const e = at;
  return Pf = function(t, n) {
    class r extends t {
      constructor(s) {
        super(s), this.addP = e.promisify(this.add_async), this.removeP = e.promisify(this.remove_async), this.matchP = e.promisify(this.match_async), this.testP = e.promisify(this.test_async), this.clearP = e.promisify(this.clear_async), this._get_visitorP = e.promisify(this.get_visitor_async), this._visit_nextP = e.promisify(this.visit_next_async), this._get_restorerP = e.promisify(this.get_restorer_async), this._restore_nextP = e.promisify(this.restore_next_async), this._match_iterP = e.promisify(this.match_iter_async), this._match_nextP = e.promisify(this.match_next_async);
      }
      *visit() {
        const s = this.get_visitor();
        for (; ; ) {
          const o = this.visit_next(s);
          if (o === void 0)
            break;
          yield o;
        }
      }
      async *visitP() {
        const s = await this._get_visitorP();
        for (; ; ) {
          const o = await this._visit_nextP(s);
          if (o === void 0)
            break;
          yield o;
        }
      }
      *match_iter(s, o) {
        const a = super.match_iter(s, o);
        for (; ; ) {
          const l = this.match_next(a);
          if (l === void 0)
            break;
          yield l.value;
        }
      }
      async *match_iterP(s, o) {
        const a = await this._match_iterP(s, o);
        for (; ; ) {
          const l = await this._match_nextP(a);
          if (l === void 0)
            break;
          yield l.value;
        }
      }
      get_trie() {
        const s = new n(this.options), o = s.get_restorer();
        for (let a of this.visit())
          o(a);
        return s.get_trie();
      }
      get_restorer(s) {
        const o = super.get_restorer(s);
        return (a) => {
          super.restore_next(o, a);
        };
      }
      async get_restorerP(s) {
        const o = await this._get_restorerP(s);
        return async (a) => {
          await this._restore_nextP(o, a);
        };
      }
    }
    return r.is_native = !0, r.nonNative = n, r;
  }, Pf;
}
(function(e) {
  var t = at;
  function n(u) {
    u = u || {}, this._separator = u.separator || ".", this._wildcard_one = u.wildcard_one || "*", this._wildcard_some = u.wildcard_some || "#", this._max_words = u.max_words || 100, this._max_wildcard_somes = u.max_wildcard_somes || 3, this._match_empty_levels = u.match_empty_levels, this._trie = /* @__PURE__ */ new Map(), u.cache_adds instanceof Map ? this._shortcuts = u.cache_adds : u.cache_adds && (this._shortcuts = /* @__PURE__ */ new Map()), u.cache_splits > 0 && (this._cache_splits = u.cache_splits, this._split_cache = /* @__PURE__ */ new Map());
  }
  n.prototype._initial_value = function(u) {
    return [u];
  }, n.prototype._add_value = function(u, f) {
    u[u.length] = f;
  }, n.prototype._add_values = function(u, f) {
    var d, p = u.length, h = f.length;
    for (d = 0; d < h; d += 1)
      u[p + d] = f[d];
  }, n.prototype._iter_values = function(u, f) {
    return u[Symbol.iterator](f);
  }, n.prototype._remove_value = function(u, f) {
    if (f === void 0)
      return !0;
    var d = u.lastIndexOf(f);
    return d >= 0 && u.splice(d, 1), u.length === 0;
  }, n.prototype._add = function(u, f, d, p) {
    var h, m;
    return f === d.length ? (h = p.get(this._separator), h ? this._add_value(h, u) : (h = this._initial_value(u), p.set(this._separator, h)), h) : (m = d[f], h = p.get(m), h || (h = /* @__PURE__ */ new Map(), p.set(m, h)), this._add(u, f + 1, d, h));
  }, n.prototype._remove = function(u, f, d, p) {
    var h, m, v;
    return f === d.length ? (h = p.get(this._separator), h && this._remove_value(h, u) ? (p.delete(this._separator), !0) : !1) : (m = d[f], h = p.get(m), h ? (v = this._remove(u, f + 1, d, h), h.size === 0 && p.delete(m), v) : !1);
  }, n.prototype._match_some = function(u, f, d, p, h) {
    var m, v;
    for (v of p.keys())
      if (v !== this._separator) {
        for (m = f; m < d.length; m += 1)
          u = this._match(u, m, d, p, h);
        break;
      }
    return u;
  }, n.prototype._match = function(u, f, d, p, h) {
    var m, v;
    return v = p.get(this._wildcard_some), v && (u = this._match_some(u, f, d, v, h), u = this._match(u, d.length, d, v, h)), f === d.length ? (v = p.get(this._separator), v && (u.dest ? (this._add_values(u.dest, u.source, h), this._add_values(u.dest, v, h), u = u.dest) : u.source ? (u.dest = u.source, u.source = v) : this._add_values(u, v, h))) : (m = d[f], m !== this._wildcard_one && m !== this._wildcard_some && (v = p.get(m), v && (u = this._match(u, f + 1, d, v, h))), (m || this._match_empty_levels) && (v = p.get(this._wildcard_one), v && (u = this._match(u, f + 1, d, v, h)))), u;
  }, n.prototype._match2 = function(u, f, d) {
    var p = this._match(
      {
        source: u
      },
      0,
      this._split(f, !1),
      this._trie,
      d
    );
    return p.source || p;
  }, n.prototype._test_some = function(u, f, d, p) {
    var h, m;
    for (m of p.keys())
      if (m !== this._separator) {
        for (h = f; h < d.length; h += 1)
          if (this._test(u, h, d, p))
            return !0;
        break;
      }
    return !1;
  }, n.prototype._test = function(u, f, d, p) {
    var h, m;
    if (m = p.get(this._wildcard_some), m && (this._test_some(u, f, d, m) || // and we'll end up matching the rest of the words:
    this._test(u, d.length, d, m)))
      return !0;
    if (f === d.length) {
      if (m = p.get(this._separator), m && this.test_values(m, u))
        return !0;
    } else if (h = d[f], h !== this._wildcard_one && h !== this._wildcard_some && (m = p.get(h), m && this._test(u, f + 1, d, m)) || (h || this._match_empty_levels) && (m = p.get(this._wildcard_one), m && this._test(u, f + 1, d, m)))
      return !0;
    return !1;
  }, n.prototype._match_some_iter = function* (u, f, d, p) {
    var h, m;
    for (m of d.keys())
      if (m !== this._separator) {
        for (h = u; h < f.length; h += 1)
          yield* this._match_iter(h, f, d, p);
        break;
      }
  }, n.prototype._match_iter = function* (u, f, d, p) {
    var h, m;
    m = d.get(this._wildcard_some), m && (yield* this._match_some_iter(u, f, m, p), yield* this._match_iter(f.length, f, m, p)), u === f.length ? (m = d.get(this._separator), m && (yield* this._iter_values(m, p))) : (h = f[u], h !== this._wildcard_one && h !== this._wildcard_some && (m = d.get(h), m && (yield* this._match_iter(u + 1, f, m, p))), (h || this._match_empty_levels) && (m = d.get(this._wildcard_one), m && (yield* this._match_iter(u + 1, f, m, p))));
  }, n.prototype._split_words = function(u) {
    const f = u.split(this._separator);
    if (f.length > this._max_words)
      throw new Error("too many words");
    return f;
  }, n.prototype._split = function(u, f) {
    let d;
    if (this._split_cache) {
      if (d = this._split_cache.get(u), d === void 0 && (d = this._split_words(u), this._split_cache.set(u, d), this._split_cache.size > this._cache_splits))
        for (let p of this._split_cache.keys()) {
          this._split_cache.delete(p);
          break;
        }
    } else
      d = this._split_words(u);
    if (f && d.reduce((p, h) => p + (h === this._wildcard_some), 0) > this._max_wildcard_somes)
      throw new Error("too many wildcard somes");
    return d;
  }, n.prototype.add = function(u, f) {
    var d = this._shortcuts && this._shortcuts.get(u);
    return d ? this._add_value(d, f) : (d = this._add(f, 0, this._split(u, !0), this._trie), this._shortcuts && this._shortcuts.set(u, d)), this;
  }, n.prototype.remove = function(u, f) {
    return this._remove(f, 0, this._split(u, !1), this._trie) && this._shortcuts && this._shortcuts.delete(u), this;
  }, n.prototype.match = function(u, f) {
    return this._match2([], u, f);
  }, n.prototype.match_iter = function(u, f) {
    return this._match_iter(0, this._split(u, !1), this._trie, f);
  }, n.prototype.test = function(u, f) {
    return this._test(f, 0, this._split(u, !1), this._trie);
  }, n.prototype.test_values = function(u, f) {
    return u.indexOf(f) >= 0;
  }, n.prototype.clear = function() {
    return this._trie.clear(), this._shortcuts && this._shortcuts.clear(), this._split_cache && this._split_cache.clear(), this;
  }, n.prototype.get_trie = function() {
    return this._trie;
  }, n.prototype.visit = function* () {
    let u = [], f = this._trie.entries(), d = 0;
    for (; ; ) {
      d === 0 && (yield { type: "start_entries" });
      let p = f.next();
      if (p.done) {
        yield { type: "end_entries" };
        let v = u.pop();
        if (v === void 0)
          return;
        [f, d] = v;
        continue;
      }
      let [h, m] = p.value;
      if (yield { type: "entry", key: h }, ++d, h === this._separator) {
        if (yield { type: "start_values" }, m[Symbol.iterator])
          for (let v of m)
            yield { type: "value", value: v };
        else
          yield { type: "value", value: m };
        yield { type: "end_values" };
        continue;
      }
      u.push([f, d]), f = m.entries(), d = 0;
    }
  }, n.prototype.get_restorer = function(u) {
    u = u || {};
    let f = [], d = this._trie, p = "";
    return (h) => {
      switch (h.type) {
        case "entry":
          d = d || /* @__PURE__ */ new Map(), f.push([d, h.key, p]), d = d.get(h.key), u.cache_adds && (p && (p += this._separator), p += h.key);
          break;
        case "value":
          d ? this._add_value(d, h.value) : d = this._initial_value(h.value);
          break;
        case "end_entries":
          d && d.size === 0 && (d = void 0);
        case "end_values":
          let m = f.pop();
          if (m === void 0)
            d = void 0, p = "";
          else {
            let [v, b, E] = m;
            d && (u.cache_adds && this._shortcuts && h.type === "end_values" && this._shortcuts.set(E, d), v.set(b, d)), d = v, p = E;
          }
          break;
      }
    };
  };
  function r(u) {
    n.call(this, u);
  }
  t.inherits(r, n), r.prototype._initial_value = function(u) {
    return (/* @__PURE__ */ new Set()).add(u);
  }, r.prototype._add_value = function(u, f) {
    u.add(f);
  }, r.prototype._add_values = function(u, f) {
    f.forEach(function(d) {
      u.add(d);
    });
  }, r.prototype._remove_value = function(u, f) {
    return f === void 0 ? !0 : (u.delete(f), u.size === 0);
  }, r.prototype.test_values = function(u, f) {
    return u.has(f);
  }, r.prototype.match = function(u, f) {
    return this._match2(/* @__PURE__ */ new Set(), u, f);
  };
  function i(u) {
    n.call(this, u);
  }
  t.inherits(i, n), i.prototype._initial_value = function() {
    return !0;
  }, i.prototype._add_value = function() {
  }, i.prototype._remove_value = function() {
    return !0;
  }, i.prototype._iter_values = function* () {
    yield !0;
  }, i.prototype.test_values = function() {
    return !0;
  }, i.prototype.match = function(u, f) {
    return this.test(u, f);
  };
  let s = at;
  function o(u) {
    s.Readable.call(this, { objectMode: !0 }), this._iterator = u.visit();
  }
  t.inherits(o, s.Readable), o.prototype._read = function() {
    for (; ; ) {
      let { done: u, value: f } = this._iterator.next();
      if (u) {
        this.push(null);
        break;
      }
      if (!this.push(f))
        break;
    }
  };
  function a(u) {
    s.Writable.call(this, { objectMode: !0 }), this._restorer = u.get_restorer();
  }
  t.inherits(a, s.Writable), a.prototype._write = function(u, f, d) {
    this._restorer(u), d();
  };
  let l = null;
  function c(u) {
    if (u !== l) {
      const f = e3();
      n.nativeString = f(u.QlobberString, n), n.nativeNumber = f(u.QlobberNumber, n), r.nativeString = f(u.QlobberDedupString, r), r.nativeNumber = f(u.QlobberDedupNumber, r), i.native = f(u.QlobberTrue, i), l = u;
    }
    return e;
  }
  e.Qlobber = n, e.QlobberDedup = r, e.QlobberTrue = i, e.VisitorStream = o, e.RestorerStream = a, e.set_native = c;
})(ZE);
var t3 = ZE, n3 = i3, r3 = Object.prototype.hasOwnProperty;
function i3() {
  for (var e = {}, t = 0; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      r3.call(n, r) && (e[r] = n[r]);
  }
  return e;
}
var s3 = n3, p0 = bb, o3 = {
  released: Cr,
  results: !0
};
function a3(e) {
  e = s3(o3, e);
  var t = e.released, n = p0(e.results ? c3 : l3), r = p0(u3), i = e.results ? u : d, s = e.results ? c : f;
  return o;
  function o(p, h, m, v) {
    var b = n.get();
    v = v || Cr, h.length === 0 ? (v.call(p), t(b)) : (b._callback = v, b._callThat = p, b._release = a, typeof h == "function" ? s(p, h, m, b) : i(p, h, m, b), b._count === 0 && b.release());
  }
  function a(p) {
    n.release(p), t(p);
  }
  function l(p) {
    r.release(p);
  }
  function c(p, h, m, v) {
    var b = null;
    v._count = m.length, v._results = new Array(v._count);
    for (var E = 0; E < m.length; E++)
      b = r.get(), b._release = l, b.parent = v, b.pos = E, p ? h.call(p, m[E], b.release) : h(m[E], b.release);
  }
  function u(p, h, m, v) {
    var b = null, E = Cr;
    v._count = h.length, v._results = new Array(v._count);
    for (var y = 0; y < h.length; y++)
      b = r.get(), b._release = l, b.parent = v, b.pos = y, E = h[y], p ? E.length === 1 ? E.call(p, b.release) : E.call(p, m, b.release) : E.length === 1 ? E(b.release) : E(m, b.release);
  }
  function f(p, h, m, v) {
    v._count = m.length;
    for (var b = 0; b < m.length; b++)
      p ? h.call(p, m[b], v.release) : h(m[b], v.release);
  }
  function d(p, h, m, v) {
    var b = null;
    v._count = h.length;
    for (var E = 0; E < h.length; E++)
      b = h[E], p ? b.length === 1 ? b.call(p, v.release) : b.call(p, m, v.release) : b.length === 1 ? b(v.release) : b(m, v.release);
  }
}
function l3() {
  this._count = -1, this._callback = Cr, this._callThat = null, this._release = null, this.next = null;
  var e = this, t = 0;
  this.release = function() {
    var n = e._callback;
    (++t === e._count || e._count === 0) && (e._callThat ? n.call(e._callThat) : n(), e._callback = Cr, e._callThat = null, t = 0, e._release(e));
  };
}
function u3() {
  this.pos = -1, this._release = Cr, this.parent = null, this.next = null;
  var e = this;
  this.release = function(t, n) {
    e.parent.release(t, e.pos, n), e.pos = -1, e.parent = null, e._release(e);
  };
}
function c3() {
  this._count = -1, this._callback = Cr, this._results = null, this._err = null, this._callThat = null, this._release = Cr, this.next = null;
  var e = this, t = 0;
  this.release = function(n, r, i) {
    e._err = e._err || n, r >= 0 && (e._results[r] = i);
    var s = e._callback;
    (++t === e._count || e._count === 0) && (e._callThat ? s.call(e._callThat, e._err, e._results) : s(e._err, e._results), e._callback = Cr, e._results = null, e._err = null, e._callThat = null, t = 0, e._release(e));
  };
}
function Cr() {
}
var f3 = a3;
const { Qlobber: d3 } = t3, As = at, p3 = f3;
function Er(e) {
  if (!(this instanceof Er))
    return new Er(e);
  const t = this;
  e = e || {}, e.matchEmptyLevels = e.matchEmptyLevels === void 0 ? !0 : !!e.matchEmptyLevels, e.separator = e.separator || "/", e.wildcardOne = e.wildcardOne || "+", e.wildcardSome = e.wildcardSome || "#", this._messageQueue = [], this._messageCallbacks = [], this._parallel = p3({
    results: !1,
    released: n
  }), this.concurrency = e.concurrency || 0, this.current = 0, this._doing = !1, this._matcher = new d3({
    match_empty_levels: e.matchEmptyLevels,
    separator: e.separator,
    wildcard_one: e.wildcardOne,
    wildcard_some: e.wildcardSome
  }), this.closed = !1, this._released = n;
  function n() {
    t.current--;
    const r = t._messageQueue.shift(), i = t._messageCallbacks.shift();
    r ? t._do(r, i) : t._doing = !1;
  }
}
Object.defineProperty(Er.prototype, "length", {
  get: function() {
    return this._messageQueue.length;
  },
  enumerable: !0
});
Er.prototype.on = function(t, n, r) {
  return As(t), As(n), this._matcher.add(t, n), r && setImmediate(r), this;
};
Er.prototype.removeListener = function(t, n, r) {
  As(t), As(n);
  const i = this;
  return setImmediate(function() {
    i._matcher.remove(t, n), r && r();
  }), this;
};
Er.prototype.removeAllListeners = function(t, n) {
  return As(t), this._matcher.remove(t), n && setImmediate(n), this;
};
Er.prototype.emit = function(t, n) {
  return As(t), n = n || h3, this.closed ? n(new Error("mqemitter is closed")) : (this.concurrency > 0 && this.current >= this.concurrency ? (this._messageQueue.push(t), this._messageCallbacks.push(n), this._doing || (process.emitWarning("MqEmitter leak detected", { detail: "For more info check: https://github.com/mcollina/mqemitter/pull/94" }), this._released())) : this._do(t, n), this);
};
Er.prototype.close = function(t) {
  return this.closed = !0, setImmediate(t), this;
};
Er.prototype._do = function(e, t) {
  this._doing = !0;
  const n = this._matcher.match(e.topic);
  return this.current++, this._parallel(this, n, e, t), this;
};
function h3() {
}
var m3 = Er;
const y3 = at, g3 = uu.lru, b3 = {
  prepared: (e) => ({
    isPersistedQuery: (t) => t.persisted,
    getHash: (t) => t.query,
    getQueryFromHash: async (t) => e[t]
  }),
  preparedOnly: (e) => ({
    isPersistedQuery: (t) => !0,
    getHash: (t) => t.persisted ? t.query : !1,
    // Only support persisted queries
    getQueryFromHash: async (t) => e[t]
  }),
  automatic: (e) => {
    const t = g3(e || 1024);
    return {
      isPersistedQuery: (n) => !n.query && (n.extensions || {}).persistedQuery,
      getHash: (n) => {
        const { version: r, sha256Hash: i } = n.extensions.persistedQuery;
        return r === 1 ? i : !1;
      },
      getQueryFromHash: async (n) => t.get(n),
      getHashForQuery: (n) => y3.createHash("sha256").update(n, "utf8").digest("hex"),
      saveQuery: async (n, r) => t.set(n, r),
      notFoundError: "PersistedQueryNotFound",
      notSupportedError: "PersistedQueryNotSupported"
    };
  }
};
var v3 = b3;
const _3 = oa, h0 = uu.lru, w3 = dx, { compileQuery: E3, isCompiledQuery: S3 } = Zv, { Factory: m0 } = QV, {
  parse: y0,
  buildSchema: T3,
  getOperationAST: $3,
  GraphQLObjectType: kf,
  GraphQLScalarType: N3,
  GraphQLEnumType: O3,
  GraphQLInterfaceType: I3,
  GraphQLUnionType: R3,
  GraphQLSchema: A3,
  extendSchema: x3,
  validate: D3,
  validateSchema: P3,
  specifiedRules: k3,
  execute: L3
} = Ln, { buildExecutionContext: j3 } = ME, C3 = ZV, g0 = m3, { PubSub: b0, withFilter: M3 } = Vv, Nd = v3, F3 = YE, {
  ErrorWithProps: U3,
  defaultErrorFormatter: eS,
  addErrorsToExecutionResult: V3,
  MER_ERR_GQL_INVALID_SCHEMA: B3,
  MER_ERR_GQL_VALIDATION: go,
  MER_ERR_INVALID_OPTS: yn,
  MER_ERR_METHOD_NOT_ALLOWED: G3
} = xs, { Hooks: z3, assignLifeCycleHooksToContext: q3, assignApplicationHooksToContext: H3 } = rp, { kLoaders: al, kFactory: Lf, kSubscriptionFactory: W3, kHooks: ll } = Su, {
  preParsingHandler: Q3,
  preValidationHandler: J3,
  preExecutionHandler: K3,
  onResolutionHandler: Y3,
  onExtendSchemaHandler: X3
} = Wv;
function v0(e) {
  if (Object.prototype.hasOwnProperty.call(e, "cache")) {
    const t = typeof e.cache == "boolean", n = typeof e.cache == "number";
    if (t && e.cache === !1)
      return null;
    if (n)
      return h0(e.cache);
    if (!t && !n)
      throw new yn("Cache type is not supported");
  }
  return h0(1024);
}
const is = _3(async function(e, t) {
  const n = v0(t), r = v0(t);
  if (n && t.validationRules && typeof t.validationRules == "function")
    throw new yn("Using a function for the validationRules is incompatible with query caching");
  const i = t.jit || 0, s = t.queryDepth, o = typeof t.errorFormatter == "function" ? t.errorFormatter : eS;
  t.graphql = t.graphql || {};
  const a = t.graphql.parseOptions || {}, l = t.graphql.validateOptions || {};
  if (t.persistedQueries)
    t.onlyPersisted ? (t.persistedQueryProvider = Nd.preparedOnly(t.persistedQueries), t.graphiql = !1, t.ide = !1) : t.persistedQueryProvider = Nd.prepared(t.persistedQueries);
  else if (t.onlyPersisted)
    throw new yn("onlyPersisted is true but there are no persistedQueries");
  if (t.persistedQueryProvider) {
    if (t.persistedQueryProvider.getHash) {
      if (!t.persistedQueryProvider.getQueryFromHash)
        throw new yn("persistedQueryProvider: getQueryFromHash is required when getHash is provided");
    } else
      throw new yn("persistedQueryProvider: getHash is required");
    if (t.persistedQueryProvider.getHashForQuery && !t.persistedQueryProvider.saveQuery)
      throw new yn("persistedQueryProvider: saveQuery is required when getHashForQuery is provided");
  }
  if (typeof i != "number")
    throw new yn("the jit option must be a number");
  const c = {}, u = t.subscription;
  let f, d, p, h, m, v, b, E;
  typeof u == "object" ? (u.pubsub ? d = u.pubsub : (f = u.emitter || g0(), d = new b0(f)), p = u.verifyClient, h = u.context, m = u.onConnect, v = u.onDisconnect, b = u.keepAlive, E = u.fullWsTransport) : u === !0 && (f = g0(), d = new b0(f)), u && (J.pubsub = d);
  let y = t.schema;
  if (Array.isArray(y)) {
    if (y.some((j) => typeof j != "string"))
      throw new yn('when providing an array to the "schema" option, only string schemas are allowed');
    y = y.join(`
`);
  }
  typeof y == "string" ? y = T3(y) : t.schema || (y = new A3({
    query: new kf({
      name: "Query",
      fields: {}
    }),
    mutation: t.defineMutation ? new kf({
      name: "Mutation",
      fields: {}
    }) : void 0
  })), J.schema = y, e.addHook("onReady", async function() {
    const j = P3(J.schema);
    if (j.length === 1)
      throw j[0];
    if (j.length > 1) {
      const ee = new B3();
      throw ee.errors = j, ee;
    }
  });
  const D = Symbol("ctx");
  if (t.routes !== !1) {
    const j = t.graphiql || t.ide;
    e.register(w3, {
      errorHandler: t.errorHandler,
      errorFormatter: t.errorFormatter,
      ide: j,
      prefix: t.prefix,
      path: t.path,
      context: t.context,
      persistedQueryProvider: t.persistedQueryProvider,
      allowBatchedQueries: t.allowBatchedQueries,
      subscriber: d,
      verifyClient: p,
      onConnect: m,
      onDisconnect: v,
      entityResolversFactory: void 0,
      subscriptionContextFn: h,
      keepAlive: b,
      fullWsTransport: E,
      additionalRouteOptions: t.additionalRouteOptions
    });
  }
  e.decorateReply(D, null), e.decorateReply("graphql", function(j, ee, le, ce) {
    return ee || (ee = {}), ee = Object.assign(ee, { reply: this, app: e }), e[Lf] && (!t.allowBatchedQueries || !this[al]) && (this[al] = e[Lf].create(ee)), e.graphql(j, ee, le, ce);
  }), e.decorate("graphql", J), J.replaceSchema = function(j) {
    if (!j || typeof j != "object")
      throw new yn("Must provide valid Document AST");
    J.schema = j, n && n.clear(), r && r.clear();
  }, J.extendSchema = J.extendSchema || function(j) {
    if (typeof j == "string")
      j = y0(j, a);
    else if (!j || typeof j != "object")
      throw new yn("Must provide valid Document AST");
    J.schema = x3(J.schema, j);
    const ee = H3({}, J[ll]);
    if (ee.onExtendSchema !== null)
      return X3({ schema: J.schema, context: ee });
  }, J.defineResolvers = J.defineResolvers || function(j) {
    const ee = (y.getSubscriptionType() || {}).name || "Subscription", le = !!J.pubsub;
    for (const ce of Object.keys(j)) {
      const U = J.schema.getType(ce);
      if (typeof j[ce] == "function")
        c[ce] = j[ce];
      else if (U instanceof kf) {
        const z = U.getFields(), ne = j[ce];
        ne.isTypeOf && (U.isTypeOf = ne.isTypeOf, delete ne.isTypeOf);
        for (const K of Object.keys(ne))
          if (le && ce === ee)
            z[K] = {
              ...z[K],
              ...ne[K]
            };
          else if (K === "__resolveReference")
            U.resolveReference = ne[K];
          else if (z[K])
            z[K].resolve = ne[K];
          else
            throw new yn(`Cannot find field ${K} of type ${U}`);
      } else if (U instanceof N3 || U instanceof O3) {
        const z = j[ce];
        for (const ne of Object.keys(z))
          U[ne] = z[ne];
      } else if (U instanceof I3 || U instanceof R3) {
        const z = j[ce];
        U.resolveType = z.resolveType;
      } else
        throw new yn(`Cannot find type ${ce}`);
    }
  };
  let F, W;
  J.defineLoaders = J.defineLoaders || function(j) {
    F || (F = new m0(), e.decorateReply(al), e.decorate(Lf, F)), W || (W = new m0(), e.decorate(W3, W));
    function ee(U, z) {
      return async function(ne, K, se, re) {
        const { reply: ue } = se;
        if (!ue)
          throw new yn("loaders only work via reply.graphql()");
        const te = z.cache === !1 ? { obj: ne, params: K, info: re } : { obj: ne, params: K };
        return ue[al][U](te);
      };
    }
    function le(U) {
      return U.info ? F3({ obj: U.obj, params: U.params }) : U;
    }
    const ce = {};
    for (const U of Object.keys(j)) {
      const z = j[U];
      ce[U] = {};
      for (const ne of Object.keys(z)) {
        const K = U + "-" + ne, se = [{}, z[ne].opts || {}];
        t.cache === !1 && se.push({
          cache: !1
        });
        const re = Object.assign(...se);
        ce[U][ne] = ee(K, re), typeof z[ne] == "function" ? (F.add(K, re, z[ne], le), W.add(K, { cache: !1 }, z[ne], le)) : (F.add(K, re, z[ne].loader, le), W.add(K, Object.assign({}, z[ne].opts, { cache: !1 }), z[ne].loader, le));
      }
    }
    J.defineResolvers(ce);
  }, J.transformSchema = function(j) {
    Array.isArray(j) || (j = [j]);
    for (const ee of j)
      J.replaceSchema(ee(J.schema));
  }, t.resolvers && J.defineResolvers(t.resolvers), t.loaders && J.defineLoaders(t.loaders), t.schemaTransforms && J.transformSchema(t.schemaTransforms), J[ll] = new z3(), J.addHook = function(j, ee) {
    this[ll].add(j, ee);
  };
  async function J(j, ee, le, ce) {
    ee || (ee = {}), ee = Object.assign(ee, { app: this, errors: null }), ee = q3(ee, J[ll]);
    const U = ee.reply;
    ee.preParsing !== null && await Q3({ schema: J.schema, source: j, context: ee });
    const z = n !== null && n.get(j);
    let ne = null;
    if (z)
      ne = z.document;
    else {
      const B = r !== null && r.get(j);
      if (B) {
        const T = new go();
        throw T.errors = B.validationErrors, T;
      }
      try {
        ne = y0(j, a);
      } catch (T) {
        try {
          if (a.maxTokens && T.message === `Syntax Error: Document contains more that ${a.maxTokens} tokens. Parsing aborted.`)
            throw T;
          ne = JSON.parse(j);
        } catch {
          const P = new go();
          throw P.errors = [T], P;
        }
      }
      ee.preValidation !== null && await J3({ schema: J.schema, document: ne, context: ee });
      let M = [];
      t.validationRules && (Array.isArray(t.validationRules) ? M = t.validationRules : M = t.validationRules({ source: j, variables: le, operationName: ce }));
      const N = D3(J.schema, ne, [...k3, ...M], l);
      if (N.length > 0) {
        r && r.set(j, { document: ne, validationErrors: N });
        const T = new go();
        throw T.errors = N, T;
      }
      if (s) {
        const T = C3(ne.definitions, s);
        if (T.length > 0) {
          const P = new go();
          throw P.errors = T, P;
        }
      }
      n && n.set(j, { document: ne, validationErrors: N, count: 1, jit: null });
    }
    if (U && U.request.raw.method === "GET" && !U.request.ws && $3(ne, ce).operation !== "query") {
      const M = new G3();
      throw M.errors = [new Error("Operation cannot be performed via a GET request")], M;
    }
    const K = z && z.count++ === i;
    if (le !== void 0 && !K) {
      const B = j3({
        schema: J.schema,
        document: ne,
        rootValue: c,
        contextValue: ee,
        variableValues: le,
        operationName: ce
      });
      if (Array.isArray(B)) {
        const M = new go();
        throw M.errors = B, M;
      }
    }
    let se, re, ue;
    if (ee.preExecution !== null && ({ modifiedSchema: se, modifiedDocument: re, modifiedVariables: ue } = await K3({
      schema: J.schema,
      document: ne,
      context: ee,
      variables: le
    })), K && (!se && !re ? z.jit = E3(J.schema, ne, ce, t.compilerOptions) : z && z.count--), z && z.jit !== null && !se && !re && S3(z.jit)) {
      const B = await z.jit.query(c, ee, ue || le || {});
      return Z(B, ee);
    }
    const te = await L3({
      schema: se || J.schema,
      document: re || ne,
      rootValue: c,
      contextValue: ee,
      variableValues: ue || le,
      operationName: ce
    });
    return Z(te, ee);
  }
  async function Z(j, ee) {
    if (j = V3(j, ee.errors), j.errors) {
      const { reply: le } = ee, { statusCode: ce, response: { data: U, errors: z } } = o(j, ee);
      j.data = U, j.errors = z, le && le.code(ce);
    }
    return ee.onResolution !== null && await Y3({ execution: j, context: ee }), j;
  }
}, {
  name: "mercurius",
  fastify: "4.x"
});
is.ErrorWithProps = U3;
is.defaultErrorFormatter = eS;
is.persistedQueryDefaults = Nd;
is.withFilter = M3;
lu.exports = is;
lu.exports.mercurius = is;
lu.exports.default = is;
var Z3 = lu.exports;
const eB = /* @__PURE__ */ pS(Z3), tB = async (e, t) => {
  const n = e.config.graphql.plugins, r = {
    config: e.config,
    database: e.slonik,
    dbSchema: e.dbSchema
  };
  if (n)
    for (const i of n)
      await i.updateContext(r, e, t);
  return r;
}, nB = async (e) => {
  const t = e.config.graphql;
  t?.enabled ? await e.register(eB, {
    context: tB,
    ...t
  }) : e.log.info("GraphQL API not enabled");
};
oa(nB);
var ou = function() {
  return ou = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var i in t)
        Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
    }
    return e;
  }, ou.apply(this, arguments);
}, Rl = /* @__PURE__ */ new Map(), Od = /* @__PURE__ */ new Map(), tS = !0, au = !1;
function nS(e) {
  return e.replace(/[\s,]+/g, " ").trim();
}
function rB(e) {
  return nS(e.source.body.substring(e.start, e.end));
}
function iB(e) {
  var t = /* @__PURE__ */ new Set(), n = [];
  return e.definitions.forEach(function(r) {
    if (r.kind === "FragmentDefinition") {
      var i = r.name.value, s = rB(r.loc), o = Od.get(i);
      o && !o.has(s) ? tS && console.warn("Warning: fragment with name " + i + ` already exists.
graphql-tag enforces all fragment names across your application to be unique; read more about
this in the docs: http://dev.apollodata.com/core/fragments.html#unique-names`) : o || Od.set(i, o = /* @__PURE__ */ new Set()), o.add(s), t.has(s) || (t.add(s), n.push(r));
    } else
      n.push(r);
  }), ou(ou({}, e), { definitions: n });
}
function sB(e) {
  var t = new Set(e.definitions);
  t.forEach(function(r) {
    r.loc && delete r.loc, Object.keys(r).forEach(function(i) {
      var s = r[i];
      s && typeof s == "object" && t.add(s);
    });
  });
  var n = e.loc;
  return n && (delete n.startToken, delete n.endToken), e;
}
function oB(e) {
  var t = nS(e);
  if (!Rl.has(t)) {
    var n = sS(e, {
      experimentalFragmentVariables: au,
      allowLegacyFragmentVariables: au
    });
    if (!n || n.kind !== "Document")
      throw new Error("Not a valid GraphQL document.");
    Rl.set(t, sB(iB(n)));
  }
  return Rl.get(t);
}
function qi(e) {
  for (var t = [], n = 1; n < arguments.length; n++)
    t[n - 1] = arguments[n];
  typeof e == "string" && (e = [e]);
  var r = e[0];
  return t.forEach(function(i, s) {
    i && i.kind === "Document" ? r += i.loc.source.body : r += i, r += e[s + 1];
  }), oB(r);
}
function aB() {
  Rl.clear(), Od.clear();
}
function lB() {
  tS = !1;
}
function uB() {
  au = !0;
}
function cB() {
  au = !1;
}
var bo = {
  gql: qi,
  resetCaches: aB,
  disableFragmentWarnings: lB,
  enableExperimentalFragmentVariables: uB,
  disableExperimentalFragmentVariables: cB
};
(function(e) {
  e.gql = bo.gql, e.resetCaches = bo.resetCaches, e.disableFragmentWarnings = bo.disableFragmentWarnings, e.enableExperimentalFragmentVariables = bo.enableExperimentalFragmentVariables, e.disableExperimentalFragmentVariables = bo.disableExperimentalFragmentVariables;
})(qi || (qi = {}));
qi.default = qi;
const fB = 80;
let _0 = {};
function dB(e) {
  return `
# ` + e.replace(/\n/g, `
# `);
}
function Pe(e, t) {
  return e ? e.filter((n) => n).join(t || "") : "";
}
function w0(e) {
  return e?.some((t) => t.includes(`
`)) ?? !1;
}
function pB(e) {
  return (t, n, r, i, s) => {
    const o = [], a = i.reduce((u, f) => (["fields", "arguments", "values"].includes(f) && u.name && o.push(u.name.value), u[f]), s[0]), l = [...o, a?.name?.value].filter(Boolean).join("."), c = [];
    return t.kind.includes("Definition") && _0[l] && c.push(..._0[l]), Pe([...c.map(dB), t.description, e(t, n, r, i, s)], `
`);
  };
}
function Uo(e) {
  return e && `  ${e.replace(/\n/g, `
  `)}`;
}
function zn(e) {
  return e && e.length !== 0 ? `{
${Uo(Pe(e, `
`))}
}` : "";
}
function Ot(e, t, n) {
  return t ? e + t + (n || "") : "";
}
function hB(e, t = !1) {
  const n = e.replace(/"""/g, '\\"""');
  return (e[0] === " " || e[0] === "	") && e.indexOf(`
`) === -1 ? `"""${n.replace(/"$/, `"
`)}"""` : `"""
${t ? n : Uo(n)}
"""`;
}
const E0 = {
  Name: { leave: (e) => e.value },
  Variable: { leave: (e) => "$" + e.name },
  // Document
  Document: {
    leave: (e) => Pe(e.definitions, `

`)
  },
  OperationDefinition: {
    leave: (e) => {
      const t = Ot("(", Pe(e.variableDefinitions, ", "), ")");
      return Pe([e.operation, Pe([e.name, t]), Pe(e.directives, " ")], " ") + " " + e.selectionSet;
    }
  },
  VariableDefinition: {
    leave: ({ variable: e, type: t, defaultValue: n, directives: r }) => e + ": " + t + Ot(" = ", n) + Ot(" ", Pe(r, " "))
  },
  SelectionSet: { leave: ({ selections: e }) => zn(e) },
  Field: {
    leave({ alias: e, name: t, arguments: n, directives: r, selectionSet: i }) {
      const s = Ot("", e, ": ") + t;
      let o = s + Ot("(", Pe(n, ", "), ")");
      return o.length > fB && (o = s + Ot(`(
`, Uo(Pe(n, `
`)), `
)`)), Pe([o, Pe(r, " "), i], " ");
    }
  },
  Argument: { leave: ({ name: e, value: t }) => e + ": " + t },
  // Fragments
  FragmentSpread: {
    leave: ({ name: e, directives: t }) => "..." + e + Ot(" ", Pe(t, " "))
  },
  InlineFragment: {
    leave: ({ typeCondition: e, directives: t, selectionSet: n }) => Pe(["...", Ot("on ", e), Pe(t, " "), n], " ")
  },
  FragmentDefinition: {
    leave: ({ name: e, typeCondition: t, variableDefinitions: n, directives: r, selectionSet: i }) => (
      // Note: fragment variable definitions are experimental and may be changed
      // or removed in the future.
      `fragment ${e}${Ot("(", Pe(n, ", "), ")")} on ${t} ${Ot("", Pe(r, " "), " ")}` + i
    )
  },
  // Value
  IntValue: { leave: ({ value: e }) => e },
  FloatValue: { leave: ({ value: e }) => e },
  StringValue: {
    leave: ({ value: e, block: t }) => t ? hB(e) : JSON.stringify(e)
  },
  BooleanValue: { leave: ({ value: e }) => e ? "true" : "false" },
  NullValue: { leave: () => "null" },
  EnumValue: { leave: ({ value: e }) => e },
  ListValue: { leave: ({ values: e }) => "[" + Pe(e, ", ") + "]" },
  ObjectValue: { leave: ({ fields: e }) => "{" + Pe(e, ", ") + "}" },
  ObjectField: { leave: ({ name: e, value: t }) => e + ": " + t },
  // Directive
  Directive: {
    leave: ({ name: e, arguments: t }) => "@" + e + Ot("(", Pe(t, ", "), ")")
  },
  // Type
  NamedType: { leave: ({ name: e }) => e },
  ListType: { leave: ({ type: e }) => "[" + e + "]" },
  NonNullType: { leave: ({ type: e }) => e + "!" },
  // Type System Definitions
  SchemaDefinition: {
    leave: ({ directives: e, operationTypes: t }) => Pe(["schema", Pe(e, " "), zn(t)], " ")
  },
  OperationTypeDefinition: {
    leave: ({ operation: e, type: t }) => e + ": " + t
  },
  ScalarTypeDefinition: {
    leave: ({ name: e, directives: t }) => Pe(["scalar", e, Pe(t, " ")], " ")
  },
  ObjectTypeDefinition: {
    leave: ({ name: e, interfaces: t, directives: n, fields: r }) => Pe([
      "type",
      e,
      Ot("implements ", Pe(t, " & ")),
      Pe(n, " "),
      zn(r)
    ], " ")
  },
  FieldDefinition: {
    leave: ({ name: e, arguments: t, type: n, directives: r }) => e + (w0(t) ? Ot(`(
`, Uo(Pe(t, `
`)), `
)`) : Ot("(", Pe(t, ", "), ")")) + ": " + n + Ot(" ", Pe(r, " "))
  },
  InputValueDefinition: {
    leave: ({ name: e, type: t, defaultValue: n, directives: r }) => Pe([e + ": " + t, Ot("= ", n), Pe(r, " ")], " ")
  },
  InterfaceTypeDefinition: {
    leave: ({ name: e, interfaces: t, directives: n, fields: r }) => Pe([
      "interface",
      e,
      Ot("implements ", Pe(t, " & ")),
      Pe(n, " "),
      zn(r)
    ], " ")
  },
  UnionTypeDefinition: {
    leave: ({ name: e, directives: t, types: n }) => Pe(["union", e, Pe(t, " "), Ot("= ", Pe(n, " | "))], " ")
  },
  EnumTypeDefinition: {
    leave: ({ name: e, directives: t, values: n }) => Pe(["enum", e, Pe(t, " "), zn(n)], " ")
  },
  EnumValueDefinition: {
    leave: ({ name: e, directives: t }) => Pe([e, Pe(t, " ")], " ")
  },
  InputObjectTypeDefinition: {
    leave: ({ name: e, directives: t, fields: n }) => Pe(["input", e, Pe(t, " "), zn(n)], " ")
  },
  DirectiveDefinition: {
    leave: ({ name: e, arguments: t, repeatable: n, locations: r }) => "directive @" + e + (w0(t) ? Ot(`(
`, Uo(Pe(t, `
`)), `
)`) : Ot("(", Pe(t, ", "), ")")) + (n ? " repeatable" : "") + " on " + Pe(r, " | ")
  },
  SchemaExtension: {
    leave: ({ directives: e, operationTypes: t }) => Pe(["extend schema", Pe(e, " "), zn(t)], " ")
  },
  ScalarTypeExtension: {
    leave: ({ name: e, directives: t }) => Pe(["extend scalar", e, Pe(t, " ")], " ")
  },
  ObjectTypeExtension: {
    leave: ({ name: e, interfaces: t, directives: n, fields: r }) => Pe([
      "extend type",
      e,
      Ot("implements ", Pe(t, " & ")),
      Pe(n, " "),
      zn(r)
    ], " ")
  },
  InterfaceTypeExtension: {
    leave: ({ name: e, interfaces: t, directives: n, fields: r }) => Pe([
      "extend interface",
      e,
      Ot("implements ", Pe(t, " & ")),
      Pe(n, " "),
      zn(r)
    ], " ")
  },
  UnionTypeExtension: {
    leave: ({ name: e, directives: t, types: n }) => Pe(["extend union", e, Pe(t, " "), Ot("= ", Pe(n, " | "))], " ")
  },
  EnumTypeExtension: {
    leave: ({ name: e, directives: t, values: n }) => Pe(["extend enum", e, Pe(t, " "), zn(n)], " ")
  },
  InputObjectTypeExtension: {
    leave: ({ name: e, directives: t, fields: n }) => Pe(["extend input", e, Pe(t, " "), zn(n)], " ")
  }
};
Object.keys(E0).reduce((e, t) => ({
  ...e,
  [t]: {
    leave: pB(E0[t].leave)
  }
}), {});
var S0;
(function(e) {
  e[e.A_SMALLER_THAN_B = -1] = "A_SMALLER_THAN_B", e[e.A_EQUALS_B = 0] = "A_EQUALS_B", e[e.A_GREATER_THAN_B = 1] = "A_GREATER_THAN_B";
})(S0 || (S0 = {}));
var Jn = {};
Object.defineProperty(Jn, "__esModule", {
  value: !0
});
Jn.Token = Jn.QueryDocumentKeys = Jn.OperationTypeNode = Jn.Location = void 0;
Jn.isNode = bB;
class mB {
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The Token at which this Node begins.
   */
  /**
   * The Token at which this Node ends.
   */
  /**
   * The Source document the AST represents.
   */
  constructor(t, n, r) {
    this.start = t.start, this.end = n.end, this.startToken = t, this.endToken = n, this.source = r;
  }
  get [Symbol.toStringTag]() {
    return "Location";
  }
  toJSON() {
    return {
      start: this.start,
      end: this.end
    };
  }
}
Jn.Location = mB;
class yB {
  /**
   * The kind of Token.
   */
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The 1-indexed line number on which this Token appears.
   */
  /**
   * The 1-indexed column number at which this Token begins.
   */
  /**
   * For non-punctuation tokens, represents the interpreted value of the token.
   *
   * Note: is undefined for punctuation tokens, but typed as string for
   * convenience in the parser.
   */
  /**
   * Tokens exist as nodes in a double-linked-list amongst all tokens
   * including ignored tokens. <SOF> is always the first node and <EOF>
   * the last.
   */
  constructor(t, n, r, i, s, o) {
    this.kind = t, this.start = n, this.end = r, this.line = i, this.column = s, this.value = o, this.prev = null, this.next = null;
  }
  get [Symbol.toStringTag]() {
    return "Token";
  }
  toJSON() {
    return {
      kind: this.kind,
      value: this.value,
      line: this.line,
      column: this.column
    };
  }
}
Jn.Token = yB;
const rS = {
  Name: [],
  Document: ["definitions"],
  OperationDefinition: [
    "name",
    "variableDefinitions",
    "directives",
    "selectionSet"
  ],
  VariableDefinition: ["variable", "type", "defaultValue", "directives"],
  Variable: ["name"],
  SelectionSet: ["selections"],
  Field: ["alias", "name", "arguments", "directives", "selectionSet"],
  Argument: ["name", "value"],
  FragmentSpread: ["name", "directives"],
  InlineFragment: ["typeCondition", "directives", "selectionSet"],
  FragmentDefinition: [
    "name",
    // Note: fragment variable definitions are deprecated and will removed in v17.0.0
    "variableDefinitions",
    "typeCondition",
    "directives",
    "selectionSet"
  ],
  IntValue: [],
  FloatValue: [],
  StringValue: [],
  BooleanValue: [],
  NullValue: [],
  EnumValue: [],
  ListValue: ["values"],
  ObjectValue: ["fields"],
  ObjectField: ["name", "value"],
  Directive: ["name", "arguments"],
  NamedType: ["name"],
  ListType: ["type"],
  NonNullType: ["type"],
  SchemaDefinition: ["description", "directives", "operationTypes"],
  OperationTypeDefinition: ["type"],
  ScalarTypeDefinition: ["description", "name", "directives"],
  ObjectTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  FieldDefinition: ["description", "name", "arguments", "type", "directives"],
  InputValueDefinition: [
    "description",
    "name",
    "type",
    "defaultValue",
    "directives"
  ],
  InterfaceTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  UnionTypeDefinition: ["description", "name", "directives", "types"],
  EnumTypeDefinition: ["description", "name", "directives", "values"],
  EnumValueDefinition: ["description", "name", "directives"],
  InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
  DirectiveDefinition: ["description", "name", "arguments", "locations"],
  SchemaExtension: ["directives", "operationTypes"],
  ScalarTypeExtension: ["name", "directives"],
  ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
  InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
  UnionTypeExtension: ["name", "directives", "types"],
  EnumTypeExtension: ["name", "directives", "values"],
  InputObjectTypeExtension: ["name", "directives", "fields"]
};
Jn.QueryDocumentKeys = rS;
const gB = new Set(Object.keys(rS));
function bB(e) {
  const t = e?.kind;
  return typeof t == "string" && gB.has(t);
}
var Id;
Jn.OperationTypeNode = Id;
(function(e) {
  e.QUERY = "query", e.MUTATION = "mutation", e.SUBSCRIPTION = "subscription";
})(Id || (Jn.OperationTypeNode = Id = {}));
qi`
  directive @auth(profileValidation: Boolean) on OBJECT | FIELD_DEFINITION
  directive @hasPermission(permission: String!) on OBJECT | FIELD_DEFINITION

  scalar DateTime
  scalar JSON

  input Filters {
    AND: [Filters]
    OR: [Filters]
    not: Boolean
    key: String
    operator: String
    value: String
  }

  enum SortDirection {
    ASC
    DESC
  }

  input SortInput {
    key: String
    direction: SortDirection
  }

  type DeleteResult {
    result: Boolean!
  }
`;
const JB = qi`
  input OrganizationCreateInput {
    billingAddress: String
    name: String
    schema: String
    taxId: String
    tenant: Boolean
    typeId: Int
  }

  input OrganizationUpdateInput {
    billingAddress: String
    name: String
    taxId: String
    typeId: Int
  }

  type Mutation {
    createOrganization(data: OrganizationCreateInput!): Organization @auth
    deleteOrganization(id: Int!): Organization @auth
    updateOrganization(id: Int!, data: OrganizationUpdateInput!): Organization
      @auth
  }

  type Organizations {
    totalCount: Int
    filteredCount: Int
    data: [Organization]!
  }

  type Organization {
    id: String!
    billingAddress: String!
    name: String!
    schema: String
    taxId: String
    tenant: Boolean
    typeId: Int!
  }

  type Query {
    organizations(
      limit: Int
      offset: Int
      filters: Filters
      sort: [SortInput]
    ): Organizations! @auth
    organization(id: Int!): Organization @auth
  }
`, vB = () => Jh.unsafe`
    CREATE TABLE IF NOT EXISTS ${Jh.identifier([T0])} (
      "id" INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
      "billing_address" VARCHAR(255),
      "name" VARCHAR(255),
      "schema" VARCHAR(63) DEFAULT 'public',
      "tax_id" VARCHAR(255),
      "tenant" BOOLEAN,
      "type_id" INTEGER
    );
  `, _B = async (e) => {
  await e.connect(async (t) => {
    await t.query(vB());
  });
}, KB = oa(
  async (e, t, n) => {
    const { log: r, slonik: i } = e;
    r.info("Registering billing-fastify plugin"), await _B(i), n();
  }
);
export {
  KB as default,
  NB as organizationResolver,
  $B as organizationRoutes,
  JB as organizationSchema,
  mr as organizationService
};
