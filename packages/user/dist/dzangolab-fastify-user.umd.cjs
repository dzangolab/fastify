(function(c,h){typeof exports=="object"&&typeof module<"u"?h(exports,require("@dzangolab/fastify-mercurius"),require("fastify-plugin"),require("mercurius"),require("mercurius-auth"),require("@fastify/cors"),require("@fastify/formbody"),require("supertokens-node"),require("supertokens-node/framework/fastify"),require("supertokens-node/recipe/session/framework/fastify"),require("supertokens-node/recipe/session"),require("supertokens-node/recipe/thirdpartyemailpassword"),require("supertokens-node/recipe/userroles"),require("@dzangolab/fastify-slonik"),require("@dzangolab/fastify-mailer"),require("validator"),require("zod")):typeof define=="function"&&define.amd?define(["exports","@dzangolab/fastify-mercurius","fastify-plugin","mercurius","mercurius-auth","@fastify/cors","@fastify/formbody","supertokens-node","supertokens-node/framework/fastify","supertokens-node/recipe/session/framework/fastify","supertokens-node/recipe/session","supertokens-node/recipe/thirdpartyemailpassword","supertokens-node/recipe/userroles","@dzangolab/fastify-slonik","@dzangolab/fastify-mailer","validator","zod"],h):(c=typeof globalThis<"u"?globalThis:c||self,h(c.DzangolabFastifyUser={},c.DzangolabFastifyMercurius,c.FastifyPlugin,c.Mercurius,c.MercuriusAuth,c.FastifyCors,c.FastifyFormbody,c.SupertokensNode,c.SupertokensFastify,c.SupertokensSessionFastify,c.SupertokensSession,c.SupertokensThirdPartyEmailPassword,c.SupertokensUserRoles,c.DzangolabFastifySlonik,c.DzangolabFastifyMailer,c.validator,c.zod))})(this,function(c,h,P,v,D,_,q,R,U,L,S,d,g,k,me,E,I){"use strict";const M=P(async s=>{s.config.mercurius.enabled&&s.register(D,{async applyPolicy(e,n,t,o){if(!o.user){const i=new v.ErrorWithProps("unauthorized");return i.statusCode=200,i}return!0},authDirective:"auth"})}),A=()=>({override:{functions:function(s){return{...s,createNewSession:async function(r){return r.accessTokenPayload={...r.accessTokenPayload,user:await d.getUserById(r.userId,{tenant:r.userContext.tenant})},s.createNewSession(r)}}}}}),B=s=>{const r=s.config.user.supertokens.recipes;return r&&r.session?S.init(r.session(s)):S.init(A())};class $ extends k.DefaultSqlFactory{}class f extends k.BaseService{static LIMIT_DEFAULT=20;static LIMIT_MAX=50;get table(){return this.config.user?.table?.name||"users"}get factory(){if(!this.table)throw new Error("Service table is not defined");return this._factory||(this._factory=new $(this)),this._factory}}const O=s=>s.multiTenant?.table?.columns?.id||"id",y={addTenantPrefix:(s,r,e)=>(e&&(r=e[O(s)]+"_"+r),r),removeTenantPrefix:(s,r)=>(r&&(s=s.slice(Math.max(0,s.indexOf("_")+1))),s)},z=(s,r)=>{const{config:e,slonik:n}=r;return async t=>{const o=t.email;t.email=y.addTenantPrefix(e,t.email,t.userContext.tenant);const i=await s.emailPasswordSignIn(t);if(i.status!=="OK")return i;const a=new f(e,n);let u=null;try{u=await a.findById(i.user.id)}catch{}const{roles:l}=await g.getRolesForUser(i.user.id);return{status:"OK",user:{...i.user,email:o,profile:u,roles:l}}}},x=(s,r)=>async e=>{if(e.userContext.tenant=e.options.req.original.tenant,s.emailPasswordSignInPOST===void 0)throw new Error("Should never come here");return await s.emailPasswordSignInPOST(e)},C=async({fastify:s,subject:r,templateData:e={},templateName:n,to:t})=>{const{config:o,mailer:i,log:a}=s;return i.sendMail({subject:r,templateName:n,to:t,templateData:{appName:o.appName,...e}}).catch(u=>{throw a.error(u.stack),{name:"SEND_EMAIL",message:u.message,statusCode:500}})},K=(s,r)=>{const{config:e,log:n}=r;return async t=>{if(e.user.features?.signUp===!1)throw{name:"SIGN_UP_DISABLED",message:"SignUp feature is currently disabled",statusCode:404};const o=t.email;t.email=y.addTenantPrefix(e,o,t.userContext.tenant);let i=await s.emailPasswordSignUp(t);if(i.status==="OK"){const a=await g.addRoleToUser(i.user.id,e.user.role||"USER");a.status!=="OK"&&n.error(a.status)}if(e.user.supertokens.sendUserAlreadyExistsWarning&&i.status==="EMAIL_ALREADY_EXISTS_ERROR")try{await C({fastify:r,subject:"Duplicate Email Registration",templateData:{emailId:o},templateName:"duplicate-email-warning",to:o})}catch(a){n.error(a)}return i.status==="OK"&&(i={...i,user:{...i.user,email:o}}),i}},H=(s,r)=>async e=>{if(e.userContext.tenant=e.options.req.original.tenant,s.emailPasswordSignUpPOST===void 0)throw new Error("Should never come here");const n=await s.emailPasswordSignUpPOST(e);if(n.status==="OK"){const{roles:t}=await g.getRolesForUser(n.user.id);return{status:"OK",user:{...n.user,profile:null,roles:t},session:n.session}}return n},J=(s,r,e)=>(e&&r.find(n=>{n.id==="email"&&(n.value=e[O(s)]+"_"+n.value)}),r),W=(s,r)=>async e=>{if(e.userContext.tenant=e.options.req.original.tenant,s.generatePasswordResetTokenPOST===void 0)throw new Error("Should never come here");return e.formFields=J(r.config,e.formFields,e.userContext.tenant),await s.generatePasswordResetTokenPOST(e)},j=s=>async r=>{let e=await s.getUserById(r);return e&&r.userContext.tenant&&(e={...e,email:y.removeTenantPrefix(e.email,r.userContext.tenant)}),e},G=s=>{let r;try{if(r=new URL(s).origin,!r||r==="null")throw new Error("Origin is empty")}catch{r=""}return r},Q=s=>{const r=s.config.appOrigin[0],e="/reset-password";return async n=>{const t=n.userContext._default.request.request,o=t.headers.referer||t.headers.origin||t.hostname,i=G(o)||r,a=n.passwordResetLink.replace(r+"/auth/reset-password",i+(s.config.user.supertokens.resetPasswordPath||e));await C({fastify:s,subject:"Reset Password",templateName:"reset-password",to:y.removeTenantPrefix(n.user.email,n.userContext.tenant),templateData:{passwordResetLink:a}})}},V=(s,r)=>{const{config:e,log:n}=r;return async t=>{const o=t.userContext.tenant;if(o){const u=o[O(e)];t.thirdPartyUserId=u+"_"+t.thirdPartyUserId}if(!await d.getUserByThirdPartyInfo(t.thirdPartyId,t.thirdPartyUserId,t.userContext)&&e.user.features?.signUp===!1)throw{name:"SIGN_UP_DISABLED",message:"SignUp feature is currently disabled",statusCode:404};const a=await s.thirdPartySignInUp(t);if(a.status==="OK"){const u=await g.addRoleToUser(a.user.id,e.user.role||"USER");u.status!=="OK"&&n.error(u.status)}return a}},X=(s,r)=>async e=>{if(e.userContext.tenant=e.options.req.original.tenant,s.thirdPartySignInUpPOST===void 0)throw new Error("Should never come here");const n=await s.thirdPartySignInUpPOST(e);if(n.status==="OK"&&n.createdNewUser){const{roles:t}=await g.getRolesForUser(n.user.id),o={...n.user,profile:null,roles:t};return{status:"OK",createdNewUser:n.createdNewUser,user:o,session:n.session,authCodeResponse:n.authCodeResponse}}return n},Y=s=>{const{Apple:r,Facebook:e,Github:n,Google:t}=d,o=s.user.supertokens.providers,i=[],a=[{name:"google",initProvider:t},{name:"github",initProvider:n},{name:"facebook",initProvider:e},{name:"apple",initProvider:r}];for(const u of a)o?.[u.name]&&i.push(u.initProvider(o[u.name]));return i},Z=(s,r)=>I.z.string({required_error:s.required}).refine(e=>E.isEmail(e,r||{}),{message:s.invalid}),T={minLength:8,minLowercase:0,minUppercase:0,minNumbers:0,minSymbols:0,returnScore:!1,pointsPerUnique:1,pointsPerRepeat:.5,pointsForContainingLower:10,pointsForContainingUpper:10,pointsForContainingNumber:10,pointsForContainingSymbol:10},ee=(s,r)=>{const e={...T,...r};return I.z.string({required_error:s.required}).refine(n=>E.isStrongPassword(n,e),{message:s.weak})},se=(s,r)=>{const e=Z({invalid:"Email is invalid",required:"Email is required"},r.user.email).safeParse(s);return e.success?{success:!0}:{message:e.error.issues[0].message,success:!1}},re=s=>{let r="Password is too weak";if(!s)return r;const e=[];if(s.minLength){const n=s.minLength;e.push(`minimum ${n} ${n>1?"characters":"character"}`)}if(s.minLowercase){const n=s.minLowercase;e.push(`minimum ${n} ${n>1?"lowercases":"lowercase"}`)}if(s.minUppercase){const n=s.minUppercase;e.push(`minimum ${n} ${n>1?"uppercases":"uppercase"}`)}if(s.minNumbers){const n=s.minNumbers;e.push(`minimum ${n} ${n>1?"numbers":"number"}`)}if(s.minSymbols){const n=s.minSymbols;e.push(`minimum ${n} ${n>1?"symbols":"symbol"}`)}if(e.length>0){r="Password should contain ";const n=e.pop();e.length>0&&(r+=e.join(", ")+" and "),r+=n}return r},b=(s,r)=>{const e=r.user.password,n=ee({required:"Password is required",weak:re({...T,...e})},e).safeParse(s);return n.success?{success:!0}:{message:n.error.issues[0].message,success:!1}},ne=s=>{const{config:r}=s;return{override:{apis:e=>({...e,emailPasswordSignInPOST:x(e),emailPasswordSignUpPOST:H(e),generatePasswordResetTokenPOST:W(e,s),thirdPartySignInUpPOST:X(e)}),functions:e=>({...e,emailPasswordSignIn:z(e,s),emailPasswordSignUp:K(e,s),getUserById:j(e),thirdPartySignInUp:V(e,s)})},signUpFeature:{formFields:[{id:"email",validate:async e=>{const n=se(e,r);if(!n.success)return n.message}},{id:"password",validate:async e=>{const n=b(e,r);if(!n.success)return n.message}}]},emailDelivery:{override:e=>({...e,sendEmail:Q(s)})},providers:Y(r)}},te=s=>{const r=s.config.user.supertokens.recipes;return r&&r.thirdPartyEmailPassword?d.init(r.thirdPartyEmailPassword(s)):d.init(ne(s))},oe=()=>({}),ie=s=>{const r=s.config.user.supertokens.recipes;return r&&r.userRoles?g.init(r.userRoles(s)):g.init(oe())},ae=s=>[B(s),te(s),ie(s)],ce=s=>{const{config:r}=s;R.init({appInfo:{apiDomain:r.baseUrl,appName:r.appName,websiteDomain:r.appOrigin[0]},recipeList:ae(s),supertokens:{connectionURI:r.user.supertokens.connectionUri}})},ue=P(async(s,r,e)=>{const{config:n,log:t}=s;t.info("Registering supertokens plugin"),ce(s),s.setErrorHandler(U.errorHandler()),s.register(_,{origin:n.appOrigin,allowedHeaders:["Content-Type","st-auth-mode",...R.getAllCORSHeaders()],credentials:!0}),s.register(q),s.register(U.plugin),t.info("Registering supertokens plugin complete"),s.decorate("verifySession",L.verifySession),e()}),de=async(s,r,e)=>{const{config:n,slonik:t,tenant:o}=r,a=(await S.getSession(r,U.wrapResponse(e),{sessionRequired:!1}))?.getUserId();if(a){const u=new f(n,t),l=await d.getUserById(a,{tenant:o});if(l){let p=null;const{roles:m}=await g.getRolesForUser(a);try{p=await u.findById(a)}catch{}const N={...l,profile:p,roles:m};s.user=N}}},F=P(async(s,r,e)=>{const{mercurius:n}=s.config;await s.register(ue),n.enabled&&await s.register(M),e()});F.updateContext=de;const le={Query:{user:async(s,r,e)=>await new f(e.config,e.database).findById(r.id),users:async(s,r,e)=>await new f(e.config,e.database).list(r.limit,r.offset,r.filters?JSON.parse(JSON.stringify(r.filters)):void 0,r.sort?JSON.parse(JSON.stringify(r.sort)):void 0)}},ge=async(s,r,e)=>{const n="/users";s.get(n,{preHandler:s.verifySession()},async(t,o)=>{const i=new f(t.config,t.slonik),{limit:a,offset:u,filters:l,sort:p}=t.query,m=await i.list(a,u,l?JSON.parse(l):void 0,p?JSON.parse(p):void 0);o.send(m)}),e()};class w{config;database;constructor(r,e){this.config=r,this.database=e}changePassword=async(r,e,n,t)=>{const o=b(n,this.config);if(!o.success)return{status:"FIELD_ERROR",message:o.message};const i=await d.getUserById(r,{tenant:t});if(e&&n)if(i)if((await d.emailPasswordSignIn(i.email,e,{tenant:t})).status==="OK"){if(await d.updateEmailOrPassword({userId:r,password:n,userContext:{tenant:t}}))return await S.revokeAllSessionsForUser(r),{status:"OK"};throw{status:"FAILED",message:"Oops! Something went wrong, couldn't change password"}}else return{status:"INVALID_PASSWORD",message:"Invalid password"};else throw{status:"NOT_FOUND",message:"User not found"};else return{status:"FIELD_ERROR",message:"Password cannot be empty"}};getUserById=async(r,e)=>{const n=await d.getUserById(r,{tenant:e}),t=new f(this.config,this.database);let o=null;try{o=await t.findById(r)}catch{}const i=await g.getRolesForUser(r);return{email:n?.email,id:r,profile:o,roles:i.roles,timeJoined:n?.timeJoined}}}const pe={Mutation:{changePassword:async(s,r,e)=>{const n=new w(e.config,e.database);try{return e.user?.id?await n.changePassword(e.user?.id,r.oldPassword,r.newPassword,e.tenant):{status:"NOT_FOUND",message:"User not found"}}catch(t){e.app.log.error(t);const o=new v.ErrorWithProps("Oops, Something went wrong");return o.statusCode=500,o}}},Query:{me:async(s,r,e)=>{const n=new w(e.config,e.database);if(e.user?.id)return n.getUserById(e.user.id,e.tenant);{e.app.log.error("Cound not get user id from mercurius context");const t=new v.ErrorWithProps("Oops, Something went wrong");return t.statusCode=500,t}}}},fe=async(s,r,e)=>{const n="/change_password",t="/me";s.post(n,{preHandler:s.verifySession()},async(o,i)=>{try{const a=o.session,u=o.body,l=a&&a.getUserId();if(!l)throw new Error("User not found in session");const p=u.oldPassword??"",m=u.newPassword??"",we=await new w(o.config,o.slonik).changePassword(l,p,m,o.tenant);i.send(we)}catch(a){s.log.error(a),i.status(500),i.send({status:"ERROR",message:"Oops! Something went wrong",error:a})}}),s.get(t,{preHandler:s.verifySession()},async(o,i)=>{const a=new w(o.config,o.slonik),u=o.session?.getUserId();if(u)i.send(await a.getUserById(u,o.tenant));else throw s.log.error("Cound not get user id from session"),new Error("Oops, Something went wrong")}),e()};c.UserProfileService=f,c.UserService=w,c.default=F,c.userProfileResolver=le,c.userProfileRoutes=ge,c.userResolver=pe,c.userRoutes=fe,Object.defineProperties(c,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});
