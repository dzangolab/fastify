(function(c,J){typeof exports=="object"&&typeof module<"u"?J(exports,require("@dzangolab/fastify-mercurius"),require("fastify-plugin"),require("mercurius"),require("mercurius-auth"),require("supertokens-node/recipe/emailverification"),require("supertokens-node/recipe/userroles"),require("supertokens-node/recipe/session"),require("@fastify/cors"),require("@fastify/formbody"),require("supertokens-node"),require("supertokens-node/framework/fastify"),require("supertokens-node/recipe/session/framework/fastify"),require("@dzangolab/fastify-mailer"),require("@dzangolab/fastify-slonik"),require("supertokens-node/recipe/thirdpartyemailpassword"),require("humps"),require("slonik"),require("validator"),require("zod")):typeof define=="function"&&define.amd?define(["exports","@dzangolab/fastify-mercurius","fastify-plugin","mercurius","mercurius-auth","supertokens-node/recipe/emailverification","supertokens-node/recipe/userroles","supertokens-node/recipe/session","@fastify/cors","@fastify/formbody","supertokens-node","supertokens-node/framework/fastify","supertokens-node/recipe/session/framework/fastify","@dzangolab/fastify-mailer","@dzangolab/fastify-slonik","supertokens-node/recipe/thirdpartyemailpassword","humps","slonik","validator","zod"],J):(c=typeof globalThis<"u"?globalThis:c||self,J(c.DzangolabFastifyUser={},c.DzangolabFastifyMercurius,c.FastifyPlugin,c.Mercurius,c.MercuriusAuth,c.EmailVerification,c.SupertokensUserRoles,c.SupertokensSession,c.FastifyCors,c.FastifyFormbody,c.SupertokensNode,c.SupertokensFastify,c.SupertokensSessionFastify,c.DzangolabFastifyMailer,c.DzangolabFastifySlonik,c.SupertokensThirdPartyEmailPassword,c.Humps,c.Slonik,c.validator,c.zod))})(this,function(c,J,q,g,ce,b,R,P,je,ze,W,X,Je,Wr,f,N,Z,w,ue,de){"use strict";const Ge=q(async r=>{await r.register(ce,{async applyPolicy(e,t,s,n){return n.user?n.user.disabled?new g.ErrorWithProps("user is disabled",{},401):r.config.user.features?.signUp?.emailVerification&&!await b.isEmailVerified(n.user.id)?new g.ErrorWithProps("invalid claim",{claimValidationErrors:[{id:"st-ev",reason:{message:"wrong value",expectedValue:!0,actualValue:!1}}]},403):!0:new g.ErrorWithProps("unauthorized",{},401)},authDirective:"auth"})}),le="/signup/token/:token",ge=30,me="/invitations",pe="/invitations/token/:token",we="/invitations",Ee="/invitations/token/:token",Se="/invitations/resend/:id(^\\d+)",he="/invitations/revoke/:id(^\\d+)",fe="invitations",Re="/reset-password",y="ADMIN",ve="SUPER_ADMIN",G="USER",Ie="/change_password",x="/signup/admin",ee="/me",Oe="/users",Pe="/users/:id/disable",Te="/users/:id/enable",re="users",se="/roles",te="/roles/permissions",_e="/permissions",Ne="REQUIRED",ye="/verify-email",Ae="invitations:create",Ue="invitations:list",be="invitations:resend",Le="invitations:revoke",Ce="users:disable",De="users:enable",ke="users:enable",S="public",Qe=async r=>{let e=[];for(const t of r){const s=await R.getPermissionsForRole(t);s.status==="OK"&&(e=[...new Set([...e,...s.permissions])])}return e},ne=async(r,e,t)=>{const s=r.config.user.permissions;if(!s||!s.includes(t))return!0;const{roles:n}=await R.getRolesForUser(S,e);if(n&&n.includes(ve))return!0;const o=await Qe(n);return!(!o||!o.includes(t))},Ye=q(async r=>{await r.register(ce,{applyPolicy:async(e,t,s,n)=>{const o=e.arguments.find(a=>a.name.value==="permission").value.value;return n.user?await ne(n.app,n.user?.id,o)?!0:new g.ErrorWithProps("invalid claim",{claimValidationErrors:[{id:"st-perm",reason:{message:"Not have enough permission",expectedToInclude:o}}]},403):new g.ErrorWithProps("unauthorized",{},401)},authDirective:"hasPermission"})}),Xe=q(async r=>{r.config.mercurius.enabled&&(await r.register(Ye),await r.register(Ge))}),Ze=r=>async e=>{const t=e.session?.getUserId();if(!t)throw new P.Error({type:"UNAUTHORISED",message:"unauthorised"});if(!await ne(e.server,t,r))throw new P.Error({type:"INVALID_CLAIMS",message:"Not have enough permission",payload:[{id:R.PermissionClaim.key,reason:{message:"Not have enough permission",expectedToInclude:r}}]})},Q=r=>{let e;try{if(e=new URL(r).origin,!e||e==="null")throw new Error("Origin is empty")}catch{e=""}return e},F=async({fastify:r,subject:e,templateData:t={},templateName:s,to:n})=>{const{config:o,log:i,mailer:a}=r;return a.sendMail({subject:e,templateName:s,to:n,templateData:{appName:o.appName,...t}}).catch(d=>{i.error(d.stack)})},xe=(r,e)=>{const t=e.config.appOrigin[0];return async s=>{let n;try{const i=s.userContext._default.request.request,a=i.headers.referer||i.headers.origin||i.hostname;n=Q(a)||t}catch{n=t}const o=s.emailVerifyLink.replace(t+"/auth/verify-email",n+(e.config.user.supertokens.emailVerificationPath||ye));F({fastify:e,subject:"Email Verification",templateName:"email-verification",to:s.user.email,templateData:{emailVerifyLink:o}})}},er=r=>{const{config:e}=r;let t={};return typeof e.user.supertokens.recipes?.emailVerification=="object"&&(t=e.user.supertokens.recipes.emailVerification),{mode:t?.mode||Ne,emailDelivery:{override:s=>{let n;return t?.sendEmail&&(n=t.sendEmail),{...s,sendEmail:n?n(s,r):xe(s,r)}}},override:{apis:s=>{const n={};if(t.override?.apis){const o=t.override.apis;let i;for(i in o){const a=o[i];a&&(n[i]=a(s,r))}}return{...s,verifyEmailPOST:async o=>{if(s.verifyEmailPOST===void 0)throw new Error("Should never come here");return o.session?await s.verifyEmailPOST(o):{status:"EMAIL_VERIFICATION_INVALID_TOKEN_ERROR"}},...n}},functions:s=>{const n={};if(t.override?.functions){const o=t.override.functions;let i;for(i in o){const a=o[i];a&&(n[i]=a(s,r))}}return{...s,...n}}}}},rr=r=>{const e=r.config.user.supertokens.recipes?.emailVerification;return typeof e=="function"?b.init(e(r)):b.init(er(r))},sr=(r,e)=>{if(e&&e.length>0){const t=[];for(const s of e){const n=s.direction==="ASC"?w.sql.fragment`ASC`:w.sql.fragment`DESC`;let o;s.key==="roles"&&(o=w.sql.fragment`user_role.role ->> 0`);const i=w.sql.identifier([...r.names,Z.decamelize(s.key)]);t.push(w.sql.fragment`${o??i} ${n}`)}return w.sql.fragment`ORDER BY ${w.sql.join(t,w.sql.fragment`,`)}`}return w.sql.fragment``},oe=(r,e)=>{let t=w.sql.fragment`ASC`;return Array.isArray(e)||(e=[]),e.some(s=>s.key==="roles"&&s.direction!="ASC"?(t=w.sql.fragment`DESC`,!0):!1),w.sql.fragment`ORDER BY ${r} ${t}`};class Fe extends f.DefaultSqlFactory{getFindByIdSql=e=>w.sql.type(this.validationSchema)`
      SELECT
        ${this.getTableFragment()}.*,
        COALESCE(user_role.role, '[]') AS roles
      FROM ${this.getTableFragment()}
      LEFT JOIN LATERAL (
        SELECT jsonb_agg(ur.role ${oe(w.sql.identifier(["ur","role"]))}) AS role
        FROM "public"."st__user_roles" as ur
        WHERE ur.user_id = users.id
      ) AS user_role ON TRUE
      WHERE id = ${e};
    `;getListSql=(e,t,s,n)=>{const o=f.createTableIdentifier(this.table,this.schema);return w.sql.type(this.validationSchema)`
      SELECT
        ${this.getTableFragment()}.*,
        COALESCE(user_role.role, '[]') AS roles
      FROM ${this.getTableFragment()}
      LEFT JOIN LATERAL (
        SELECT jsonb_agg(ur.role ${oe(w.sql.identifier(["ur","role"]),n)}) AS role
        FROM "public"."st__user_roles" as ur
        WHERE ur.user_id = users.id
      ) AS user_role ON TRUE
      ${f.createFilterFragment(s,o)}
      ${sr(o,this.getSortInput(n))}
      ${f.createLimitFragment(e,t)};
    `};getUpdateSql=(e,t)=>{const s=[];for(const n in t){const o=t[n];s.push(w.sql.fragment`${w.sql.identifier([Z.decamelize(n)])} = ${o}`)}return w.sql.type(this.validationSchema)`
      UPDATE ${this.getTableFragment()}
      SET ${w.sql.join(s,w.sql.fragment`, `)}
      WHERE id = ${e}
      RETURNING *, (
        SELECT COALESCE(user_role.role, '[]') AS roles
        FROM ${this.getTableFragment()}
        LEFT JOIN LATERAL (
          SELECT jsonb_agg(ur.role ${oe(w.sql.identifier(["ur","role"]))}) AS role
          FROM "public"."st__user_roles" as ur
          WHERE ur.user_id = users.id
        ) AS user_role ON TRUE
        WHERE id = ${e}
      ) as roles;
    `}}const tr=(r,e)=>de.z.string({required_error:r.required}).refine(t=>ue.isEmail(t,e||{}),{message:r.invalid}),$e={minLength:8,minLowercase:0,minUppercase:0,minNumbers:0,minSymbols:0,returnScore:!1,pointsPerUnique:1,pointsPerRepeat:.5,pointsForContainingLower:10,pointsForContainingUpper:10,pointsForContainingNumber:10,pointsForContainingSymbol:10},nr=(r,e)=>{const t={...$e,...e};return de.z.string({required_error:r.required}).refine(s=>ue.isStrongPassword(s,t),{message:r.weak})},or=r=>{let e="Password is too weak";if(!r)return e;const t=[];if(r.minLength){const s=r.minLength;t.push(`minimum ${s} ${s>1?"characters":"character"}`)}if(r.minLowercase){const s=r.minLowercase;t.push(`minimum ${s} ${s>1?"lowercases":"lowercase"}`)}if(r.minUppercase){const s=r.minUppercase;t.push(`minimum ${s} ${s>1?"uppercases":"uppercase"}`)}if(r.minNumbers){const s=r.minNumbers;t.push(`minimum ${s} ${s>1?"numbers":"number"}`)}if(r.minSymbols){const s=r.minSymbols;t.push(`minimum ${s} ${s>1?"symbols":"symbol"}`)}if(t.length>0){e="Password should contain ";const s=t.pop();t.length>0&&(e+=t.join(", ")+" and "),e+=s}return e},k=(r,e)=>{const t=e.user.password,s=nr({required:"Password is required",weak:or({...$e,...t})},t).safeParse(r);return s.success?{success:!0}:{message:s.error.issues[0].message,success:!1}};class Me extends f.BaseService{get table(){return this.config.user?.table?.name||re}get factory(){if(!this.table)throw new Error("Service table is not defined");return this._factory||(this._factory=new Fe(this)),this._factory}changePassword=async(e,t,s)=>{const n=k(s,this.config);if(!n.success)return{status:"FIELD_ERROR",message:n.message};const o=await N.getUserById(e);if(t&&s)if(o)if((await N.emailPasswordSignIn(S,o.email,t,{dbSchema:this.schema})).status==="OK"){if(await N.updateEmailOrPassword({userId:e,password:s}))return await P.revokeAllSessionsForUser(e),{status:"OK"};throw{status:"FAILED",message:"Oops! Something went wrong, couldn't change password"}}else return{status:"INVALID_PASSWORD",message:"Invalid password"};else throw{status:"NOT_FOUND",message:"User not found"};else return{status:"FIELD_ERROR",message:"Password cannot be empty"}}}const v=(r,e,t)=>{const s=r.user.services?.user||Me;return new s(r,e,t)},ir=(r,e)=>async t=>{if(r.createNewSession===void 0)throw new Error("Should never come here");const s=t.userContext._default.request.request,n=await r.createNewSession(t),o=n.getUserId();if((await v(s.config,s.slonik,s.dbSchema).findById(o))?.disabled)throw await n.revokeSession(),{name:"SIGN_IN_FAILED",message:"user is disabled",statusCode:401};return n},ar=(r,e)=>async t=>{if(r.verifySession===void 0)throw new Error("Should never come here");const s=await r.verifySession(t);if(s){const n=s.getUserId(),o=t.userContext._default.request.request;if((await v(o.config,o.slonik,o.dbSchema).findById(n))?.disabled)throw await s.revokeSession(),{name:"SESSION_VERIFICATION_FAILED",message:"user is disabled",statusCode:401}}return s},cr=r=>{const{config:e}=r;let t={};return typeof e.user.supertokens.recipes?.session=="object"&&(t=e.user.supertokens.recipes.session),{...t,getTokenTransferMethod:s=>s.req.getHeaderValue("st-auth-mode")==="header"?"header":"cookie",override:{apis:s=>{const n={};if(t.override?.apis){const o=t.override.apis;let i;for(i in o){const a=o[i];a&&(n[i]=a(s,r))}}return{...s,verifySession:ar(s),...n}},functions:s=>{const n={};if(t.override?.functions){const o=t.override.functions;let i;for(i in o){const a=o[i];a&&(n[i]=a(s,r))}}return{...s,createNewSession:ir(s),...n}},openIdFeature:t.override?.openIdFeature}}},ur=r=>{const e=r.config.user.supertokens.recipes?.session;return typeof e=="function"?P.init(e(r)):P.init(cr(r))},dr=(r,e)=>async t=>{if(r.appleRedirectHandlerPOST===void 0)throw new Error("Should never come here");const s=t.formPostInfoFromProvider.state,n=JSON.parse(Buffer.from(s,"base64").toString("ascii"));if(n.isAndroid&&n.appId){const i=`intent://callback?${`code=${t.formPostInfoFromProvider.code}&state=${t.formPostInfoFromProvider.state}`}#Intent;package=${n.appId};scheme=signinwithapple;end`;t.options.res.original.redirect(i)}else r.appleRedirectHandlerPOST(t)},lr=(r,e)=>{const{config:t,log:s,slonik:n}=e;return async o=>{const i=await r.emailPasswordSignIn(o);if(i.status!=="OK")return i;const a=v(t,n),d=await a.findById(i.user.id);return d?(d.lastLoginAt=Date.now(),await a.update(d.id,{lastLoginAt:f.formatDate(new Date(d.lastLoginAt))}).catch(l=>{s.error(`Unable to update lastLoginAt for userId ${i.user.id}`),s.error(l)}),{status:"OK",user:{...i.user,...d}}):(s.error(`User record not found for userId ${i.user.id}`),{status:"WRONG_CREDENTIALS_ERROR"})}},Ve=async r=>{const e=await b.createEmailVerificationToken(S,r);e.status==="OK"&&await b.verifyEmailUsingToken(S,e.token)},ie=async r=>{const{roles:e}=await R.getAllRoles();return r.every(t=>e.includes(t))},gr=(r,e)=>{const{config:t,log:s,slonik:n}=e;return async o=>{const i=o.userContext.roles||[];if(!await ie(i))throw s.error(`At least one role from ${i.join(", ")} does not exist.`),{name:"SIGN_UP_FAILED",message:"Something went wrong",statusCode:500};const a=await r.emailPasswordSignUp(o);if(a.status==="OK"){const d=v(t,n);let u;try{if(u=await d.create({id:a.user.id,email:a.user.email}),!u)throw new Error("User not found")}catch(l){throw s.error("Error while creating user"),s.error(l),await W.deleteUser(a.user.id),{name:"SIGN_UP_FAILED",message:"Something went wrong",statusCode:500}}u.roles=i,a.user={...a.user,...u};for(const l of i){const p=await R.addRoleToUser(S,a.user.id,l);p.status!=="OK"&&s.error(p.status)}if(t.user.features?.signUp?.emailVerification)try{if(o.userContext.autoVerifyEmail)await Ve(u.id);else{const l=await b.createEmailVerificationToken(S,a.user.id);l.status==="OK"&&await b.sendEmail({type:"EMAIL_VERIFICATION",user:a.user,emailVerifyLink:`${t.appOrigin[0]}/auth/verify-email?token=${l.token}&rid=emailverification`,tenantId:S,userContext:o.userContext})}}catch(l){s.error(l)}}if(t.user.supertokens.sendUserAlreadyExistsWarning&&a.status==="EMAIL_ALREADY_EXISTS_ERROR")try{F({fastify:e,subject:"Duplicate Email Registration",templateData:{emailId:o.email},templateName:"duplicate-email-warning",to:o.email})}catch(d){s.error(d)}return a}},mr=(r,e)=>async t=>{if(t.userContext.roles=[e.config.user.role||G],r.emailPasswordSignUpPOST===void 0)throw new Error("Should never come here");if(e.config.user.features?.signUp?.enabled===!1)throw{name:"SIGN_UP_DISABLED",message:"SignUp feature is currently disabled",statusCode:404};const s=await r.emailPasswordSignUpPOST(t);return s.status==="OK"?{status:"OK",user:s.user,session:s.session}:s},L=(r,e)=>{const t=tr({invalid:"Email is invalid",required:"Email is required"},e.user.email).safeParse(r);return t.success?{success:!0}:{message:t.error.issues[0].message,success:!1}},pr=r=>[{id:"email",validate:async e=>{const t=L(e,r);if(!t.success)return t.message}},{id:"password",validate:async e=>{const t=k(e,r);if(!t.success)return t.message}}],wr=r=>{let e=[];if(typeof r.user.supertokens?.recipes?.thirdPartyEmailPassword=="object"){const s=r.user.supertokens?.recipes?.thirdPartyEmailPassword.signUpFeature?.formFields;s&&(e=[...s])}const t=new Set(e.map(s=>s.id));for(const s of pr(r))t.has(s.id)||e.push(s);return e},Er=(r,e)=>async t=>{const s=await r.resetPasswordUsingToken(t);if(s.status==="OK"&&s.userId){const n=await N.getUserById(s.userId);n&&F({fastify:e,subject:"Reset Password Notification",templateName:"reset-password-notification",to:n.email,templateData:{emailId:n.email}})}return s},Sr=(r,e)=>{const t=e.config.appOrigin[0];return async s=>{const n=s.userContext._default.request.request,o=n.headers.referer||n.headers.origin||n.hostname,i=Q(o)||t,a=s.passwordResetLink.replace(t+"/auth/reset-password",i+(e.config.user.supertokens.resetPasswordPath||Re));F({fastify:e,subject:"Reset Password",templateName:"reset-password",to:s.user.email,templateData:{passwordResetLink:a}})}},hr=(r,e)=>{const{config:t,log:s}=e;return async n=>{const o=n.userContext.roles||[];if(!await N.getUserByThirdPartyInfo(n.tenantId,n.thirdPartyId,n.thirdPartyUserId,n.userContext)&&t.user.features?.signUp?.enabled===!1)throw{name:"SIGN_UP_DISABLED",message:"SignUp feature is currently disabled",statusCode:404};const a=await r.thirdPartySignInUp(n);if(a.status==="OK"&&a.createdNewUser){if(!await ie(o))throw await W.deleteUser(a.user.id),s.error(`At least one role from ${o.join(", ")} does not exist.`),{name:"SIGN_UP_FAILED",message:"Something went wrong",statusCode:500};for(const d of o){const u=await R.addRoleToUser(S,a.user.id,d);u.status!=="OK"&&s.error(u.status)}}return a}},fr=(r,e)=>{const{config:t,log:s,slonik:n}=e;return async o=>{if(o.userContext.roles=[t.user.role||G],r.thirdPartySignInUpPOST===void 0)throw new Error("Should never come here");const i=await r.thirdPartySignInUpPOST(o);if(i.status==="OK"){const a=v(t,n);let d;if(i.createdNewUser)try{if(d=await a.create({id:i.user.id,email:i.user.email}),!d)throw new Error("User not found");d.roles=o.userContext.roles}catch(u){throw s.error("Error while creating user"),s.error(u),await W.deleteUser(i.user.id),{name:"SIGN_UP_FAILED",message:"Something went wrong",statusCode:500}}else{if(d=await a.findById(i.user.id),!d)return s.error(`User record not found for userId ${i.user.id}`),{status:"GENERAL_ERROR",message:"Something went wrong"};d.lastLoginAt=Date.now(),await a.update(d.id,{lastLoginAt:f.formatDate(new Date(d.lastLoginAt))}).catch(u=>{s.error(`Unable to update lastLoginAt for userId ${i.user.id}`),s.error(u)})}return{...i,user:{...i.user,...d}}}return i}},Rr=r=>{const{config:e}=r;let t={};return typeof e.user.supertokens.recipes?.thirdPartyEmailPassword=="object"&&(t=e.user.supertokens.recipes.thirdPartyEmailPassword),{override:{apis:s=>{const n={};if(t.override?.apis){const o=t.override.apis;let i;for(i in o){const a=o[i];a&&(n[i]=a(s,r))}}return{...s,emailPasswordSignUpPOST:mr(s,r),thirdPartySignInUpPOST:fr(s,r),appleRedirectHandlerPOST:dr(s),...n}},functions:s=>{const n={};if(t.override?.functions){const o=t.override.functions;let i;for(i in o){const a=o[i];a&&(n[i]=a(s,r))}}return{...s,emailPasswordSignIn:lr(s,r),emailPasswordSignUp:gr(s,r),resetPasswordUsingToken:Er(s,r),thirdPartySignInUp:hr(s,r),...n}}},signUpFeature:{formFields:wr(e)},emailDelivery:{override:s=>{let n;return t?.sendEmail&&(n=t.sendEmail),{...s,sendEmail:n?n(s,r):Sr(s,r)}}},providers:e.user.supertokens.providers}},vr=r=>{const e=r.config.user.supertokens.recipes?.thirdPartyEmailPassword;return typeof e=="function"?N.init(e(r)):N.init(Rr(r))},Ir=()=>({}),Or=r=>{const e=r.config.user.supertokens.recipes;return e&&e.userRoles?R.init(e.userRoles(r)):R.init(Ir())},Pr=r=>{const e=[ur(r),vr(r),Or(r)];return r.config.user.features?.signUp?.emailVerification&&e.push(rr(r)),e},Tr=r=>{const{config:e}=r;W.init({appInfo:{apiDomain:e.baseUrl,appName:e.appName,websiteDomain:e.appOrigin[0]},framework:"fastify",recipeList:Pr(r),supertokens:{connectionURI:e.user.supertokens.connectionUri}})},_r=q(async(r,e,t)=>{const{config:s,log:n}=r;n.info("Registering supertokens plugin"),Tr(r),r.setErrorHandler(X.errorHandler()),await r.register(je,{origin:s.appOrigin,allowedHeaders:["Content-Type","st-auth-mode",...W.getAllCORSHeaders()],credentials:!0}),await r.register(ze),await r.register(X.plugin),n.info("Registering supertokens plugin complete"),r.decorate("verifySession",Je.verifySession),t()}),Nr=async(r,e,t)=>{const{config:s,slonik:n,dbSchema:o}=e;let i;try{const a=await P.getSession(e,X.wrapResponse(t),{sessionRequired:!1,overrideGlobalClaimValidators:async d=>d.filter(u=>u.id!==b.EmailVerificationClaim.key)});i=a===void 0?void 0:a.getUserId()}catch(a){throw P.Error.isErrorFromSuperTokens(a)?new g.ErrorWithProps("Session related error",{code:"UNAUTHENTICATED",http:{status:a.type===P.Error.INVALID_CLAIMS?403:401}},a.type===P.Error.INVALID_CLAIMS?403:401):a}if(i&&!r.user){const a=v(s,n,o);let d=null;try{d=await a.findById(i)}catch{}if(!d)throw new Error("Unable to find user");const{roles:u}=await R.getRolesForUser(S,i);r.user=d,r.roles=u}},qe=q(async(r,e,t)=>{const{mercurius:s}=r.config;await r.register(_r),r.decorate("hasPermission",Ze),s.enabled&&await r.register(Xe),t()});qe.updateContext=Nr;const yr=new Set(["id","disable","enable","email","lastLoginAt","roles","signedUpAt"]),We=r=>{for(const e of Object.keys(r))yr.has(Z.camelize(e))&&delete r[e]},Ar={Mutation:{adminSignUp:async(r,e,t)=>{const{app:s,config:n,reply:o}=t;try{const{email:i,password:a}=e.data,d=await R.getUsersThatHaveRole(S,y);let u;if(d.status==="UNKNOWN_ROLE_ERROR"?u=d.status:d.users.length>0&&(u="First admin user already exists"),u)return new g.ErrorWithProps(u);const l=L(i,n);if(!l.success&&l.message)return new g.ErrorWithProps(l.message);const p=k(a,n);if(!p.success&&p.message)return new g.ErrorWithProps(p.message);const m=await N.emailPasswordSignUp(S,i,a,{autoVerifyEmail:!0,roles:[y],_default:{request:{request:o.request}}});return m.status!=="OK"?new g.ErrorWithProps(m.status):(await P.createNewSession(o.request,o,S,m.user.id),{...m,user:{...m.user,roles:[y]}})}catch(i){s.log.error(i);const a=new g.ErrorWithProps("Oops, Something went wrong");return a.statusCode=500,a}},disableUser:async(r,e,t)=>{const{id:s}=e;if(t.user?.id===s){const i=new g.ErrorWithProps("you cannot disable yourself");return i.statusCode=409,i}return await v(t.config,t.database,t.dbSchema).update(s,{disabled:!0})?{status:"OK"}:new g.ErrorWithProps(`user id ${s} not found`,{},404)},enableUser:async(r,e,t)=>{const{id:s}=e;return await v(t.config,t.database,t.dbSchema).update(s,{disabled:!1})?{status:"OK"}:new g.ErrorWithProps(`user id ${s} not found`,{},404)},changePassword:async(r,e,t)=>{const s=v(t.config,t.database,t.dbSchema);try{return t.user?.id?await s.changePassword(t.user.id,e.oldPassword,e.newPassword):{status:"NOT_FOUND",message:"User not found"}}catch(n){t.app.log.error(n);const o=new g.ErrorWithProps("Oops, Something went wrong");return o.statusCode=500,o}},updateMe:async(r,e,t)=>{const{data:s}=e,n=v(t.config,t.database,t.dbSchema);try{return t.user?.id?(We(s),await n.update(t.user.id,s)):{status:"NOT_FOUND",message:"User not found"}}catch(o){t.app.log.error(o);const i=new g.ErrorWithProps("Oops, Something went wrong");return i.statusCode=500,i}}},Query:{canAdminSignUp:async(r,e,t)=>{const{app:s}=t;try{const n=await R.getUsersThatHaveRole(S,y);return n.status==="UNKNOWN_ROLE_ERROR"?new g.ErrorWithProps(n.status):n.users.length>0?{signUp:!1}:{signUp:!0}}catch(n){s.log.error(n);const o=new g.ErrorWithProps("Oops! Something went wrong");return o.statusCode=500,o}},me:async(r,e,t)=>{const s=v(t.config,t.database,t.dbSchema);if(t.user?.id)return await s.findById(t.user.id);{t.app.log.error("Could not able to get user id from mercurius context");const n=new g.ErrorWithProps("Oops, Something went wrong");return n.statusCode=500,n}},user:async(r,e,t)=>await v(t.config,t.database,t.dbSchema).findById(e.id),users:async(r,e,t)=>await v(t.config,t.database,t.dbSchema).list(e.limit,e.offset,e.filters?JSON.parse(JSON.stringify(e.filters)):void 0,e.sort?JSON.parse(JSON.stringify(e.sort)):void 0)}},C={adminSignUp:async(r,e)=>{const{body:t,config:s,log:n}=r;try{const{email:o,password:i}=t,a=await R.getUsersThatHaveRole(S,y);if(a.status==="UNKNOWN_ROLE_ERROR")return e.send({status:"ERROR",message:a.status});if(a.users.length>0)return e.send({status:"ERROR",message:"First admin user already exists"});const d=L(o,s);if(!d.success)return e.send({status:"ERROR",message:d.message});const u=k(i,s);if(!u.success)return e.send({status:"ERROR",message:u.message});const l=await N.emailPasswordSignUp(S,o,i,{autoVerifyEmail:!0,roles:[y],_default:{request:{request:r}}});if(l.status!=="OK")return e.send(l);await P.createNewSession(r,e,S,l.user.id),e.send({...l,user:{...l.user,roles:[y]}})}catch(o){n.error(o),e.status(500),e.send({status:"ERROR",message:"Oops! Something went wrong"})}},canAdminSignUp:async(r,e)=>{const{log:t}=r;try{const s=await R.getUsersThatHaveRole(S,y);if(s.status==="UNKNOWN_ROLE_ERROR")return e.send({status:"ERROR",message:s.status});if(s.users.length>0)return e.send({signUp:!1});e.send({signUp:!0})}catch(s){t.error(s),e.status(500),e.send({status:"ERROR",message:"Oops! Something went wrong"})}},changePassword:async(r,e)=>{try{const t=r.session,s=r.body,n=t&&t.getUserId();if(!n)throw new Error("User not found in session");const o=s.oldPassword??"",i=s.newPassword??"",d=await v(r.config,r.slonik,r.dbSchema).changePassword(n,o,i);e.send(d)}catch(t){r.log.error(t),e.status(500),e.send({status:"ERROR",message:"Oops! Something went wrong",error:t})}},disable:async(r,e)=>{if(r.session){const{id:t}=r.params;return r.session.getUserId()===t?(e.status(409),await e.send({message:"you cannot disable yourself"})):await v(r.config,r.slonik,r.dbSchema).update(t,{disabled:!0})?await e.send({status:"OK"}):(e.status(404),await e.send({message:`user id ${t} not found`}))}else throw r.log.error("could not get session"),new Error("Oops, Something went wrong")},enable:async(r,e)=>{if(r.session){const{id:t}=r.params;return await v(r.config,r.slonik,r.dbSchema).update(t,{disabled:!1})?await e.send({status:"OK"}):(e.status(404),await e.send({message:`user id ${t} not found`}))}else throw r.log.error("could not get session"),new Error("Oops, Something went wrong")},me:async(r,e)=>{const t=v(r.config,r.slonik,r.dbSchema),s=r.session?.getUserId();if(s)e.send(await t.findById(s));else throw r.log.error("Could not able to get user id from session"),new Error("Oops, Something went wrong")},updateMe:async(r,e)=>{const t=r.session?.getUserId(),s=r.body;if(t){const n=v(r.config,r.slonik,r.dbSchema);We(s),e.send(await n.update(t,s))}else throw r.log.error("could not get user id from session"),new Error("Oops, Something went wrong")},users:async(r,e)=>{const t=v(r.config,r.slonik,r.dbSchema),{limit:s,offset:n,filters:o,sort:i}=r.query,a=await t.list(s,n,o?JSON.parse(o):void 0,i?JSON.parse(i):void 0);e.send(a)}},Ur=async(r,e,t)=>{const s=r.config.user.handlers?.user;r.get(Oe,{preHandler:[r.verifySession(),r.hasPermission(ke)]},s?.users||C.users),r.post(Ie,{preHandler:r.verifySession()},s?.changePassword||C.changePassword),r.get(ee,{preHandler:r.verifySession()},s?.me||C.me),r.put(ee,{preHandler:r.verifySession()},s?.updateMe||C.updateMe),r.put(Pe,{preHandler:[r.verifySession(),r.hasPermission(Ce)]},s?.disable||C.disable),r.put(Te,{preHandler:[r.verifySession(),r.hasPermission(De)]},s?.enable||C.enable),r.post(x,s?.adminSignUp||C.adminSignUp),r.get(x,s?.canAdminSignUp||C.canAdminSignUp),t()},ae=(r,e)=>e||f.formatDate(new Date(Date.now()+(r.user.invitation?.expireAfterInDays??ge)*(24*60*60*1e3)));class Be extends f.DefaultSqlFactory{getFindByTokenSql=e=>w.sql.type(this.validationSchema)`
      SELECT *
      FROM ${this.getTableFragment()}
      WHERE token = ${e};
    `;getListSql=(e,t,s,n)=>{const o=f.createTableIdentifier(this.table,this.schema),i=f.createTableFragment(this.config.user.table?.name||re,this.schema);return w.sql.type(this.validationSchema)`
      SELECT ${this.getTableFragment()}.*, ROW_TO_JSON("user") as "invited_by"
      FROM ${this.getTableFragment()}
      join ${i} "user" on ${this.getTableFragment()}."invited_by_id" = "user"."id"
      ${f.createFilterFragment(s,o)}
      ${f.createSortFragment(o,this.getSortInput(n))}
      ${f.createLimitFragment(e,t)};
    `}}class He extends f.BaseService{static TABLE=fe;create=async e=>{const t={AND:[{key:"email",operator:"eq",value:e.email},{key:"acceptedAt",operator:"eq",value:"null"},{key:"expiresAt",operator:"gt",value:f.formatDate(new Date)},{key:"revokedAt",operator:"eq",value:"null"}]};if(await this.count(t)>0)throw new Error("Invitation already exist");const n=this.factory.getCreateSql(e),o=await this.database.connect(async i=>i.query(n).then(a=>a.rows[0]));return o?this.postCreate(o):void 0};findByToken=async e=>{if(!this.validateUUID(e))return null;const t=this.factory.getFindByTokenSql(e);return await this.database.connect(n=>n.maybeOne(t))};get factory(){if(!this.table)throw new Error("Service table is not defined");return this._factory||(this._factory=new Be(this)),this._factory}validateUUID=e=>/^[\da-f]{8}(?:\b-[\da-f]{4}){3}\b-[\da-f]{12}$/gi.test(e)}const T=(r,e,t)=>{const s=r.user.services?.invitation||He;return new s(r,e,t)},B=r=>!(r.acceptedAt||r.revokedAt||Date.now()>r.expiresAt),br=(r,e,t)=>{const{token:s}=e;let n=r.user.invitation?.acceptLinkPath||le;return n=n.replace(/:token(?!\w)/g,s),new URL(n,t).href},H=async(r,e,t)=>{const{config:s,log:n}=r,o=s.apps?.find(i=>i.id===e.appId)?.origin||Q(t||"")||s.appOrigin[0];o?F({fastify:r,subject:"Invitation for Sign Up",templateData:{invitationLink:br(s,e,o)},templateName:"user-invitation",to:e.email}):n.error(`Could not send email for invitation ID ${e.id}`)},Lr={Mutation:{acceptInvitation:async(r,e,t)=>{const{app:s,config:n,database:o,dbSchema:i,reply:a}=t,{token:d,data:u}=e;try{const{email:l,password:p}=u,m=L(l,n);if(!m.success&&m.message)return new g.ErrorWithProps(m.message);const E=k(p,n);if(!E.success&&E.message)return new g.ErrorWithProps(E.message);const I=T(n,o,i),h=await I.findByToken(d);if(!h||!B(h))return new g.ErrorWithProps("Invitation is invalid or has expired");if(h.email!=l)return new g.ErrorWithProps("Email do not match with the invitation");const _=await N.emailPasswordSignUp(S,l,p,{roles:[h.role],autoVerifyEmail:!0});if(_.status!=="OK")return _;await I.update(h.id,{acceptedAt:f.formatDate(new Date(Date.now()))});try{await n.user.invitation?.postAccept?.(a.request,h,_.user)}catch(U){s.log.error(U)}return await P.createNewSession(a.request,a,S,_.user.id),{..._,user:{..._.user,roles:[h.role]}}}catch(l){s.log.error(l);const p=new g.ErrorWithProps("Oops! Something went wrong");return p.statusCode=500,p}},createInvitation:async(r,e,t)=>{const{app:s,config:n,database:o,dbSchema:i,reply:a,user:d}=t;try{if(!d)throw new Error("User not found in session");const{appId:u,email:l,expiresAt:p,payload:m,role:E}=e.data,I=L(l,n);if(!I.success&&I.message)return new g.ErrorWithProps(I.message);const h=T(n,o,i),_={key:"email",operator:"eq",value:l};if(await h.count(_)>0)return new g.ErrorWithProps(`User with email ${l} already exists`);const D={email:l,expiresAt:ae(n,p),invitedById:d.id,role:E||n.user.role||y},K=n.apps?.find(O=>O.id==u);if(K)if(K.supportedRoles.includes(D.role))D.appId=u;else return new g.ErrorWithProps(`App ${K.name} does not support role ${D.role}`);Object.keys(m||{}).length>0&&(D.payload=JSON.stringify(m));let j;try{j=await h.create(D)}catch(O){return new g.ErrorWithProps(O.message)}if(j){try{const{headers:O,hostname:M}=a.request,V=O.referer||O.origin||M;H(s,j,V)}catch(O){s.log.error(O)}return j}}catch(u){s.log.error(u);const l=new g.ErrorWithProps("Oops, Something went wrong");return l.statusCode=500,l}},resendInvitation:async(r,e,t)=>{const{app:s,config:n,database:o,dbSchema:i,reply:a}=t,u=await T(n,o,i).findById(e.id);if(!u||!B(u))return new g.ErrorWithProps("Invitation is invalid or has expired");const{headers:l,hostname:p}=a.request,m=l.referer||l.origin||p;try{H(s,u,m)}catch(E){s.log.error(E)}return u},revokeInvitation:async(r,e,t)=>{const s=T(t.config,t.database,t.dbSchema);let n=await s.findById(e.id),o;return n?n.acceptedAt?o="Invitation is already accepted":Date.now()>n.expiresAt?o="Invitation is expired":n.revokedAt&&(o="Invitation is already revoked"):o="Invitation not found",o?new g.ErrorWithProps(o):(n=await s.update(e.id,{revokedAt:f.formatDate(new Date(Date.now()))}),n)}},Query:{getInvitationByToken:async(r,e,t)=>{try{return await T(t.config,t.database,t.dbSchema).findByToken(e.token)}catch(s){t.app.log.error(s);const n=new g.ErrorWithProps("Oops, Something went wrong");return n.statusCode=500,n}},invitations:async(r,e,t)=>await T(t.config,t.database,t.dbSchema).list(e.limit,e.offset,e.filters?JSON.parse(JSON.stringify(e.filters)):void 0,e.sort?JSON.parse(JSON.stringify(e.sort)):void 0)}},$={acceptInvitation:async(r,e)=>{const{body:t,config:s,dbSchema:n,log:o,params:i,slonik:a}=r,{token:d}=i;try{const{email:u,password:l}=t,p=L(u,s);if(!p.success)return e.send({status:"ERROR",message:p.message});const m=k(l,s);if(!m.success)return e.send({status:"ERROR",message:m.message});const E=T(s,a,n),I=await E.findByToken(d);if(!I||!B(I))return e.send({status:"ERROR",message:"Invitation is invalid or has expired"});if(I.email!=u)return e.send({status:"ERROR",message:"Email do not match with the invitation"});const h=await N.emailPasswordSignUp(S,u,l,{roles:[I.role],autoVerifyEmail:!0});if(h.status!=="OK")return e.send(h);await E.update(I.id,{acceptedAt:f.formatDate(new Date(Date.now()))});try{await s.user.invitation?.postAccept?.(r,I,h.user)}catch(_){o.error(_)}await P.createNewSession(r,e,S,h.user.id),e.send({...h,user:{...h.user,roles:[I.role]}})}catch(u){o.error(u),e.status(500),e.send({status:"ERROR",message:"Oops! Something went wrong"})}},createInvitation:async(r,e)=>{const{body:t,config:s,dbSchema:n,headers:o,hostname:i,log:a,server:d,session:u,slonik:l}=r;try{const p=u&&u.getUserId();if(!p)throw new Error("User not found in session");const{appId:m,email:E,expiresAt:I,payload:h,role:_}=t,U=L(E,s);if(!U.success)return e.send({status:"ERROR",message:U.message});const D=T(s,l,n),K={key:"email",operator:"eq",value:E};if(await D.count(K)>0)return e.send({status:"ERROR",message:`User with email ${E} already exists`});const O={email:E,expiresAt:ae(s,I),invitedById:p,role:_||s.user.role||G},M=s.apps?.find(z=>z.id==m);if(M)if(M.supportedRoles.includes(O.role))O.appId=m;else return e.send({status:"ERROR",message:`App ${M.name} does not support role ${O.role}`});Object.keys(h||{}).length>0&&(O.payload=JSON.stringify(h));let V;try{V=await D.create(O)}catch(z){return e.send({status:"ERROR",message:z.message})}if(V){const z=o.referer||o.origin||i;try{H(d,V,z)}catch(qr){a.error(qr)}const Ke=V;delete Ke.token,e.send(Ke)}}catch(p){a.error(p),e.status(500),e.send({status:"ERROR",message:"Oops! Something went wrong"})}},getInvitationByToken:async(r,e)=>{const{config:t,dbSchema:s,log:n,params:o,slonik:i}=r,{token:a}=o;try{const u=await T(t,i,s).findByToken(a);e.send(u)}catch(d){n.error(d),e.status(500),e.send({status:"ERROR",message:"Oops! Something went wrong"})}},listInvitation:async(r,e)=>{const{config:t,dbSchema:s,log:n,query:o,slonik:i}=r;try{const{limit:a,offset:d,filters:u,sort:l}=o,m=await T(t,i,s).list(a,d,u?JSON.parse(u):void 0,l?JSON.parse(l):void 0);for(const E of m.data)delete E.token;e.send(m)}catch(a){n.error(a),e.status(500),e.send({status:"ERROR",message:"Oops! Something went wrong"})}},resendInvitation:async(r,e)=>{const{config:t,dbSchema:s,headers:n,hostname:o,log:i,params:a,slonik:d,server:u}=r;try{const{id:l}=a,m=await T(t,d,s).findById(l);if(!m||!B(m))return e.send({status:"ERROR",message:"Invitation is invalid or has expired"});const E=n.referer||n.origin||o;try{H(u,m,E)}catch(h){i.error(h)}const I=m;delete I.token,e.send(I)}catch(l){i.error(l),e.status(500),e.send({status:"ERROR",message:"Oops! Something went wrong"})}},revokeInvitation:async(r,e)=>{const{config:t,dbSchema:s,log:n,params:o,slonik:i}=r;try{const{id:a}=o,d=T(t,i,s);let u=await d.findById(a);if(u){if(u.acceptedAt)return e.send({status:"error",message:"Invitation is already accepted"});if(Date.now()>u.expiresAt)return e.send({status:"error",message:"Invitation is expired"});if(u.revokedAt)return e.send({status:"error",message:"Invitation is already revoked"})}else return e.send({status:"error",message:"Invitation not found"});u=await d.update(a,{revokedAt:f.formatDate(new Date(Date.now()))});const l=u;delete l.token,e.send(l)}catch(a){n.error(a),e.status(500),e.send({status:"ERROR",message:"Oops! Something went wrong"})}}},Cr=async(r,e,t)=>{const s=r.config.user.handlers?.invitation;r.get(me,{preHandler:[r.verifySession(),r.hasPermission(Ue)]},s?.list||$.listInvitation),r.post(we,{preHandler:[r.verifySession(),r.hasPermission(Ae)]},s?.create||$.createInvitation),r.get(Ee,s?.getByToken||$.getInvitationByToken),r.post(pe,s?.accept||$.acceptInvitation),r.put(he,{preHandler:[r.verifySession(),r.hasPermission(Le)]},s?.revoke||$.revokeInvitation),r.post(Se,{preHandler:[r.verifySession(),r.hasPermission(be)]},s?.resend||$.resendInvitation),t()},Dr={Query:{permissions:async(r,e,t)=>{const{app:s,config:n}=t;try{return n.user.permissions||[]}catch(o){s.log.error(o);const i=new g.ErrorWithProps("Oops, Something went wrong");return i.statusCode=500,i}}}},kr={getPermissions:async(r,e)=>{const{config:t,log:s}=r;try{const n=t.user.permissions||[];e.send({permissions:n})}catch(n){s.error(n),e.status(500),e.send({status:"ERROR",message:"Oops! Something went wrong"})}}},Fr=async(r,e,t)=>{r.get(_e,{preHandler:[r.verifySession()]},kr.getPermissions),t()};class A{createRole=async e=>{await R.createNewRoleOrAddPermissions(e,[])};getPermissionsForRole=async e=>{let t=[];const s=await R.getPermissionsForRole(e);return s.status==="OK"&&(t=s.permissions),t};getRoles=async()=>{let e=[];const t=await R.getAllRoles();return t.status==="OK"&&(e=t.roles),e};updateRolePermissions=async(e,t)=>{const s=await R.getPermissionsForRole(e);if(s.status==="UNKNOWN_ROLE_ERROR")throw new Error("UNKNOWN_ROLE_ERROR");const n=s.permissions,o=t.filter(a=>!n.includes(a)),i=n.filter(a=>!t.includes(a));return await R.removePermissionsFromRole(e,i),await R.createNewRoleOrAddPermissions(e,o),this.getPermissionsForRole(e)}}const $r={Mutation:{createRole:async(r,e,t)=>{const{app:s}=t;try{return await new A().createRole(e.role),e.role}catch(n){s.log.error(n);const o=new g.ErrorWithProps("Oops, Something went wrong");return o.statusCode=500,o}},updateRolePermissions:async(r,e,t)=>{const{app:s}=t,{permissions:n,role:o}=e;try{return await new A().updateRolePermissions(o,n)}catch(i){s.log.error(i);const a=new g.ErrorWithProps("Oops, Something went wrong");return a.statusCode=500,a}}},Query:{roles:async(r,e,t)=>{const{app:s}=t;try{return await new A().getRoles()}catch(n){s.log.error(n);const o=new g.ErrorWithProps("Oops, Something went wrong");return o.statusCode=500,o}},rolePermissions:async(r,e,t)=>{const{app:s}=t,{role:n}=e;let o=[];try{return n&&(o=await new A().getPermissionsForRole(n)),o}catch(i){s.log.error(i);const a=new g.ErrorWithProps("Oops, Something went wrong");return a.statusCode=500,a}}}},Y={createRole:async(r,e)=>{const{body:t,log:s}=r,{role:n}=t;try{return await new A().createRole(n),e.send({role:n})}catch(o){return s.error(o),e.status(500),e.send({status:"ERROR",message:"Oops! Something went wrong"})}},getRoles:async(r,e)=>{const{log:t}=r;try{const n=await new A().getRoles();return e.send({roles:n})}catch(s){return t.error(s),e.status(500),e.send({status:"ERROR",message:"Oops! Something went wrong"})}},getPermissions:async(r,e)=>{const{log:t,query:s}=r;let n=[];try{const{role:o}=s;return o&&(n=await new A().getPermissionsForRole(o)),e.send({permissions:n})}catch(o){return t.error(o),e.status(500),e.send({status:"ERROR",message:"Oops! Something went wrong"})}},updatePermissions:async(r,e)=>{const{log:t,body:s}=r;try{const{role:n,permissions:o}=s,a=await new A().updateRolePermissions(n,o);return e.send({permissions:a})}catch(n){return t.error(n),e.status(500),e.send({status:"ERROR",message:"Oops! Something went wrong"})}}},Mr=async(r,e,t)=>{r.get(se,{preHandler:[r.verifySession()]},Y.getRoles),r.get(te,{preHandler:[r.verifySession()]},Y.getPermissions),r.post(se,{preHandler:[r.verifySession()]},Y.createRole),r.put(te,{preHandler:[r.verifySession()]},Y.updatePermissions),t()},Vr=async r=>{const{roles:e}=await R.getAllRoles();return e.includes(r)};Object.defineProperty(c,"formatDate",{enumerable:!0,get:()=>f.formatDate}),c.EMAIL_VERIFICATION_MODE=Ne,c.EMAIL_VERIFICATION_PATH=ye,c.INVITATION_ACCEPT_LINK_PATH=le,c.INVITATION_EXPIRE_AFTER_IN_DAYS=ge,c.InvitationService=He,c.InvitationSqlFactory=Be,c.PERMISSIONS_INVITATIONS_CREATE=Ae,c.PERMISSIONS_INVITATIONS_LIST=Ue,c.PERMISSIONS_INVITATIONS_RESEND=be,c.PERMISSIONS_INVITATIONS_REVOKE=Le,c.PERMISSIONS_USERS_DISABLE=Ce,c.PERMISSIONS_USERS_ENABLE=De,c.PERMISSIONS_USERS_LIST=ke,c.RESET_PASSWORD_PATH=Re,c.ROLE_ADMIN=y,c.ROLE_SUPER_ADMIN=ve,c.ROLE_USER=G,c.ROUTE_CHANGE_PASSWORD=Ie,c.ROUTE_INVITATIONS=me,c.ROUTE_INVITATIONS_ACCEPT=pe,c.ROUTE_INVITATIONS_CREATE=we,c.ROUTE_INVITATIONS_GET_BY_TOKEN=Ee,c.ROUTE_INVITATIONS_RESEND=Se,c.ROUTE_INVITATIONS_REVOKE=he,c.ROUTE_ME=ee,c.ROUTE_PERMISSIONS=_e,c.ROUTE_ROLES=se,c.ROUTE_ROLES_PERMISSIONS=te,c.ROUTE_SIGNUP_ADMIN=x,c.ROUTE_USERS=Oe,c.ROUTE_USERS_DISABLE=Pe,c.ROUTE_USERS_ENABLE=Te,c.RoleService=A,c.TABLE_INVITATIONS=fe,c.TABLE_USERS=re,c.TENANT_ID=S,c.UserService=Me,c.UserSqlFactory=Fe,c.areRolesExist=ie,c.computeInvitationExpiresAt=ae,c.default=qe,c.getInvitationService=T,c.getOrigin=Q,c.getUserService=v,c.hasUserPermission=ne,c.invitationResolver=Lr,c.invitationRoutes=Cr,c.isInvitationValid=B,c.isRoleExists=Vr,c.permissionResolver=Dr,c.permissionRoutes=Fr,c.roleResolver=$r,c.roleRoutes=Mr,c.sendEmail=F,c.sendInvitation=H,c.userResolver=Ar,c.userRoutes=Ur,c.validateEmail=L,c.validatePassword=k,c.verifyEmail=Ve,Object.defineProperties(c,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});
