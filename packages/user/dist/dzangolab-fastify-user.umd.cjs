(function(c,X){typeof exports=="object"&&typeof module<"u"?X(exports,require("@dzangolab/fastify-mercurius"),require("fastify-plugin"),require("mercurius"),require("mercurius-auth"),require("supertokens-node/recipe/emailverification"),require("supertokens-node/recipe/userroles"),require("supertokens-node/recipe/session"),require("@fastify/cors"),require("@fastify/formbody"),require("supertokens-node"),require("supertokens-node/framework/fastify"),require("supertokens-node/recipe/session/framework/fastify"),require("@dzangolab/fastify-mailer"),require("@dzangolab/fastify-slonik"),require("supertokens-node/recipe/thirdpartyemailpassword"),require("humps"),require("slonik"),require("validator"),require("zod")):typeof define=="function"&&define.amd?define(["exports","@dzangolab/fastify-mercurius","fastify-plugin","mercurius","mercurius-auth","supertokens-node/recipe/emailverification","supertokens-node/recipe/userroles","supertokens-node/recipe/session","@fastify/cors","@fastify/formbody","supertokens-node","supertokens-node/framework/fastify","supertokens-node/recipe/session/framework/fastify","@dzangolab/fastify-mailer","@dzangolab/fastify-slonik","supertokens-node/recipe/thirdpartyemailpassword","humps","slonik","validator","zod"],X):(c=typeof globalThis<"u"?globalThis:c||self,X(c.DzangolabFastifyUser={},c.DzangolabFastifyMercurius,c.FastifyPlugin,c.Mercurius,c.MercuriusAuth,c.EmailVerification,c.SupertokensUserRoles,c.SupertokensSession,c.FastifyCors,c.FastifyFormbody,c.SupertokensNode,c.SupertokensFastify,c.SupertokensSessionFastify,c.DzangolabFastifyMailer,c.DzangolabFastifySlonik,c.SupertokensThirdPartyEmailPassword,c.Humps,c.Slonik,c.validator,c.zod))})(this,function(c,X,K,g,de,b,p,N,Je,ze,B,ee,Ge,Ks,v,T,se,S,le,ge){"use strict";const Qe=K(async s=>{await s.register(de,{async applyPolicy(e,t,r,n){return n.user?n.user.disabled?new g.ErrorWithProps("user is disabled",{},401):s.config.user.features?.signUp?.emailVerification&&!await b.isEmailVerified(n.user.id)?new g.ErrorWithProps("invalid claim",{claimValidationErrors:[{id:"st-ev",reason:{message:"wrong value",expectedValue:!0,actualValue:!1}}]},403):!0:new g.ErrorWithProps("unauthorized",{},401)},authDirective:"auth"})}),me="/signup/token/:token",pe=30,we="/invitations",Ee="/invitations/token/:token",he="/invitations",Se="/invitations/token/:token",Re="/invitations/resend/:id(^\\d+)",fe="/invitations/revoke/:id(^\\d+)",ve="invitations",Ie="/reset-password",F="ADMIN",C="SUPER_ADMIN",H="USER",Oe="/change_password",re="/signup/admin",te="/me",Ne="/users",_e="/users/:id/disable",Pe="/users/:id/enable",ne="users",Z="/roles",oe="/roles/permissions",Te="/permissions",ye="REQUIRED",Ue="/verify-email",Ae="invitations:create",be="invitations:list",Ce="invitations:resend",Le="invitations:revoke",De="users:disable",ke="users:enable",Fe="users:enable",w="public",Ye=async s=>{let e=[];for(const t of s){const r=await p.getPermissionsForRole(t);r.status==="OK"&&(e=[...new Set([...e,...r.permissions])])}return e},ie=async(s,e,t)=>{const r=s.config.user.permissions;if(!r||!r.includes(t))return!0;const{roles:n}=await p.getRolesForUser(w,e);if(n&&n.includes(C))return!0;const o=await Ye(n);return!(!o||!o.includes(t))},Xe=K(async s=>{await s.register(de,{applyPolicy:async(e,t,r,n)=>{const o=e.arguments.find(a=>a.name.value==="permission").value.value;return n.user?await ie(n.app,n.user?.id,o)?!0:new g.ErrorWithProps("invalid claim",{claimValidationErrors:[{id:"st-perm",reason:{message:"Not have enough permission",expectedToInclude:o}}]},403):new g.ErrorWithProps("unauthorized",{},401)},authDirective:"hasPermission"})}),Ze=K(async s=>{s.config.mercurius.enabled&&(await s.register(Xe),await s.register(Qe))}),xe=s=>async e=>{const t=e.session?.getUserId();if(!t)throw new N.Error({type:"UNAUTHORISED",message:"unauthorised"});if(!await ie(e.server,t,s))throw new N.Error({type:"INVALID_CLAIMS",message:"Not have enough permission",payload:[{id:p.PermissionClaim.key,reason:{message:"Not have enough permission",expectedToInclude:s}}]})},x=s=>{let e;try{if(e=new URL(s).origin,!e||e==="null")throw new Error("Origin is empty")}catch{e=""}return e},M=async({fastify:s,subject:e,templateData:t={},templateName:r,to:n})=>{const{config:o,log:i,mailer:a}=s;return a.sendMail({subject:e,templateName:r,to:n,templateData:{appName:o.appName,...t}}).catch(u=>{i.error(u.stack)})},es=(s,e)=>{const t=e.config.appOrigin[0];return async r=>{let n;try{const i=r.userContext._default.request.request,a=i.headers.referer||i.headers.origin||i.hostname;n=x(a)||t}catch{n=t}const o=r.emailVerifyLink.replace(t+"/auth/verify-email",n+(e.config.user.supertokens.emailVerificationPath||Ue));M({fastify:e,subject:"Email Verification",templateName:"email-verification",to:r.user.email,templateData:{emailVerifyLink:o}})}},ss=s=>{const{config:e}=s;let t={};return typeof e.user.supertokens.recipes?.emailVerification=="object"&&(t=e.user.supertokens.recipes.emailVerification),{mode:t?.mode||ye,emailDelivery:{override:r=>{let n;return t?.sendEmail&&(n=t.sendEmail),{...r,sendEmail:n?n(r,s):es(r,s)}}},override:{apis:r=>{const n={};if(t.override?.apis){const o=t.override.apis;let i;for(i in o){const a=o[i];a&&(n[i]=a(r,s))}}return{...r,verifyEmailPOST:async o=>{if(r.verifyEmailPOST===void 0)throw new Error("Should never come here");return o.session?await r.verifyEmailPOST(o):{status:"EMAIL_VERIFICATION_INVALID_TOKEN_ERROR"}},...n}},functions:r=>{const n={};if(t.override?.functions){const o=t.override.functions;let i;for(i in o){const a=o[i];a&&(n[i]=a(r,s))}}return{...r,...n}}}}},rs=s=>{const e=s.config.user.supertokens.recipes?.emailVerification;return typeof e=="function"?b.init(e(s)):b.init(ss(s))},ts=(s,e)=>{if(e&&e.length>0){const t=[];for(const r of e){const n=r.direction==="ASC"?S.sql.fragment`ASC`:S.sql.fragment`DESC`;let o;r.key==="roles"&&(o=S.sql.fragment`user_role.role ->> 0`);const i=S.sql.identifier([...s.names,se.decamelize(r.key)]);t.push(S.sql.fragment`${o??i} ${n}`)}return S.sql.fragment`ORDER BY ${S.sql.join(t,S.sql.fragment`,`)}`}return S.sql.fragment``},ae=(s,e)=>{let t=S.sql.fragment`ASC`;return Array.isArray(e)||(e=[]),e.some(r=>r.key==="roles"&&r.direction!="ASC"?(t=S.sql.fragment`DESC`,!0):!1),S.sql.fragment`ORDER BY ${s} ${t}`};class $e extends v.DefaultSqlFactory{getFindByIdSql=e=>S.sql.type(this.validationSchema)`
      SELECT
        ${this.getTableFragment()}.*,
        COALESCE(user_role.role, '[]') AS roles
      FROM ${this.getTableFragment()}
      LEFT JOIN LATERAL (
        SELECT jsonb_agg(ur.role ${ae(S.sql.identifier(["ur","role"]))}) AS role
        FROM "public"."st__user_roles" as ur
        WHERE ur.user_id = users.id
      ) AS user_role ON TRUE
      WHERE id = ${e};
    `;getListSql=(e,t,r,n)=>{const o=v.createTableIdentifier(this.table,this.schema);return S.sql.type(this.validationSchema)`
      SELECT
        ${this.getTableFragment()}.*,
        COALESCE(user_role.role, '[]') AS roles
      FROM ${this.getTableFragment()}
      LEFT JOIN LATERAL (
        SELECT jsonb_agg(ur.role ${ae(S.sql.identifier(["ur","role"]),n)}) AS role
        FROM "public"."st__user_roles" as ur
        WHERE ur.user_id = users.id
      ) AS user_role ON TRUE
      ${v.createFilterFragment(r,o)}
      ${ts(o,this.getSortInput(n))}
      ${v.createLimitFragment(e,t)};
    `};getUpdateSql=(e,t)=>{const r=[];for(const n in t){const o=t[n];r.push(S.sql.fragment`${S.sql.identifier([se.decamelize(n)])} = ${o}`)}return S.sql.type(this.validationSchema)`
      UPDATE ${this.getTableFragment()}
      SET ${S.sql.join(r,S.sql.fragment`, `)}
      WHERE id = ${e}
      RETURNING *, (
        SELECT COALESCE(user_role.role, '[]') AS roles
        FROM ${this.getTableFragment()}
        LEFT JOIN LATERAL (
          SELECT jsonb_agg(ur.role ${ae(S.sql.identifier(["ur","role"]))}) AS role
          FROM "public"."st__user_roles" as ur
          WHERE ur.user_id = users.id
        ) AS user_role ON TRUE
        WHERE id = ${e}
      ) as roles;
    `}}const ns=(s,e)=>ge.z.string({required_error:s.required}).refine(t=>le.isEmail(t,e||{}),{message:s.invalid}),Me={minLength:8,minLowercase:0,minUppercase:0,minNumbers:0,minSymbols:0,returnScore:!1,pointsPerUnique:1,pointsPerRepeat:.5,pointsForContainingLower:10,pointsForContainingUpper:10,pointsForContainingNumber:10,pointsForContainingSymbol:10},os=(s,e)=>{const t={...Me,...e};return ge.z.string({required_error:s.required}).refine(r=>le.isStrongPassword(r,t),{message:s.weak})},is=s=>{let e="Password is too weak";if(!s)return e;const t=[];if(s.minLength){const r=s.minLength;t.push(`minimum ${r} ${r>1?"characters":"character"}`)}if(s.minLowercase){const r=s.minLowercase;t.push(`minimum ${r} ${r>1?"lowercases":"lowercase"}`)}if(s.minUppercase){const r=s.minUppercase;t.push(`minimum ${r} ${r>1?"uppercases":"uppercase"}`)}if(s.minNumbers){const r=s.minNumbers;t.push(`minimum ${r} ${r>1?"numbers":"number"}`)}if(s.minSymbols){const r=s.minSymbols;t.push(`minimum ${r} ${r>1?"symbols":"symbol"}`)}if(t.length>0){e="Password should contain ";const r=t.pop();t.length>0&&(e+=t.join(", ")+" and "),e+=r}return e},$=(s,e)=>{const t=e.user.password,r=os({required:"Password is required",weak:is({...Me,...t})},t).safeParse(s);return r.success?{success:!0}:{message:r.error.issues[0].message,success:!1}};class We extends v.BaseService{get table(){return this.config.user?.table?.name||ne}get factory(){if(!this.table)throw new Error("Service table is not defined");return this._factory||(this._factory=new $e(this)),this._factory}changePassword=async(e,t,r)=>{const n=$(r,this.config);if(!n.success)return{status:"FIELD_ERROR",message:n.message};const o=await T.getUserById(e);if(t&&r)if(o)if((await T.emailPasswordSignIn(w,o.email,t,{dbSchema:this.schema})).status==="OK"){if(await T.updateEmailOrPassword({userId:e,password:r}))return await N.revokeAllSessionsForUser(e),{status:"OK"};throw{status:"FAILED",message:"Oops! Something went wrong, couldn't change password"}}else return{status:"INVALID_PASSWORD",message:"Invalid password"};else throw{status:"NOT_FOUND",message:"User not found"};else return{status:"FIELD_ERROR",message:"Password cannot be empty"}}}const I=(s,e,t)=>{const r=s.user.services?.user||We;return new r(s,e,t)},as=(s,e)=>async t=>{if(s.createNewSession===void 0)throw new Error("Should never come here");const r=t.userContext._default.request.request,n=await s.createNewSession(t),o=n.getUserId();if((await I(r.config,r.slonik,r.dbSchema).findById(o))?.disabled)throw await n.revokeSession(),{name:"SIGN_IN_FAILED",message:"user is disabled",statusCode:401};return n},cs=(s,e)=>async t=>{if(s.verifySession===void 0)throw new Error("Should never come here");const r=await s.verifySession(t);if(r){const n=r.getUserId(),o=t.userContext._default.request.request;if((await I(o.config,o.slonik,o.dbSchema).findById(n))?.disabled)throw await r.revokeSession(),{name:"SESSION_VERIFICATION_FAILED",message:"user is disabled",statusCode:401}}return r},us=s=>{const{config:e}=s;let t={};return typeof e.user.supertokens.recipes?.session=="object"&&(t=e.user.supertokens.recipes.session),{...t,getTokenTransferMethod:r=>r.req.getHeaderValue("st-auth-mode")==="header"?"header":"cookie",override:{apis:r=>{const n={};if(t.override?.apis){const o=t.override.apis;let i;for(i in o){const a=o[i];a&&(n[i]=a(r,s))}}return{...r,verifySession:cs(r),...n}},functions:r=>{const n={};if(t.override?.functions){const o=t.override.functions;let i;for(i in o){const a=o[i];a&&(n[i]=a(r,s))}}return{...r,createNewSession:as(r),...n}},openIdFeature:t.override?.openIdFeature}}},ds=s=>{const e=s.config.user.supertokens.recipes?.session;return typeof e=="function"?N.init(e(s)):N.init(us(s))},ls=(s,e)=>async t=>{if(s.appleRedirectHandlerPOST===void 0)throw new Error("Should never come here");const r=t.formPostInfoFromProvider.state,n=JSON.parse(Buffer.from(r,"base64").toString("ascii"));if(n.isAndroid&&n.appId){const i=`intent://callback?${`code=${t.formPostInfoFromProvider.code}&state=${t.formPostInfoFromProvider.state}`}#Intent;package=${n.appId};scheme=signinwithapple;end`;t.options.res.original.redirect(i)}else s.appleRedirectHandlerPOST(t)},gs=(s,e)=>{const{config:t,log:r,slonik:n}=e;return async o=>{const i=await s.emailPasswordSignIn(o);if(i.status!=="OK")return i;const a=I(t,n),u=await a.findById(i.user.id);return u?(u.lastLoginAt=Date.now(),await a.update(u.id,{lastLoginAt:v.formatDate(new Date(u.lastLoginAt))}).catch(l=>{r.error(`Unable to update lastLoginAt for userId ${i.user.id}`),r.error(l)}),{status:"OK",user:{...i.user,...u}}):(r.error(`User record not found for userId ${i.user.id}`),{status:"WRONG_CREDENTIALS_ERROR"})}},Ve=async s=>{const e=await b.createEmailVerificationToken(w,s);e.status==="OK"&&await b.verifyEmailUsingToken(w,e.token)},ce=async s=>{const{roles:e}=await p.getAllRoles();return s.every(t=>e.includes(t))},ms=(s,e)=>{const{config:t,log:r,slonik:n}=e;return async o=>{const i=o.userContext.roles||[];if(!await ce(i))throw r.error(`At least one role from ${i.join(", ")} does not exist.`),{name:"SIGN_UP_FAILED",message:"Something went wrong",statusCode:500};const a=await s.emailPasswordSignUp(o);if(a.status==="OK"){const u=I(t,n);let d;try{if(d=await u.create({id:a.user.id,email:a.user.email}),!d)throw new Error("User not found")}catch(l){throw r.error("Error while creating user"),r.error(l),await B.deleteUser(a.user.id),{name:"SIGN_UP_FAILED",message:"Something went wrong",statusCode:500}}d.roles=i,a.user={...a.user,...d};for(const l of i){const m=await p.addRoleToUser(w,a.user.id,l);m.status!=="OK"&&r.error(m.status)}if(t.user.features?.signUp?.emailVerification)try{if(o.userContext.autoVerifyEmail)await Ve(d.id);else{const l=await b.createEmailVerificationToken(w,a.user.id);l.status==="OK"&&await b.sendEmail({type:"EMAIL_VERIFICATION",user:a.user,emailVerifyLink:`${t.appOrigin[0]}/auth/verify-email?token=${l.token}&rid=emailverification`,tenantId:w,userContext:o.userContext})}}catch(l){r.error(l)}}if(t.user.supertokens.sendUserAlreadyExistsWarning&&a.status==="EMAIL_ALREADY_EXISTS_ERROR")try{M({fastify:e,subject:"Duplicate Email Registration",templateData:{emailId:o.email},templateName:"duplicate-email-warning",to:o.email})}catch(u){r.error(u)}return a}},ps=(s,e)=>async t=>{if(t.userContext.roles=[e.config.user.role||H],s.emailPasswordSignUpPOST===void 0)throw new Error("Should never come here");if(e.config.user.features?.signUp?.enabled===!1)throw{name:"SIGN_UP_DISABLED",message:"SignUp feature is currently disabled",statusCode:404};const r=await s.emailPasswordSignUpPOST(t);return r.status==="OK"?{status:"OK",user:r.user,session:r.session}:r},L=(s,e)=>{const t=ns({invalid:"Email is invalid",required:"Email is required"},e.user.email).safeParse(s);return t.success?{success:!0}:{message:t.error.issues[0].message,success:!1}},ws=s=>[{id:"email",validate:async e=>{const t=L(e,s);if(!t.success)return t.message}},{id:"password",validate:async e=>{const t=$(e,s);if(!t.success)return t.message}}],Es=s=>{let e=[];if(typeof s.user.supertokens?.recipes?.thirdPartyEmailPassword=="object"){const r=s.user.supertokens?.recipes?.thirdPartyEmailPassword.signUpFeature?.formFields;r&&(e=[...r])}const t=new Set(e.map(r=>r.id));for(const r of ws(s))t.has(r.id)||e.push(r);return e},hs=(s,e)=>async t=>{const r=await s.resetPasswordUsingToken(t);if(r.status==="OK"&&r.userId){const n=await T.getUserById(r.userId);n&&M({fastify:e,subject:"Reset Password Notification",templateName:"reset-password-notification",to:n.email,templateData:{emailId:n.email}})}return r},Ss=(s,e)=>{const t=e.config.appOrigin[0];return async r=>{const n=r.userContext._default.request.request,o=n.headers.referer||n.headers.origin||n.hostname,i=x(o)||t,a=r.passwordResetLink.replace(t+"/auth/reset-password",i+(e.config.user.supertokens.resetPasswordPath||Ie));M({fastify:e,subject:"Reset Password",templateName:"reset-password",to:r.user.email,templateData:{passwordResetLink:a}})}},Rs=(s,e)=>{const{config:t,log:r}=e;return async n=>{const o=n.userContext.roles||[];if(!await T.getUserByThirdPartyInfo(n.tenantId,n.thirdPartyId,n.thirdPartyUserId,n.userContext)&&t.user.features?.signUp?.enabled===!1)throw{name:"SIGN_UP_DISABLED",message:"SignUp feature is currently disabled",statusCode:404};const a=await s.thirdPartySignInUp(n);if(a.status==="OK"&&a.createdNewUser){if(!await ce(o))throw await B.deleteUser(a.user.id),r.error(`At least one role from ${o.join(", ")} does not exist.`),{name:"SIGN_UP_FAILED",message:"Something went wrong",statusCode:500};for(const u of o){const d=await p.addRoleToUser(w,a.user.id,u);d.status!=="OK"&&r.error(d.status)}}return a}},fs=(s,e)=>{const{config:t,log:r,slonik:n}=e;return async o=>{if(o.userContext.roles=[t.user.role||H],s.thirdPartySignInUpPOST===void 0)throw new Error("Should never come here");const i=await s.thirdPartySignInUpPOST(o);if(i.status==="OK"){const a=I(t,n);let u;if(i.createdNewUser)try{if(u=await a.create({id:i.user.id,email:i.user.email}),!u)throw new Error("User not found");u.roles=o.userContext.roles}catch(d){throw r.error("Error while creating user"),r.error(d),await B.deleteUser(i.user.id),{name:"SIGN_UP_FAILED",message:"Something went wrong",statusCode:500}}else{if(u=await a.findById(i.user.id),!u)return r.error(`User record not found for userId ${i.user.id}`),{status:"GENERAL_ERROR",message:"Something went wrong"};u.lastLoginAt=Date.now(),await a.update(u.id,{lastLoginAt:v.formatDate(new Date(u.lastLoginAt))}).catch(d=>{r.error(`Unable to update lastLoginAt for userId ${i.user.id}`),r.error(d)})}return{...i,user:{...i.user,...u}}}return i}},vs=s=>{const{config:e}=s;let t={};return typeof e.user.supertokens.recipes?.thirdPartyEmailPassword=="object"&&(t=e.user.supertokens.recipes.thirdPartyEmailPassword),{override:{apis:r=>{const n={};if(t.override?.apis){const o=t.override.apis;let i;for(i in o){const a=o[i];a&&(n[i]=a(r,s))}}return{...r,emailPasswordSignUpPOST:ps(r,s),thirdPartySignInUpPOST:fs(r,s),appleRedirectHandlerPOST:ls(r),...n}},functions:r=>{const n={};if(t.override?.functions){const o=t.override.functions;let i;for(i in o){const a=o[i];a&&(n[i]=a(r,s))}}return{...r,emailPasswordSignIn:gs(r,s),emailPasswordSignUp:ms(r,s),resetPasswordUsingToken:hs(r,s),thirdPartySignInUp:Rs(r,s),...n}}},signUpFeature:{formFields:Es(e)},emailDelivery:{override:r=>{let n;return t?.sendEmail&&(n=t.sendEmail),{...r,sendEmail:n?n(r,s):Ss(r,s)}}},providers:e.user.supertokens.providers}},Is=s=>{const e=s.config.user.supertokens.recipes?.thirdPartyEmailPassword;return typeof e=="function"?T.init(e(s)):T.init(vs(s))},Os=()=>({}),Ns=s=>{const e=s.config.user.supertokens.recipes;return e&&e.userRoles?p.init(e.userRoles(s)):p.init(Os())},_s=s=>{const e=[ds(s),Is(s),Ns(s)];return s.config.user.features?.signUp?.emailVerification&&e.push(rs(s)),e},Ps=s=>{const{config:e}=s;B.init({appInfo:{apiDomain:e.baseUrl,appName:e.appName,websiteDomain:e.appOrigin[0]},framework:"fastify",recipeList:_s(s),supertokens:{connectionURI:e.user.supertokens.connectionUri}})},Ts=K(async(s,e,t)=>{const{config:r,log:n}=s;n.info("Registering supertokens plugin"),Ps(s),s.setErrorHandler(ee.errorHandler()),await s.register(Je,{origin:r.appOrigin,allowedHeaders:["Content-Type","st-auth-mode",...B.getAllCORSHeaders()],credentials:!0}),await s.register(ze),await s.register(ee.plugin),n.info("Registering supertokens plugin complete"),s.decorate("verifySession",Ge.verifySession),t()}),ys=async(s,e,t)=>{const{config:r,slonik:n,dbSchema:o}=e;let i;try{const a=await N.getSession(e,ee.wrapResponse(t),{sessionRequired:!1,overrideGlobalClaimValidators:async u=>u.filter(d=>d.id!==b.EmailVerificationClaim.key)});i=a===void 0?void 0:a.getUserId()}catch(a){throw N.Error.isErrorFromSuperTokens(a)?new g.ErrorWithProps("Session related error",{code:"UNAUTHENTICATED",http:{status:a.type===N.Error.INVALID_CLAIMS?403:401}},a.type===N.Error.INVALID_CLAIMS?403:401):a}if(i&&!s.user){const a=I(r,n,o);let u=null;try{u=await a.findById(i)}catch{}if(!u)throw new Error("Unable to find user");const{roles:d}=await p.getRolesForUser(w,i);s.user=u,s.roles=d}},qe=K(async(s,e,t)=>{const{mercurius:r}=s.config;await s.register(Ts),s.decorate("hasPermission",xe),r.enabled&&await s.register(Ze),t()});qe.updateContext=ys;const Us=new Set(["id","disable","enable","email","lastLoginAt","roles","signedUpAt"]),Ke=s=>{for(const e of Object.keys(s))Us.has(se.camelize(e))&&delete s[e]},As={Mutation:{adminSignUp:async(s,e,t)=>{const{app:r,config:n,reply:o}=t;try{const{email:i,password:a}=e.data,u=await p.getUsersThatHaveRole(w,F),d=await p.getUsersThatHaveRole(w,C);let l;if(u.status==="UNKNOWN_ROLE_ERROR"&&d.status==="UNKNOWN_ROLE_ERROR"?l=u.status:(u.status==="OK"&&u.users.length>0||d.status==="OK"&&d.users.length>0)&&(l="First admin user already exists"),l)return new g.ErrorWithProps(l);const m=L(i,n);if(!m.success&&m.message)return new g.ErrorWithProps(m.message);const E=$(a,n);if(!E.success&&E.message)return new g.ErrorWithProps(E.message);const h=await T.emailPasswordSignUp(w,i,a,{autoVerifyEmail:!0,roles:[F,...d.status==="OK"?[C]:[]],_default:{request:{request:o.request}}});return h.status!=="OK"?new g.ErrorWithProps(h.status):(await N.createNewSession(o.request,o,w,h.user.id),h)}catch(i){r.log.error(i);const a=new g.ErrorWithProps("Oops, Something went wrong");return a.statusCode=500,a}},disableUser:async(s,e,t)=>{const{id:r}=e;if(t.user?.id===r){const i=new g.ErrorWithProps("you cannot disable yourself");return i.statusCode=409,i}return await I(t.config,t.database,t.dbSchema).update(r,{disabled:!0})?{status:"OK"}:new g.ErrorWithProps(`user id ${r} not found`,{},404)},enableUser:async(s,e,t)=>{const{id:r}=e;return await I(t.config,t.database,t.dbSchema).update(r,{disabled:!1})?{status:"OK"}:new g.ErrorWithProps(`user id ${r} not found`,{},404)},changePassword:async(s,e,t)=>{const r=I(t.config,t.database,t.dbSchema);try{return t.user?.id?await r.changePassword(t.user.id,e.oldPassword,e.newPassword):{status:"NOT_FOUND",message:"User not found"}}catch(n){t.app.log.error(n);const o=new g.ErrorWithProps("Oops, Something went wrong");return o.statusCode=500,o}},updateMe:async(s,e,t)=>{const{data:r}=e,n=I(t.config,t.database,t.dbSchema);try{return t.user?.id?(Ke(r),await n.update(t.user.id,r)):{status:"NOT_FOUND",message:"User not found"}}catch(o){t.app.log.error(o);const i=new g.ErrorWithProps("Oops, Something went wrong");return i.statusCode=500,i}}},Query:{canAdminSignUp:async(s,e,t)=>{const{app:r}=t;try{const n=await p.getUsersThatHaveRole(w,F),o=await p.getUsersThatHaveRole(w,C);return n.status==="UNKNOWN_ROLE_ERROR"&&o.status==="UNKNOWN_ROLE_ERROR"?new g.ErrorWithProps(n.status):n.status==="OK"&&n.users.length>0||o.status==="OK"&&o.users.length>0?{signUp:!1}:{signUp:!0}}catch(n){r.log.error(n);const o=new g.ErrorWithProps("Oops! Something went wrong");return o.statusCode=500,o}},me:async(s,e,t)=>{const r=I(t.config,t.database,t.dbSchema);if(t.user?.id)return await r.findById(t.user.id);{t.app.log.error("Could not able to get user id from mercurius context");const n=new g.ErrorWithProps("Oops, Something went wrong");return n.statusCode=500,n}},user:async(s,e,t)=>await I(t.config,t.database,t.dbSchema).findById(e.id),users:async(s,e,t)=>await I(t.config,t.database,t.dbSchema).list(e.limit,e.offset,e.filters?JSON.parse(JSON.stringify(e.filters)):void 0,e.sort?JSON.parse(JSON.stringify(e.sort)):void 0)}},D={adminSignUp:async(s,e)=>{const{body:t,config:r,log:n}=s;try{const{email:o,password:i}=t,a=await p.getUsersThatHaveRole(w,F),u=await p.getUsersThatHaveRole(w,C);if(a.status==="UNKNOWN_ROLE_ERROR"&&u.status==="UNKNOWN_ROLE_ERROR")return e.send({status:"ERROR",message:a.status});if(a.status==="OK"&&a.users.length>0||u.status==="OK"&&u.users.length>0)return e.send({status:"ERROR",message:"First admin user already exists"});const d=L(o,r);if(!d.success)return e.send({status:"ERROR",message:d.message});const l=$(i,r);if(!l.success)return e.send({status:"ERROR",message:l.message});const m=await T.emailPasswordSignUp(w,o,i,{autoVerifyEmail:!0,roles:[F,...u.status==="OK"?[C]:[]],_default:{request:{request:s}}});if(m.status!=="OK")return e.send(m);await N.createNewSession(s,e,w,m.user.id),e.send(m)}catch(o){n.error(o),e.status(500),e.send({status:"ERROR",message:"Oops! Something went wrong"})}},canAdminSignUp:async(s,e)=>{const{log:t}=s;try{const r=await p.getUsersThatHaveRole(w,F),n=await p.getUsersThatHaveRole(w,C);if(r.status==="UNKNOWN_ROLE_ERROR"&&n.status==="UNKNOWN_ROLE_ERROR")return e.send({status:"ERROR",message:r.status});if(r.status==="OK"&&r.users.length>0||n.status==="OK"&&n.users.length>0)return e.send({signUp:!1});e.send({signUp:!0})}catch(r){t.error(r),e.status(500),e.send({status:"ERROR",message:"Oops! Something went wrong"})}},changePassword:async(s,e)=>{try{const t=s.session,r=s.body,n=t&&t.getUserId();if(!n)throw new Error("User not found in session");const o=r.oldPassword??"",i=r.newPassword??"",u=await I(s.config,s.slonik,s.dbSchema).changePassword(n,o,i);e.send(u)}catch(t){s.log.error(t),e.status(500),e.send({status:"ERROR",message:"Oops! Something went wrong",error:t})}},disable:async(s,e)=>{if(s.session){const{id:t}=s.params;return s.session.getUserId()===t?(e.status(409),await e.send({message:"you cannot disable yourself"})):await I(s.config,s.slonik,s.dbSchema).update(t,{disabled:!0})?await e.send({status:"OK"}):(e.status(404),await e.send({message:`user id ${t} not found`}))}else throw s.log.error("could not get session"),new Error("Oops, Something went wrong")},enable:async(s,e)=>{if(s.session){const{id:t}=s.params;return await I(s.config,s.slonik,s.dbSchema).update(t,{disabled:!1})?await e.send({status:"OK"}):(e.status(404),await e.send({message:`user id ${t} not found`}))}else throw s.log.error("could not get session"),new Error("Oops, Something went wrong")},me:async(s,e)=>{const t=I(s.config,s.slonik,s.dbSchema),r=s.session?.getUserId();if(r)e.send(await t.findById(r));else throw s.log.error("Could not able to get user id from session"),new Error("Oops, Something went wrong")},updateMe:async(s,e)=>{const t=s.session?.getUserId(),r=s.body;if(t){const n=I(s.config,s.slonik,s.dbSchema);Ke(r),e.send(await n.update(t,r))}else throw s.log.error("could not get user id from session"),new Error("Oops, Something went wrong")},users:async(s,e)=>{const t=I(s.config,s.slonik,s.dbSchema),{limit:r,offset:n,filters:o,sort:i}=s.query,a=await t.list(r,n,o?JSON.parse(o):void 0,i?JSON.parse(i):void 0);e.send(a)}},bs=async(s,e,t)=>{const r=s.config.user.handlers?.user;s.get(Ne,{preHandler:[s.verifySession(),s.hasPermission(Fe)]},r?.users||D.users),s.post(Oe,{preHandler:s.verifySession()},r?.changePassword||D.changePassword),s.get(te,{preHandler:s.verifySession()},r?.me||D.me),s.put(te,{preHandler:s.verifySession()},r?.updateMe||D.updateMe),s.put(_e,{preHandler:[s.verifySession(),s.hasPermission(De)]},r?.disable||D.disable),s.put(Pe,{preHandler:[s.verifySession(),s.hasPermission(ke)]},r?.enable||D.enable),s.post(re,r?.adminSignUp||D.adminSignUp),s.get(re,r?.canAdminSignUp||D.canAdminSignUp),t()},ue=(s,e)=>e||v.formatDate(new Date(Date.now()+(s.user.invitation?.expireAfterInDays??pe)*(24*60*60*1e3)));class Be extends v.DefaultSqlFactory{getFindByTokenSql=e=>S.sql.type(this.validationSchema)`
      SELECT *
      FROM ${this.getTableFragment()}
      WHERE token = ${e};
    `;getListSql=(e,t,r,n)=>{const o=v.createTableIdentifier(this.table,this.schema),i=v.createTableFragment(this.config.user.table?.name||ne,this.schema);return S.sql.type(this.validationSchema)`
      SELECT ${this.getTableFragment()}.*, ROW_TO_JSON("user") as "invited_by"
      FROM ${this.getTableFragment()}
      join ${i} "user" on ${this.getTableFragment()}."invited_by_id" = "user"."id"
      ${v.createFilterFragment(r,o)}
      ${v.createSortFragment(o,this.getSortInput(n))}
      ${v.createLimitFragment(e,t)};
    `}}class He extends v.BaseService{static TABLE=ve;create=async e=>{const t={AND:[{key:"email",operator:"eq",value:e.email},{key:"acceptedAt",operator:"eq",value:"null"},{key:"expiresAt",operator:"gt",value:v.formatDate(new Date)},{key:"revokedAt",operator:"eq",value:"null"}]};if(await this.count(t)>0)throw new Error("Invitation already exist");const n=this.factory.getCreateSql(e),o=await this.database.connect(async i=>i.query(n).then(a=>a.rows[0]));return o?this.postCreate(o):void 0};findByToken=async e=>{if(!this.validateUUID(e))return null;const t=this.factory.getFindByTokenSql(e);return await this.database.connect(n=>n.maybeOne(t))};get factory(){if(!this.table)throw new Error("Service table is not defined");return this._factory||(this._factory=new Be(this)),this._factory}validateUUID=e=>/^[\da-f]{8}(?:\b-[\da-f]{4}){3}\b-[\da-f]{12}$/gi.test(e)}const _=(s,e,t)=>{const r=s.user.services?.invitation||He;return new r(s,e,t)},j=s=>!(s.acceptedAt||s.revokedAt||Date.now()>s.expiresAt),Cs=(s,e,t)=>{const{token:r}=e;let n=s.user.invitation?.acceptLinkPath||me;return n=n.replace(/:token(?!\w)/g,r),new URL(n,t).href},J=async(s,e,t)=>{const{config:r,log:n}=s,o=r.apps?.find(i=>i.id===e.appId)?.origin||x(t||"")||r.appOrigin[0];o?M({fastify:s,subject:"Invitation for Sign Up",templateData:{invitationLink:Cs(r,e,o)},templateName:"user-invitation",to:e.email}):n.error(`Could not send email for invitation ID ${e.id}`)},Ls={Mutation:{acceptInvitation:async(s,e,t)=>{const{app:r,config:n,database:o,dbSchema:i,reply:a}=t,{token:u,data:d}=e;try{const{email:l,password:m}=d,E=L(l,n);if(!E.success&&E.message)return new g.ErrorWithProps(E.message);const h=$(m,n);if(!h.success&&h.message)return new g.ErrorWithProps(h.message);const R=_(n,o,i),f=await R.findByToken(u);if(!f||!j(f))return new g.ErrorWithProps("Invitation is invalid or has expired");if(f.email!=l)return new g.ErrorWithProps("Email do not match with the invitation");const P=await T.emailPasswordSignUp(w,l,m,{roles:[f.role],autoVerifyEmail:!0});if(P.status!=="OK")return P;await R.update(f.id,{acceptedAt:v.formatDate(new Date(Date.now()))});try{await n.user.invitation?.postAccept?.(a.request,f,P.user)}catch(A){r.log.error(A)}return await N.createNewSession(a.request,a,w,P.user.id),{...P,user:{...P.user,roles:[f.role]}}}catch(l){r.log.error(l);const m=new g.ErrorWithProps("Oops! Something went wrong");return m.statusCode=500,m}},createInvitation:async(s,e,t)=>{const{app:r,config:n,database:o,dbSchema:i,reply:a,user:u}=t;try{if(!u)throw new Error("User not found in session");const{appId:d,email:l,expiresAt:m,payload:E,role:h}=e.data,R=L(l,n);if(!R.success&&R.message)return new g.ErrorWithProps(R.message);const f=_(n,o,i),P={key:"email",operator:"eq",value:l};if(await f.count(P)>0)return new g.ErrorWithProps(`User with email ${l} already exists`);const k={email:l,expiresAt:ue(n,m),invitedById:u.id,role:h||n.user.role||H},G=n.apps?.find(O=>O.id==d);if(G)if(G.supportedRoles.includes(k.role))k.appId=d;else return new g.ErrorWithProps(`App ${G.name} does not support role ${k.role}`);Object.keys(E||{}).length>0&&(k.payload=JSON.stringify(E));let Q;try{Q=await f.create(k)}catch(O){return new g.ErrorWithProps(O.message)}if(Q){try{const{headers:O,hostname:V}=a.request,q=O.referer||O.origin||V;J(r,Q,q)}catch(O){r.log.error(O)}return Q}}catch(d){r.log.error(d);const l=new g.ErrorWithProps("Oops, Something went wrong");return l.statusCode=500,l}},resendInvitation:async(s,e,t)=>{const{app:r,config:n,database:o,dbSchema:i,reply:a}=t,d=await _(n,o,i).findById(e.id);if(!d||!j(d))return new g.ErrorWithProps("Invitation is invalid or has expired");const{headers:l,hostname:m}=a.request,E=l.referer||l.origin||m;try{J(r,d,E)}catch(h){r.log.error(h)}return d},revokeInvitation:async(s,e,t)=>{const r=_(t.config,t.database,t.dbSchema);let n=await r.findById(e.id),o;return n?n.acceptedAt?o="Invitation is already accepted":Date.now()>n.expiresAt?o="Invitation is expired":n.revokedAt&&(o="Invitation is already revoked"):o="Invitation not found",o?new g.ErrorWithProps(o):(n=await r.update(e.id,{revokedAt:v.formatDate(new Date(Date.now()))}),n)}},Query:{getInvitationByToken:async(s,e,t)=>{try{return await _(t.config,t.database,t.dbSchema).findByToken(e.token)}catch(r){t.app.log.error(r);const n=new g.ErrorWithProps("Oops, Something went wrong");return n.statusCode=500,n}},invitations:async(s,e,t)=>await _(t.config,t.database,t.dbSchema).list(e.limit,e.offset,e.filters?JSON.parse(JSON.stringify(e.filters)):void 0,e.sort?JSON.parse(JSON.stringify(e.sort)):void 0)}},W={acceptInvitation:async(s,e)=>{const{body:t,config:r,dbSchema:n,log:o,params:i,slonik:a}=s,{token:u}=i;try{const{email:d,password:l}=t,m=L(d,r);if(!m.success)return e.send({status:"ERROR",message:m.message});const E=$(l,r);if(!E.success)return e.send({status:"ERROR",message:E.message});const h=_(r,a,n),R=await h.findByToken(u);if(!R||!j(R))return e.send({status:"ERROR",message:"Invitation is invalid or has expired"});if(R.email!=d)return e.send({status:"ERROR",message:"Email do not match with the invitation"});const f=await T.emailPasswordSignUp(w,d,l,{roles:[R.role],autoVerifyEmail:!0});if(f.status!=="OK")return e.send(f);await h.update(R.id,{acceptedAt:v.formatDate(new Date(Date.now()))});try{await r.user.invitation?.postAccept?.(s,R,f.user)}catch(P){o.error(P)}await N.createNewSession(s,e,w,f.user.id),e.send({...f,user:{...f.user,roles:[R.role]}})}catch(d){o.error(d),e.status(500),e.send({status:"ERROR",message:"Oops! Something went wrong"})}},createInvitation:async(s,e)=>{const{body:t,config:r,dbSchema:n,headers:o,hostname:i,log:a,server:u,session:d,slonik:l}=s;try{const m=d&&d.getUserId();if(!m)throw new Error("User not found in session");const{appId:E,email:h,expiresAt:R,payload:f,role:P}=t,A=L(h,r);if(!A.success)return e.send({status:"ERROR",message:A.message});const k=_(r,l,n),G={key:"email",operator:"eq",value:h};if(await k.count(G)>0)return e.send({status:"ERROR",message:`User with email ${h} already exists`});const O={email:h,expiresAt:ue(r,R),invitedById:m,role:P||r.user.role||H},V=r.apps?.find(Y=>Y.id==E);if(V)if(V.supportedRoles.includes(O.role))O.appId=E;else return e.send({status:"ERROR",message:`App ${V.name} does not support role ${O.role}`});Object.keys(f||{}).length>0&&(O.payload=JSON.stringify(f));let q;try{q=await k.create(O)}catch(Y){return e.send({status:"ERROR",message:Y.message})}if(q){const Y=o.referer||o.origin||i;try{J(u,q,Y)}catch(qs){a.error(qs)}const je=q;delete je.token,e.send(je)}}catch(m){a.error(m),e.status(500),e.send({status:"ERROR",message:"Oops! Something went wrong"})}},getInvitationByToken:async(s,e)=>{const{config:t,dbSchema:r,log:n,params:o,slonik:i}=s,{token:a}=o;try{const d=await _(t,i,r).findByToken(a);e.send(d)}catch(u){n.error(u),e.status(500),e.send({status:"ERROR",message:"Oops! Something went wrong"})}},listInvitation:async(s,e)=>{const{config:t,dbSchema:r,log:n,query:o,slonik:i}=s;try{const{limit:a,offset:u,filters:d,sort:l}=o,E=await _(t,i,r).list(a,u,d?JSON.parse(d):void 0,l?JSON.parse(l):void 0);for(const h of E.data)delete h.token;e.send(E)}catch(a){n.error(a),e.status(500),e.send({status:"ERROR",message:"Oops! Something went wrong"})}},resendInvitation:async(s,e)=>{const{config:t,dbSchema:r,headers:n,hostname:o,log:i,params:a,slonik:u,server:d}=s;try{const{id:l}=a,E=await _(t,u,r).findById(l);if(!E||!j(E))return e.send({status:"ERROR",message:"Invitation is invalid or has expired"});const h=n.referer||n.origin||o;try{J(d,E,h)}catch(f){i.error(f)}const R=E;delete R.token,e.send(R)}catch(l){i.error(l),e.status(500),e.send({status:"ERROR",message:"Oops! Something went wrong"})}},revokeInvitation:async(s,e)=>{const{config:t,dbSchema:r,log:n,params:o,slonik:i}=s;try{const{id:a}=o,u=_(t,i,r);let d=await u.findById(a);if(d){if(d.acceptedAt)return e.send({status:"error",message:"Invitation is already accepted"});if(Date.now()>d.expiresAt)return e.send({status:"error",message:"Invitation is expired"});if(d.revokedAt)return e.send({status:"error",message:"Invitation is already revoked"})}else return e.send({status:"error",message:"Invitation not found"});d=await u.update(a,{revokedAt:v.formatDate(new Date(Date.now()))});const l=d;delete l.token,e.send(l)}catch(a){n.error(a),e.status(500),e.send({status:"ERROR",message:"Oops! Something went wrong"})}}},Ds=async(s,e,t)=>{const r=s.config.user.handlers?.invitation;s.get(we,{preHandler:[s.verifySession(),s.hasPermission(be)]},r?.list||W.listInvitation),s.post(he,{preHandler:[s.verifySession(),s.hasPermission(Ae)]},r?.create||W.createInvitation),s.get(Se,r?.getByToken||W.getInvitationByToken),s.post(Ee,r?.accept||W.acceptInvitation),s.put(fe,{preHandler:[s.verifySession(),s.hasPermission(Le)]},r?.revoke||W.revokeInvitation),s.post(Re,{preHandler:[s.verifySession(),s.hasPermission(Ce)]},r?.resend||W.resendInvitation),t()},ks={Query:{permissions:async(s,e,t)=>{const{app:r,config:n}=t;try{return n.user.permissions||[]}catch(o){r.log.error(o);const i=new g.ErrorWithProps("Oops, Something went wrong");return i.statusCode=500,i}}}},Fs={getPermissions:async(s,e)=>{const{config:t,log:r}=s;try{const n=t.user.permissions||[];e.send({permissions:n})}catch(n){r.error(n),e.status(500),e.send({status:"ERROR",message:"Oops! Something went wrong"})}}},$s=async(s,e,t)=>{s.get(Te,{preHandler:[s.verifySession()]},Fs.getPermissions),t()};class U extends Error{statusCode;constructor({message:e,name:t,statusCode:r}){super(e),this.message=e,this.name=t,this.statusCode=r}}class y{createRole=async(e,t)=>await p.createNewRoleOrAddPermissions(e,t||[]);deleteRole=async e=>{const t=await p.getUsersThatHaveRole(w,e);if(t.status==="UNKNOWN_ROLE_ERROR")throw new U({name:t.status,message:"Invalid role",statusCode:422});if(t.users.length>0)throw new U({name:"ROLE_IN_USE",message:"The role is currently assigned to one or more users and cannot be deleted",statusCode:422});return await p.deleteRole(e)};getPermissionsForRole=async e=>{let t=[];const r=await p.getPermissionsForRole(e);return r.status==="OK"&&(t=r.permissions),t};getRoles=async()=>{let e=[];const t=await p.getAllRoles();return t.status==="OK"&&(e=await Promise.all(t.roles.map(async r=>{const n=await p.getPermissionsForRole(r);return{role:r,permissions:n.status==="OK"?n.permissions:[]}}))),e};updateRolePermissions=async(e,t)=>{const r=await p.getPermissionsForRole(e);if(r.status==="UNKNOWN_ROLE_ERROR")throw new U({name:"UNKNOWN_ROLE_ERROR",message:"Invalid role",statusCode:422});const n=r.permissions,o=t.filter(u=>!n.includes(u)),i=n.filter(u=>!t.includes(u));return await p.removePermissionsFromRole(e,i),await p.createNewRoleOrAddPermissions(e,o),{status:"OK",permissions:await this.getPermissionsForRole(e)}}}const Ms={Mutation:{createRole:async(s,e,t)=>{const{app:r}=t;try{return await new y().createRole(e.role,e.permissions)}catch(n){r.log.error(n);const o=new g.ErrorWithProps("Oops, Something went wrong");return o.statusCode=500,o}},deleteRole:async(s,e,t)=>{const{app:r}=t;try{const n=new y,{role:o}=e;return await n.deleteRole(o)}catch(n){if(n instanceof U){const i=new g.ErrorWithProps(n.name);return i.statusCode=n.statusCode,i}r.log.error(n);const o=new g.ErrorWithProps("Oops, Something went wrong");return o.statusCode=500,o}},updateRolePermissions:async(s,e,t)=>{const{app:r}=t,{permissions:n,role:o}=e;try{return await new y().updateRolePermissions(o,n)}catch(i){if(i instanceof U){const u=new g.ErrorWithProps(i.name);return u.statusCode=i.statusCode,u}r.log.error(i);const a=new g.ErrorWithProps("Oops, Something went wrong");return a.statusCode=500,a}}},Query:{roles:async(s,e,t)=>{const{app:r}=t;try{return await new y().getRoles()}catch(n){r.log.error(n);const o=new g.ErrorWithProps("Oops, Something went wrong");return o.statusCode=500,o}},rolePermissions:async(s,e,t)=>{const{app:r}=t,{role:n}=e;let o=[];try{return n&&(o=await new y().getPermissionsForRole(n)),o}catch(i){r.log.error(i);const a=new g.ErrorWithProps("Oops, Something went wrong");return a.statusCode=500,a}}}},z={deleteRole:async(s,e)=>{const{log:t,query:r}=s;try{let{role:n}=r;if(n){try{n=JSON.parse(n)}catch{}if(typeof n!="string")throw new U({name:"UNKNOWN_ROLE_ERROR",message:"Invalid role",statusCode:422});const i=await new y().deleteRole(n);return e.send(i)}throw new U({name:"UNKNOWN_ROLE_ERROR",message:"Invalid role",statusCode:422})}catch(n){return n instanceof U?(e.status(n.statusCode),e.send({message:n.message,name:n.name,statusCode:n.statusCode})):(t.error(n),e.status(500),e.send({status:"ERROR",message:"Oops! Something went wrong"}))}},createRole:async(s,e)=>{const{body:t,log:r}=s,{role:n,permissions:o}=t;try{const a=await new y().createRole(n,o);return e.send(a)}catch(i){return r.error(i),e.status(500),e.send({status:"ERROR",message:"Oops! Something went wrong"})}},getRoles:async(s,e)=>{const{log:t}=s;try{const n=await new y().getRoles();return e.send({roles:n})}catch(r){return t.error(r),e.status(500),e.send({status:"ERROR",message:"Oops! Something went wrong"})}},getPermissions:async(s,e)=>{const{log:t,query:r}=s;let n=[];try{let{role:o}=r;if(o){try{o=JSON.parse(o)}catch{}if(typeof o!="string")return e.send({permissions:n});n=await new y().getPermissionsForRole(o)}return e.send({permissions:n})}catch(o){return t.error(o),e.status(500),e.send({status:"ERROR",message:"Oops! Something went wrong"})}},updatePermissions:async(s,e)=>{const{log:t,body:r}=s;try{const{role:n,permissions:o}=r,a=await new y().updateRolePermissions(n,o);return e.send(a)}catch(n){return n instanceof U?(e.status(n.statusCode),e.send({message:n.message,name:n.name,statusCode:n.statusCode})):(t.error(n),e.status(500),e.send({status:"ERROR",message:"Oops! Something went wrong"}))}}},Ws=async(s,e,t)=>{s.delete(Z,{preHandler:[s.verifySession()]},z.deleteRole),s.get(Z,{preHandler:[s.verifySession()]},z.getRoles),s.get(oe,{preHandler:[s.verifySession()]},z.getPermissions),s.post(Z,{preHandler:[s.verifySession()]},z.createRole),s.put(oe,{preHandler:[s.verifySession()]},z.updatePermissions),t()},Vs=async s=>{const{roles:e}=await p.getAllRoles();return e.includes(s)};Object.defineProperty(c,"formatDate",{enumerable:!0,get:()=>v.formatDate}),c.EMAIL_VERIFICATION_MODE=ye,c.EMAIL_VERIFICATION_PATH=Ue,c.INVITATION_ACCEPT_LINK_PATH=me,c.INVITATION_EXPIRE_AFTER_IN_DAYS=pe,c.InvitationService=He,c.InvitationSqlFactory=Be,c.PERMISSIONS_INVITATIONS_CREATE=Ae,c.PERMISSIONS_INVITATIONS_LIST=be,c.PERMISSIONS_INVITATIONS_RESEND=Ce,c.PERMISSIONS_INVITATIONS_REVOKE=Le,c.PERMISSIONS_USERS_DISABLE=De,c.PERMISSIONS_USERS_ENABLE=ke,c.PERMISSIONS_USERS_LIST=Fe,c.RESET_PASSWORD_PATH=Ie,c.ROLE_ADMIN=F,c.ROLE_SUPER_ADMIN=C,c.ROLE_USER=H,c.ROUTE_CHANGE_PASSWORD=Oe,c.ROUTE_INVITATIONS=we,c.ROUTE_INVITATIONS_ACCEPT=Ee,c.ROUTE_INVITATIONS_CREATE=he,c.ROUTE_INVITATIONS_GET_BY_TOKEN=Se,c.ROUTE_INVITATIONS_RESEND=Re,c.ROUTE_INVITATIONS_REVOKE=fe,c.ROUTE_ME=te,c.ROUTE_PERMISSIONS=Te,c.ROUTE_ROLES=Z,c.ROUTE_ROLES_PERMISSIONS=oe,c.ROUTE_SIGNUP_ADMIN=re,c.ROUTE_USERS=Ne,c.ROUTE_USERS_DISABLE=_e,c.ROUTE_USERS_ENABLE=Pe,c.RoleService=y,c.TABLE_INVITATIONS=ve,c.TABLE_USERS=ne,c.TENANT_ID=w,c.UserService=We,c.UserSqlFactory=$e,c.areRolesExist=ce,c.computeInvitationExpiresAt=ue,c.default=qe,c.getInvitationService=_,c.getOrigin=x,c.getUserService=I,c.hasUserPermission=ie,c.invitationResolver=Ls,c.invitationRoutes=Ds,c.isInvitationValid=j,c.isRoleExists=Vs,c.permissionResolver=ks,c.permissionRoutes=$s,c.roleResolver=Ms,c.roleRoutes=Ws,c.sendEmail=M,c.sendInvitation=J,c.userResolver=As,c.userRoutes=bs,c.validateEmail=L,c.validatePassword=$,c.verifyEmail=Ve,Object.defineProperties(c,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});
