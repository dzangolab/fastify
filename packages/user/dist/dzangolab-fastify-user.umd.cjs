(function(c,S){typeof exports=="object"&&typeof module<"u"?S(exports,require("@dzangolab/fastify-mercurius"),require("fastify-plugin"),require("mercurius"),require("mercurius-auth"),require("@fastify/cors"),require("@fastify/formbody"),require("supertokens-node"),require("supertokens-node/framework/fastify"),require("supertokens-node/recipe/session/framework/fastify"),require("supertokens-node/recipe/session"),require("supertokens-node/recipe/thirdpartyemailpassword"),require("supertokens-node/recipe/userroles"),require("@dzangolab/fastify-slonik"),require("@dzangolab/fastify-mailer")):typeof define=="function"&&define.amd?define(["exports","@dzangolab/fastify-mercurius","fastify-plugin","mercurius","mercurius-auth","@fastify/cors","@fastify/formbody","supertokens-node","supertokens-node/framework/fastify","supertokens-node/recipe/session/framework/fastify","supertokens-node/recipe/session","supertokens-node/recipe/thirdpartyemailpassword","supertokens-node/recipe/userroles","@dzangolab/fastify-slonik","@dzangolab/fastify-mailer"],S):(c=typeof globalThis<"u"?globalThis:c||self,S(c.DzangolabFastifyUser={},c.DzangolabFastifyMercurius,c.FastifyPlugin,c.Mercurius,c.MercuriusAuth,c.FastifyCors,c.FastifyFormbody,c.SupertokensNode,c.SupertokensFastify,c.SupertokensSessionFastify,c.SupertokensSession,c.SupertokensThirdPartyEmailPassword,c.SupertokensUserRoles,c.DzangolabFastifySlonik))})(this,function(c,S,y,v,C,D,b,O,U,F,h,d,g,k){"use strict";const N=y(async s=>{s.config.mercurius.enabled&&s.register(C,{async applyPolicy(e,o,n,t){if(!t.user){const i=new v.ErrorWithProps("unauthorized");return i.statusCode=200,i}return!0},authDirective:"auth"})}),_=()=>({override:{functions:function(s){return{...s,createNewSession:async function(r){return r.accessTokenPayload={...r.accessTokenPayload,user:await d.getUserById(r.userId,{tenant:r.userContext.tenant})},s.createNewSession(r)}}}}}),L=s=>{const r=s.config.user.supertokens.recipes;return r&&r.session?h.init(r.session(s)):h.init(_())},R=s=>s.multiTenant?.table?.columns?.id||"id",P={addTenantPrefix:(s,r,e)=>(e&&(r=e[R(s)]+"_"+r),r),removeTenantPrefix:(s,r)=>(r&&(s=s.slice(Math.max(0,s.indexOf("_")+1))),s)},A=(s,r)=>async e=>{const o=e.email;e.email=P.addTenantPrefix(r.config,e.email,e.userContext.tenant);let n=await s.emailPasswordSignIn(e);return n.status==="OK"&&(n={...n,user:{...n.user,email:o}}),n};class B extends k.DefaultSqlFactory{}class w extends k.BaseService{static LIMIT_DEFAULT=20;static LIMIT_MAX=50;get table(){return this.config.user?.table?.name||"users"}get factory(){if(!this.table)throw new Error("Service table is not defined");return this._factory||(this._factory=new B(this)),this._factory}}const M=(s,r)=>async e=>{e.userContext.tenant=e.options.req.original.tenant;const{config:o,slonik:n}=r;if(s.emailPasswordSignInPOST===void 0)throw new Error("Should never come here");const t=await s.emailPasswordSignInPOST(e);if(t.status!=="OK")return t;const i=new w(o,n);let a=null;try{a=await i.findById(t.user.id)}catch{}const{roles:u}=await g.getRolesForUser(t.user.id);return{status:"OK",user:{...t.user,profile:a,roles:u},session:t.session}},E=async({fastify:s,subject:r,templateData:e={},templateName:o,to:n})=>{const{config:t,mailer:i,log:a}=s;return i.sendMail({subject:r,templateName:o,to:n,templateData:{appName:t.appName,...e}}).catch(u=>{throw a.error(u.stack),{name:"SEND_EMAIL",message:u.message,statusCode:500}})},q=(s,r)=>{const{config:e,log:o}=r;return async n=>{if(e.user.features?.signUp===!1)throw{name:"SIGN_UP_DISABLED",message:"SignUp feature is currently disabled",statusCode:404};const t=n.email;n.email=P.addTenantPrefix(e,n.email,n.userContext.tenant);let i=await s.emailPasswordSignUp(n);if(e.user.supertokens.sendUserAlreadyExistsWarning&&i.status==="EMAIL_ALREADY_EXISTS_ERROR")try{await E({fastify:r,subject:"Duplicate Email Registration",templateData:{emailId:t},templateName:"duplicate-email-warning",to:t})}catch(a){o.error(a)}return i.status==="OK"&&(i={...i,user:{...i.user,email:t}}),i}},x=(s,r)=>{const{log:e,config:o}=r;return async n=>{if(n.userContext.tenant=n.options.req.original.tenant,s.emailPasswordSignUpPOST===void 0)throw new Error("Should never come here");const t=await s.emailPasswordSignUpPOST(n);if(t.status==="OK"){const i=await g.addRoleToUser(t.user.id,o.user.role||"USER");i.status!=="OK"&&e.error(i.status);const{roles:a}=await g.getRolesForUser(t.user.id);return{status:"OK",user:{...t.user,profile:null,roles:a},session:t.session}}return t}},K=(s,r,e)=>(e&&r.find(o=>{o.id==="email"&&(o.value=e[R(s)]+"_"+o.value)}),r),z=(s,r)=>async e=>{if(e.userContext.tenant=e.options.req.original.tenant,s.generatePasswordResetTokenPOST===void 0)throw new Error("Should never come here");return e.formFields=K(r.config,e.formFields,e.userContext.tenant),await s.generatePasswordResetTokenPOST(e)},$=s=>async r=>{let e=await s.getUserById(r);return e&&r.userContext.tenant&&(e={...e,email:P.removeTenantPrefix(e.email,r.userContext.tenant)}),e},H=s=>{let r;try{if(r=new URL(s).origin,!r||r==="null")throw console.log("Error"),new Error("Origin is empty")}catch{r=""}return r},J=s=>{const r=s.config.appOrigin[0],e="/reset-password";return async o=>{const n=o.userContext._default.request.request,t=n.headers.referer||n.headers.origin||n.hostname,i=H(t)||r,a=o.passwordResetLink.replace(r+"/auth/reset-password",i+(s.config.user.supertokens.resetPasswordPath?s.config.user.supertokens.resetPasswordPath:e));await E({fastify:s,subject:"Reset Password",templateName:"reset-password",to:P.removeTenantPrefix(o.user.email,o.userContext.tenant),templateData:{passwordResetLink:a}})}},V=(s,r)=>async e=>{const o=e.userContext.tenant;if(o){const i=o[R(r.config)];e.thirdPartyUserId=i+"_"+e.thirdPartyUserId}if(!await d.getUserByThirdPartyInfo(e.thirdPartyId,e.thirdPartyUserId,e.userContext)&&r.config.user.features?.signUp===!1)throw{name:"SIGN_UP_DISABLED",message:"SignUp feature is currently disabled",statusCode:404};return await s.thirdPartySignInUp(e)},W=(s,r)=>{const{log:e,config:o}=r;return async n=>{if(n.userContext.tenant=n.options.req.original.tenant,s.thirdPartySignInUpPOST===void 0)throw new Error("Should never come here");const t=await s.thirdPartySignInUpPOST(n);if(t.status==="OK"&&t.createdNewUser){const i=await g.addRoleToUser(t.user.id,o.user.role||"USER");i.status!=="OK"&&e.error(i.status);const{roles:a}=await g.getRolesForUser(t.user.id),u={...t.user,profile:null,roles:a};return{status:"OK",createdNewUser:t.createdNewUser,user:u,session:t.session,authCodeResponse:t.authCodeResponse}}return t}},G=s=>{const{Apple:r,Facebook:e,Github:o,Google:n}=d,t=s.user.supertokens.providers,i=[],a=[{name:"google",initProvider:n},{name:"github",initProvider:o},{name:"facebook",initProvider:e},{name:"apple",initProvider:r}];for(const u of a)t?.[u.name]&&i.push(u.initProvider(t[u.name]));return i},Q=(s,r)=>{const e=s.split("@")?.[1];return e?!!r.includes(e):!1},j=s=>{const{config:r}=s;return{override:{apis:e=>({...e,emailPasswordSignInPOST:M(e,s),emailPasswordSignUpPOST:x(e,s),generatePasswordResetTokenPOST:z(e,s),thirdPartySignInUpPOST:W(e,s)}),functions:e=>({...e,emailPasswordSignIn:A(e,s),emailPasswordSignUp:q(e,s),getUserById:$(e),thirdPartySignInUp:V(e,s)})},signUpFeature:{formFields:[{id:"email",validate:async e=>{const o=/^([\w+.]+)(\w)(@)(\w+)(\.\w+)+$/,n=r.user.supertokens.supportedEmailDomains;if(!o.test(e))return"Email is invalid";if(n&&n.filter(t=>!!t).length!==0&&!Q(e,r.user.supertokens.supportedEmailDomains))return"Unsupported Email Domain"}}]},emailDelivery:{override:e=>({...e,sendEmail:J(s)})},providers:G(r)}},X=s=>{const r=s.config.user.supertokens.recipes;return r&&r.thirdPartyEmailPassword?d.init(r.thirdPartyEmailPassword(s)):d.init(j(s))},Y=()=>({}),Z=s=>{const r=s.config.user.supertokens.recipes;return r&&r.userRoles?g.init(r.userRoles(s)):g.init(Y())},ee=s=>[L(s),X(s),Z(s)],se=s=>{const{config:r}=s;O.init({appInfo:{apiDomain:r.baseUrl,appName:r.appName,websiteDomain:r.appOrigin[0]},recipeList:ee(s),supertokens:{connectionURI:r.user.supertokens.connectionUri}})},re=y(async(s,r,e)=>{const{config:o,log:n}=s;n.info("Registering supertokens plugin"),se(s),s.setErrorHandler(U.errorHandler()),s.register(D,{origin:o.appOrigin,allowedHeaders:["Content-Type","st-auth-mode",...O.getAllCORSHeaders()],credentials:!0}),s.register(b),s.register(U.plugin),n.info("Registering supertokens plugin complete"),s.decorate("verifySession",F.verifySession),e()}),te=async(s,r,e)=>{const{config:o,slonik:n,tenant:t}=r,a=(await h.getSession(r,U.wrapResponse(e),{sessionRequired:!1}))?.getUserId();if(a){const u=new w(o,n),l=await d.getUserById(a,{tenant:t});if(l){let p=null;const{roles:m}=await g.getRolesForUser(a);try{p=await u.findById(a)}catch{}const T={...l,profile:p,roles:m};s.user=T}}},I=y(async(s,r,e)=>{const{mercurius:o}=s.config;await s.register(re),o.enabled&&await s.register(N),e()});I.updateContext=te;const ne={Query:{user:async(s,r,e)=>await new w(e.config,e.database).findById(r.id),users:async(s,r,e)=>await new w(e.config,e.database).list(r.limit,r.offset,r.filters?JSON.parse(JSON.stringify(r.filters)):void 0,r.sort?JSON.parse(JSON.stringify(r.sort)):void 0)}},oe=async(s,r,e)=>{const o="/users";s.get(o,{preHandler:s.verifySession()},async(n,t)=>{const i=new w(n.config,n.slonik),{limit:a,offset:u,filters:l,sort:p}=n.query,m=await i.list(a,u,l?JSON.parse(l):void 0,p?JSON.parse(p):void 0);t.send(m)}),e()};class f{config;database;constructor(r,e){this.config=r,this.database=e}changePassword=async(r,e,o,n)=>{const t=await d.getUserById(r,{tenant:n}),i=/^(?=.*?[a-z]).{8,}$/,a=/^(?=.*?\d).{8,}$/;if(!/^.{8,}$/.test(o))return{status:"FIELD_ERROR",message:"Password must contain at least 8 characters"};if(!i.test(o))return{status:"FIELD_ERROR",message:"Password must contain at least one lower case alphabet"};if(!a.test(o))return{status:"FIELD_ERROR",message:"Password must contain at least one number"};if(e&&o)if(t)if((await d.emailPasswordSignIn(t.email,e,{tenant:n})).status==="OK"){if(await d.updateEmailOrPassword({userId:r,password:o,userContext:{tenant:n}}))return await h.revokeAllSessionsForUser(r),{status:"OK"};throw{status:"FAILED",message:"Oops! Something went wrong, couldn't change password"}}else return{status:"INVALID_PASSWORD",message:"Invalid password"};else throw{status:"NOT_FOUND",message:"User not found"};else return{status:"FIELD_ERROR",message:"Password cannot be empty"}};getUserById=async(r,e)=>{const o=await d.getUserById(r,{tenant:e}),n=new w(this.config,this.database);let t=null;try{t=await n.findById(r)}catch{}const i=await g.getRolesForUser(r);return{email:o?.email,id:r,profile:t,roles:i.roles,timeJoined:o?.timeJoined}}}const ie={Mutation:{changePassword:async(s,r,e)=>{const o=new f(e.config,e.database);try{return e.user?.id?await o.changePassword(e.user?.id,r.oldPassword,r.newPassword,e.tenant):{status:"NOT_FOUND",message:"User not found"}}catch(n){e.app.log.error(n);const t=new v.ErrorWithProps("Oops, Something went wrong");return t.statusCode=500,t}}},Query:{me:async(s,r,e)=>{const o=new f(e.config,e.database);if(e.user?.id)return o.getUserById(e.user.id,e.tenant);{e.app.log.error("Cound not get user id from mercurius context");const n=new v.ErrorWithProps("Oops, Something went wrong");return n.statusCode=500,n}}}},ae=async(s,r,e)=>{const o="/change_password",n="/me";s.post(o,{preHandler:s.verifySession()},async(t,i)=>{try{const a=t.session,u=t.body,l=a&&a.getUserId();if(!l)throw new Error("User not found in session");const p=u.oldPassword??"",m=u.newPassword??"",ce=await new f(t.config,t.slonik).changePassword(l,p,m,t.tenant);i.send(ce)}catch(a){s.log.error(a),i.status(500),i.send({status:"ERROR",message:"Oops! Something went wrong",error:a})}}),s.get(n,{preHandler:s.verifySession()},async(t,i)=>{const a=new f(t.config,t.slonik),u=t.session?.getUserId();if(u)i.send(await a.getUserById(u,t.tenant));else throw s.log.error("Cound not get user id from session"),new Error("Oops, Something went wrong")}),e()};c.UserProfileService=w,c.UserService=f,c.default=I,c.userProfileResolver=ne,c.userProfileRoutes=oe,c.userResolver=ie,c.userRoutes=ae,Object.defineProperties(c,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});
