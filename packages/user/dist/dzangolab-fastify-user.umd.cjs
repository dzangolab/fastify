(function(c,T){typeof exports=="object"&&typeof module<"u"?T(exports,require("fastify-plugin"),require("mercurius"),require("mercurius-auth"),require("supertokens-node/recipe/emailverification"),require("supertokens-node/recipe/session"),require("supertokens-node/lib/build/framework/fastify/framework"),require("supertokens-node"),require("supertokens-node/lib/build/recipe/session/claims"),require("supertokens-node/recipe/userroles"),require("@fastify/cors"),require("@fastify/formbody"),require("supertokens-node/framework/fastify"),require("supertokens-node/recipe/session/framework/fastify"),require("@dzangolab/fastify-slonik"),require("supertokens-node/recipe/thirdpartyemailpassword"),require("humps"),require("slonik"),require("validator"),require("zod"),require("@dzangolab/fastify-graphql")):typeof define=="function"&&define.amd?define(["exports","fastify-plugin","mercurius","mercurius-auth","supertokens-node/recipe/emailverification","supertokens-node/recipe/session","supertokens-node/lib/build/framework/fastify/framework","supertokens-node","supertokens-node/lib/build/recipe/session/claims","supertokens-node/recipe/userroles","@fastify/cors","@fastify/formbody","supertokens-node/framework/fastify","supertokens-node/recipe/session/framework/fastify","@dzangolab/fastify-slonik","supertokens-node/recipe/thirdpartyemailpassword","humps","slonik","validator","zod","@dzangolab/fastify-graphql"],T):(c=typeof globalThis<"u"?globalThis:c||self,T(c.DzangolabFastifyUser={},c.FastifyPlugin,c.Mercurius,c.MercuriusAuth,c.EmailVerification,c.SupertokensSession,c.SupertokensFramework,c.SupertokensNode,c.claims,c.SupertokensUserRoles,c.FastifyCors,c.FastifyFormbody,c.SupertokensFastify,c.SupertokensSessionFastify,c.DzangolabFastifySlonik,c.SupertokensThirdPartyEmailPassword,c.Humps,c.Slonik,c.validator,c.zod,c.DzangolabFastifyGraphql))})(this,function(c,T,p,pe,k,O,Ze,F,xe,S,es,ss,se,rs,E,_,re,h,me,Se,J){"use strict";const W=(s,e)=>(s===void 0&&(s={}),s._default===void 0&&(s._default={}),typeof s._default=="object"&&(s._default.request=new Ze.FastifyRequest(e)),s);class y extends xe.SessionClaim{static defaultMaxAgeInSeconds=void 0;static key="profileValidation";constructor(){super("profileValidation")}addToPayload_internal(e,t,r){return{...e,[this.key]:{v:t,t:Date.now()}}}fetchValue=async(e,t)=>{const r=F.getRequestFromUserContext(t)?.original;if(!r)throw new Error("Request not set in userContext");const n=r.config.user?.features?.profileValidation;if(!n?.enabled)throw new Error("Profile validation is not enabled");const o=r?.user;if(!o)throw new Error("User not found");const a=!(n.fields||[]).some(d=>o[d]===null);return{gracePeriodEndsAt:!a&&n.gracePeriodInDays?o.signedUpAt+n.gracePeriodInDays*(24*60*60*1e3):void 0,isVerified:a}};getLastRefetchTime(e,t){return e[this.key]?.t}getValueFromPayload(e,t){return e[this.key]?.v}removeFromPayload(e,t){const r={...e};return delete r[this.key],r}removeFromPayloadByMerge_internal(e,t){return{...e,[this.key]:null}}validators={isVerified:(e=y.defaultMaxAgeInSeconds,t)=>({claim:this,id:t??this.key,shouldRefetch:()=>!0,validate:async(r,n)=>{const i=this.getValueFromPayload(r,n);return i===void 0?{isValid:!1,reason:{message:"value does not exist",expectedValue:!0,actualValue:void 0}}:i.isVerified!==!0&&(!i.gracePeriodEndsAt||i.gracePeriodEndsAt<=Date.now())?{isValid:!1,reason:{message:"User profile is incomplete",expectedValue:!0,actualValue:i.isVerified}}:{isValid:!0}}})}}const ts=T(async s=>{await s.register(pe,{async applyPolicy(e,t,r,n){if(!n.user)return new p.ErrorWithProps("unauthorized",{},401);if(n.user.disabled)return new p.ErrorWithProps("user is disabled",{},401);if(s.config.user.features?.signUp?.emailVerification&&!await k.isEmailVerified(n.user.id))return new p.ErrorWithProps("invalid claim",{claimValidationErrors:[{id:"st-ev",reason:{message:"wrong value",expectedValue:!0,actualValue:!1}}]},403);if(s.config.user.features?.profileValidation?.enabled&&e.arguments.find(i=>i?.name?.value==="profileValidation")?.value?.value!=!1){const i=n.reply.request,a=new y,u=W(void 0,n.reply.request);await i.session?.fetchAndSetClaim(a,u);try{await i.session?.assertClaims([a.validators.isVerified()],u)}catch(d){if(d instanceof O.Error)return new p.ErrorWithProps("invalid claim",{claimValidationErrors:d.payload},403);throw d}}return!0},authDirective:"auth"})}),we="/signup/token/:token",he=30,fe="/invitations",Ee="/invitations/token/:token",Re="/invitations",ve="/invitations/:id(^\\d+)",Ie="/invitations/token/:token",Oe="/invitations/resend/:id(^\\d+)",Pe="/invitations/revoke/:id(^\\d+)",ye="invitations",_e="/reset-password",V="ADMIN",D="SUPERADMIN",G="USER",Ue="/change_password",te="/signup/admin",ne="/me",Ne="/users",Ae="/users/:id",Te="/users/:id/disable",be="/users/:id/enable",oe="users",Z="/roles",ie="/roles/permissions",Ce="/permissions",ke="REQUIRED",Fe="/verify-email",De="invitations:create",Le="invitations:delete",Ve="invitations:list",$e="invitations:resend",qe="invitations:revoke",Me="users:disable",We="users:enable",Be="users:list",Ke="users:read",ns=async s=>{let e=[];for(const t of s){const r=await S.getPermissionsForRole(t);r.status==="OK"&&(e=[...new Set([...e,...r.permissions])])}return e},ae=async(s,e,t)=>{const r=s.config.user.permissions;if(!r||!r.includes(t))return!0;const{roles:n}=await S.getRolesForUser(e);if(n&&n.includes(D))return!0;const o=await ns(n);return!(!o||!o.includes(t))},os=T(async s=>{await s.register(pe,{applyPolicy:async(e,t,r,n)=>{const o=e.arguments.find(a=>a.name.value==="permission").value.value;return n.user?await ae(n.app,n.user?.id,o)?!0:new p.ErrorWithProps("invalid claim",{claimValidationErrors:[{id:"st-perm",reason:{message:"Not have enough permission",expectedToInclude:o}}]},403):new p.ErrorWithProps("unauthorized",{},401)},authDirective:"hasPermission"})}),is=T(async s=>{s.config.graphql?.enabled&&(await s.register(os),await s.register(ts))}),as=s=>async e=>{const t=e.session?.getUserId();if(!t)throw new O.Error({type:"UNAUTHORISED",message:"unauthorised"});if(!await ae(e.server,t,s))throw new O.Error({type:"INVALID_CLAIMS",message:"Not have enough permission",payload:[{id:S.PermissionClaim.key,reason:{message:"Not have enough permission",expectedToInclude:s}}]})},x=s=>{let e;try{if(e=new URL(s).origin,!e||e==="null")throw new Error("Origin is empty")}catch{e=""}return e},B=async({fastify:s,subject:e,templateData:t={},templateName:r,to:n})=>{const{config:o,log:i,mailer:a}=s;return a.sendMail({subject:e,templateName:r,to:n,templateData:{appName:o.appName,...t}}).catch(u=>{i.error(u.stack)})},cs=(s,e)=>{const t=e.config.appOrigin[0];return async r=>{let n;try{const i=r.userContext._default.request.request,a=i.headers.referer||i.headers.origin||i.hostname;n=x(a)||t}catch{n=t}const o=r.emailVerifyLink.replace(t+"/auth/verify-email",n+(e.config.user.supertokens.emailVerificationPath||Fe));B({fastify:e,subject:"Email Verification",templateName:"email-verification",to:r.user.email,templateData:{emailVerifyLink:o}})}},us=s=>{const{config:e}=s;let t={};return typeof e.user.supertokens.recipes?.emailVerification=="object"&&(t=e.user.supertokens.recipes.emailVerification),{mode:t?.mode||ke,emailDelivery:{override:r=>{let n;return t?.sendEmail&&(n=t.sendEmail),{...r,sendEmail:n?n(r,s):cs(r,s)}}},override:{apis:r=>{const n={};if(t.override?.apis){const o=t.override.apis;let i;for(i in o){const a=o[i];a&&(n[i]=a(r,s))}}return{...r,verifyEmailPOST:async o=>{if(r.verifyEmailPOST===void 0)throw new Error("Should never come here");return o.session?await r.verifyEmailPOST(o):{status:"EMAIL_VERIFICATION_INVALID_TOKEN_ERROR"}},...n}},functions:r=>{const n={};if(t.override?.functions){const o=t.override.functions;let i;for(i in o){const a=o[i];a&&(n[i]=a(r,s))}}return{...r,...n}}}}},ds=s=>{const e=s.config.user.supertokens.recipes?.emailVerification;return typeof e=="function"?k.init(e(s)):k.init(us(s))},ls=(s,e)=>{if(e&&e.length>0){const t=[];for(const r of e){const n=r.direction==="ASC"?h.sql.fragment`ASC`:h.sql.fragment`DESC`;let o;r.key==="roles"&&(o=h.sql.fragment`user_role.role ->> 0`);const i=h.sql.identifier([...s.names,re.decamelize(r.key)]);t.push(h.sql.fragment`${o??i} ${n}`)}return h.sql.fragment`ORDER BY ${h.sql.join(t,h.sql.fragment`,`)}`}return h.sql.fragment``},ce=(s,e)=>{let t=h.sql.fragment`ASC`;return Array.isArray(e)||(e=[]),e.some(r=>r.key==="roles"&&r.direction!="ASC"?(t=h.sql.fragment`DESC`,!0):!1),h.sql.fragment`ORDER BY ${s} ${t}`};class He extends E.DefaultSqlFactory{getFindByIdSql=e=>h.sql.type(this.validationSchema)`
      SELECT
        ${this.getTableFragment()}.*,
        COALESCE(user_role.role, '[]') AS roles
      FROM ${this.getTableFragment()}
      LEFT JOIN LATERAL (
        SELECT jsonb_agg(ur.role ${ce(h.sql.identifier(["ur","role"]))}) AS role
        FROM "public"."st__user_roles" as ur
        WHERE ur.user_id = users.id
      ) AS user_role ON TRUE
      WHERE id = ${e};
    `;getListSql=(e,t,r,n)=>{const o=E.createTableIdentifier(this.table,this.schema);return h.sql.type(this.validationSchema)`
      SELECT
        ${this.getTableFragment()}.*,
        COALESCE(user_role.role, '[]') AS roles
      FROM ${this.getTableFragment()}
      LEFT JOIN LATERAL (
        SELECT jsonb_agg(ur.role ${ce(h.sql.identifier(["ur","role"]),n)}) AS role
        FROM "public"."st__user_roles" as ur
        WHERE ur.user_id = users.id
      ) AS user_role ON TRUE
      ${E.createFilterFragment(r,o)}
      ${ls(o,this.getSortInput(n))}
      ${E.createLimitFragment(e,t)};
    `};getUpdateSql=(e,t)=>{const r=[];for(const n in t){const o=t[n];r.push(h.sql.fragment`${h.sql.identifier([re.decamelize(n)])} = ${o}`)}return h.sql.type(this.validationSchema)`
      UPDATE ${this.getTableFragment()}
      SET ${h.sql.join(r,h.sql.fragment`, `)}
      WHERE id = ${e}
      RETURNING *, (
        SELECT COALESCE(user_role.role, '[]') AS roles
        FROM ${this.getTableFragment()}
        LEFT JOIN LATERAL (
          SELECT jsonb_agg(ur.role ${ce(h.sql.identifier(["ur","role"]))}) AS role
          FROM "public"."st__user_roles" as ur
          WHERE ur.user_id = users.id
        ) AS user_role ON TRUE
        WHERE id = ${e}
      ) as roles;
    `}}const gs=(s,e)=>Se.z.string({required_error:s.required}).refine(t=>me.isEmail(t,e||{}),{message:s.invalid}),je={minLength:8,minLowercase:0,minUppercase:0,minNumbers:0,minSymbols:0,returnScore:!1,pointsPerUnique:1,pointsPerRepeat:.5,pointsForContainingLower:10,pointsForContainingUpper:10,pointsForContainingNumber:10,pointsForContainingSymbol:10},ps=(s,e)=>{const t={...je,...e};return Se.z.string({required_error:s.required}).refine(r=>me.isStrongPassword(r,t),{message:s.weak})},ms=s=>{let e="Password is too weak";if(!s)return e;const t=[];if(s.minLength){const r=s.minLength;t.push(`minimum ${r} ${r>1?"characters":"character"}`)}if(s.minLowercase){const r=s.minLowercase;t.push(`minimum ${r} ${r>1?"lowercases":"lowercase"}`)}if(s.minUppercase){const r=s.minUppercase;t.push(`minimum ${r} ${r>1?"uppercases":"uppercase"}`)}if(s.minNumbers){const r=s.minNumbers;t.push(`minimum ${r} ${r>1?"numbers":"number"}`)}if(s.minSymbols){const r=s.minSymbols;t.push(`minimum ${r} ${r>1?"symbols":"symbol"}`)}if(t.length>0){e="Password should contain ";const r=t.pop();t.length>0&&(e+=t.join(", ")+" and "),e+=r}return e},$=(s,e)=>{const t=e.user.password,r=ps({required:"Password is required",weak:ms({...je,...t})},t).safeParse(s);return r.success?{success:!0}:{message:r.error.issues[0].message,success:!1}};class Je extends E.BaseService{changePassword=async(e,t,r)=>{const n=$(r,this.config);if(!n.success)return{status:"FIELD_ERROR",message:n.message};const o=await _.getUserById(e);if(t&&r)if(o)if((await _.emailPasswordSignIn(o.email,t,{dbSchema:this.schema})).status==="OK"){if(await _.updateEmailOrPassword({userId:e,password:r}))return await O.revokeAllSessionsForUser(e),{status:"OK"};throw{status:"FAILED",message:"Oops! Something went wrong, couldn't change password"}}else return{status:"INVALID_PASSWORD",message:"Invalid password"};else throw{status:"NOT_FOUND",message:"User not found"};else return{status:"FIELD_ERROR",message:"Password cannot be empty"}};get table(){return this.config.user?.table?.name||oe}get factory(){if(!this.table)throw new Error("Service table is not defined");return this._factory||(this._factory=new He(this)),this._factory}}const R=(s,e,t)=>{const r=s.user.services?.user||Je;return new r(s,e,t)},Ss=(s,e)=>async t=>{if(s.createNewSession===void 0)throw new Error("Should never come here");const r=F.getRequestFromUserContext(t.userContext)?.original;if(r){const{config:o,dbSchema:i,slonik:a}=r,d=await R(o,a,i).findById(t.userId)||void 0;if(d?.disabled)throw{name:"SIGN_IN_FAILED",message:"user is disabled",statusCode:401};r.user=d}const n=await s.createNewSession(t);return r?.user&&r?.config.user.features?.profileValidation?.enabled&&await n.fetchAndSetClaim(new y,t.userContext),n},ws=(s,e)=>async t=>{if(s.getGlobalClaimValidators===void 0)throw new Error("Should never come here");const r=F.getRequestFromUserContext(t.userContext)?.original;return r&&r.config.user.features?.profileValidation?.enabled?[...t.claimValidatorsAddedByOtherRecipes,new y().validators.isVerified()]:t.claimValidatorsAddedByOtherRecipes},hs=(s,e)=>async t=>{if(s.getSession===void 0)throw new Error("Should never come here");const{config:r,dbSchema:n,slonik:o}=t.userContext._default.request.request;t.options={checkDatabase:r.user.supertokens.checkSessionInDatabase??!0,...t.options};const i=await s.getSession(t);if(i){const a=i.getUserId(),d=await R(r,o,n).findById(a)||void 0;t.userContext._default.request.request.user=d}return i},fs=(s,e)=>async t=>{if(s.verifySession===void 0)throw new Error("Should never come here");t.verifySessionOptions={checkDatabase:e.config.user.supertokens.checkSessionInDatabase??!0,...t.verifySessionOptions};const r=await s.verifySession(t);if(r&&t.userContext._default.request.request.user?.disabled)throw await r.revokeSession(),{name:"SESSION_VERIFICATION_FAILED",message:"user is disabled",statusCode:401};return r},Es=s=>{const{config:e}=s;let t={};return typeof e.user.supertokens.recipes?.session=="object"&&(t=e.user.supertokens.recipes.session),{...t,getTokenTransferMethod:r=>r.req.getHeaderValue("st-auth-mode")==="header"?"header":"cookie",override:{apis:r=>{const n={};if(t.override?.apis){const o=t.override.apis;let i;for(i in o){const a=o[i];a&&(n[i]=a(r,s))}}return{...r,verifySession:fs(r,s),...n}},functions:r=>{const n={};if(t.override?.functions){const o=t.override.functions;let i;for(i in o){const a=o[i];a&&(n[i]=a(r,s))}}return{...r,createNewSession:Ss(r),...n,getSession:hs(r),getGlobalClaimValidators:ws(r)}},openIdFeature:t.override?.openIdFeature}}},Rs=s=>{const e=s.config.user.supertokens.recipes?.session;return typeof e=="function"?O.init(e(s)):O.init(Es(s))},vs=(s,e)=>async t=>{if(s.appleRedirectHandlerPOST===void 0)throw new Error("Should never come here");const r=t.state,n=JSON.parse(Buffer.from(r,"base64").toString("ascii"));if(n.isAndroid&&n.appId){const i=`intent://callback?${`code=${t.code}&state=${t.state}`}#Intent;package=${n.appId};scheme=signinwithapple;end`;t.options.res.original.redirect(i)}else s.appleRedirectHandlerPOST(t)},Is=(s,e)=>{const{config:t,log:r,slonik:n}=e;return async o=>{const i=await s.emailPasswordSignIn(o);if(i.status!=="OK")return i;const a=R(t,n),u=await a.findById(i.user.id);return u?(u.lastLoginAt=Date.now(),await a.update(u.id,{lastLoginAt:E.formatDate(new Date(u.lastLoginAt))}).catch(l=>{r.error(`Unable to update lastLoginAt for userId ${i.user.id}`),r.error(l)}),{status:"OK",user:{...i.user,...u}}):(r.error(`User record not found for userId ${i.user.id}`),{status:"WRONG_CREDENTIALS_ERROR"})}},Ge=async s=>{const e=await k.createEmailVerificationToken(s);e.status==="OK"&&await k.verifyEmailUsingToken(e.token)},ue=async s=>{const{roles:e}=await S.getAllRoles();return s.every(t=>e.includes(t))},Os=(s,e)=>{const{config:t,log:r,slonik:n}=e;return async o=>{const i=o.userContext.roles||[];if(!await ue(i))throw r.error(`At least one role from ${i.join(", ")} does not exist.`),{name:"SIGN_UP_FAILED",message:"Something went wrong",statusCode:500};const a=await s.emailPasswordSignUp(o);if(a.status==="OK"){const u=R(t,n);let d;try{if(d=await u.create({id:a.user.id,email:a.user.email}),!d)throw new Error("User not found")}catch(l){throw r.error("Error while creating user"),r.error(l),await F.deleteUser(a.user.id),{name:"SIGN_UP_FAILED",message:"Something went wrong",statusCode:500}}d.roles=i,a.user={...a.user,...d};for(const l of i){const g=await S.addRoleToUser(a.user.id,l);g.status!=="OK"&&r.error(g.status)}if(t.user.features?.signUp?.emailVerification)try{if(o.userContext.autoVerifyEmail)await Ge(d.id);else{const l=await k.createEmailVerificationToken(a.user.id);l.status==="OK"&&await k.sendEmail({type:"EMAIL_VERIFICATION",user:a.user,emailVerifyLink:`${t.appOrigin[0]}/auth/verify-email?token=${l.token}&rid=emailverification`,userContext:o.userContext})}}catch(l){r.error(l)}}if(t.user.supertokens.sendUserAlreadyExistsWarning&&a.status==="EMAIL_ALREADY_EXISTS_ERROR")try{B({fastify:e,subject:"Duplicate Email Registration",templateData:{emailId:o.email},templateName:"duplicate-email-warning",to:o.email})}catch(u){r.error(u)}return a}},Ps=(s,e)=>async t=>{if(t.userContext.roles=[e.config.user.role||G],s.emailPasswordSignUpPOST===void 0)throw new Error("Should never come here");if(e.config.user.features?.signUp?.enabled===!1)throw{name:"SIGN_UP_DISABLED",message:"SignUp feature is currently disabled",statusCode:404};const r=await s.emailPasswordSignUpPOST(t);return r.status==="OK"?{status:"OK",user:r.user,session:r.session}:r},L=(s,e)=>{const t=gs({invalid:"Email is invalid",required:"Email is required"},e.user.email).safeParse(s);return t.success?{success:!0}:{message:t.error.issues[0].message,success:!1}},ys=s=>[{id:"email",validate:async e=>{const t=L(e,s);if(!t.success)return t.message}},{id:"password",validate:async e=>{const t=$(e,s);if(!t.success)return t.message}}],_s=s=>{let e=[];if(typeof s.user.supertokens?.recipes?.thirdPartyEmailPassword=="object"){const r=s.user.supertokens?.recipes?.thirdPartyEmailPassword.signUpFeature?.formFields;r&&(e=[...r])}const t=new Set(e.map(r=>r.id));for(const r of ys(s))t.has(r.id)||e.push(r);return e},Us=(s,e)=>async t=>{const r=await s.resetPasswordUsingToken(t);if(r.status==="OK"&&r.userId){const n=await _.getUserById(r.userId);n&&B({fastify:e,subject:"Reset Password Notification",templateName:"reset-password-notification",to:n.email,templateData:{emailId:n.email}})}return r},Ns=(s,e)=>{const t=e.config.appOrigin[0];return async r=>{const n=r.userContext._default.request.request;let o;if(n.query.appId){const d=Number(n.query.appId);o=e.config.apps?.find(l=>l.id===d)}const i=o?.origin||n.headers.referer||n.headers.origin||n.hostname,a=x(i)||t,u=r.passwordResetLink.replace(t+"/auth/reset-password",a+(e.config.user.supertokens.resetPasswordPath||_e));B({fastify:e,subject:"Reset Password",templateName:"reset-password",to:r.user.email,templateData:{passwordResetLink:u}})}},As=(s,e)=>{const{config:t,log:r,slonik:n}=e;return async o=>{const i=o.userContext.roles||[];if(!await _.getUserByThirdPartyInfo(o.thirdPartyId,o.thirdPartyUserId,o.userContext)&&t.user.features?.signUp?.enabled===!1)throw{name:"SIGN_UP_DISABLED",message:"SignUp feature is currently disabled",statusCode:404};const u=await s.thirdPartySignInUp(o),d=R(t,n,o.userContext._default.request.request.dbSchema);if(u.createdNewUser){if(!await ue(i))throw await F.deleteUser(u.user.id),r.error(`At least one role from ${i.join(", ")} does not exist.`),{name:"SIGN_UP_FAILED",message:"Something went wrong",statusCode:500};for(const g of i){const m=await S.addRoleToUser(u.user.id,g);m.status!=="OK"&&r.error(m.status)}let l;try{if(l=await d.create({id:u.user.id,email:u.user.email}),!l)throw new Error("User not found")}catch(g){throw r.error("Error while creating user"),r.error(g),await F.deleteUser(u.user.id),{name:"SIGN_UP_FAILED",message:"Something went wrong",statusCode:500}}}else await d.update(u.user.id,{lastLoginAt:E.formatDate(new Date(Date.now()))}).catch(l=>{r.error(`Unable to update lastLoginAt for userId ${u.user.id}`),r.error(l)});return u}},Ts=(s,e)=>{const{config:t,log:r,slonik:n}=e;return async o=>{if(o.userContext.roles=[t.user.role||G],s.thirdPartySignInUpPOST===void 0)throw new Error("Should never come here");const i=await s.thirdPartySignInUpPOST(o);if(i.status==="OK"){const u=await R(t,n,o.userContext._default.request.request.dbSchema).findById(i.user.id);return u?{...i,user:{...i.user,...u}}:(r.error(`User record not found for userId ${i.user.id}`),{status:"GENERAL_ERROR",message:"Something went wrong"})}return i}},bs=s=>{const{Apple:e,Facebook:t,Github:r,Google:n}=_,o=s.user.supertokens.providers,i=[],a=[{name:"google",initProvider:n},{name:"github",initProvider:r},{name:"facebook",initProvider:t},{name:"apple",initProvider:e}];for(const d of a)if(o?.[d.name])if(d.name==="apple"){const l=o[d.name];if(l)for(const g of l)i.push(d.initProvider(g))}else i.push(d.initProvider(o[d.name]));const u=o?.custom;if(u)for(const d of u)i.push(d);return i},Cs=s=>{const{config:e}=s;let t={};return typeof e.user.supertokens.recipes?.thirdPartyEmailPassword=="object"&&(t=e.user.supertokens.recipes.thirdPartyEmailPassword),{override:{apis:r=>{const n={};if(t.override?.apis){const o=t.override.apis;let i;for(i in o){const a=o[i];a&&(n[i]=a(r,s))}}return{...r,emailPasswordSignUpPOST:Ps(r,s),thirdPartySignInUpPOST:Ts(r,s),appleRedirectHandlerPOST:vs(r),...n}},functions:r=>{const n={};if(t.override?.functions){const o=t.override.functions;let i;for(i in o){const a=o[i];a&&(n[i]=a(r,s))}}return{...r,emailPasswordSignIn:Is(r,s),emailPasswordSignUp:Os(r,s),resetPasswordUsingToken:Us(r,s),thirdPartySignInUp:As(r,s),...n}}},signUpFeature:{formFields:_s(e)},emailDelivery:{override:r=>{let n;return t?.sendEmail&&(n=t.sendEmail),{...r,sendEmail:n?n(r,s):Ns(r,s)}}},providers:bs(e)}},ks=s=>{const e=s.config.user.supertokens.recipes?.thirdPartyEmailPassword;return typeof e=="function"?_.init(e(s)):_.init(Cs(s))},Fs=()=>({}),Ds=s=>{const e=s.config.user.supertokens.recipes;return e&&e.userRoles?S.init(e.userRoles(s)):S.init(Fs())},Ls=s=>{const e=[Rs(s),ks(s),Ds(s)];return s.config.user.features?.signUp?.emailVerification&&e.push(ds(s)),e},Vs=s=>{const{config:e}=s;F.init({appInfo:{apiDomain:e.baseUrl,appName:e.appName,websiteDomain:e.appOrigin[0]},framework:"fastify",recipeList:Ls(s),supertokens:{connectionURI:e.user.supertokens.connectionUri}})},$s=T(async(s,e,t)=>{const{config:r,log:n}=s;n.info("Registering supertokens plugin"),Vs(s),s.setErrorHandler(se.errorHandler()),await s.register(es,{origin:r.appOrigin,allowedHeaders:["Content-Type","st-auth-mode",...F.getAllCORSHeaders()],credentials:!0}),await s.register(ss),await s.register(se.plugin),n.info("Registering supertokens plugin complete"),s.decorate("verifySession",rs.verifySession),s.addHook("onSend",async(o,i)=>{const a=o.server.config.user.supertokens.refreshTokenCookiePath,u=i.getHeader("set-cookie");if(u&&a){const l=(Array.isArray(u)?u:[u]).map(g=>String(g).startsWith("sRefreshToken")?String(g).replace(/Path=\/[^;]*/i,`Path=${a}`):g);i.removeHeader("set-cookie"),i.header("set-cookie",l)}}),t()}),qs=async(s,e,t)=>{try{e.session=await O.getSession(e,se.wrapResponse(t),{sessionRequired:!1,overrideGlobalClaimValidators:async r=>r.filter(n=>![k.EmailVerificationClaim.key,y.key].includes(n.id))})}catch(r){if(!O.Error.isErrorFromSuperTokens(r))throw r}s.user=e.user,s.roles=e.user?.roles},ze=T(async(s,e,t)=>{const{graphql:r}=s.config;await s.register($s),s.decorate("hasPermission",as),r?.enabled&&await s.register(is),t()});ze.updateContext=qs;const Ms=new Set(["id","disable","enable","email","lastLoginAt","roles","signedUpAt"]),Qe=s=>{for(const e of Object.keys(s))Ms.has(re.camelize(e))&&delete s[e]},Ws={Mutation:{adminSignUp:async(s,e,t)=>{const{app:r,config:n,reply:o}=t;try{const{email:i,password:a}=e.data,u=await S.getUsersThatHaveRole(V),d=await S.getUsersThatHaveRole(D);let l;if(u.status==="UNKNOWN_ROLE_ERROR"&&d.status==="UNKNOWN_ROLE_ERROR"?l=u.status:(u.status==="OK"&&u.users.length>0||d.status==="OK"&&d.users.length>0)&&(l="First admin user already exists"),l)return new p.ErrorWithProps(l);const g=L(i,n);if(!g.success&&g.message)return new p.ErrorWithProps(g.message);const m=$(a,n);if(!m.success&&m.message)return new p.ErrorWithProps(m.message);const w=await _.emailPasswordSignUp(i,a,{autoVerifyEmail:!0,roles:[V,...d.status==="OK"?[D]:[]],_default:{request:{request:o.request}}});return w.status!=="OK"?new p.ErrorWithProps(w.status):(await O.createNewSession(o.request,o,w.user.id),w)}catch(i){r.log.error(i);const a=new p.ErrorWithProps("Oops, Something went wrong");return a.statusCode=500,a}},disableUser:async(s,e,t)=>{const{id:r}=e;if(t.user?.id===r){const i=new p.ErrorWithProps("you cannot disable yourself");return i.statusCode=409,i}return await R(t.config,t.database,t.dbSchema).update(r,{disabled:!0})?{status:"OK"}:new p.ErrorWithProps(`user id ${r} not found`,{},404)},enableUser:async(s,e,t)=>{const{id:r}=e;return await R(t.config,t.database,t.dbSchema).update(r,{disabled:!1})?{status:"OK"}:new p.ErrorWithProps(`user id ${r} not found`,{},404)},changePassword:async(s,e,t)=>{const{app:r,config:n,database:o,dbSchema:i,reply:a,user:u}=t,d=R(n,o,i);try{if(u){const l=await d.changePassword(u.id,e.oldPassword,e.newPassword);return l.status==="OK"&&await O.createNewSession(a.request,a,u.id),l}else return{status:"NOT_FOUND",message:"User not found"}}catch(l){r.log.error(l);const g=new p.ErrorWithProps("Oops, Something went wrong");return g.statusCode=500,g}},updateMe:async(s,e,t)=>{const{data:r}=e,n=R(t.config,t.database,t.dbSchema);try{if(t.user?.id){Qe(r);const o=await n.update(t.user.id,r),i=t.reply.request;return i.user=o,t.config.user.features?.profileValidation?.enabled&&await i.session?.fetchAndSetClaim(new y,W(void 0,i)),o}else return{status:"NOT_FOUND",message:"User not found"}}catch(o){t.app.log.error(o);const i=new p.ErrorWithProps("Oops, Something went wrong");return i.statusCode=500,i}}},Query:{canAdminSignUp:async(s,e,t)=>{const{app:r}=t;try{const n=await S.getUsersThatHaveRole(V),o=await S.getUsersThatHaveRole(D);return n.status==="UNKNOWN_ROLE_ERROR"&&o.status==="UNKNOWN_ROLE_ERROR"?new p.ErrorWithProps(n.status):n.status==="OK"&&n.users.length>0||o.status==="OK"&&o.users.length>0?{signUp:!1}:{signUp:!0}}catch(n){r.log.error(n);const o=new p.ErrorWithProps("Oops! Something went wrong");return o.statusCode=500,o}},me:async(s,e,t)=>{if(t.user)return t.user;{t.app.log.error("Could not able to get user from mercurius context");const r=new p.ErrorWithProps("Oops, Something went wrong");return r.statusCode=500,r}},user:async(s,e,t)=>{const n=await R(t.config,t.database,t.dbSchema).findById(e.id);if(t.config.user.features?.profileValidation?.enabled){const o=t.reply.request;await o.session?.fetchAndSetClaim(new y,W(void 0,o))}return n},users:async(s,e,t)=>await R(t.config,t.database,t.dbSchema).list(e.limit,e.offset,e.filters?JSON.parse(JSON.stringify(e.filters)):void 0,e.sort?JSON.parse(JSON.stringify(e.sort)):void 0)}},b={adminSignUp:async(s,e)=>{const{body:t,config:r,log:n}=s;try{const{email:o,password:i}=t,a=await S.getUsersThatHaveRole(V),u=await S.getUsersThatHaveRole(D);if(a.status==="UNKNOWN_ROLE_ERROR"&&u.status==="UNKNOWN_ROLE_ERROR")return e.send({status:"ERROR",message:a.status});if(a.status==="OK"&&a.users.length>0||u.status==="OK"&&u.users.length>0)return e.send({status:"ERROR",message:"First admin user already exists"});const d=L(o,r);if(!d.success)return e.send({status:"ERROR",message:d.message});const l=$(i,r);if(!l.success)return e.send({status:"ERROR",message:l.message});const g=await _.emailPasswordSignUp(o,i,{autoVerifyEmail:!0,roles:[V,...u.status==="OK"?[D]:[]],_default:{request:{request:s}}});if(g.status!=="OK")return e.send(g);await O.createNewSession(s,e,g.user.id),e.send(g)}catch(o){n.error(o),e.status(500),e.send({status:"ERROR",message:"Oops! Something went wrong"})}},canAdminSignUp:async(s,e)=>{const{log:t}=s;try{const r=await S.getUsersThatHaveRole(V),n=await S.getUsersThatHaveRole(D);if(r.status==="UNKNOWN_ROLE_ERROR"&&n.status==="UNKNOWN_ROLE_ERROR")return e.send({status:"ERROR",message:r.status});if(r.status==="OK"&&r.users.length>0||n.status==="OK"&&n.users.length>0)return e.send({signUp:!1});e.send({signUp:!0})}catch(r){t.error(r),e.status(500),e.send({status:"ERROR",message:"Oops! Something went wrong"})}},changePassword:async(s,e)=>{try{const t=s.session,r=s.body,n=t&&t.getUserId();if(!n)throw new Error("User not found in session");const o=r.oldPassword??"",i=r.newPassword??"",u=await R(s.config,s.slonik,s.dbSchema).changePassword(n,o,i);u.status==="OK"&&await O.createNewSession(s,e,n),e.send(u)}catch(t){s.log.error(t),e.status(500),e.send({status:"ERROR",message:"Oops! Something went wrong",error:t})}},disable:async(s,e)=>{if(s.session){const{id:t}=s.params;return s.session.getUserId()===t?(e.status(409),await e.send({message:"you cannot disable yourself"})):await R(s.config,s.slonik,s.dbSchema).update(t,{disabled:!0})?await e.send({status:"OK"}):(e.status(404),await e.send({message:`user id ${t} not found`}))}else throw s.log.error("could not get session"),new Error("Oops, Something went wrong")},enable:async(s,e)=>{if(s.session){const{id:t}=s.params;return await R(s.config,s.slonik,s.dbSchema).update(t,{disabled:!1})?await e.send({status:"OK"}):(e.status(404),await e.send({message:`user id ${t} not found`}))}else throw s.log.error("could not get session"),new Error("Oops, Something went wrong")},me:async(s,e)=>{if(s.user)s.config.user.features?.profileValidation?.enabled&&await s.session?.fetchAndSetClaim(new y,W(void 0,s)),e.send(s.user);else throw s.log.error("Could not able to get user from session"),new Error("Oops, Something went wrong")},updateMe:async(s,e)=>{const t=s.session?.getUserId(),r=s.body;if(t){const n=R(s.config,s.slonik,s.dbSchema);Qe(r);const o=await n.update(t,r);s.user=o,s.config.user.features?.profileValidation?.enabled&&await s.session?.fetchAndSetClaim(new y,W(void 0,s)),e.send(o)}else throw s.log.error("could not get user id from session"),new Error("Oops, Something went wrong")},user:async(s,e)=>{const t=R(s.config,s.slonik,s.dbSchema),{id:r}=s.params,n=await t.findById(r);e.send(n)},users:async(s,e)=>{const t=R(s.config,s.slonik,s.dbSchema),{limit:r,offset:n,filters:o,sort:i}=s.query,a=await t.list(r,n,o?JSON.parse(o):void 0,i?JSON.parse(i):void 0);e.send(a)}},Bs=async(s,e,t)=>{const r=s.config.user.handlers?.user;s.get(Ne,{preHandler:[s.verifySession(),s.hasPermission(Be)]},r?.users||b.users),s.get(Ae,{preHandler:[s.verifySession(),s.hasPermission(Ke)]},r?.user||b.user),s.post(Ue,{preHandler:s.verifySession()},r?.changePassword||b.changePassword),s.get(ne,{preHandler:s.verifySession({overrideGlobalClaimValidators:async n=>n.filter(o=>o.id!==y.key)})},r?.me||b.me),s.put(ne,{preHandler:s.verifySession({overrideGlobalClaimValidators:async n=>n.filter(o=>o.id!==y.key)})},r?.updateMe||b.updateMe),s.put(Te,{preHandler:[s.verifySession(),s.hasPermission(Me)]},r?.disable||b.disable),s.put(be,{preHandler:[s.verifySession(),s.hasPermission(We)]},r?.enable||b.enable),s.post(te,r?.adminSignUp||b.adminSignUp),s.get(te,r?.canAdminSignUp||b.canAdminSignUp),t()},de=(s,e)=>e||E.formatDate(new Date(Date.now()+(s.user.invitation?.expireAfterInDays??he)*(24*60*60*1e3)));class Ye extends E.DefaultSqlFactory{getFindByTokenSql=e=>h.sql.type(this.validationSchema)`
      SELECT *
      FROM ${this.getTableFragment()}
      WHERE token = ${e};
    `;getListSql=(e,t,r,n)=>{const o=E.createTableIdentifier(this.table,this.schema),i=E.createTableFragment(this.config.user.table?.name||oe,this.schema);return h.sql.type(this.validationSchema)`
      SELECT ${this.getTableFragment()}.*, ROW_TO_JSON("user") as "invited_by"
      FROM ${this.getTableFragment()}
      join ${i} "user" on ${this.getTableFragment()}."invited_by_id" = "user"."id"
      ${E.createFilterFragment(r,o)}
      ${E.createSortFragment(o,this.getSortInput(n))}
      ${E.createLimitFragment(e,t)};
    `}}class le extends E.BaseService{static TABLE=ye;create=async e=>{const t={AND:[{key:"email",operator:"eq",value:e.email},{key:"acceptedAt",operator:"eq",value:"null"},{key:"expiresAt",operator:"gt",value:E.formatDate(new Date)},{key:"revokedAt",operator:"eq",value:"null"}]};if(await this.count(t)>0)throw new Error("Invitation already exist");const n=this.factory.getCreateSql(e),o=await this.database.connect(async i=>i.query(n).then(a=>a.rows[0]));return o?this.postCreate(o):void 0};findByToken=async e=>{if(!this.validateUUID(e))return null;const t=this.factory.getFindByTokenSql(e);return await this.database.connect(n=>n.maybeOne(t))};get factory(){if(!this.table)throw new Error("Service table is not defined");return this._factory||(this._factory=new Ye(this)),this._factory}validateUUID=e=>/^[\da-f]{8}(?:\b-[\da-f]{4}){3}\b-[\da-f]{12}$/gi.test(e)}const P=(s,e,t)=>{const r=s.user.services?.invitation||le;return new r(s,e,t)},z=s=>!(s.acceptedAt||s.revokedAt||Date.now()>s.expiresAt),Ks=(s,e,t)=>{const{token:r}=e;let n=s.user.invitation?.acceptLinkPath||we;return n=n.replace(/:token(?!\w)/g,r),new URL(n,t).href},Q=async(s,e,t)=>{const{config:r,log:n}=s,o=r.apps?.find(i=>i.id===e.appId)?.origin||x(t||"")||r.appOrigin[0];o?B({fastify:s,subject:"Invitation for Sign Up",templateData:{invitationLink:Ks(r,e,o)},templateName:"user-invitation",to:e.email}):n.error(`Could not send email for invitation ID ${e.id}`)},Hs={Mutation:{acceptInvitation:async(s,e,t)=>{const{app:r,config:n,database:o,dbSchema:i,reply:a}=t,{token:u,data:d}=e;try{const{email:l,password:g}=d,m=L(l,n);if(!m.success&&m.message)return new p.ErrorWithProps(m.message);const w=$(g,n);if(!w.success&&w.message)return new p.ErrorWithProps(w.message);const f=P(n,o,i),v=await f.findByToken(u);if(!v||!z(v))return new p.ErrorWithProps("Invitation is invalid or has expired");if(v.email!=l)return new p.ErrorWithProps("Email do not match with the invitation");const N=await _.emailPasswordSignUp(l,g,{roles:[v.role],autoVerifyEmail:!0});if(N.status!=="OK")return N;await f.update(v.id,{acceptedAt:E.formatDate(new Date(Date.now()))});try{await n.user.invitation?.postAccept?.(a.request,v,N.user)}catch(C){r.log.error(C)}return await O.createNewSession(a.request,a,N.user.id),{...N,user:{...N.user,roles:[v.role]}}}catch(l){r.log.error(l);const g=new p.ErrorWithProps("Oops! Something went wrong");return g.statusCode=500,g}},createInvitation:async(s,e,t)=>{const{app:r,config:n,database:o,dbSchema:i,reply:a,user:u}=t;try{if(!u)throw new Error("User not found in session");const{appId:d,email:l,expiresAt:g,payload:m,role:w}=e.data,f=L(l,n);if(!f.success&&f.message)return new p.ErrorWithProps(f.message);const v=R(n,o,i),N={key:"email",operator:"eq",value:l};if(await v.count(N)>0)return new p.ErrorWithProps(`User with email ${l} already exists`);const ge=P(n,o,i),M={email:l,expiresAt:de(n,g),invitedById:u.id,role:w||n.user.role||G},ee=n.apps?.find(I=>I.id==d);if(ee)if(ee.supportedRoles.includes(M.role))M.appId=d;else return new p.ErrorWithProps(`App ${ee.name} does not support role ${M.role}`);Object.keys(m||{}).length>0&&(M.payload=JSON.stringify(m));let K;try{K=await ge.create(M)}catch(I){return new p.ErrorWithProps(I.message)}if(K){try{const{headers:I,hostname:H}=a.request,j=I.referer||I.origin||H;Q(r,K,j)}catch(I){r.log.error(I)}return K}}catch(d){r.log.error(d);const l=new p.ErrorWithProps("Oops, Something went wrong");return l.statusCode=500,l}},resendInvitation:async(s,e,t)=>{const{app:r,config:n,database:o,dbSchema:i,reply:a}=t,d=await P(n,o,i).findById(e.id);if(!d||!z(d))return new p.ErrorWithProps("Invitation is invalid or has expired");const{headers:l,hostname:g}=a.request,m=l.referer||l.origin||g;try{Q(r,d,m)}catch(w){r.log.error(w)}return d},revokeInvitation:async(s,e,t)=>{const r=P(t.config,t.database,t.dbSchema);let n=await r.findById(e.id),o;return n?n.acceptedAt?o="Invitation is already accepted":Date.now()>n.expiresAt?o="Invitation is expired":n.revokedAt&&(o="Invitation is already revoked"):o="Invitation not found",o?new p.ErrorWithProps(o):(n=await r.update(e.id,{revokedAt:E.formatDate(new Date(Date.now()))}),n)},deleteInvitation:async(s,e,t)=>{const n=await P(t.config,t.database,t.dbSchema).delete(e.id);let o;return n||(o="Invitation not found"),o?new p.ErrorWithProps(o):n}},Query:{getInvitationByToken:async(s,e,t)=>{try{return await P(t.config,t.database,t.dbSchema).findByToken(e.token)}catch(r){t.app.log.error(r);const n=new p.ErrorWithProps("Oops, Something went wrong");return n.statusCode=500,n}},invitations:async(s,e,t)=>await P(t.config,t.database,t.dbSchema).list(e.limit,e.offset,e.filters?JSON.parse(JSON.stringify(e.filters)):void 0,e.sort?JSON.parse(JSON.stringify(e.sort)):void 0)}},q={acceptInvitation:async(s,e)=>{const{body:t,config:r,dbSchema:n,log:o,params:i,slonik:a}=s,{token:u}=i;try{const{email:d,password:l}=t,g=L(d,r);if(!g.success)return e.send({status:"ERROR",message:g.message});const m=$(l,r);if(!m.success)return e.send({status:"ERROR",message:m.message});const w=P(r,a,n),f=await w.findByToken(u);if(!f||!z(f))return e.send({status:"ERROR",message:"Invitation is invalid or has expired"});if(f.email!=d)return e.send({status:"ERROR",message:"Email do not match with the invitation"});const v=await _.emailPasswordSignUp(d,l,{roles:[f.role],autoVerifyEmail:!0});if(v.status!=="OK")return e.send(v);await w.update(f.id,{acceptedAt:E.formatDate(new Date(Date.now()))});try{await r.user.invitation?.postAccept?.(s,f,v.user)}catch(N){o.error(N)}await O.createNewSession(s,e,v.user.id),e.send({...v,user:{...v.user,roles:[f.role]}})}catch(d){o.error(d),e.status(500),e.send({status:"ERROR",message:"Oops! Something went wrong"})}},createInvitation:async(s,e)=>{const{body:t,config:r,dbSchema:n,headers:o,hostname:i,log:a,server:u,session:d,slonik:l}=s;try{const g=d&&d.getUserId();if(!g)throw new Error("User not found in session");const{appId:m,email:w,expiresAt:f,payload:v,role:N}=t,C=L(w,r);if(!C.success)return e.send({status:"ERROR",message:C.message});const ge=R(r,l,n),M={key:"email",operator:"eq",value:w};if(await ge.count(M)>0)return e.send({status:"ERROR",message:`User with email ${w} already exists`});const K=P(r,l,n),I={email:w,expiresAt:de(r,f),invitedById:g,role:N||r.user.role||G},H=r.apps?.find(X=>X.id==m);if(H)if(H.supportedRoles.includes(I.role))I.appId=m;else return e.send({status:"ERROR",message:`App ${H.name} does not support role ${I.role}`});Object.keys(v||{}).length>0&&(I.payload=JSON.stringify(v));let j;try{j=await K.create(I)}catch(X){return e.send({status:"ERROR",message:X.message})}if(j){const X=o.referer||o.origin||i;try{Q(u,j,X)}catch(rr){a.error(rr)}const Xe=j;delete Xe.token,e.send(Xe)}}catch(g){a.error(g),e.status(500),e.send({status:"ERROR",message:"Oops! Something went wrong"})}},deleteInvitation:async(s,e)=>{const{config:t,dbSchema:r,log:n,params:o,slonik:i}=s;try{const{id:a}=o,d=await new le(t,i,r).delete(a);if(!d)return e.send({status:"error",message:"Invitation not found"});const l=d;delete l.token,e.send(l)}catch(a){n.error(a),e.status(500),e.send({status:"ERROR",message:"Oops! Something went wrong"})}},getInvitationByToken:async(s,e)=>{const{config:t,dbSchema:r,log:n,params:o,slonik:i}=s,{token:a}=o;try{const d=await P(t,i,r).findByToken(a);e.send(d)}catch(u){n.error(u),e.status(500),e.send({status:"ERROR",message:"Oops! Something went wrong"})}},listInvitation:async(s,e)=>{const{config:t,dbSchema:r,log:n,query:o,slonik:i}=s;try{const{limit:a,offset:u,filters:d,sort:l}=o,m=await P(t,i,r).list(a,u,d?JSON.parse(d):void 0,l?JSON.parse(l):void 0);for(const w of m.data)delete w.token;e.send(m)}catch(a){n.error(a),e.status(500),e.send({status:"ERROR",message:"Oops! Something went wrong"})}},resendInvitation:async(s,e)=>{const{config:t,dbSchema:r,headers:n,hostname:o,log:i,params:a,slonik:u,server:d}=s;try{const{id:l}=a,m=await P(t,u,r).findById(l);if(!m||!z(m))return e.send({status:"ERROR",message:"Invitation is invalid or has expired"});const w=n.referer||n.origin||o;try{Q(d,m,w)}catch(v){i.error(v)}const f=m;delete f.token,e.send(f)}catch(l){i.error(l),e.status(500),e.send({status:"ERROR",message:"Oops! Something went wrong"})}},revokeInvitation:async(s,e)=>{const{config:t,dbSchema:r,log:n,params:o,slonik:i}=s;try{const{id:a}=o,u=P(t,i,r);let d=await u.findById(a);if(d){if(d.acceptedAt)return e.send({status:"error",message:"Invitation is already accepted"});if(Date.now()>d.expiresAt)return e.send({status:"error",message:"Invitation is expired"});if(d.revokedAt)return e.send({status:"error",message:"Invitation is already revoked"})}else return e.send({status:"error",message:"Invitation not found"});d=await u.update(a,{revokedAt:E.formatDate(new Date(Date.now()))});const l=d;delete l.token,e.send(l)}catch(a){n.error(a),e.status(500),e.send({status:"ERROR",message:"Oops! Something went wrong"})}}},js=async(s,e,t)=>{const r=s.config.user.handlers?.invitation;s.get(fe,{preHandler:[s.verifySession(),s.hasPermission(Ve)]},r?.list||q.listInvitation),s.post(Re,{preHandler:[s.verifySession(),s.hasPermission(De)]},r?.create||q.createInvitation),s.get(Ie,r?.getByToken||q.getInvitationByToken),s.post(Ee,r?.accept||q.acceptInvitation),s.put(Pe,{preHandler:[s.verifySession(),s.hasPermission(qe)]},r?.revoke||q.revokeInvitation),s.post(Oe,{preHandler:[s.verifySession(),s.hasPermission($e)]},r?.resend||q.resendInvitation),s.delete(ve,{preHandler:[s.verifySession(),s.hasPermission(Le)]},r?.delete||q.deleteInvitation),t()},Js={Query:{permissions:async(s,e,t)=>{const{app:r,config:n}=t;try{return n.user.permissions||[]}catch(o){r.log.error(o);const i=new p.ErrorWithProps("Oops, Something went wrong");return i.statusCode=500,i}}}},Gs={getPermissions:async(s,e)=>{const{config:t,log:r}=s;try{const n=t.user.permissions||[];e.send({permissions:n})}catch(n){r.error(n),e.status(500),e.send({status:"ERROR",message:"Oops! Something went wrong"})}}},zs=async(s,e,t)=>{s.get(Ce,{preHandler:[s.verifySession()]},Gs.getPermissions),t()};class U extends Error{statusCode;constructor({message:e,name:t,statusCode:r}){super(e),this.message=e,this.name=t,this.statusCode=r}}class A{createRole=async(e,t)=>{const{roles:r}=await S.getAllRoles(e);if(r.includes(e))throw new U({name:"ROLE_ALREADY_EXISTS",message:"Unable to create role as it already exists",statusCode:422});return{status:(await S.createNewRoleOrAddPermissions(e,t||[])).status}};deleteRole=async e=>{const t=await S.getUsersThatHaveRole(e);if(t.status==="UNKNOWN_ROLE_ERROR")throw new U({name:t.status,message:"Invalid role",statusCode:422});if(t.users.length>0)throw new U({name:"ROLE_IN_USE",message:"The role is currently assigned to one or more users and cannot be deleted",statusCode:422});return{status:(await S.deleteRole(e)).status}};getPermissionsForRole=async e=>{let t=[];const r=await S.getPermissionsForRole(e);return r.status==="OK"&&(t=r.permissions),t};getRoles=async()=>{let e=[];const t=await S.getAllRoles();return t.status==="OK"&&(e=await Promise.all(t.roles.map(async r=>{const n=await S.getPermissionsForRole(r);return{role:r,permissions:n.status==="OK"?n.permissions:[]}}))),e};updateRolePermissions=async(e,t)=>{const r=await S.getPermissionsForRole(e);if(r.status==="UNKNOWN_ROLE_ERROR")throw new U({name:"UNKNOWN_ROLE_ERROR",message:"Invalid role",statusCode:422});const n=r.permissions,o=t.filter(u=>!n.includes(u)),i=n.filter(u=>!t.includes(u));return await S.removePermissionsFromRole(e,i),await S.createNewRoleOrAddPermissions(e,o),{status:"OK",permissions:await this.getPermissionsForRole(e)}}}const Qs={Mutation:{createRole:async(s,e,t)=>{const{app:r}=t;try{return await new A().createRole(e.role,e.permissions)}catch(n){if(n instanceof U){const i=new p.ErrorWithProps(n.name);return i.statusCode=n.statusCode,i}r.log.error(n);const o=new p.ErrorWithProps("Oops, Something went wrong");return o.statusCode=500,o}},deleteRole:async(s,e,t)=>{const{app:r}=t;try{const n=new A,{role:o}=e;return await n.deleteRole(o)}catch(n){if(n instanceof U){const i=new p.ErrorWithProps(n.name);return i.statusCode=n.statusCode,i}r.log.error(n);const o=new p.ErrorWithProps("Oops, Something went wrong");return o.statusCode=500,o}},updateRolePermissions:async(s,e,t)=>{const{app:r}=t,{permissions:n,role:o}=e;try{return await new A().updateRolePermissions(o,n)}catch(i){if(i instanceof U){const u=new p.ErrorWithProps(i.name);return u.statusCode=i.statusCode,u}r.log.error(i);const a=new p.ErrorWithProps("Oops, Something went wrong");return a.statusCode=500,a}}},Query:{roles:async(s,e,t)=>{const{app:r}=t;try{return await new A().getRoles()}catch(n){r.log.error(n);const o=new p.ErrorWithProps("Oops, Something went wrong");return o.statusCode=500,o}},rolePermissions:async(s,e,t)=>{const{app:r}=t,{role:n}=e;let o=[];try{return n&&(o=await new A().getPermissionsForRole(n)),o}catch(i){r.log.error(i);const a=new p.ErrorWithProps("Oops, Something went wrong");return a.statusCode=500,a}}}},Y={deleteRole:async(s,e)=>{const{log:t,query:r}=s;try{let{role:n}=r;if(n){try{n=JSON.parse(n)}catch{}if(typeof n!="string")throw new U({name:"UNKNOWN_ROLE_ERROR",message:"Invalid role",statusCode:422});const i=await new A().deleteRole(n);return e.send(i)}throw new U({name:"UNKNOWN_ROLE_ERROR",message:"Invalid role",statusCode:422})}catch(n){return n instanceof U?(e.status(n.statusCode),e.send({message:n.message,name:n.name,statusCode:n.statusCode})):(t.error(n),e.status(500),e.send({status:"ERROR",message:"Oops! Something went wrong"}))}},createRole:async(s,e)=>{const{body:t,log:r}=s,{role:n,permissions:o}=t;try{const a=await new A().createRole(n,o);return e.send(a)}catch(i){return i instanceof U?(e.status(i.statusCode),e.send({message:i.message,name:i.name,statusCode:i.statusCode})):(r.error(i),e.status(500),e.send({status:"ERROR",message:"Oops! Something went wrong"}))}},getRoles:async(s,e)=>{const{log:t}=s;try{const n=await new A().getRoles();return e.send({roles:n})}catch(r){return t.error(r),e.status(500),e.send({status:"ERROR",message:"Oops! Something went wrong"})}},getPermissions:async(s,e)=>{const{log:t,query:r}=s;let n=[];try{let{role:o}=r;if(o){try{o=JSON.parse(o)}catch{}if(typeof o!="string")return e.send({permissions:n});n=await new A().getPermissionsForRole(o)}return e.send({permissions:n})}catch(o){return t.error(o),e.status(500),e.send({status:"ERROR",message:"Oops! Something went wrong"})}},updatePermissions:async(s,e)=>{const{log:t,body:r}=s;try{const{role:n,permissions:o}=r,a=await new A().updateRolePermissions(n,o);return e.send(a)}catch(n){return n instanceof U?(e.status(n.statusCode),e.send({message:n.message,name:n.name,statusCode:n.statusCode})):(t.error(n),e.status(500),e.send({status:"ERROR",message:"Oops! Something went wrong"}))}}},Ys=async(s,e,t)=>{s.delete(Z,{preHandler:[s.verifySession()]},Y.deleteRole),s.get(Z,{preHandler:[s.verifySession()]},Y.getRoles),s.get(ie,{preHandler:[s.verifySession()]},Y.getPermissions),s.post(Z,{preHandler:[s.verifySession()]},Y.createRole),s.put(ie,{preHandler:[s.verifySession()]},Y.updatePermissions),t()},Xs=async s=>{const{roles:e}=await S.getAllRoles();return e.includes(s)},Zs=J.gql`
  type Invitation {
    id: Int!
    acceptedAt: Float
    appId: Int
    email: String!
    expiresAt: Float!
    invitedById: String!
    payload: JSON
    revokedAt: Float
    role: String!
    createdAt: Float!
    updatedAt: Float!
  }

  type Invitations {
    totalCount: Int
    filteredCount: Int
    data: [Invitation]!
  }

  input AcceptInvitationFieldInput {
    email: String!
    password: String!
  }

  input InvitationCreateInput {
    appId: Int
    email: String!
    expiresAt: String
    payload: JSON
    role: String!
  }

  input InvitationUpdateInput {
    acceptedAt: String
    expiresAt: String
    revokedAt: String
  }

  type Mutation {
    acceptInvitation(
      token: String!
      data: AcceptInvitationFieldInput!
    ): AuthResponse
    createInvitation(data: InvitationCreateInput!): Invitation @auth
    deleteInvitation(id: Int!): Invitation @auth
    resendInvitation(id: Int!): Invitation @auth
    revokeInvitation(id: Int!): Invitation @auth
  }

  type Query {
    invitations(
      limit: Int
      offset: Int
      filters: Filters
      sort: [SortInput]
    ): Invitations!
    getInvitationByToken(token: String!): Invitation
  }
`,xs=J.gql`
  type Role {
    role: String!
    permissions: [String]!
  }

  type UpdateRolePermissionsResponse {
    status: String!
    permissions: [String]!
  }

  type RoleResponse {
    status: String!
  }

  type Mutation {
    createRole(role: String!, permissions: [String]): RoleResponse! @auth
    deleteRole(role: String!): RoleResponse! @auth
    updateRolePermissions(
      role: String!
      permissions: [String]!
    ): UpdateRolePermissionsResponse! @auth
  }

  type Query {
    permissions: [String]! @auth
    roles: [Role]! @auth
    rolePermissions(role: String!): [String]! @auth
  }
`,er=J.gql`
  type User {
    id: String!
    disabled: Boolean!
    email: String!
    lastLoginAt: Float!
    roles: [String]
    signedUpAt: Float!
    timeJoined: Float
  }

  type Users {
    totalCount: Int
    filteredCount: Int
    data: [User]!
  }

  type ChangePasswordResponse {
    statusCode: Int
    status: String
    message: String
  }

  type AuthResponse {
    status: String!
    user: User!
  }

  type CanAdminSignUpResponse {
    signUp: Boolean!
  }

  type UpdateUserResponse {
    status: String!
  }

  input UserUpdateInput {
    id: String
  }

  input SingUpFieldInput {
    email: String!
    password: String!
  }

  type Mutation {
    adminSignUp(data: SingUpFieldInput!): AuthResponse
    disableUser(id: String!): UpdateUserResponse @auth
    enableUser(id: String!): UpdateUserResponse @auth
    changePassword(
      oldPassword: String
      newPassword: String
    ): ChangePasswordResponse @auth
    updateMe(data: UserUpdateInput): User @auth(profileValidation: false)
  }

  type Query {
    canAdminSignUp: CanAdminSignUpResponse
    user(id: String): User @auth
    users(limit: Int, offset: Int, filters: Filters, sort: [SortInput]): Users!
      @auth
    me: User! @auth(profileValidation: false)
  }
`,sr=J.mergeTypeDefs([J.baseSchema,Zs,xs,er]);Object.defineProperty(c,"formatDate",{enumerable:!0,get:()=>E.formatDate}),c.EMAIL_VERIFICATION_MODE=ke,c.EMAIL_VERIFICATION_PATH=Fe,c.INVITATION_ACCEPT_LINK_PATH=we,c.INVITATION_EXPIRE_AFTER_IN_DAYS=he,c.InvitationService=le,c.InvitationSqlFactory=Ye,c.PERMISSIONS_INVITATIONS_CREATE=De,c.PERMISSIONS_INVITATIONS_DELETE=Le,c.PERMISSIONS_INVITATIONS_LIST=Ve,c.PERMISSIONS_INVITATIONS_RESEND=$e,c.PERMISSIONS_INVITATIONS_REVOKE=qe,c.PERMISSIONS_USERS_DISABLE=Me,c.PERMISSIONS_USERS_ENABLE=We,c.PERMISSIONS_USERS_LIST=Be,c.PERMISSIONS_USERS_READ=Ke,c.ProfileValidationClaim=y,c.RESET_PASSWORD_PATH=_e,c.ROLE_ADMIN=V,c.ROLE_SUPERADMIN=D,c.ROLE_USER=G,c.ROUTE_CHANGE_PASSWORD=Ue,c.ROUTE_INVITATIONS=fe,c.ROUTE_INVITATIONS_ACCEPT=Ee,c.ROUTE_INVITATIONS_CREATE=Re,c.ROUTE_INVITATIONS_DELETE=ve,c.ROUTE_INVITATIONS_GET_BY_TOKEN=Ie,c.ROUTE_INVITATIONS_RESEND=Oe,c.ROUTE_INVITATIONS_REVOKE=Pe,c.ROUTE_ME=ne,c.ROUTE_PERMISSIONS=Ce,c.ROUTE_ROLES=Z,c.ROUTE_ROLES_PERMISSIONS=ie,c.ROUTE_SIGNUP_ADMIN=te,c.ROUTE_USERS=Ne,c.ROUTE_USERS_DISABLE=Te,c.ROUTE_USERS_ENABLE=be,c.ROUTE_USERS_FIND_BY_ID=Ae,c.RoleService=A,c.TABLE_INVITATIONS=ye,c.TABLE_USERS=oe,c.UserService=Je,c.UserSqlFactory=He,c.areRolesExist=ue,c.computeInvitationExpiresAt=de,c.createUserContext=W,c.default=ze,c.getInvitationService=P,c.getOrigin=x,c.getUserService=R,c.hasUserPermission=ae,c.invitationResolver=Hs,c.invitationRoutes=js,c.isInvitationValid=z,c.isRoleExists=Xs,c.permissionResolver=Js,c.permissionRoutes=zs,c.roleResolver=Qs,c.roleRoutes=Ys,c.sendEmail=B,c.sendInvitation=Q,c.userResolver=Ws,c.userRoutes=Bs,c.userSchema=sr,c.validateEmail=L,c.validatePassword=$,c.verifyEmail=Ge,Object.defineProperties(c,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});
