(function(c,h){typeof exports=="object"&&typeof module<"u"?h(exports,require("@dzangolab/fastify-mercurius"),require("fastify-plugin"),require("mercurius"),require("mercurius-auth"),require("@fastify/cors"),require("@fastify/formbody"),require("supertokens-node"),require("supertokens-node/framework/fastify"),require("supertokens-node/recipe/session/framework/fastify"),require("supertokens-node/recipe/session"),require("supertokens-node/recipe/thirdpartyemailpassword"),require("supertokens-node/recipe/userroles"),require("@dzangolab/fastify-slonik"),require("@dzangolab/fastify-mailer"),require("validator"),require("zod")):typeof define=="function"&&define.amd?define(["exports","@dzangolab/fastify-mercurius","fastify-plugin","mercurius","mercurius-auth","@fastify/cors","@fastify/formbody","supertokens-node","supertokens-node/framework/fastify","supertokens-node/recipe/session/framework/fastify","supertokens-node/recipe/session","supertokens-node/recipe/thirdpartyemailpassword","supertokens-node/recipe/userroles","@dzangolab/fastify-slonik","@dzangolab/fastify-mailer","validator","zod"],h):(c=typeof globalThis<"u"?globalThis:c||self,h(c.DzangolabFastifyUser={},c.DzangolabFastifyMercurius,c.FastifyPlugin,c.Mercurius,c.MercuriusAuth,c.FastifyCors,c.FastifyFormbody,c.SupertokensNode,c.SupertokensFastify,c.SupertokensSessionFastify,c.SupertokensSession,c.SupertokensThirdPartyEmailPassword,c.SupertokensUserRoles,c.DzangolabFastifySlonik,c.DzangolabFastifyMailer,c.validator,c.zod))})(this,function(c,h,y,v,N,_,L,R,U,q,S,d,l,k,me,E,I){"use strict";const M=y(async e=>{e.config.mercurius.enabled&&e.register(N,{async applyPolicy(s,n,o,t){if(!t.user){const i=new v.ErrorWithProps("unauthorized");return i.statusCode=200,i}return!0},authDirective:"auth"})}),A=()=>({override:{functions:function(e){return{...e,createNewSession:async function(r){return r.accessTokenPayload={...r.accessTokenPayload,user:await d.getUserById(r.userId,{tenant:r.userContext.tenant})},e.createNewSession(r)}}}}}),B=e=>{const r=e.config.user.supertokens.recipes;return r&&r.session?S.init(r.session(e)):S.init(A())},O=e=>e.multiTenant?.table?.columns?.id||"id",P={addTenantPrefix:(e,r,s)=>(s&&(r=s[O(e)]+"_"+r),r),removeTenantPrefix:(e,r)=>(r&&(e=e.slice(Math.max(0,e.indexOf("_")+1))),e)},$=(e,r)=>async s=>{const n=s.email;s.email=P.addTenantPrefix(r.config,s.email,s.userContext.tenant);let o=await e.emailPasswordSignIn(s);return o.status==="OK"&&(o={...o,user:{...o.user,email:n}}),o};class z extends k.DefaultSqlFactory{}class p extends k.BaseService{static LIMIT_DEFAULT=20;static LIMIT_MAX=50;get table(){return this.config.user?.table?.name||"users"}get factory(){if(!this.table)throw new Error("Service table is not defined");return this._factory||(this._factory=new z(this)),this._factory}}const x=(e,r)=>async s=>{s.userContext.tenant=s.options.req.original.tenant;const{config:n,slonik:o}=r;if(e.emailPasswordSignInPOST===void 0)throw new Error("Should never come here");const t=await e.emailPasswordSignInPOST(s);if(t.status!=="OK")return t;const i=new p(n,o);let a=null;try{a=await i.findById(t.user.id)}catch{}const{roles:u}=await l.getRolesForUser(t.user.id);return{status:"OK",user:{...t.user,profile:a,roles:u},session:t.session}},C=async({fastify:e,subject:r,templateData:s={},templateName:n,to:o})=>{const{config:t,mailer:i,log:a}=e;return i.sendMail({subject:r,templateName:n,to:o,templateData:{appName:t.appName,...s}}).catch(u=>{throw a.error(u.stack),{name:"SEND_EMAIL",message:u.message,statusCode:500}})},K=(e,r)=>{const{config:s,log:n}=r;return async o=>{if(s.user.features?.signUp===!1)throw{name:"SIGN_UP_DISABLED",message:"SignUp feature is currently disabled",statusCode:404};const t=o.email;o.email=P.addTenantPrefix(s,o.email,o.userContext.tenant);let i=await e.emailPasswordSignUp(o);if(s.user.supertokens.sendUserAlreadyExistsWarning&&i.status==="EMAIL_ALREADY_EXISTS_ERROR")try{await C({fastify:r,subject:"Duplicate Email Registration",templateData:{emailId:t},templateName:"duplicate-email-warning",to:t})}catch(a){n.error(a)}return i.status==="OK"&&(i={...i,user:{...i.user,email:t}}),i}},H=(e,r)=>{const{log:s,config:n}=r;return async o=>{if(o.userContext.tenant=o.options.req.original.tenant,e.emailPasswordSignUpPOST===void 0)throw new Error("Should never come here");const t=await e.emailPasswordSignUpPOST(o);if(t.status==="OK"){const i=await l.addRoleToUser(t.user.id,n.user.role||"USER");i.status!=="OK"&&s.error(i.status);const{roles:a}=await l.getRolesForUser(t.user.id);return{status:"OK",user:{...t.user,profile:null,roles:a},session:t.session}}return t}},J=(e,r,s)=>(s&&r.find(n=>{n.id==="email"&&(n.value=s[O(e)]+"_"+n.value)}),r),W=(e,r)=>async s=>{if(s.userContext.tenant=s.options.req.original.tenant,e.generatePasswordResetTokenPOST===void 0)throw new Error("Should never come here");return s.formFields=J(r.config,s.formFields,s.userContext.tenant),await e.generatePasswordResetTokenPOST(s)},j=e=>async r=>{let s=await e.getUserById(r);return s&&r.userContext.tenant&&(s={...s,email:P.removeTenantPrefix(s.email,r.userContext.tenant)}),s},G=e=>{let r;try{if(r=new URL(e).origin,!r||r==="null")throw console.log("Error"),new Error("Origin is empty")}catch{r=""}return r},Q=e=>{const r=e.config.appOrigin[0],s="/reset-password";return async n=>{const o=n.userContext._default.request.request,t=o.headers.referer||o.headers.origin||o.hostname,i=G(t)||r,a=n.passwordResetLink.replace(r+"/auth/reset-password",i+(e.config.user.supertokens.resetPasswordPath?e.config.user.supertokens.resetPasswordPath:s));await C({fastify:e,subject:"Reset Password",templateName:"reset-password",to:P.removeTenantPrefix(n.user.email,n.userContext.tenant),templateData:{passwordResetLink:a}})}},V=(e,r)=>async s=>{const n=s.userContext.tenant;if(n){const i=n[O(r.config)];s.thirdPartyUserId=i+"_"+s.thirdPartyUserId}if(!await d.getUserByThirdPartyInfo(s.thirdPartyId,s.thirdPartyUserId,s.userContext)&&r.config.user.features?.signUp===!1)throw{name:"SIGN_UP_DISABLED",message:"SignUp feature is currently disabled",statusCode:404};return await e.thirdPartySignInUp(s)},X=(e,r)=>{const{log:s,config:n}=r;return async o=>{if(o.userContext.tenant=o.options.req.original.tenant,e.thirdPartySignInUpPOST===void 0)throw new Error("Should never come here");const t=await e.thirdPartySignInUpPOST(o);if(t.status==="OK"&&t.createdNewUser){const i=await l.addRoleToUser(t.user.id,n.user.role||"USER");i.status!=="OK"&&s.error(i.status);const{roles:a}=await l.getRolesForUser(t.user.id),u={...t.user,profile:null,roles:a};return{status:"OK",createdNewUser:t.createdNewUser,user:u,session:t.session,authCodeResponse:t.authCodeResponse}}return t}},Y=e=>{const{Apple:r,Facebook:s,Github:n,Google:o}=d,t=e.user.supertokens.providers,i=[],a=[{name:"google",initProvider:o},{name:"github",initProvider:n},{name:"facebook",initProvider:s},{name:"apple",initProvider:r}];for(const u of a)t?.[u.name]&&i.push(u.initProvider(t[u.name]));return i},Z=(e,r)=>I.z.string({required_error:e.required}).refine(s=>E.isEmail(s,r||{}),{message:e.invalid}),T={minLength:8,minLowercase:0,minUppercase:0,minNumbers:0,minSymbols:0,returnScore:!1,pointsPerUnique:1,pointsPerRepeat:.5,pointsForContainingLower:10,pointsForContainingUpper:10,pointsForContainingNumber:10,pointsForContainingSymbol:10},ee=(e,r)=>{const s={...T,...r};return I.z.string({required_error:e.required}).refine(n=>E.isStrongPassword(n,s),{message:e.weak})},se=(e,r)=>{const{supportedEmailDomains:s,validatorOptions:n}=r.user.supertokens;let o=[];s&&s.some(a=>!!a)&&(o=s);const t=n?.email?.host_whitelist;t&&(o=[...o,...t]),(!o||o.filter(a=>!!a).length===0)&&(o=void 0);const i=Z({invalid:"Email is invalid",required:"Email is required"},{...n?.email,host_whitelist:o}).safeParse(e);return i.success?{success:!0}:{message:i.error.issues[0].message,success:!1}},re=e=>{let r="Password is too weak";if(!e)return r;const s=[];if(e.minLength){const n=e.minLength;s.push(`minimum ${n} ${n>1?"characters":"character"}`)}if(e.minLowercase){const n=e.minLowercase;s.push(`minimum ${n} ${n>1?"lowercases":"lowercase"}`)}if(e.minUppercase){const n=e.minUppercase;s.push(`minimum ${n} ${n>1?"uppercases":"uppercase"}`)}if(e.minNumbers){const n=e.minNumbers;s.push(`minimum ${n} ${n>1?"numbers":"number"}`)}if(e.minSymbols){const n=e.minSymbols;s.push(`minimum ${n} ${n>1?"symbols":"symbol"}`)}if(s.length>0){r="Passsword should contain ";const n=s.pop();s.length>0&&(r+=s.join(", ")+" and "),r+=n}return r},b=(e,r)=>{const s=r.user.supertokens.validatorOptions?.password,n=ee({required:"Password is required",weak:re({...T,...s})},s).safeParse(e);return n.success?{success:!0}:{message:n.error.issues[0].message,success:!1}},ne=e=>{const{config:r}=e;return{override:{apis:s=>({...s,emailPasswordSignInPOST:x(s,e),emailPasswordSignUpPOST:H(s,e),generatePasswordResetTokenPOST:W(s,e),thirdPartySignInUpPOST:X(s,e)}),functions:s=>({...s,emailPasswordSignIn:$(s,e),emailPasswordSignUp:K(s,e),getUserById:j(s),thirdPartySignInUp:V(s,e)})},signUpFeature:{formFields:[{id:"email",validate:async s=>{const n=se(s,r);if(!n.success)return n.message}},{id:"password",validate:async s=>{const n=b(s,r);if(!n.success)return n.message}}]},emailDelivery:{override:s=>({...s,sendEmail:Q(e)})},providers:Y(r)}},te=e=>{const r=e.config.user.supertokens.recipes;return r&&r.thirdPartyEmailPassword?d.init(r.thirdPartyEmailPassword(e)):d.init(ne(e))},oe=()=>({}),ie=e=>{const r=e.config.user.supertokens.recipes;return r&&r.userRoles?l.init(r.userRoles(e)):l.init(oe())},ae=e=>[B(e),te(e),ie(e)],ce=e=>{const{config:r}=e;R.init({appInfo:{apiDomain:r.baseUrl,appName:r.appName,websiteDomain:r.appOrigin[0]},recipeList:ae(e),supertokens:{connectionURI:r.user.supertokens.connectionUri}})},ue=y(async(e,r,s)=>{const{config:n,log:o}=e;o.info("Registering supertokens plugin"),ce(e),e.setErrorHandler(U.errorHandler()),e.register(_,{origin:n.appOrigin,allowedHeaders:["Content-Type","st-auth-mode",...R.getAllCORSHeaders()],credentials:!0}),e.register(L),e.register(U.plugin),o.info("Registering supertokens plugin complete"),e.decorate("verifySession",q.verifySession),s()}),de=async(e,r,s)=>{const{config:n,slonik:o,tenant:t}=r,a=(await S.getSession(r,U.wrapResponse(s),{sessionRequired:!1}))?.getUserId();if(a){const u=new p(n,o),g=await d.getUserById(a,{tenant:t});if(g){let w=null;const{roles:m}=await l.getRolesForUser(a);try{w=await u.findById(a)}catch{}const D={...g,profile:w,roles:m};e.user=D}}},F=y(async(e,r,s)=>{const{mercurius:n}=e.config;await e.register(ue),n.enabled&&await e.register(M),s()});F.updateContext=de;const le={Query:{user:async(e,r,s)=>await new p(s.config,s.database).findById(r.id),users:async(e,r,s)=>await new p(s.config,s.database).list(r.limit,r.offset,r.filters?JSON.parse(JSON.stringify(r.filters)):void 0,r.sort?JSON.parse(JSON.stringify(r.sort)):void 0)}},ge=async(e,r,s)=>{const n="/users";e.get(n,{preHandler:e.verifySession()},async(o,t)=>{const i=new p(o.config,o.slonik),{limit:a,offset:u,filters:g,sort:w}=o.query,m=await i.list(a,u,g?JSON.parse(g):void 0,w?JSON.parse(w):void 0);t.send(m)}),s()};class f{config;database;constructor(r,s){this.config=r,this.database=s}changePassword=async(r,s,n,o)=>{const t=b(n,this.config);if(!t.success)return{status:"FIELD_ERROR",message:t.message};const i=await d.getUserById(r,{tenant:o});if(s&&n)if(i)if((await d.emailPasswordSignIn(i.email,s,{tenant:o})).status==="OK"){if(await d.updateEmailOrPassword({userId:r,password:n,userContext:{tenant:o}}))return await S.revokeAllSessionsForUser(r),{status:"OK"};throw{status:"FAILED",message:"Oops! Something went wrong, couldn't change password"}}else return{status:"INVALID_PASSWORD",message:"Invalid password"};else throw{status:"NOT_FOUND",message:"User not found"};else return{status:"FIELD_ERROR",message:"Password cannot be empty"}};getUserById=async(r,s)=>{const n=await d.getUserById(r,{tenant:s}),o=new p(this.config,this.database);let t=null;try{t=await o.findById(r)}catch{}const i=await l.getRolesForUser(r);return{email:n?.email,id:r,profile:t,roles:i.roles,timeJoined:n?.timeJoined}}}const pe={Mutation:{changePassword:async(e,r,s)=>{const n=new f(s.config,s.database);try{return s.user?.id?await n.changePassword(s.user?.id,r.oldPassword,r.newPassword,s.tenant):{status:"NOT_FOUND",message:"User not found"}}catch(o){s.app.log.error(o);const t=new v.ErrorWithProps("Oops, Something went wrong");return t.statusCode=500,t}}},Query:{me:async(e,r,s)=>{const n=new f(s.config,s.database);if(s.user?.id)return n.getUserById(s.user.id,s.tenant);{s.app.log.error("Cound not get user id from mercurius context");const o=new v.ErrorWithProps("Oops, Something went wrong");return o.statusCode=500,o}}}},we=async(e,r,s)=>{const n="/change_password",o="/me";e.post(n,{preHandler:e.verifySession()},async(t,i)=>{try{const a=t.session,u=t.body,g=a&&a.getUserId();if(!g)throw new Error("User not found in session");const w=u.oldPassword??"",m=u.newPassword??"",fe=await new f(t.config,t.slonik).changePassword(g,w,m,t.tenant);i.send(fe)}catch(a){e.log.error(a),i.status(500),i.send({status:"ERROR",message:"Oops! Something went wrong",error:a})}}),e.get(o,{preHandler:e.verifySession()},async(t,i)=>{const a=new f(t.config,t.slonik),u=t.session?.getUserId();if(u)i.send(await a.getUserById(u,t.tenant));else throw e.log.error("Cound not get user id from session"),new Error("Oops, Something went wrong")}),s()};c.UserProfileService=p,c.UserService=f,c.default=F,c.userProfileResolver=le,c.userProfileRoutes=ge,c.userResolver=pe,c.userRoutes=we,Object.defineProperties(c,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});
