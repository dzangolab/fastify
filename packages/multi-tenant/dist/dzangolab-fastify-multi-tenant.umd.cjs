(function(s,d){typeof exports=="object"&&typeof module<"u"?d(exports,require("@dzangolab/fastify-config"),require("mercurius"),require("fastify-plugin"),require("node:fs"),require("pg"),require("@dzangolab/postgres-migrations"),require("@dzangolab/fastify-slonik"),require("humps"),require("slonik"),require("zod")):typeof define=="function"&&define.amd?define(["exports","@dzangolab/fastify-config","mercurius","fastify-plugin","node:fs","pg","@dzangolab/postgres-migrations","@dzangolab/fastify-slonik","humps","slonik","zod"],d):(s=typeof globalThis<"u"?globalThis:s||self,d(s.DzangolabFastifyMultiTenant={},s.DzangolabFastifyConfig,s.Mercurius,s.FastifyPlugin,s.NodeFs,s.Pg,s.DzangolabPostgresMigrations,s.DzangolabFastifySlonik,s.Humps,s.Slonik,s.Zod))})(this,function(s,d,x,m,y,M,z,T,g,i,f){"use strict";function E(e){const t=Object.create(null,{[Symbol.toStringTag]:{value:"Module"}});if(e){for(const n in e)if(n!=="default"){const a=Object.getOwnPropertyDescriptor(e,n);Object.defineProperty(t,n,a.get?a:{enumerable:!0,get:()=>e[n]})}}return t.default=e,Object.freeze(t)}const O=E(M),D=async(e,t)=>{t.config.mercurius.enabled&&(e.tenant=t.tenant)},b=async(e,t)=>{await e.query(`
      CREATE SCHEMA IF NOT EXISTS ${t};
      SET search_path TO ${t};
    `)},q=e=>({database:e.db.databaseName,user:e.db.username,password:e.db.password,host:e.db.host,port:e.db.port}),w=async e=>{const t=new O.Client(e);return await t.connect(),t},S=e=>{const t=e.slonik?.migrations?.path||"migrations";return{migrations:{path:e.multiTenant?.migrations?.path||`${t}/tenants`},reserved:{domains:e.multiTenant?.reserved?.domains||[],slugs:e.multiTenant?.reserved?.slugs||[]},table:{name:e.multiTenant?.table?.name||"tenants",columns:{id:e.multiTenant?.table?.columns?.id||"id",name:e.multiTenant?.table?.columns?.name||"name",slug:e.multiTenant?.table?.columns?.slug||"slug",domain:e.multiTenant?.table?.columns?.domain||"domain"}}}},$=async(e,t,n)=>{if(!y.existsSync(t))return!1;const a="client"in e?e.client:await w(e);return await b(a,n.slug),await z.migrate({client:a},t),"client"in e||await a.end(),!0};class R extends T.DefaultSqlFactory{fieldMappings=new Map(Object.entries({domain:"domain",id:"id",name:"name",slug:"slug"}));constructor(t){super(t),this.init()}getAllWithAliasesSql=t=>{const n=[];for(const a of t)n.push(i.sql.fragment`${this.getAliasedField(a)}`);return i.sql.type(f.z.any())`
      SELECT ${i.sql.join(n,i.sql.fragment`, `)}
      FROM ${this.getTableFragment()}
      ORDER BY ${i.sql.identifier([g.decamelize(this.getMappedField("id"))])} ASC;
    `};getCreateSql=t=>{const n=[],a=[];for(const r in t){const o=r,c=t[o];n.push(i.sql.identifier([g.decamelize(this.getMappedField(o))])),a.push(c)}return i.sql.type(f.z.any())`
      INSERT INTO ${this.getTableFragment()}
        (${i.sql.join(n,i.sql.fragment`, `)})
      VALUES (${i.sql.join(a,i.sql.fragment`, `)})
      RETURNING *;
    `};getFindByHostnameSql=(t,n)=>i.sql.type(f.z.any())`
      SELECT *
      FROM ${this.getTableFragment()}
      WHERE ${i.sql.identifier([g.decamelize(this.getMappedField("domain"))])} = ${t}
      OR (
        ${i.sql.identifier([g.decamelize(this.getMappedField("slug"))])}
        || '.' ||
        ${n}
      ) = ${t};
    `;getAliasedField=t=>{const n=this.getMappedField(t);return n===t?i.sql.identifier([t]):i.sql.join([i.sql.identifier([n]),i.sql.identifier([t])],i.sql.fragment` AS `)};getMappedField=t=>this.fieldMappings.has(t)?this.fieldMappings.get(t):t;init(){const t=this.config.multiTenant?.table?.columns;if(t)for(const n in t){const a=n;this.fieldMappings.set(a,t[a])}}}class p extends T.BaseService{all=async t=>{const n=this.factory.getAllWithAliasesSql(t);return await this.database.connect(r=>r.any(n))};findByHostname=async t=>{const n=this.factory.getFindByHostnameSql(t,this.config.multiTenant.rootDomain);return await this.database.connect(async r=>r.maybeOne(n))};get factory(){if(!this.table)throw new Error("Service table is not defined");return this._factory||(this._factory=new R(this)),this._factory}get table(){return this.config.multiTenant?.table?.name||"tenants"}postCreate=async t=>{const n=S(this.config);return await $(q(this.config.slonik),n.migrations.path,t),t}}const j=m(async(e,t,n)=>{try{const{config:a,slonik:r}=e,o=q(a.slonik),l=S(a).migrations.path;if(y.existsSync(l)){const P=await new p(a,r).all(["name","slug"]),h=await w(o);for(const F of P)e.log.info(`Running migrations for tenant ${F.name}`),await $({client:h},l,F);await b(h,"public"),await h.end()}else e.log.warn(`Tenant migrations path '${l}' does not exists.`)}catch(a){throw e.log.error("ðŸ”´ multi-tenant: Failed to run tenant migrations"),a}n()}),A=async(e,t,n)=>{const a=e.multiTenant?.reserved?.slugs,r=e.multiTenant?.reserved?.domains;if(r&&r.includes(n)||a&&a.some(l=>`${l}.${e.multiTenant.rootDomain}`===n))return null;const c=await new p(e,t).findByHostname(n);if(c)return c;throw new Error("Tenant not found")},C=e=>{let t;try{if(t=new URL(e).host,!t)throw new Error("Host is empty")}catch{t=e}return t},H=m(async(e,t,n)=>{e.addHook("preHandler",async(a,r)=>{const o=a.headers.referer||a.headers.origin||a.hostname,{config:c,slonik:l}=a;try{const u=await A(c,l,C(o));u&&(a.tenant=u)}catch(u){return e.log.error(u),r.send({error:{message:"Tenant not found"}})}}),n()}),v=m(async(e,t,n)=>{e.log.info("Registering fastify-multi-tenant plugin"),await e.register(j),await e.register(H),n()});v.updateContext=D,s.TenantService=p,s.default=v,Object.defineProperties(s,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});
