(function(l,O){typeof exports=="object"&&typeof module<"u"?O(exports,require("@dzangolab/fastify-config"),require("mercurius"),require("fastify-plugin"),require("lodash.merge"),require("supertokens-node/recipe/userroles"),require("@dzangolab/fastify-user"),require("supertokens-node/framework/fastify"),require("supertokens-node/recipe/session"),require("@dzangolab/fastify-slonik"),require("supertokens-node"),require("supertokens-node/recipe/emailverification"),require("supertokens-node/recipe/thirdpartyemailpassword"),require("humps"),require("slonik"),require("zod"),require("node:fs"),require("@dzangolab/postgres-migrations"),require("pg")):typeof define=="function"&&define.amd?define(["exports","@dzangolab/fastify-config","mercurius","fastify-plugin","lodash.merge","supertokens-node/recipe/userroles","@dzangolab/fastify-user","supertokens-node/framework/fastify","supertokens-node/recipe/session","@dzangolab/fastify-slonik","supertokens-node","supertokens-node/recipe/emailverification","supertokens-node/recipe/thirdpartyemailpassword","humps","slonik","zod","node:fs","@dzangolab/postgres-migrations","pg"],O):(l=typeof globalThis<"u"?globalThis:l||self,O(l.DzangolabFastifyMultiTenant={},l.DzangolabFastifyConfig,l.Mercurius,l.FastifyPlugin,l.LodashMerge,l.SupertokensUserRoles,l.DzangolabFastifyUser,l.SupertokensFastify,l.SupertokensSession,l.DzangolabFastifySlonik,l.SupertokensNode,l.EmailVerification,l.SupertokensThirdPartyEmailPassword,l.Humps,l.Slonik,l.Zod,l.NodeFs,l.DzangolabPostgresMigrations,l.Pg))})(this,function(l,O,E,A,G,T,u,K,J,f,R,$,q,v,c,S,L,X,Q){"use strict";function Y(n){const t=Object.create(null,{[Symbol.toStringTag]:{value:"Module"}});if(n){for(const e in n)if(e!=="default"){const s=Object.getOwnPropertyDescriptor(n,e);Object.defineProperty(t,e,s.get?s:{enumerable:!0,get:()=>n[e]})}}return t.default=n,Object.freeze(t)}const Z=Y(Q),b="TENANT_OWNER",ee=async()=>{await T.createNewRoleOrAddPermissions(b,[])},w=n=>{const t=n.slonik?.migrations?.path||"migrations";return{migrations:{path:n.multiTenant?.migrations?.path||`${t}/tenants`},reserved:{admin:{domains:n.multiTenant.reserved?.admin?.domains||[],enabled:n.multiTenant.reserved?.admin?.enabled??!0,slugs:n.multiTenant.reserved?.admin?.slugs||["admin"]},blacklisted:{domains:n.multiTenant.reserved?.blacklisted?.domains||[],enabled:n.multiTenant.reserved?.blacklisted?.enabled??!0,slugs:n.multiTenant.reserved?.blacklisted?.slugs||[]},others:{domains:n.multiTenant.reserved?.others?.domains||[],enabled:n.multiTenant.reserved?.others?.enabled??!0,slugs:n.multiTenant.reserved?.others?.slugs||[]},www:{domains:n.multiTenant.reserved?.www?.domains||[],enabled:n.multiTenant.reserved?.www?.enabled??!0,slugs:n.multiTenant.reserved?.www?.slugs||["www"]}},table:{name:n.multiTenant?.table?.name||"tenants",columns:{id:n.multiTenant?.table?.columns?.id||"id",domain:n.multiTenant?.table?.columns?.domain||"domain",name:n.multiTenant?.table?.columns?.name||"name",ownerId:n.multiTenant?.table?.columns?.ownerId||"owner_id",slug:n.multiTenant?.table?.columns?.slug||"slug"}}}},P=(n,t,e)=>{const s=w(n),a=e?e[s.table.columns.slug]:"";return u.getUserService(n,t,a)},te=async(n,t,e)=>{const{config:s,slonik:a,tenant:r}=t;n.tenant=r;const d=(await J.getSession(t,K.wrapResponse(e),{sessionRequired:!1}))?.getUserId();if(d&&!n.user){const i=P(s,a,r);let m;try{m=await i.findById(d)}catch{}if(!m)throw new Error("Unable to find user");const{roles:h}=await T.getRolesForUser(u.TENANT_ID,d);n.user=m,n.roles=h}},C={addTenantPrefix:(n,t,e)=>(e&&(t=e[w(n).table.columns.id]+"_"+t),t),removeTenantPrefix:(n,t,e)=>(e&&e[w(n).table.columns.id]==t.slice(0,Math.max(0,Math.max(0,t.indexOf("_"))))&&(t=t.slice(Math.max(0,t.indexOf("_")+1))),t)},ne=(n,t)=>{const e=t.config.appOrigin[0];return async s=>{let a;try{const r=s.userContext._default.request.request;try{const i=r.headers.referer||r.headers.origin||r.hostname;a=u.getOrigin(i)||e}catch{a=e}const o=s.emailVerifyLink.replace(e+"/auth/verify-email",a+(t.config.user.supertokens.emailVerificationPath||u.EMAIL_VERIFICATION_PATH));let d=s.user.email;r.tenant&&(d=C.removeTenantPrefix(r.config,d,r.tenant)),u.sendEmail({fastify:t,subject:"Email Verification",templateName:"email-verification",to:d,templateData:{emailVerifyLink:o}})}catch(r){r instanceof Error&&t.log.error(r.message)}}},se=(n,t)=>async e=>{if(n.createNewSession===void 0)throw new Error("Should never come here");const s=e.userContext.tenant;if(s){const i=e.userContext._default.request.request,m=w(i.config);e.accessTokenPayload={...e.accessTokenPayload,tenantId:s[m.table.columns.id]}}const a=await n.createNewSession(e),r=a.getUserId();if((await P(t.config,t.slonik,s).findById(r))?.disabled)throw await a.revokeSession(),{name:"SIGN_IN_FAILED",message:"user is disabled",statusCode:401};return a},re=(n,t)=>async e=>{if(n.verifySession===void 0)throw new Error("Should never come here");const s=await n.verifySession(e);if(s){const a=s.getUserId(),r=e.userContext._default.request.request,o=s.getAccessTokenPayload().tenantId;if(r.tenant){const m=w(r.config);if(o!=r.tenant[m.table.columns.id])throw{name:"SESSION_VERIFICATION_FAILED",message:"invalid session",statusCode:401}}if((await P(t.config,t.slonik,r.tenant).findById(a))?.disabled)throw await s.revokeSession(),{name:"SESSION_VERIFICATION_FAILED",message:"user is disabled",statusCode:401}}return s},ae=(n,t)=>async e=>{if(n.refreshPOST===void 0)throw new Error("Should never come here");const s=await n.refreshPOST(e);if(s){const a=e.userContext._default.request.request,r=s.getAccessTokenPayload().tenantId;if(a.tenant){const o=w(a.config);if(r!=a.tenant[o.table.columns.id])throw{name:"SESSION_VERIFICATION_FAILED",message:"invalid session",statusCode:401}}}return s},oe=(n,t)=>{const{config:e,log:s,slonik:a}=t;return async r=>{r.email=C.addTenantPrefix(e,r.email,r.userContext.tenant);const o=await n.emailPasswordSignIn(r);if(o.status!=="OK")return o;const d=P(e,a,r.userContext.dbSchema),i=await d.findById(o.user.id);return i?(i.lastLoginAt=Date.now(),await d.update(i.id,{lastLoginAt:f.formatDate(new Date(i.lastLoginAt))}).catch(h=>{s.error(`Unable to update lastLoginAt for userId ${o.user.id}`),s.error(h)}),{status:"OK",user:{...o.user,...i}}):(s.error(`User record not found for userId ${o.user.id}`),{status:"WRONG_CREDENTIALS_ERROR"})}},ie=(n,t)=>async e=>{if(e.userContext.tenant=e.options.req.original.tenant,e.userContext.dbSchema=e.options.req.original.dbSchema,n.emailPasswordSignInPOST===void 0)throw new Error("Should never come here");return await n.emailPasswordSignInPOST(e)},de=(n,t)=>{const{config:e,log:s,slonik:a}=t;return async r=>{const o=r.userContext.roles||[];if(!await u.areRolesExist(o))throw s.error(`At least one role from ${o.join(", ")} does not exist.`),{name:"SIGN_UP_FAILED",message:"Something went wrong",statusCode:500};const d=r.email;r.email=C.addTenantPrefix(e,d,r.userContext.tenant);const i=await n.emailPasswordSignUp(r);if(i.status==="OK"){const m=P(e,a,r.userContext.tenant);let h;try{if(h=await m.create({id:i.user.id,email:d}),!h)throw new Error("User not found")}catch(g){throw s.error("Error while creating user"),s.error(g),await R.deleteUser(i.user.id),{name:"SIGN_UP_FAILED",message:"Something went wrong",statusCode:500}}h.roles=o,i.user={...i.user,...h};for(const g of o){const I=await T.addRoleToUser(u.TENANT_ID,i.user.id,g);I.status!=="OK"&&s.error(I.status)}if(e.user.features?.signUp?.emailVerification)try{if(r.userContext.autoVerifyEmail)await u.verifyEmail(h.id);else{const g=await $.createEmailVerificationToken(u.TENANT_ID,i.user.id);g.status==="OK"&&await $.sendEmail({tenantId:u.TENANT_ID,type:"EMAIL_VERIFICATION",user:{id:i.user.id,email:r.email},emailVerifyLink:`${e.appOrigin[0]}/auth/verify-email?token=${g.token}&rid=emailverification`,userContext:r.userContext})}}catch(g){s.error(g)}}if(e.user.supertokens.sendUserAlreadyExistsWarning&&i.status==="EMAIL_ALREADY_EXISTS_ERROR")try{u.sendEmail({fastify:t,subject:"Duplicate Email Registration",templateData:{emailId:d},templateName:"duplicate-email-warning",to:d})}catch(m){s.error(m)}return i}},_=n=>{let t;try{if(t=new URL(n).host,!t)throw new Error("Host is empty")}catch{t=n}return t},ce=(n,t)=>async e=>{const s=e.options.req.original,a=s.headers.referer||s.headers.origin||s.hostname,r=_(a),{admin:o,www:d}=w(s.config).reserved;if(e.userContext.roles=d.enabled&&(d.slugs.some(i=>`${i}.${s.config.multiTenant.rootDomain}`===r)||d.domains.includes(r))?[b]:[s.config.user.role||u.ROLE_USER],o.enabled&&(o.slugs.some(i=>`${i}.${s.config.multiTenant.rootDomain}`===r)||o.domains.includes(r)))throw{name:"SIGN_UP_FAILED",message:"Admin signUp is not allowed",statusCode:403};if(e.userContext.tenant=s.tenant,n.emailPasswordSignUpPOST===void 0)throw new Error("Should never come here");if(t.config.user.features?.signUp?.enabled===!1)throw{name:"SIGN_UP_DISABLED",message:"SignUp feature is currently disabled",statusCode:404};return await n.emailPasswordSignUpPOST(e)},le=(n,t,e)=>(e&&t.find(s=>{s.id==="email"&&(s.value=e[w(n).table.columns.id]+"_"+s.value)}),t),U={emailVerification:{sendEmail:ne},thirdPartyEmailPassword:{override:{apis:{emailPasswordSignInPOST:ie,emailPasswordSignUpPOST:ce,generatePasswordResetTokenPOST:(n,t)=>async e=>{if(e.userContext.tenant=e.options.req.original.tenant,n.generatePasswordResetTokenPOST===void 0)throw new Error("Should never come here");return e.formFields=le(t.config,e.formFields,e.userContext.tenant),await n.generatePasswordResetTokenPOST(e)},thirdPartySignInUpPOST:(n,t)=>{const{config:e,log:s,slonik:a}=t;return async r=>{const o=r.options.req.original,d=o.headers.referer||o.headers.origin||o.hostname,i=_(d),{admin:m,www:h}=w(o.config).reserved;if(r.userContext.roles=h.enabled&&(h.slugs.some(I=>`${I}.${o.config.multiTenant.rootDomain}`===i)||h.domains.includes(i))?[b]:[o.config.user.role||u.ROLE_USER],m.enabled&&(m.slugs.some(I=>`${I}.${o.config.multiTenant.rootDomain}`===i)||m.domains.includes(i)))throw{name:"SIGN_UP_FAILED",message:"Admin signUp is not allowed",statusCode:403};if(r.userContext.tenant=o.tenant,n.thirdPartySignInUpPOST===void 0)throw new Error("Should never come here");const g=await n.thirdPartySignInUpPOST(r);if(g.status==="OK"){const I=P(e,a,r.userContext.tenant);let y;if(g.createdNewUser)try{if(y=await I.create({id:g.user.id,email:g.user.email}),!y)throw new Error("User not found");y.roles=r.userContext.roles}catch(D){throw s.error("Error while creating user"),s.error(D),await R.deleteUser(g.user.id),{name:"SIGN_UP_FAILED",message:"Something went wrong",statusCode:500}}else{if(y=await I.findById(g.user.id),!y)return s.error(`User record not found for userId ${g.user.id}`),{status:"GENERAL_ERROR",message:"Something went wrong"};y.lastLoginAt=Date.now(),await I.update(y.id,{lastLoginAt:f.formatDate(new Date(y.lastLoginAt))}).catch(D=>{s.error(`Unable to update lastLoginAt for userId ${g.user.id}`),s.error(D)})}return{...g,user:{...g.user,...y}}}return g}}},functions:{emailPasswordSignIn:oe,emailPasswordSignUp:de,getUserById:(n,t)=>async e=>{let s=await n.getUserById(e);return s&&e.userContext&&e.userContext.tenant&&(s={...s,email:C.removeTenantPrefix(t.config,s.email,e.userContext.tenant)}),s},resetPasswordUsingToken:(n,t)=>async e=>{const s=await n.resetPasswordUsingToken(e);if(s.status==="OK"&&s.userId){const a=await q.getUserById(s.userId,{tenant:e.userContext._default.request.request.tenant});a&&u.sendEmail({fastify:t,subject:"Reset Password Notification",templateName:"reset-password-notification",to:a.email,templateData:{emailId:a.email}})}return s},thirdPartySignInUp:(n,t)=>{const{config:e,log:s}=t;return async a=>{const r=a.userContext.roles||[],o=a.userContext.tenant;if(o){const m=o[w(e).table.columns.id];a.thirdPartyUserId=m+"_"+a.thirdPartyUserId}if(!await q.getUserByThirdPartyInfo(a.tenantId,a.thirdPartyId,a.thirdPartyUserId,a.userContext)&&e.user.features?.signUp?.enabled===!1)throw{name:"SIGN_UP_DISABLED",message:"SignUp feature is currently disabled",statusCode:404};const i=await n.thirdPartySignInUp(a);if(i.status==="OK"&&i.createdNewUser){if(!await u.areRolesExist(r))throw await R.deleteUser(i.user.id),s.error(`At least one role from ${r.join(", ")} does not exist.`),{name:"SIGN_UP_FAILED",message:"Something went wrong",statusCode:500};for(const m of r){const h=await T.addRoleToUser(u.TENANT_ID,i.user.id,m);h.status!=="OK"&&s.error(h.status)}}return i}}}},sendEmail:(n,t)=>{const e=t.config.appOrigin[0];return async s=>{const a=s.userContext._default.request.request,r=a.headers.referer||a.headers.origin||a.hostname,o=u.getOrigin(r)||e,d=s.passwordResetLink.replace(e+"/auth/reset-password",o+(t.config.user.supertokens.resetPasswordPath||u.RESET_PASSWORD_PATH));u.sendEmail({fastify:t,subject:"Reset Password",templateName:"reset-password",to:C.removeTenantPrefix(a.config,s.user.email,s.userContext.tenant),templateData:{passwordResetLink:d}})}}},session:{override:{apis:{refreshPOST:ae,verifySession:re},functions:{createNewSession:se}}}},M=n=>{const t=w(n).reserved;let e=[];for(const[,s]of Object.entries(t))s.enabled&&(e=[...e,...s.domains]);return e},x=n=>{const t=w(n).reserved;let e=[];for(const[,s]of Object.entries(t))s.enabled&&(e=[...e,...s.slugs]);return e};class ue extends f.DefaultSqlFactory{fieldMappings=new Map(Object.entries({domain:"domain",id:"id",name:"name",ownerId:"owner_id",slug:"slug"}));constructor(t){super(t),this.init()}getAllWithAliasesSql=t=>{const e=[];for(const i of t)i!="host"&&e.push(c.sql.fragment`${this.getAliasedField(i)}`);const s=f.createTableIdentifier(this.table,this.schema),a=c.sql.identifier([this.getMappedField("domain")]),r=c.sql.identifier([this.getMappedField("slug")]),o=this.config.multiTenant.rootDomain,d=t.includes("host")?c.sql.fragment`,
          CASE
            WHEN ${a} IS NOT NULL THEN ${a}
            ELSE CONCAT(${r}, ${"."+o}::TEXT)
          END AS host
        `:c.sql.fragment``;return c.sql.type(S.z.any())`
      SELECT ${c.sql.join(e,c.sql.fragment`, `)}
        ${d}
      FROM ${this.getTableFragment()}
      ${f.createFilterFragment(this.filterWithOwnerId(),s)}
      ORDER BY ${c.sql.identifier([v.decamelize(this.getMappedField("id"))])} ASC;
    `};getCountSql=t=>{const e=f.createTableIdentifier(this.table,this.schema),s=S.z.object({count:S.z.number()});return c.sql.type(s)`
      SELECT COUNT(*)
      FROM ${this.getTableFragment()}
      ${f.createFilterFragment(this.filterWithOwnerId(t),e)};
    `};getCreateSql=t=>{const e=[],s=[];for(const a in t){const r=a,o=t[r];e.push(c.sql.identifier([v.decamelize(this.getMappedField(r))])),s.push(o)}return c.sql.type(S.z.any())`
      INSERT INTO ${this.getTableFragment()}
        (${c.sql.join(e,c.sql.fragment`, `)})
      VALUES (${c.sql.join(s,c.sql.fragment`, `)})
      RETURNING *;
    `};getFindByHostnameSql=(t,e)=>c.sql.type(S.z.any())`
      SELECT *
      FROM ${this.getTableFragment()}
      WHERE ${c.sql.identifier([v.decamelize(this.getMappedField("domain"))])} = ${t}
      OR (
        ${c.sql.identifier([v.decamelize(this.getMappedField("slug"))])}
        || '.' ||
        ${e}
      ) = ${t};
    `;getFindByIdSql=t=>{const e={key:this.getMappedField("id"),operator:"eq",value:t},s=f.createTableIdentifier(this.table,this.schema);return c.sql.type(this.validationSchema)`
      SELECT *
      FROM ${this.getTableFragment()}
      ${f.createFilterFragment(this.filterWithOwnerId(e),s)}
    `};getFindBySlugOrDomainSql=(t,e)=>{const s=c.sql.identifier([this.getMappedField("domain")]),a=c.sql.identifier([this.getMappedField("slug")]),r=e?c.sql.fragment`
        OR ${s} = ${e}
      `:c.sql.fragment``;return c.sql.type(this.validationSchema)`
      SELECT *
      FROM ${this.getTableFragment()}
      WHERE
      ${a} = ${t}
      ${r};
    `};getListSql=(t,e,s,a)=>{const r=f.createTableIdentifier(this.table,this.schema);return c.sql.type(this.validationSchema)`
      SELECT *
      FROM ${this.getTableFragment()}
      ${f.createFilterFragment(this.filterWithOwnerId(s),r)}
      ${f.createSortFragment(r,this.getSortInput(a))}
      ${f.createLimitFragment(t,e)};
    `};getAliasedField=t=>{const e=this.getMappedField(t);return e===t?c.sql.identifier([v.decamelize(t)]):c.sql.join([c.sql.identifier([v.decamelize(e)]),c.sql.identifier([t])],c.sql.fragment` AS `)};getMappedField=t=>this.fieldMappings.has(t)?this.fieldMappings.get(t):t;init(){const t=this.config.multiTenant?.table?.columns;if(t)for(const e in t){const s=e;this.fieldMappings.set(s,t[s])}}filterWithOwnerId(t){if(this.ownerId){const e={key:this.getMappedField("ownerId"),operator:"eq",value:this.ownerId};return t?{AND:[e,t]}:e}return t}get ownerId(){return this.service.ownerId}}const z=n=>{let t={database:n.db.databaseName,user:n.db.username,password:n.db.password,host:n.db.host,port:n.db.port};return n.clientConfiguration?.ssl&&(t={...t,ssl:n.clientConfiguration?.ssl}),t},k=async(n,t)=>{await n.query(`
      CREATE SCHEMA IF NOT EXISTS ${t};
      SET search_path TO ${t};
    `)},j=async n=>{const t=new Z.Client(n);return await t.connect(),t},W=async(n,t,e)=>{if(!L.existsSync(t))return!1;const s="client"in n?n.client:await j(n);return await k(s,e.slug),await X.migrate({client:s},t),"client"in n||await s.end(),!0},F=S.z.optional(S.z.string().max(255).regex(/^([\da-z]([\da-z-]{0,61}[\da-z])?\.)+[a-z]{2,}$/)),B=S.z.string().regex(/^(?!.*-+$)[a-z][\da-z-]{0,61}([\da-z])?$/),H=(n,t)=>{const e=w(n).table.columns,s={slug:t[e.slug],domain:t[e.domain]},r=S.z.object({slug:B,domain:F}).safeParse(s);if(!r.success)throw{message:r.error.issues[0].message,issues:r.error.issues,statusCode:422}},me=Object.freeze(Object.defineProperty({__proto__:null,domainSchema:F,slugSchema:B,validateTenantInput:H,validateTenantUpdate:(n,t)=>{const e=w(n).table.columns,s={domain:t[e.domain]},r=S.z.object({domain:F}).safeParse(s);if(!r.success)throw{message:r.error.issues[0].message,issues:r.error.issues,statusCode:422}}},Symbol.toStringTag,{value:"Module"}));class p extends f.BaseService{_ownerId=void 0;all=async t=>{const e=this.factory.getAllWithAliasesSql(t);return await this.database.connect(a=>a.any(e))};create=async t=>{const e=w(this.config),{slug:s,domain:a}=e.table.columns;if(t[a]===""&&delete t[a],H(this.config,t),x(this.config).includes(t[s]))throw{name:"CREATE_TENANT_FAILED",message:`The requested ${s} "${t[s]}" is reserved and cannot be used`,statusCode:422};if(M(this.config).includes(t[a]))throw{name:"CREATE_TENANT_FAILED",message:`The requested ${a} "${t[a]}" is reserved and cannot be used`,statusCode:422};await this.validateSlugOrDomain(t[s],t[a]);const r=this.factory.getCreateSql(t),o=await this.database.connect(async d=>d.query(r).then(i=>i.rows[0]));return o?this.postCreate(o):void 0};findByHostname=async t=>{const e=this.factory.getFindByHostnameSql(t,this.config.multiTenant.rootDomain);return await this.database.connect(async a=>a.maybeOne(e))};validateSlugOrDomain=async(t,e)=>{const s=this.factory.getFindBySlugOrDomainSql(t,e);if((await this.database.connect(async r=>r.any(s))).length>0){const r=w(this.config),{slug:o,domain:d}=r.table.columns;throw{name:"FIELD_VALIDATION_FAILED",message:`The specified ${o} "${t}" or ${d} "${e}" already exits`,statusCode:422}}};get factory(){if(!this.table)throw new Error("Service table is not defined");return this._factory||(this._factory=new ue(this)),this._factory}get sortKey(){return this.config.multiTenant.table?.columns?.id||super.sortKey}get ownerId(){return this._ownerId}set ownerId(t){this._ownerId=t}get table(){return this.config.multiTenant?.table?.name||"tenants"}postCreate=async t=>{const e=w(this.config);return await W(z(this.config.slonik),e.migrations.path,t),t}}const ge=async(n,t,e)=>{if(M(n).includes(e)||x(n).some(r=>`${r}.${n.multiTenant.rootDomain}`===e))return null;const a=await new p(n,t).findByHostname(e);if(a)return a;throw new Error("Tenant not found")},we=A(async(n,t,e)=>{n.addHook("preHandler",async(s,a)=>{const r=s.headers.referer||s.headers.origin||s.hostname,{config:o,slonik:d}=s;try{const i=await ge(o,d,_(r));i&&(s.tenant=i,s.dbSchema=i[w(o).table.columns.slug])}catch(i){return n.log.error(i),a.send({error:{message:"Tenant not found"}})}}),e()}),V=A(async(n,t,e)=>{n.log.info("Registering fastify-multi-tenant plugin"),await n.register(we);const{config:s}=n,a={recipes:U};s.user.supertokens=G(a,s.user.supertokens),n.addHook("onReady",async()=>{await ee()}),e()});V.updateContext=te;const he=A(async(n,t,e)=>{try{const{config:s,slonik:a}=n,r=z(s.slonik),d=w(s).migrations.path;if(L.existsSync(d)){const m=await new p(s,a).all(["name","slug"]),h=await j(r);for(const g of m)n.log.info(`Running migrations for tenant ${g.name}`),await W({client:h},d,g);await k(h,"public"),await h.end()}else n.log.warn(`Tenant migrations path '${d}' does not exists.`)}catch(s){throw n.log.error("🔴 multi-tenant: Failed to run tenant migrations"),s}e()}),fe={Mutation:{createTenant:async(n,t,e)=>{if(e.tenant)return new E.ErrorWithProps("Tenant app cannot be used to create tenant",void 0,403);const s=e.user?.id;if(s){const a=t.data,r=w(e.config);return a[r.table.columns.ownerId]=s,await new p(e.config,e.database,e.dbSchema).create(a).catch(d=>new E.ErrorWithProps(d.message,void 0,d.statusCode))}else{e.app.log.error("Could not able to get user id from mercurius context");const a=new E.ErrorWithProps("Oops, Something went wrong");return a.statusCode=500,a}}},Query:{allTenants:async(n,t,e)=>{if(e.tenant)return new E.ErrorWithProps("Tenant app cannot display all tenants",void 0,403);const s=e.user?.id;if(!s)return new E.ErrorWithProps("Oops, Something went wrong",void 0,500);const a=new p(e.config,e.database,e.dbSchema),{roles:r}=await T.getRolesForUser(u.TENANT_ID,s);return r.includes(b)&&(a.ownerId=s),await a.all(JSON.parse(JSON.stringify(t.fields)))},tenant:async(n,t,e)=>{if(e.tenant)return new E.ErrorWithProps("Tenant app cannot retrieve tenant information",void 0,403);const s=e.user?.id;if(!s)return new E.ErrorWithProps("Oops, Something went wrong",void 0,500);const a=new p(e.config,e.database,e.dbSchema),{roles:r}=await T.getRolesForUser(u.TENANT_ID,s);return r.includes(b)&&(a.ownerId=s),await a.findById(t.id)},tenants:async(n,t,e)=>{if(e.tenant)return new E.ErrorWithProps("Tenant app cannot display a list of tenants",void 0,403);const s=e.user?.id;if(!s)return new E.ErrorWithProps("Oops, Something went wrong",void 0,500);const a=new p(e.config,e.database,e.dbSchema),{roles:r}=await T.getRolesForUser(u.TENANT_ID,s);return r.includes(b)&&(a.ownerId=s),await a.list(t.limit,t.offset,t.filters?JSON.parse(JSON.stringify(t.filters)):void 0,t.sort?JSON.parse(JSON.stringify(t.sort)):void 0)}}},N={all:async(n,t)=>{if(n.tenant)throw{name:"GET_ALL_TENANTS_FAILED",message:"Tenant app cannot display all tenants",statusCode:403};const e=n.session?.getUserId();if(!e)throw n.log.error("could not get user id from session"),new Error("Oops, Something went wrong");const s=new p(n.config,n.slonik,n.dbSchema),{roles:a}=await T.getRolesForUser(u.TENANT_ID,e);a.includes(b)&&(s.ownerId=e);const{fields:r}=n.query,o=await s.all(JSON.parse(r));t.send(o)},create:async(n,t)=>{if(n.tenant)throw{name:"CREATE_TENANT_FAILED",message:"Tenant app cannot be used to create tenant",statusCode:403};const e=n.session?.getUserId();if(e){const s=n.body,a=w(n.config);s[a.table.columns.ownerId]=e;const o=await new p(n.config,n.slonik).create(s);t.send(o)}else throw n.log.error("could not get user id from session"),new Error("Oops, Something went wrong")},tenant:async(n,t)=>{if(n.tenant)throw{name:"GET_TENANT_FAILED",message:"Tenant app cannot retrieve tenant information",statusCode:403};const e=n.session?.getUserId();if(!e)throw n.log.error("could not get user id from session"),new Error("Oops, Something went wrong");const s=new p(n.config,n.slonik,n.dbSchema),{roles:a}=await T.getRolesForUser(u.TENANT_ID,e);a.includes(b)&&(s.ownerId=e);const{id:r}=n.params,o=await s.findById(r);t.send(o)},tenants:async(n,t)=>{if(n.tenant)throw{name:"LIST_TENANTS_FAILED",message:"Tenant app cannot display a list of tenants",statusCode:403};const e=n.session?.getUserId();if(!e)throw n.log.error("could not get user id from session"),new Error("Oops, Something went wrong");const s=new p(n.config,n.slonik,n.dbSchema),{roles:a}=await T.getRolesForUser(u.TENANT_ID,e);a.includes(b)&&(s.ownerId=e);const{limit:r,offset:o,filters:d,sort:i}=n.query,m=await s.list(r,o,d?JSON.parse(d):void 0,i?JSON.parse(i):void 0);t.send(m)}},pe=async(n,t,e)=>{n.get("/tenants/all",{preHandler:n.verifySession()},N.all),n.get("/tenants",{preHandler:n.verifySession()},N.tenants),n.get("/tenants/:id(^\\d+)",{preHandler:n.verifySession()},N.tenant),n.post("/tenants",{preHandler:n.verifySession()},N.create),e()};l.TenantService=p,l.default=V,l.tenantMigrationPlugin=he,l.tenantResolver=fe,l.tenantRoutes=pe,l.thirdPartyEmailPassword=U,l.validateTenantSchema=me,Object.defineProperties(l,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});
