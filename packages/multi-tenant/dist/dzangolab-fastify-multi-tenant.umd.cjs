(function(c,P){typeof exports=="object"&&typeof module<"u"?P(exports,require("@dzangolab/fastify-config"),require("mercurius"),require("fastify-plugin"),require("lodash.merge"),require("supertokens-node/recipe/userroles"),require("@dzangolab/fastify-user"),require("supertokens-node/framework/fastify"),require("supertokens-node/recipe/session"),require("@dzangolab/fastify-slonik"),require("supertokens-node"),require("supertokens-node/recipe/emailverification"),require("supertokens-node/recipe/thirdpartyemailpassword"),require("humps"),require("slonik"),require("zod"),require("node:fs"),require("@dzangolab/postgres-migrations"),require("pg")):typeof define=="function"&&define.amd?define(["exports","@dzangolab/fastify-config","mercurius","fastify-plugin","lodash.merge","supertokens-node/recipe/userroles","@dzangolab/fastify-user","supertokens-node/framework/fastify","supertokens-node/recipe/session","@dzangolab/fastify-slonik","supertokens-node","supertokens-node/recipe/emailverification","supertokens-node/recipe/thirdpartyemailpassword","humps","slonik","zod","node:fs","@dzangolab/postgres-migrations","pg"],P):(c=typeof globalThis<"u"?globalThis:c||self,P(c.DzangolabFastifyMultiTenant={},c.DzangolabFastifyConfig,c.Mercurius,c.FastifyPlugin,c.LodashMerge,c.SupertokensUserRoles,c.DzangolabFastifyUser,c.SupertokensFastify,c.SupertokensSession,c.DzangolabFastifySlonik,c.SupertokensNode,c.EmailVerification,c.SupertokensThirdPartyEmailPassword,c.Humps,c.Slonik,c.Zod,c.NodeFs,c.DzangolabPostgresMigrations,c.Pg))})(this,function(c,P,E,N,G,S,u,K,J,f,_,$,q,b,l,T,L,X,Y){"use strict";function Q(n){const t=Object.create(null,{[Symbol.toStringTag]:{value:"Module"}});if(n){for(const e in n)if(e!=="default"){const s=Object.getOwnPropertyDescriptor(n,e);Object.defineProperty(t,e,s.get?s:{enumerable:!0,get:()=>n[e]})}}return t.default=n,Object.freeze(t)}const Z=Q(Y),v="TENANT_OWNER",ee=async()=>{await S.createNewRoleOrAddPermissions(v,[])},w=n=>{const t=n.slonik?.migrations?.path||"migrations";return{migrations:{path:n.multiTenant?.migrations?.path||`${t}/tenants`},reserved:{admin:{domains:n.multiTenant.reserved?.admin?.domains||[],enabled:n.multiTenant.reserved?.admin?.enabled??!0,slugs:n.multiTenant.reserved?.admin?.slugs||["admin"]},blacklisted:{domains:n.multiTenant.reserved?.blacklisted?.domains||[],enabled:n.multiTenant.reserved?.blacklisted?.enabled??!0,slugs:n.multiTenant.reserved?.blacklisted?.slugs||[]},others:{domains:n.multiTenant.reserved?.others?.domains||[],enabled:n.multiTenant.reserved?.others?.enabled??!0,slugs:n.multiTenant.reserved?.others?.slugs||[]},www:{domains:n.multiTenant.reserved?.www?.domains||[],enabled:n.multiTenant.reserved?.www?.enabled??!0,slugs:n.multiTenant.reserved?.www?.slugs||["www"]}},table:{name:n.multiTenant?.table?.name||"tenants",columns:{id:n.multiTenant?.table?.columns?.id||"id",domain:n.multiTenant?.table?.columns?.domain||"domain",name:n.multiTenant?.table?.columns?.name||"name",ownerId:n.multiTenant?.table?.columns?.ownerId||"owner_id",slug:n.multiTenant?.table?.columns?.slug||"slug"}}}},O=(n,t,e)=>{const s=w(n),r=e?e[s.table.columns.slug]:"";return u.getUserService(n,t,r)},te=async(n,t,e)=>{const{config:s,slonik:r,tenant:a}=t;n.tenant=a;const d=(await J.getSession(t,K.wrapResponse(e),{sessionRequired:!1}))?.getUserId();if(d&&!n.user){const i=O(s,r,a);let m;try{m=await i.findById(d)}catch{}if(!m)throw new Error("Unable to find user");const{roles:h}=await S.getRolesForUser(u.TENANT_ID,d);n.user=m,n.roles=h}},R={addTenantPrefix:(n,t,e)=>(e&&(t=e[w(n).table.columns.id]+"_"+t),t),removeTenantPrefix:(n,t,e)=>(e&&e[w(n).table.columns.id]==t.slice(0,Math.max(0,Math.max(0,t.indexOf("_"))))&&(t=t.slice(Math.max(0,t.indexOf("_")+1))),t)},ne=(n,t)=>{const e=t.config.appOrigin[0];return async s=>{let r;try{const a=s.userContext._default.request.request;try{const i=a.headers.referer||a.headers.origin||a.hostname;r=u.getOrigin(i)||e}catch{r=e}const o=s.emailVerifyLink.replace(e+"/auth/verify-email",r+(t.config.user.supertokens.emailVerificationPath||u.EMAIL_VERIFICATION_PATH));let d=s.user.email;a.tenant&&(d=R.removeTenantPrefix(a.config,d,a.tenant)),u.sendEmail({fastify:t,subject:"Email Verification",templateName:"email-verification",to:d,templateData:{emailVerifyLink:o}})}catch(a){a instanceof Error&&t.log.error(a.message)}}},se=(n,t)=>async e=>{if(n.createNewSession===void 0)throw new Error("Should never come here");const s=e.userContext.tenant;if(s){const i=e.userContext._default.request.request,m=w(i.config);e.accessTokenPayload={...e.accessTokenPayload,tenantId:s[m.table.columns.id]}}const r=await n.createNewSession(e),a=r.getUserId();if((await O(t.config,t.slonik,s).findById(a))?.disabled)throw await r.revokeSession(),{name:"SIGN_IN_FAILED",message:"user is disabled",statusCode:401};return r},re=(n,t)=>async e=>{if(n.verifySession===void 0)throw new Error("Should never come here");const s=await n.verifySession(e);if(s){const r=s.getUserId(),a=e.userContext._default.request.request,o=s.getAccessTokenPayload().tenantId;if(a.tenant){const m=w(a.config);if(o!=a.tenant[m.table.columns.id])throw{name:"SESSION_VERIFICATION_FAILED",message:"invalid session",statusCode:401}}if((await O(t.config,t.slonik,a.tenant).findById(r))?.disabled)throw await s.revokeSession(),{name:"SESSION_VERIFICATION_FAILED",message:"user is disabled",statusCode:401}}return s},ae=(n,t)=>async e=>{if(n.refreshPOST===void 0)throw new Error("Should never come here");const s=await n.refreshPOST(e);if(s){const r=e.userContext._default.request.request,a=s.getAccessTokenPayload().tenantId;if(r.tenant){const o=w(r.config);if(a!=r.tenant[o.table.columns.id])throw{name:"SESSION_VERIFICATION_FAILED",message:"invalid session",statusCode:401}}}return s},oe=(n,t)=>{const{config:e,log:s,slonik:r}=t;return async a=>{a.email=R.addTenantPrefix(e,a.email,a.userContext.tenant);const o=await n.emailPasswordSignIn(a);if(o.status!=="OK")return o;const d=O(e,r,a.userContext.dbSchema),i=await d.findById(o.user.id);return i?(i.lastLoginAt=Date.now(),await d.update(i.id,{lastLoginAt:f.formatDate(new Date(i.lastLoginAt))}).catch(h=>{s.error(`Unable to update lastLoginAt for userId ${o.user.id}`),s.error(h)}),{status:"OK",user:{...o.user,...i}}):(s.error(`User record not found for userId ${o.user.id}`),{status:"WRONG_CREDENTIALS_ERROR"})}},ie=(n,t)=>async e=>{if(e.userContext.tenant=e.options.req.original.tenant,e.userContext.dbSchema=e.options.req.original.dbSchema,n.emailPasswordSignInPOST===void 0)throw new Error("Should never come here");return await n.emailPasswordSignInPOST(e)},de=(n,t)=>{const{config:e,log:s,slonik:r}=t;return async a=>{const o=a.userContext.roles||[];if(!await u.areRolesExist(o))throw s.error(`At least one role from ${o.join(", ")} does not exist.`),{name:"SIGN_UP_FAILED",message:"Something went wrong",statusCode:500};const d=a.email;a.email=R.addTenantPrefix(e,d,a.userContext.tenant);const i=await n.emailPasswordSignUp(a);if(i.status==="OK"){const m=O(e,r,a.userContext.tenant);let h;try{if(h=await m.create({id:i.user.id,email:d}),!h)throw new Error("User not found")}catch(g){throw s.error("Error while creating user"),s.error(g),await _.deleteUser(i.user.id),{name:"SIGN_UP_FAILED",message:"Something went wrong",statusCode:500}}h.roles=o,i.user={...i.user,...h};for(const g of o){const I=await S.addRoleToUser(u.TENANT_ID,i.user.id,g);I.status!=="OK"&&s.error(I.status)}if(e.user.features?.signUp?.emailVerification)try{if(a.userContext.autoVerifyEmail)await u.verifyEmail(h.id);else{const g=await $.createEmailVerificationToken(u.TENANT_ID,i.user.id);g.status==="OK"&&await $.sendEmail({tenantId:u.TENANT_ID,type:"EMAIL_VERIFICATION",user:{id:i.user.id,email:a.email},emailVerifyLink:`${e.appOrigin[0]}/auth/verify-email?token=${g.token}&rid=emailverification`,userContext:a.userContext})}}catch(g){s.error(g)}}if(e.user.supertokens.sendUserAlreadyExistsWarning&&i.status==="EMAIL_ALREADY_EXISTS_ERROR")try{u.sendEmail({fastify:t,subject:"Duplicate Email Registration",templateData:{emailId:d},templateName:"duplicate-email-warning",to:d})}catch(m){s.error(m)}return i}},A=n=>{let t;try{if(t=new URL(n).host,!t)throw new Error("Host is empty")}catch{t=n}return t},le=(n,t)=>async e=>{const s=e.options.req.original,r=s.headers.referer||s.headers.origin||s.hostname,a=A(r),{admin:o,www:d}=w(s.config).reserved;if(e.userContext.roles=d.enabled&&(d.slugs.some(i=>`${i}.${s.config.multiTenant.rootDomain}`===a)||d.domains.includes(a))?[v]:[s.config.user.role||u.ROLE_USER],o.enabled&&(o.slugs.some(i=>`${i}.${s.config.multiTenant.rootDomain}`===a)||o.domains.includes(a)))throw{name:"SIGN_UP_FAILED",message:"Admin signUp is not allowed",statusCode:403};if(e.userContext.tenant=s.tenant,n.emailPasswordSignUpPOST===void 0)throw new Error("Should never come here");if(t.config.user.features?.signUp?.enabled===!1)throw{name:"SIGN_UP_DISABLED",message:"SignUp feature is currently disabled",statusCode:404};return await n.emailPasswordSignUpPOST(e)},ce=(n,t,e)=>(e&&t.find(s=>{s.id==="email"&&(s.value=e[w(n).table.columns.id]+"_"+s.value)}),t),U={emailVerification:{sendEmail:ne},thirdPartyEmailPassword:{override:{apis:{emailPasswordSignInPOST:ie,emailPasswordSignUpPOST:le,generatePasswordResetTokenPOST:(n,t)=>async e=>{if(e.userContext.tenant=e.options.req.original.tenant,n.generatePasswordResetTokenPOST===void 0)throw new Error("Should never come here");return e.formFields=ce(t.config,e.formFields,e.userContext.tenant),await n.generatePasswordResetTokenPOST(e)},thirdPartySignInUpPOST:(n,t)=>{const{config:e,log:s,slonik:r}=t;return async a=>{const o=a.options.req.original,d=o.headers.referer||o.headers.origin||o.hostname,i=A(d),{admin:m,www:h}=w(o.config).reserved;if(a.userContext.roles=h.enabled&&(h.slugs.some(I=>`${I}.${o.config.multiTenant.rootDomain}`===i)||h.domains.includes(i))?[v]:[o.config.user.role||u.ROLE_USER],m.enabled&&(m.slugs.some(I=>`${I}.${o.config.multiTenant.rootDomain}`===i)||m.domains.includes(i)))throw{name:"SIGN_UP_FAILED",message:"Admin signUp is not allowed",statusCode:403};if(a.userContext.tenant=o.tenant,n.thirdPartySignInUpPOST===void 0)throw new Error("Should never come here");const g=await n.thirdPartySignInUpPOST(a);if(g.status==="OK"){const I=O(e,r,a.userContext.tenant);let y;if(g.createdNewUser)try{if(y=await I.create({id:g.user.id,email:g.user.email}),!y)throw new Error("User not found");y.roles=a.userContext.roles}catch(F){throw s.error("Error while creating user"),s.error(F),await _.deleteUser(g.user.id),{name:"SIGN_UP_FAILED",message:"Something went wrong",statusCode:500}}else{if(y=await I.findById(g.user.id),!y)return s.error(`User record not found for userId ${g.user.id}`),{status:"GENERAL_ERROR",message:"Something went wrong"};y.lastLoginAt=Date.now(),await I.update(y.id,{lastLoginAt:f.formatDate(new Date(y.lastLoginAt))}).catch(F=>{s.error(`Unable to update lastLoginAt for userId ${g.user.id}`),s.error(F)})}return{...g,user:{...g.user,...y}}}return g}}},functions:{emailPasswordSignIn:oe,emailPasswordSignUp:de,getUserById:(n,t)=>async e=>{let s=await n.getUserById(e);return s&&e.userContext&&e.userContext.tenant&&(s={...s,email:R.removeTenantPrefix(t.config,s.email,e.userContext.tenant)}),s},resetPasswordUsingToken:(n,t)=>async e=>{const s=await n.resetPasswordUsingToken(e);if(s.status==="OK"&&s.userId){const r=await q.getUserById(s.userId,{tenant:e.userContext._default.request.request.tenant});r&&u.sendEmail({fastify:t,subject:"Reset Password Notification",templateName:"reset-password-notification",to:r.email,templateData:{emailId:r.email}})}return s},thirdPartySignInUp:(n,t)=>{const{config:e,log:s}=t;return async r=>{const a=r.userContext.roles||[],o=r.userContext.tenant;if(o){const m=o[w(e).table.columns.id];r.thirdPartyUserId=m+"_"+r.thirdPartyUserId}if(!await q.getUserByThirdPartyInfo(r.tenantId,r.thirdPartyId,r.thirdPartyUserId,r.userContext)&&e.user.features?.signUp?.enabled===!1)throw{name:"SIGN_UP_DISABLED",message:"SignUp feature is currently disabled",statusCode:404};const i=await n.thirdPartySignInUp(r);if(i.status==="OK"&&i.createdNewUser){if(!await u.areRolesExist(a))throw await _.deleteUser(i.user.id),s.error(`At least one role from ${a.join(", ")} does not exist.`),{name:"SIGN_UP_FAILED",message:"Something went wrong",statusCode:500};for(const m of a){const h=await S.addRoleToUser(u.TENANT_ID,i.user.id,m);h.status!=="OK"&&s.error(h.status)}}return i}}}},sendEmail:(n,t)=>{const e=t.config.appOrigin[0];return async s=>{const r=s.userContext._default.request.request,a=r.headers.referer||r.headers.origin||r.hostname,o=u.getOrigin(a)||e,d=s.passwordResetLink.replace(e+"/auth/reset-password",o+(t.config.user.supertokens.resetPasswordPath||u.RESET_PASSWORD_PATH));u.sendEmail({fastify:t,subject:"Reset Password",templateName:"reset-password",to:R.removeTenantPrefix(r.config,s.user.email,s.userContext.tenant),templateData:{passwordResetLink:d}})}}},session:{override:{apis:{refreshPOST:ae,verifySession:re},functions:{createNewSession:se}}}},M=n=>{const t=w(n).reserved;let e=[];for(const[,s]of Object.entries(t))s.enabled&&(e=[...e,...s.domains]);return e},x=n=>{const t=w(n).reserved;let e=[];for(const[,s]of Object.entries(t))s.enabled&&(e=[...e,...s.slugs]);return e};class ue extends f.DefaultSqlFactory{fieldMappings=new Map(Object.entries({domain:"domain",id:"id",name:"name",ownerId:"owner_id",slug:"slug"}));constructor(t){super(t),this.init()}getAllWithAliasesSql=t=>{const e=[];for(const i of t)i!="host"&&e.push(l.sql.fragment`${this.getAliasedField(i)}`);const s=f.createTableIdentifier(this.table,this.schema),r=l.sql.identifier([this.getMappedField("domain")]),a=l.sql.identifier([this.getMappedField("slug")]),o=this.config.multiTenant.rootDomain,d=t.includes("host")?l.sql.fragment`,
          CASE
            WHEN ${r} IS NOT NULL THEN ${r}
            ELSE CONCAT(${a}, ${"."+o}::TEXT)
          END AS host
        `:l.sql.fragment``;return l.sql.type(T.z.any())`
      SELECT ${l.sql.join(e,l.sql.fragment`, `)}
        ${d}
      FROM ${this.getTableFragment()}
      ${f.createFilterFragment(this.filterWithOwnerId(),s)}
      ORDER BY ${l.sql.identifier([b.decamelize(this.getMappedField("id"))])} ASC;
    `};getCountSql=t=>{const e=f.createTableIdentifier(this.table,this.schema),s=T.z.object({count:T.z.number()});return l.sql.type(s)`
      SELECT COUNT(*)
      FROM ${this.getTableFragment()}
      ${f.createFilterFragment(this.filterWithOwnerId(t),e)};
    `};getCreateSql=t=>{const e=[],s=[];for(const r in t){const a=r,o=t[a];e.push(l.sql.identifier([b.decamelize(this.getMappedField(a))])),s.push(o)}return l.sql.type(T.z.any())`
      INSERT INTO ${this.getTableFragment()}
        (${l.sql.join(e,l.sql.fragment`, `)})
      VALUES (${l.sql.join(s,l.sql.fragment`, `)})
      RETURNING *;
    `};getFindByHostnameSql=(t,e)=>l.sql.type(T.z.any())`
      SELECT *
      FROM ${this.getTableFragment()}
      WHERE ${l.sql.identifier([b.decamelize(this.getMappedField("domain"))])} = ${t}
      OR (
        ${l.sql.identifier([b.decamelize(this.getMappedField("slug"))])}
        || '.' ||
        ${e}
      ) = ${t};
    `;getFindByIdSql=t=>{const e={key:this.getMappedField("id"),operator:"eq",value:t},s=f.createTableIdentifier(this.table,this.schema);return l.sql.type(this.validationSchema)`
      SELECT *
      FROM ${this.getTableFragment()}
      ${f.createFilterFragment(this.filterWithOwnerId(e),s)}
    `};getFindBySlugOrDomainSql=(t,e)=>{const s=l.sql.identifier([this.getMappedField("domain")]),r=l.sql.identifier([this.getMappedField("slug")]),a=e?l.sql.fragment`
        OR ${s} = ${e}
      `:l.sql.fragment``;return l.sql.type(this.validationSchema)`
      SELECT *
      FROM ${this.getTableFragment()}
      WHERE
      ${r} = ${t}
      ${a};
    `};getListSql=(t,e,s,r)=>{const a=f.createTableIdentifier(this.table,this.schema);return l.sql.type(this.validationSchema)`
      SELECT *
      FROM ${this.getTableFragment()}
      ${f.createFilterFragment(this.filterWithOwnerId(s),a)}
      ${f.createSortFragment(a,this.getSortInput(r))}
      ${f.createLimitFragment(t,e)};
    `};getAliasedField=t=>{const e=this.getMappedField(t);return e===t?l.sql.identifier([b.decamelize(t)]):l.sql.join([l.sql.identifier([b.decamelize(e)]),l.sql.identifier([t])],l.sql.fragment` AS `)};getMappedField=t=>this.fieldMappings.has(t)?this.fieldMappings.get(t):t;init(){const t=this.config.multiTenant?.table?.columns;if(t)for(const e in t){const s=e;this.fieldMappings.set(s,t[s])}}filterWithOwnerId(t){if(this.ownerId){const e={key:this.getMappedField("ownerId"),operator:"eq",value:this.ownerId};return t?{AND:[e,t]}:e}return t}get ownerId(){return this.service.ownerId}}const z=n=>{let t={database:n.db.databaseName,user:n.db.username,password:n.db.password,host:n.db.host,port:n.db.port};return n.clientConfiguration?.ssl&&(t={...t,ssl:n.clientConfiguration?.ssl}),t},k=async(n,t)=>{await n.query(`
      CREATE SCHEMA IF NOT EXISTS ${t};
      SET search_path TO ${t};
    `)},j=async n=>{const t=new Z.Client(n);return await t.connect(),t},W=async(n,t,e)=>{if(!L.existsSync(t))return!1;const s="client"in n?n.client:await j(n);return await k(s,e.slug),await X.migrate({client:s},t),"client"in n||await s.end(),!0},D=T.z.optional(T.z.string().max(255).regex(/^([\da-z]([\da-z-]{0,61}[\da-z])?\.)+[a-z]{2,}$/)),B=T.z.string().regex(/^(?!.*-+$)[a-z][\da-z-]{0,61}([\da-z])?$/),V=(n,t)=>{const e=w(n).table.columns,s={slug:t[e.slug],domain:t[e.domain]},a=T.z.object({slug:B,domain:D}).safeParse(s);if(!a.success)throw a.error.issues.some(o=>o.path.includes("slug"))?{name:"ERROR_INVALID_SLUG",message:"Invalid slug",statusCode:422}:{name:"ERROR_INVALID_DOMAIN",message:"Invalid domain",statusCode:422}},me=Object.freeze(Object.defineProperty({__proto__:null,domainSchema:D,slugSchema:B,validateTenantInput:V,validateTenantUpdate:(n,t)=>{const e=w(n).table.columns,s={domain:t[e.domain]};if(!T.z.object({domain:D}).safeParse(s).success)throw{name:"ERROR_INVALID_DOMAIN",message:"Invalid domain",statusCode:422}}},Symbol.toStringTag,{value:"Module"}));class p extends f.BaseService{_ownerId=void 0;all=async t=>{const e=this.factory.getAllWithAliasesSql(t);return await this.database.connect(r=>r.any(e))};create=async t=>{const e=w(this.config),{slug:s,domain:r}=e.table.columns;if(t[r]===""&&delete t[r],V(this.config,t),x(this.config).includes(t[s]))throw{name:"ERROR_RESERVED_SLUG",message:`The requested ${s} "${t[s]}" is reserved and cannot be used`,statusCode:422};if(M(this.config).includes(t[r]))throw{name:"ERROR_RESERVED_DOMAIN",message:`The requested ${r} "${t[r]}" is reserved and cannot be used`,statusCode:422};await this.validateSlugOrDomain(t[s],t[r]);const a=this.factory.getCreateSql(t),o=await this.database.connect(async d=>d.query(a).then(i=>i.rows[0]));return o?this.postCreate(o):void 0};findByHostname=async t=>{const e=this.factory.getFindByHostnameSql(t,this.config.multiTenant.rootDomain);return await this.database.connect(async r=>r.maybeOne(e))};validateSlugOrDomain=async(t,e)=>{const s=this.factory.getFindBySlugOrDomainSql(t,e),r=await this.database.connect(async a=>a.any(s));if(r.length>0){const a=w(this.config),{slug:o,domain:d}=a.table.columns;throw r.some(i=>i[o]===t)?{name:"ERROR_SLUG_ALREADY_EXISTS",message:`The specified ${o} "${t}" already exits`,statusCode:422}:{name:"ERROR_DOMAIN_ALREADY_EXISTS",message:`The specified ${d} "${e}" already exits`,statusCode:422}}};get factory(){if(!this.table)throw new Error("Service table is not defined");return this._factory||(this._factory=new ue(this)),this._factory}get sortKey(){return this.config.multiTenant.table?.columns?.id||super.sortKey}get ownerId(){return this._ownerId}set ownerId(t){this._ownerId=t}get table(){return this.config.multiTenant?.table?.name||"tenants"}postCreate=async t=>{const e=w(this.config);return await W(z(this.config.slonik),e.migrations.path,t),t}}const ge=async(n,t,e)=>{if(M(n).includes(e)||x(n).some(a=>`${a}.${n.multiTenant.rootDomain}`===e))return null;const r=await new p(n,t).findByHostname(e);if(r)return r;throw new Error("Tenant not found")},we=N(async(n,t,e)=>{n.addHook("preHandler",async(s,r)=>{const a=s.headers.referer||s.headers.origin||s.hostname,{config:o,slonik:d}=s;try{const i=await ge(o,d,A(a));i&&(s.tenant=i,s.dbSchema=i[w(o).table.columns.slug])}catch(i){return n.log.error(i),r.send({error:{message:"Tenant not found"}})}}),e()}),H=N(async(n,t,e)=>{n.log.info("Registering fastify-multi-tenant plugin"),await n.register(we);const{config:s}=n,r={recipes:U};s.user.supertokens=G(r,s.user.supertokens),n.addHook("onReady",async()=>{await ee()}),e()});H.updateContext=te;const he=N(async(n,t,e)=>{try{const{config:s,slonik:r}=n,a=z(s.slonik),d=w(s).migrations.path;if(L.existsSync(d)){const m=await new p(s,r).all(["name","slug"]),h=await j(a);for(const g of m)n.log.info(`Running migrations for tenant ${g.name}`),await W({client:h},d,g);await k(h,"public"),await h.end()}else n.log.warn(`Tenant migrations path '${d}' does not exists.`)}catch(s){throw n.log.error("🔴 multi-tenant: Failed to run tenant migrations"),s}e()}),fe={Mutation:{createTenant:async(n,t,e)=>{if(e.tenant)return new E.ErrorWithProps("Tenant app cannot be used to create tenant",void 0,403);const s=e.user?.id;if(s){const r=t.data,a=w(e.config);return r[a.table.columns.ownerId]=s,await new p(e.config,e.database,e.dbSchema).create(r).catch(d=>new E.ErrorWithProps(d.message,void 0,d.statusCode))}else{e.app.log.error("Could not able to get user id from mercurius context");const r=new E.ErrorWithProps("Oops, Something went wrong");return r.statusCode=500,r}}},Query:{allTenants:async(n,t,e)=>{if(e.tenant)return new E.ErrorWithProps("Tenant app cannot display all tenants",void 0,403);const s=e.user?.id;if(!s)return new E.ErrorWithProps("Oops, Something went wrong",void 0,500);const r=new p(e.config,e.database,e.dbSchema),{roles:a}=await S.getRolesForUser(u.TENANT_ID,s);return a.includes(v)&&(r.ownerId=s),await r.all(JSON.parse(JSON.stringify(t.fields)))},tenant:async(n,t,e)=>{if(e.tenant)return new E.ErrorWithProps("Tenant app cannot retrieve tenant information",void 0,403);const s=e.user?.id;if(!s)return new E.ErrorWithProps("Oops, Something went wrong",void 0,500);const r=new p(e.config,e.database,e.dbSchema),{roles:a}=await S.getRolesForUser(u.TENANT_ID,s);return a.includes(v)&&(r.ownerId=s),await r.findById(t.id)},tenants:async(n,t,e)=>{if(e.tenant)return new E.ErrorWithProps("Tenant app cannot display a list of tenants",void 0,403);const s=e.user?.id;if(!s)return new E.ErrorWithProps("Oops, Something went wrong",void 0,500);const r=new p(e.config,e.database,e.dbSchema),{roles:a}=await S.getRolesForUser(u.TENANT_ID,s);return a.includes(v)&&(r.ownerId=s),await r.list(t.limit,t.offset,t.filters?JSON.parse(JSON.stringify(t.filters)):void 0,t.sort?JSON.parse(JSON.stringify(t.sort)):void 0)}}},C={all:async(n,t)=>{if(n.tenant)throw{name:"GET_ALL_TENANTS_FAILED",message:"Tenant app cannot display all tenants",statusCode:403};const e=n.session?.getUserId();if(!e)throw n.log.error("could not get user id from session"),new Error("Oops, Something went wrong");const s=new p(n.config,n.slonik,n.dbSchema),{roles:r}=await S.getRolesForUser(u.TENANT_ID,e);r.includes(v)&&(s.ownerId=e);const{fields:a}=n.query,o=await s.all(JSON.parse(a));t.send(o)},create:async(n,t)=>{if(n.tenant)throw{name:"CREATE_TENANT_FAILED",message:"Tenant app cannot be used to create tenant",statusCode:403};const e=n.session?.getUserId();if(e){const s=n.body,r=w(n.config);s[r.table.columns.ownerId]=e;const o=await new p(n.config,n.slonik).create(s);t.send(o)}else throw n.log.error("could not get user id from session"),new Error("Oops, Something went wrong")},tenant:async(n,t)=>{if(n.tenant)throw{name:"GET_TENANT_FAILED",message:"Tenant app cannot retrieve tenant information",statusCode:403};const e=n.session?.getUserId();if(!e)throw n.log.error("could not get user id from session"),new Error("Oops, Something went wrong");const s=new p(n.config,n.slonik,n.dbSchema),{roles:r}=await S.getRolesForUser(u.TENANT_ID,e);r.includes(v)&&(s.ownerId=e);const{id:a}=n.params,o=await s.findById(a);t.send(o)},tenants:async(n,t)=>{if(n.tenant)throw{name:"LIST_TENANTS_FAILED",message:"Tenant app cannot display a list of tenants",statusCode:403};const e=n.session?.getUserId();if(!e)throw n.log.error("could not get user id from session"),new Error("Oops, Something went wrong");const s=new p(n.config,n.slonik,n.dbSchema),{roles:r}=await S.getRolesForUser(u.TENANT_ID,e);r.includes(v)&&(s.ownerId=e);const{limit:a,offset:o,filters:d,sort:i}=n.query,m=await s.list(a,o,d?JSON.parse(d):void 0,i?JSON.parse(i):void 0);t.send(m)}},pe=async(n,t,e)=>{n.get("/tenants/all",{preHandler:n.verifySession()},C.all),n.get("/tenants",{preHandler:n.verifySession()},C.tenants),n.get("/tenants/:id(^\\d+)",{preHandler:n.verifySession()},C.tenant),n.post("/tenants",{preHandler:n.verifySession()},C.create),e()};c.TenantService=p,c.default=H,c.tenantMigrationPlugin=he,c.tenantResolver=fe,c.tenantRoutes=pe,c.thirdPartyEmailPassword=U,c.validateTenantSchema=me,Object.defineProperties(c,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});
